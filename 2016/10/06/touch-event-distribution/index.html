<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>安卓事件分发流程 | Haldir的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="图1 默认情况下事件传递的路径 

Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。">
<meta property="og:type" content="article">
<meta property="og:title" content="安卓事件分发流程">
<meta property="og:url" content="http://haldir65.github.io/2016/10/06/touch-event-distribution/index.html">
<meta property="og:site_name" content="Haldir的博客">
<meta property="og:description" content="图1 默认情况下事件传递的路径 

Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。">
<meta property="og:image" content="http://odzl05jxx.bkt.clouddn.com/dispatch_touch_event_video.JPG">
<meta property="og:image" content="http://odzl05jxx.bkt.clouddn.com/touch_event_1.png">
<meta property="og:image" content="http://odzl05jxx.bkt.clouddn.com/touch_event_2.png">
<meta property="og:updated_time" content="2016-10-12T14:16:22.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安卓事件分发流程">
<meta name="twitter:description" content="图1 默认情况下事件传递的路径 

Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。">
<meta name="twitter:image" content="http://odzl05jxx.bkt.clouddn.com/dispatch_touch_event_video.JPG">
  
    <link rel="alternative" href="/atom.xml" title="Haldir的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://odzl05jxx.bkt.clouddn.com/bolg_avatar.jpg" class="js-avatar show" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Haldir</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Android狗，python学习中</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/android">文章</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">主页</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Haldir65" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Haldir</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="nullhttp://odzl05jxx.bkt.clouddn.com/bolg_avatar.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Haldir</h1>
			</hgroup>
			
			<p class="header-subtitle">Android狗，python学习中</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/android">文章</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Haldir65" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-touch-event-distribution" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      安卓事件分发流程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://odzl05jxx.bkt.clouddn.com/dispatch_touch_event_video.JPG" alt=""></p>
<p>图1 默认情况下事件传递的路径 </p>
<blockquote>
<p>Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。<br><a id="more"></a></p>
</blockquote>
<ul>
<li>首先来关注ACTION_DOWN，用户触摸屏幕，MotionEvent开始传递：</li>
</ul>
<blockquote>
<ol>
<li><p>Activity.dispatchTouchEvent</p>
</li>
<li><p>ViewGroup.dispatchTouchEvent</p>
</li>
<li><p>ViewGroup.onInterceptTouchEvent</p>
<p>…..中间省略n个视图层级 ….&gt;&gt;&gt;</p>
</li>
<li><p>View.dispatchTouchEvent</p>
</li>
<li><p>View.onTouchEvent</p>
</li>
</ol>
<p>​      ….中间省略n个视图层级….&gt;&gt;&gt;</p>
<ol>
<li>ViewGroup.onTouchEvent</li>
<li>Activity.onTouchEvent</li>
</ol>
</blockquote>
<p>这也就是本文最开始的图1内描述的内容，注意，在默认情况下(各个函数都返回super的情况下)才能将这个从上到下，再从下到上的循环走完整。这里讨论的还只是ACTION_DOWN。</p>
<ul>
<li><p>接下来看ACTION_DOWN下发过程中各个函数返回值对于整个传递链走向的影响，我们在override这些函数的时候，返回值无非三种：</p>
<blockquote>
<p>true , false ,super</p>
</blockquote>
<ul>
<li>return true：ACTION_DOWN事件分发到此结束(消费掉)，这里有一个要注意的是onInterceptTouchEvent,返回true表示该ViewGroup打算将事件拦截下来，底层View将接收到一个ACTION_CANCEL，事件传递给该ViewGroup的onTouchEvent</li>
<li>return false: 对于dispatchTouchEvent，返回false表明不再向下分发，ACTION_DOWN发送到上一层ViewGroup(Activity)的OnTouchEvent；对于onInterceptTouchEvent,返回false表明该ViewGroup不打算拦截，继续下发，对于onTouchEvent，返回false，事件继续上传至上一层级ViewGroup的OnTouchEvent 。</li>
<li>return super : 完成整个传递链，就像图1中展示的一样。</li>
</ul>
</li>
</ul>
<p><img src="http://odzl05jxx.bkt.clouddn.com/touch_event_1.png" alt=""></p>
<p>图2 来自<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解安卓事件分发机制</a>  完美地解释了事件分发各个流程中返回值对于事件传递的影响。</p>
<p><img src="http://odzl05jxx.bkt.clouddn.com/touch_event_2.png" alt=""></p>
<p>图3 来自<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解安卓事件分发机制</a> </p>
<p>接下来看ACTION_DOWN时返回值对于后续ACTION_MOVE,ACTION_UP等传递路径的影响：</p>
<p>首先介绍概念：</p>
<blockquote>
<p>gesture = ACTION_DOWN+ a bounch of ACTIONS +ACTION_UP</p>
</blockquote>
<p>一个gesture(手势)即从手指按下到手指离开这段过程中所有的事件的集合,swipe,click,fling等等</p>
<p>ACTION_DWON发生时，android将会在当前touch区域所有的View中确定一个Touch Target,后者将接管此次gesture中的所有ACTION_MOVE,ACTION_UP。（这样做有两点好处：1.一旦确定了Touch Target，系统将会把所有的后续事件全部传递到这个target为止，这就避免了复杂的view traversing，有助于提升性能; 2：传递链中第一个能够成为Touch Target的View将独立处理后续事件，不需要考虑其他View受到影响）。在在一个gesture开始时，OnTouchEvent（ACTION_DOWN）返回true,就意味着成为TouchTarget。借用简书<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">作者</a>的总结:</p>
<blockquote>
<p>ACTION_DOWN事件在哪个控件消费了（return true），  那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</p>
</blockquote>
<p>这里可以看到，事件依旧是从上往下一直分发到TouchTarget这一层，只是在TouchTarget这一层被消费了，<strong><em>且不再往上传递</em></strong>(有助于性能提升)。父ViewGroup的dispatchTouchEvent和onInterceptTouchEvent依旧会先于TouchTarget接收到ACTION_MOVE等事件。所以此时如果父ViewGroup在onInterceptTouchEvent中返回true，父ViewGroup将取代原有的子View成为新的ViewTarget,后续事件(ACTION_MOVE等)将传递到该父ViewGroup中，而子View将收到ACTION_CANCEL(可以在这里做一些恢复状态的工作，比如从foucused变成unfocused)。举一个例子：在ScrollView(不是Android自带的那个)中放一个Button，ACTION_DOWN时，BUTTON表示可以处理ACTION_DOWN,因为这可能会是一次click，于是Button就成了TouchTarget，后续事件将不会传递到ScrollView中，ScrollView也就无法滑动。为解决这个问题，在ScrollView的onInterceptTouchEvent中，如果看到ACTION_DWON，返回false(点击事件对于滑动毫无意义)，但如果看到ACTION_MOVE(滑动事件),返回true并成为新的TouchTarget。注意是在OnInterceptTouchEvent中拦截而不是dispatchTouchEvent中拦截，后者会将事件传递到上层ViewGroup的onTouchEvent中。想想看，不去dispatch了、、、android这种Api起名还是可以的。</p>
<h3 id="onClick事件"><a href="#onClick事件" class="headerlink" title="#onClick事件"></a>#onClick事件</h3><p>接下来看onClick和onLongClick，onTouchListener这类事件何时触发</p>
<p>首先是View的dispatchTouchEvent源码部分</p>
<pre><code class="java">case MotionEvent.ACTION_UP:
                    boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                        // take focus if we don&#39;t have it already and we should in
                        // touch mode.
                        boolean focusTaken = false;
                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                            focusTaken = requestFocus();
                        }

                        if (prepressed) {
                            // The button is being released before we actually
                            // showed it as pressed.  Make it show the pressed
                            // state now (before scheduling the click) to ensure
                            // the user sees it.
                            setPressed(true, x, y);
                       }

                        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }

                        if (mUnsetPressedState == null) {
                            mUnsetPressedState = new UnsetPressedState();
                        }

                        if (prepressed) {
                            postDelayed(mUnsetPressedState,
                                    ViewConfiguration.getPressedStateDuration());
                        } else if (!post(mUnsetPressedState)) {
                            // If the post failed, unpress right now
                            mUnsetPressedState.run();
                        }

                        removeTapCallback();
                    }
                    mIgnoreNextUpEvent = false;
                    break;
</code></pre>
<p>所以onClick事件是在ACTION_UP中执行的</p>
<p>而LongClick事件要看ACTION_DOWN了</p>
<pre><code class="java">  case MotionEvent.ACTION_DOWN:
                    mHasPerformedLongPress = false;

                    if (performButtonActionOnTouchDown(event)) {
                        break;
                    }

                    // Walk up the hierarchy to determine if we&#39;re inside a scrolling container.
                    boolean isInScrollingContainer = isInScrollingContainer();

                    // For views inside a scrolling container, delay the pressed feedback for
                    // a short period in case this is a scroll.
                    if (isInScrollingContainer) {
                        mPrivateFlags |= PFLAG_PREPRESSED;
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        mPendingCheckForTap.x = event.getX();
                        mPendingCheckForTap.y = event.getY();
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        // Not inside a scrolling container, so show the feedback right away
                        setPressed(true, x, y);
                        checkForLongClick(0, x, y);
                    }
                    break;
</code></pre>
<p>关键看checkForLongClick, 不贴代码了，结论是：在ACTION_DOWN事件被捕捉后，系统会开始触发一个postDelayed操作，delay的时间为</p>
<blockquote>
<pre><code>ViewConfiguration.getLongPressTimeout() - delayOffset
</code></pre></blockquote>
<p>（这个值在Eclair2.1上为500ms），500ms后会触发CheckForLongPress线程的执行：</p>
<p>想想看，LongClick事件是在DOWN时开始计时，500ms假设，OnClick是在UP是发生，所以完全有可能同时发生OnClick和OnLongClick。这里看到当onLongClick的返回值为true时， <em>mHasPerformedLongPress</em> = true ,仔细看ACTION_UP中，如果HasPerformLongPress==true，就不会走到onClick事件里。所以在onLongClickListener里需要返回一个boolean值的原因就这么简单。</p>
<pre><code class="java"> if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }
</code></pre>
<p>接下来是OnTouchListener，直接上结论: onTouchListener里面的方法是在dispatchTouchEvent里面调用的，并且如果listener里面的onTouch返回true，事件将不会发送给onTouchEvent，因此OnTouchListener势必会优先级高于onClick和onLongClick。</p>
<h2 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h2><pre><code class="java">velocityTracker = VelocityTracker.obtain()；
velocityTracker.addMovement(event);
velocityTracker.computeCurrentVelocity(1);  
velocityTracker.getXVelocity();
velocityTracker.recycle();
</code></pre>
<p>值得注意的是，VelocityTracker内部使用了大量的native方法，所以执行速度比java要快很多。</p>
<h3 id="实现Fling效果"><a href="#实现Fling效果" class="headerlink" title="实现Fling效果"></a>实现Fling效果</h3><pre><code class="java">private void onFling(float velocityX,float velocityY){
  scroller.fling(getScrollX(),getScrollY(),(int)-velocityX
                (int)-velocityY,minScrollX,maxScrollX,
                minScrollY,maxScrollY);
  invalidate();
}
@overdide// 这是每个View都有的方法
private void computeScroll(){
  if(scroller.isFinished()){
    scroller.computeScrollOffset();
    scrollTo(scroller.getCurrX(),scroller.getCurrY());
    postInvalidateOnAnimation();
  }
}
</code></pre>
<h3 id="捕获双击事件"><a href="#捕获双击事件" class="headerlink" title="捕获双击事件"></a>捕获双击事件</h3><pre><code class="java">public class MyView extends View {

GestureDetector gestureDetector;

public MyView(Context context, AttributeSet attrs) {
    super(context, attrs);
            // creating new gesture detector 
    gestureDetector = new GestureDetector(context, new GestureListener());
} 

// skipping measure calculation and drawing 

    // delegate the event to the gesture detector 
@Override 
public boolean onTouchEvent(MotionEvent e) {
    return gestureDetector.onTouchEvent(e);
} 


private class GestureListener extends GestureDetector.SimpleOnGestureListener {

    @Override 
    public boolean onDown(MotionEvent e) {
        return true; 
    } 
    // event when double tap occurs 
    @Override 
    public boolean onDoubleTap(MotionEvent e) {
        float x = e.getX();
        float y = e.getY();

        Log.d(&quot;Double Tap&quot;, &quot;Tapped at: (&quot; + x + &quot;,&quot; + y + &quot;)&quot;);

        return true; 
    } 
} 
}
</code></pre>
<p> 最后是关于ViewConfiguration的一些常量获取的静态方法：</p>
<p>int getScaledTouchSlop(); (if Math.abs(x<em>x+y</em>y)&gt;mTouchSlop 就可以认为是滑动事件了)</p>
<pre><code class="java">/**    
  * 包含了方法和标准的常量用来设置UI的超时、大小和距离    
  */ 
 public class ViewConfiguration {     
     // 设定水平滚动条的宽度和垂直滚动条的高度，单位是像素px     
     private static final int SCROLL_BAR_SIZE = 10;     

     //定义滚动条逐渐消失的时间，单位是毫秒     
     private static final int SCROLL_BAR_FADE_DURATION = 250;     

     // 默认的滚动条多少秒之后消失，单位是毫秒     
     private static final int SCROLL_BAR_DEFAULT_DELAY = 300;     

     // 定义边缘地方褪色的长度     
     private static final int FADING_EDGE_LENGTH = 12;     

     //定义子控件按下状态的持续事件     
     private static final int PRESSED_STATE_DURATION = 125;     

     //定义一个按下状态转变成长按状态的转变时间     
     private static final int LONG_PRESS_TIMEOUT = 500;     

     //定义用户在按住适当按钮，弹出全局的对话框的持续时间     
     private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;     

     //定义一个touch事件中是点击事件还是一个滑动事件所需的时间，如果用户在这个时间之内滑动，那么就认为是一个点击事件     
     private static final int TAP_TIMEOUT = 115;     

     /**    
      * Defines the duration in milliseconds we will wait to see if a touch event     
      * is a jump tap. If the user does not complete the jump tap within this interval, it is    
      * considered to be a tap.     
      */ 
     //定义一个touch事件时候是一个点击事件。如果用户在这个时间内没有完成这个点击，那么就认为是一个点击事件     
     private static final int JUMP_TAP_TIMEOUT = 500;     

     //定义双击事件的间隔时间     
     private static final int DOUBLE_TAP_TIMEOUT = 300;     

     //定义一个缩放控制反馈到用户界面的时间     
     private static final int ZOOM_CONTROLS_TIMEOUT = 3000;     

     /**    
      * Inset in pixels to look for touchable content when the user touches the edge of the screen    
      */ 
     private static final int EDGE_SLOP = 12;     

     /**    
      * Distance a touch can wander before we think the user is scrolling in pixels    
      */ 
     private static final int TOUCH_SLOP = 16;     

     /**    
      * Distance a touch can wander before we think the user is attempting a paged scroll    
      * (in dips)    
      */ 
     private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;     

     /**    
      * Distance between the first touch and second touch to still be considered a double tap    
      */ 
     private static final int DOUBLE_TAP_SLOP = 100;     

     /**    
      * Distance a touch needs to be outside of a window&#39;s bounds for it to    
      * count as outside for purposes of dismissing the window.    
      */ 
     private static final int WINDOW_TOUCH_SLOP = 16;     

    //用来初始化fling的最小速度，单位是每秒多少像素     
     private static final int MINIMUM_FLING_VELOCITY = 50;     

     //用来初始化fling的最大速度，单位是每秒多少像素     
     private static final int MAXIMUM_FLING_VELOCITY = 4000;     

     //视图绘图缓存的最大尺寸，以字节表示。在ARGB888格式下，这个尺寸应至少等于屏幕的大小     
     @Deprecated     
     private static final int MAXIMUM_DRAWING_CACHE_SIZE = 320 * 480 * 4; // HVGA screen, ARGB8888     

     //flings和scrolls摩擦力度大小的系数     
     private static float SCROLL_FRICTION = 0.015f;     

     /**    
      * Max distance to over scroll for edge effects    
      */ 
     private static final int OVERSCROLL_DISTANCE = 0;     

     /**    
      * Max distance to over fling for edge effects    
      */ 
     private static final int OVERFLING_DISTANCE = 4;     

 }
</code></pre>
<ul>
<li><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2></li>
</ul>
<ol>
<li><a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解安卓事件分发机制</a></li>
<li><a href="https://www.youtube.com/watch?v=usBaTHZdXSI" target="_blank" rel="external">making sense of the touch system</a></li>
<li><a href="http://blog.csdn.net/ddna/article/details/5451722" target="_blank" rel="external">Android onTouchEvent, onClick及onLongClick的调用机制</a></li>
<li><a href="http://wangkuiwu.github.io/2015/01/03/TouchEvent-View/" target="_blank" rel="external">Android触摸事件机制(三)</a></li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0225/907.html" target="_blank" rel="external">ViewConfiguration用法</a></li>
<li><p><a href="http://glblong.blog.51cto.com/3058613/1559320" target="_blank" rel="external">触摸事件的分析与总结</a></p>
<p>​</p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/06/touch-event-distribution/" class="archive-article-date">
  	<time datetime="2016-10-06T15:32:30.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-06</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TouchEvent/">TouchEvent</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/10/08/android-7-0-new-features/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          android 7.0一些新特性介绍及适配方案
        
      </div>
    </a>
  
  
    <a href="/2016/09/30/service-activity-communication/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">service和activity的通信方式</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>









      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Haldir
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Butterknife/" style="font-size: 10px;">Butterknife</a> <a href="/tags/Handler-Message/" style="font-size: 10px;">Handler Message</a> <a href="/tags/RecyclerView/" style="font-size: 10px;">RecyclerView</a> <a href="/tags/TouchEvent/" style="font-size: 15px;">TouchEvent</a> <a href="/tags/Window/" style="font-size: 10px;">Window</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/android-7/" style="font-size: 10px;">android 7</a> <a href="/tags/databinding/" style="font-size: 10px;">databinding</a> <a href="/tags/foreground/" style="font-size: 10px;">foreground</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/service/" style="font-size: 10px;">service</a> <a href="/tags/statusBar/" style="font-size: 10px;">statusBar</a> <a href="/tags/transition/" style="font-size: 10px;">transition</a> <a href="/tags/坐标/" style="font-size: 10px;">坐标</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>