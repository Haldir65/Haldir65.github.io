<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haldir的博客</title>
  <subtitle>get busy living</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haldir65.github.io/"/>
  <updated>2017-08-12T03:10:15.324Z</updated>
  <id>https://haldir65.github.io/</id>
  
  <author>
    <name>Haldir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发实践手册</title>
    <link href="https://haldir65.github.io/2017/08/03/2017-08-03-high-concurrency-recipes/"/>
    <id>https://haldir65.github.io/2017/08/03/2017-08-03-high-concurrency-recipes/</id>
    <published>2017-08-03T13:04:28.000Z</published>
    <updated>2017-08-12T03:10:15.324Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://odzl05jxx.bkt.clouddn.com/image/blog/be3c80a11edfd0fdb75d098550ed2c8e.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-同时对共享资源进行操作好一点的加锁的方式"><a href="#1-同时对共享资源进行操作好一点的加锁的方式" class="headerlink" title="1. 同时对共享资源进行操作好一点的加锁的方式"></a>1. 同时对共享资源进行操作好一点的加锁的方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">           lock.lock(); <span class="comment">//拿不到lock的Thread会挂起</span></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="keyword">this</span>.mList.add(<span class="string">"new elements added by"</span> + mIndex + <span class="string">""</span>); <span class="comment">//对共享资源的操作放这里</span></div><div class="line">           &#125;</div><div class="line">           <span class="keyword">finally</span> &#123;</div><div class="line">               lock.unlock(); <span class="comment">//记得解锁</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<h2 id="2-ThreadLocal当做一个HashMap来用就好了"><a href="#2-ThreadLocal当做一个HashMap来用就好了" class="headerlink" title="2. ThreadLocal当做一个HashMap来用就好了"></a>2. ThreadLocal当做一个HashMap来用就好了</h2><p><strong>volatile并不是Atomic操作，例如，A线程对volatile变量进行写操作(实际上是读和写操作)，B线程可能在这两个操作之间进行了写操作；</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/fw0124/article/details/6672522">看起来 ReentrantLock 无论在哪方面都比 synchronized 好</a></li>
<li><a href="https://www.youtube.com/watch?v=yS0Nc-L1Uuk">Jesse Wilson - Coordinating Space and Time</a></li>
<li><a href="http://www.cnblogs.com/xrq730/p/7048693.html">一级缓存，时钟周期</a>volatile硬件层面的实现原理<br>-</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/image/blog/be3c80a11edfd0fdb75d098550ed2c8e.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
      <category term="concurrency" scheme="https://haldir65.github.io/tags/concurrency/"/>
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>多线程断点续传原理及实现</title>
    <link href="https://haldir65.github.io/2017/08/01/2017-08-01-mutithread-downloader/"/>
    <id>https://haldir65.github.io/2017/08/01/2017-08-01-mutithread-downloader/</id>
    <published>2017-08-01T14:19:31.000Z</published>
    <updated>2017-08-05T14:33:32.968Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲一下在java中实现多线程断点续传的原理,主要讲断点下载的原理。<br><img src="http://odzl05jxx.bkt.clouddn.com/4b52d8db2e9d86b95c730af1db127a81.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<p>其实就是在Http请求里面加上一个”range”的header，HttpUrlConnection可以这么干：</p>
<ul>
<li>conn.setRequestProperty(“Range”, “bytes=” + 500 + “-“ + 1000);</li>
</ul>
<p>也就是告诉服务器上次下载到的位置，本地写文件可以使用RandomAccessFile。本地需要记录下上次中断后停下来的位置。可以用db记录，也可以用sp记录。</p>
<p>这里面的难点在于多线程同步问题，高效率锁。还得要使用ArrayBlockingQueue。</p>
<h2 id="1-获取要下载的内容的contentLength"><a href="#1-获取要下载的内容的contentLength" class="headerlink" title="1. 获取要下载的内容的contentLength"></a>1. 获取要下载的内容的contentLength</h2><p>HttpUrlConnection有一个connection.getContentLength()方法，用于获取内容大小(bytes)</p>
<h2 id="2-大文件上传避免oom"><a href="#2-大文件上传避免oom" class="headerlink" title="2. 大文件上传避免oom"></a>2. 大文件上传避免oom</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Caused by java.lang.OutOfMemoryError: Failed to allocate a <span class="number">65548</span> <span class="keyword">byte</span> allocation with <span class="number">32012</span> free bytes and <span class="number">31</span>KB until OOM</div><div class="line">at com.android.okio.Segment.&lt;init&gt;(Segment.java:<span class="number">37</span>)</div><div class="line">at com.android.okio.SegmentPool.take(SegmentPool.java:<span class="number">48</span>)</div><div class="line">at com.android.okio.OkBuffer.writableSegment(OkBuffer.java:<span class="number">511</span>)</div><div class="line">at com.android.okio.OkBuffer.write(OkBuffer.java:<span class="number">424</span>)</div><div class="line">at com.android.okio.OkBuffer.clone(OkBuffer.java:<span class="number">740</span>)</div><div class="line">at com.android.okhttp.internal.http.RetryableSink.writeToSocket(RetryableSink.java:<span class="number">77</span>)</div><div class="line">at com.android.okhttp.internal.http.HttpConnection.writeRequestBody(HttpConnection.java:<span class="number">263</span>)</div><div class="line">at com.android.okhttp.internal.http.HttpTransport.writeRequestBody(HttpTransport.java:<span class="number">84</span>)</div><div class="line">at com.android.okhttp.internal.http.HttpEngine.readResponse(HttpEngine.java:<span class="number">790</span>)</div><div class="line">at com.android.okhttp.internal.http.HttpURLConnectionImpl.execute(HttpURLConnectionImpl.java:<span class="number">405</span>)</div><div class="line">at com.android.okhttp.internal.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:<span class="number">349</span>)</div><div class="line">at com.android.okhttp.internal.http.HttpURLConnectionImpl.getResponseCode(HttpURLConnectionImpl.java:<span class="number">517</span>)</div><div class="line">at com.android.okhttp.internal.http.DelegatingHttpsURLConnection.getResponseCode(DelegatingHttpsURLConnection.java:<span class="number">105</span>)</div></pre></td></tr></table></figure>
<p><a href="http://blog.sina.com.cn/s/blog_bfdb961b0101mkbo.html">参考</a> con.setChunkedStreamingMode(1024);//内部缓冲区—分段上传防止oom<br><a href="https://github.com/square/retrofit/issues/2270">解决方案</a>,RequestBody的contentLength设置为-1就好了<br><a href="http://www.cnblogs.com/begin1949/p/5060802.html">HttpURLConnection教程</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/2b82db0a5181">简书</a></li>
<li><a href="https://github.com/AriaLyy/Aria">Demo</a></li>
<li><a href="https://github.com/Aspsine/MultiThreadDownload">MultiThreadDownload for Android</a></li>
<li><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/43939279">csdn</a></li>
<li><a href="http://blog.csdn.net/chenrunhua/article/details/50113993">断点上传麻烦点，要自己搭server</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要讲一下在java中实现多线程断点续传的原理,主要讲断点下载的原理。&lt;br&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/4b52d8db2e9d86b95c730af1db127a81.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>二进制编码总结</title>
    <link href="https://haldir65.github.io/2017/07/30/2017-07-30-decoding-the-secret-of-binary/"/>
    <id>https://haldir65.github.io/2017/07/30/2017-07-30-decoding-the-secret-of-binary/</id>
    <published>2017-07-30T09:45:51.000Z</published>
    <updated>2017-08-12T03:09:58.650Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://odzl05jxx.bkt.clouddn.com/01f691dea62d22e138481a353fbb6228.jpg?imageView2/2/w/600" alt=""></p>
<a id="more"></a>
<h2 id="1-重新学习Java基本数据类型"><a href="#1-重新学习Java基本数据类型" class="headerlink" title="1.重新学习Java基本数据类型"></a>1.重新学习Java基本数据类型</h2><h3 id="基本数据类型之间的转换"><a href="#基本数据类型之间的转换" class="headerlink" title="基本数据类型之间的转换"></a>基本数据类型之间的转换</h3><p>初学java的时候都说没必要记住各种基本数据类型的大小范围。这里补上一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</div><div class="line"></div><div class="line">short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。</div><div class="line"></div><div class="line">int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</div><div class="line"></div><div class="line">long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</div><div class="line"></div><div class="line">float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</div><div class="line"></div><div class="line">double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</div><div class="line"></div><div class="line">boolean：只有true和false两个取值。</div><div class="line"></div><div class="line">char：16位，存储Unicode码，用单引号赋值。</div></pre></td></tr></table></figure>
<p>这个表的顺序是有道理的，byte-&gt;short-&gt;int-&gt;long这类表示的都是整数（不带小数点的）;<br>float-&gt;double这类表示的都是浮点数(计算机里没有小数点，都是用类似科学计数法来表示的);</p>
<p>后面这俩比较特殊：<br>boolean只有两个值;<br>char专门用来表示Unicode码，最小值是0，最大值是65535(2^16-1);</p>
<ul>
<li>(这个范围是严格限定的，比如byte a = 127都没问题，byte a = 128 立马编译有问题。)<br>另外，char是为数不多的可以在java IDE里面像python一样写单引号的机会：<br>char c = ‘1’ // ok<br>char c = ‘12’//错误<br>char c = 12 //正确</li>
</ul>
<p>当一个较大的数和一个较小的数在一块运算的时候，系统会自动将较小的数转换成较大的数，再进行运算。<a href="http://www.cnblogs.com/doit8791/archive/2012/05/25/2517448.html">这里的大小指的是基本类型范围的大小</a><br>所以(byte、short、char) -&gt; int -&gt; long -&gt; float -&gt; double这么从小往大转是没有问题的。编译器自动转，所以经常不会被察觉。<br>byte、short、char这三个是平级的，相互转换也行。<br>试了下,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</div><div class="line"><span class="keyword">char</span> c = <span class="string">'2'</span>;</div><div class="line"><span class="keyword">short</span> s = <span class="number">23</span>;</div><div class="line"></div><div class="line">s = b; <span class="comment">//只有byte往上转short是自动的</span></div><div class="line">b = (<span class="keyword">byte</span>) s;</div><div class="line"></div><div class="line"></div><div class="line">s = (<span class="keyword">short</span>) c;</div><div class="line">c = (<span class="keyword">char</span>) s;</div><div class="line"></div><div class="line">b = (<span class="keyword">byte</span>) c;</div><div class="line">c = (<span class="keyword">char</span>) b;</div></pre></td></tr></table></figure></p>
<p>强转就意味着可能的精度损失。</p>
<p>所以除去boolean以外:</p>
<ul>
<li>char</li>
<li>byte,short,int,long</li>
<li>float,double<br>可以分成这三类，从小往大转没问题，同一类从小到大转没问题。</li>
</ul>
<p>具体到实际操作上：</p>
<ol>
<li>char-&gt;byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>有一个操作数是long，结果是long</li>
<li>有一个操作数是float,结果是float</li>
<li>有一个操作数是double，结果是double</li>
<li>long l = 424323L ,后面的L要大写。</li>
<li>这些整数都是没办法表示一个小数的，要用float或者double，后面加上f（F）或者L。</li>
<li>char(16位)，能表示的范围大小和short一样，是用单引号括起来的一个字符(可以是中文字符)，两个字符不行。</li>
<li>char的原理就是转成int，根据unicode编码找到对应的符号并显示出来。</li>
<li>两个char相加，就是转成int之后两个int相加</li>
<li>double类型后面可以不写D</li>
<li>float后面写f或者F都一样</li>
</ol>
<h2 id="2-Encoding解析"><a href="#2-Encoding解析" class="headerlink" title="2. Encoding解析"></a>2. Encoding解析</h2><p>java编译器将源代码编译位字节码时，会用int来表示boolean(非零表示真)<br>byte,short,int,long这些都是有符号的整数，八进制数以0开头，十六进制数字以0x开头</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.youtube.com/watch?v=T_p22jMZSrk">Jesse Wilson | Decoding the Secrets of Binary Data </a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/01f691dea62d22e138481a353fbb6228.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>位运算总结</title>
    <link href="https://haldir65.github.io/2017/07/23/2017-07-23-manipulating-bits/"/>
    <id>https://haldir65.github.io/2017/07/23/2017-07-23-manipulating-bits/</id>
    <published>2017-07-23T11:06:46.000Z</published>
    <updated>2017-08-12T03:09:58.641Z</updated>
    
    <content type="html"><![CDATA[<p>位运算的好处至少有两点，由于是直接操作bit,没有任何包装类，速度快。另外一个就是节省内存了。</p>
<p><img src="http://odzl05jxx.bkt.clouddn.com/8af185ed137a586be732d63425d8bcb8.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-左移（-lt-lt-）"><a href="#1-左移（-lt-lt-）" class="headerlink" title="1.左移（&lt;&lt;）"></a>1.左移（&lt;&lt;）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="number">5</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//运行结果是20  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理：<br>5的二进制表示方式是：<br>0000 0000 0000 0000 0000 0000 0000 0101<br>向左挪两位就变成了<br>0000 0000 0000 0000 0000 0000 0001 0100 //末位补零 ，也就是20</p>
<p>可以认为 5&lt;&lt;n就代表乘以2的n次方<br>所以10KB可以这么写 ： 10&lt;&lt;10</p>
<h2 id="2-右移-gt-gt"><a href="#2-右移-gt-gt" class="headerlink" title="2.右移(&gt;&gt;)"></a>2.右移(&gt;&gt;)</h2><p>和左移反过来，前面补0。一样的道理，不再赘述。</p>
<h2 id="3-无符号右移-gt-gt-gt"><a href="#3-无符号右移-gt-gt-gt" class="headerlink" title="3. 无符号右移(&gt;&gt;&gt;)"></a>3. 无符号右移(&gt;&gt;&gt;)</h2><p>在java中一个int占32位，正数的首位是0，负数位-1。<br>-5 就是<br>1111 1111 1111 1111 1111 1111 1111 1011</p>
<p>正数右移，高位用0补；负数右移，高位用1补；负数无符号右移，用0补高位。</p>
<p>所以-5&gt;&gt;&gt;3 也就变成了<br>0001 1111 1111 1111 1111 1111 1111 1111 //十进制536870911</p>
<p>注意，正数或者负数左移，低位都是用0补</p>
<h2 id="4-位与-amp"><a href="#4-位与-amp" class="headerlink" title="4. 位与(&amp;)"></a>4. 位与(&amp;)</h2><p>看实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">       System.out.println(<span class="number">5</span> &amp; <span class="number">3</span>);<span class="comment">//结果为1  </span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>原因： 5的二进制是： 0000 0000 0000 0000 0000 0000 0000 0101<br>      3的二进制是：  0000 0000 0000 0000 0000 0000 0000 0011<br>同一位上必须都为1，结果才为1，否则为0；于是结果就得到：<br>      0000 0000 0000 0000 0000 0000 0000 0001 = 1</p>
<h2 id="5-位或（-）"><a href="#5-位或（-）" class="headerlink" title="5. 位或（|）"></a>5. 位或（|）</h2><p>和位与相反<br>同一位上只要有一个为1，就为1.只有两个都为0，才为0.<br>二进制下：<br>      5的二进制是： 0000 0000 0000 0000 0000 0000 0000 0101<br>      3的二进制是： 0000 0000 0000 0000 0000 0000 0000 0011<br>所以结果是 7        0000 0000 0000 0000 0000 0000 0000 0111<br>所以 (5|3) = 7(这让人想到linux文件权限的777)</p>
<p>其实就是 111 111 111 （owner,creater,others）</p>
<h2 id="6-位异或"><a href="#6-位异或" class="headerlink" title="6. 位异或(^)"></a>6. 位异或(^)</h2><p>还是拿5和3一起算<br>第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n为也为1，否则为0<br>二进制下：<br>      5的二进制是： 0000 0000 0000 0000 0000 0000 0000 0101<br>      3的二进制是： 0000 0000 0000 0000 0000 0000 0000 0011<br>所以结果是 6        0000 0000 0000 0000 0000 0000 0000 0110<br>所以a^b可以用来判断两个Flag前后有没有发生变化，有时候如果发现前后flag没有变化，即不操作。</p>
<h2 id="7-位非"><a href="#7-位非" class="headerlink" title="7.位非(~)"></a>7.位非(~)</h2><p>位非是一元操作符，对一个数进行操作<br>位非：操作数的第n位为1，那么结果的第n位为0，反之为1，就是所有的1变成0,0变成1。<br> 5的二进制是： 0000 0000 0000 0000 0000 0000 0000 0101<br> 倒过来就是：  1111 1111 1111 1111 1111 1111 1111 1010<br>负整数转二进制的标准方法：先是将对应的正整数转换成二进制后，对二进制取反，然后对结果再加一。</p>
<h2 id="8-一些衍生的操作符"><a href="#8-一些衍生的操作符" class="headerlink" title="8.一些衍生的操作符"></a>8.一些衍生的操作符</h2><p>从上面的一些基本操作符衍生来的有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&amp;= 按位与赋值</div><div class="line">|=  按位或赋值</div><div class="line">^= 按位非赋值</div><div class="line">&gt;&gt;= 右移赋值</div><div class="line">&gt;&gt;&gt;= 无符号右移赋值</div><div class="line">&lt;&lt;= 赋值左移</div></pre></td></tr></table></figure>
<p>和+=一个意思。至于那个运算符优先级，算了吧。</p>
<h2 id="9-一些常用的小技巧"><a href="#9-一些常用的小技巧" class="headerlink" title="9.一些常用的小技巧"></a>9.一些常用的小技巧</h2><p>// 1. 获得int型最大值<br>System.out.println((1 &lt;&lt; 31) - 1);// 2147483647， 由于优先级关系，括号不可省略<br>System.out.println(~(1 &lt;&lt; 31));// 2147483647</p>
<p>// 2. 获得int型最小值<br>System.out.println(1 &lt;&lt; 31);<br>System.out.println(1 &lt;&lt; -1);</p>
<p>// 3. 获得long类型的最大值<br>System.out.println(((long)1 &lt;&lt; 127) - 1);</p>
<p>// 4. 乘以2运算<br>System.out.println(10&lt;&lt;1);</p>
<p>// 5. 除以2运算(负奇数的运算不可用)<br>System.out.println(10&gt;&gt;1);</p>
<p>// 6. 乘以2的m次方<br>System.out.println(10&lt;&lt;2);</p>
<p>// 7. 除以2的m次方<br>System.out.println(16&gt;&gt;2);</p>
<p>// 8. 判断一个数的奇偶性<br>System.out.println((10 &amp; 1) == 1);<br>System.out.println((9 &amp; 1) == 1);</p>
<p>// 9. 不用临时变量交换两个数（面试常考）<br>a ^= b;<br>b ^= a;<br>a ^= b;</p>
<p>// 10. 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高）<br>int n = -1;<br>System.out.println((n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31));<br>/<em> n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1<br>若n为正数 n^0-0数不变，若n为负数n^-1 需要计算n和-1的补码，异或后再取补码，<br>结果n变号并且绝对值减1，再减去-1就是绝对值 </em>/</p>
<p>// 11. 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高）<br>System.out.println(b&amp;((a-b)&gt;&gt;31) | a&amp;(~(a-b)&gt;&gt;31));</p>
<p>// 12. 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高）<br>System.out.println(a&amp;((a-b)&gt;&gt;31) | b&amp;(~(a-b)&gt;&gt;31));</p>
<p>// 13. 判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)<br>System.out.println((a ^ b) &gt; 0);</p>
<p>// 14. 计算2的n次方 n &gt; 0<br>System.out.println(2&lt;&lt;(n-1));</p>
<p>// 15. 判断一个数n是不是2的幂<br>System.out.println((n &amp; (n - 1)) == 0);<br>/<em>如果是2的幂，n一定是100… n-1就是1111….<br>所以做与运算结果为0</em>/</p>
<p>// 16. 求两个整数的平均值<br>System.out.println((a+b) &gt;&gt; 1);</p>
<p>// 17. 从低位到高位,取n的第m位<br>int m = 2;<br>System.out.println((n &gt;&gt; (m-1)) &amp; 1);</p>
<p>// 18. 从低位到高位.将n的第m位置为1<br>System.out.println(n | (1&lt;&lt;(m-1)));<br>/<em>将1左移m-1位找到第m位，得到000…1…000<br>n在和这个数做或运算</em>/</p>
<p>// 19. 从低位到高位,将n的第m位置为0<br>System.out.println(n &amp; ~(0&lt;&lt;(m-1)));<br>/<em> 将1左移m-1位找到第m位，取反后变成111…0…1111<br>n再和这个数做与运算</em>/</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><ol>
<li>记得Chet Haase和Romain Guy曾经在2013年的一次<a href="https://www.youtube.com/watch?v=Ho-anLsWvJo">演讲</a>中提到,Android中View内部使用了3个int来表示70多个Flags。如果换做boolean(4byte大小)的话，就需要接近300bytes。由于View在Application中被广泛（成百上千）使用，framework这样做事实上为开发者节约了相当多的内存。<br>android.view.View.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int mPrivateFlags;</div><div class="line">int mPrivateFlags2;</div><div class="line">int mPrivateFlags3;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>int中的每一个bit都成为一个boolean，一共只用了12bytes(96bits)的内存.和300bytes相比，节省的内存总量还是相当可观的。<br>一个onClickListener大概500bytes<br>所以View.java中到处是这样的奇怪的Flags<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawingCacheEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">      mCachingFailed = <span class="keyword">false</span>;</div><div class="line">      setFlags(enabled ? <span class="number">0x00008000</span> : <span class="number">0</span>, <span class="number">0x00008000</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"drawing"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDrawingCacheEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> (mViewFlags &amp; <span class="number">0x00008000</span>) == <span class="number">0x00008000</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>除了省内存，位运算速度快也有一定的好处。</p>
<ol>
<li><p>不要迷信位运算，对于一些简单的操作，现代编译器还是能够帮助开发者自动做好优化的。</p>
</li>
<li><p>从java7开始，可以在java代码里<a href="https://www.bbsmax.com/A/xl569bA1Jr/">直接写二进制，八进制，十六进制的数字了</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//16进制</span></div><div class="line">jdk6写法：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="keyword">int</span> res = Integer.parseInt(<span class="string">"A"</span>, <span class="number">16</span>);</div><div class="line">         System.out.println(res);</div><div class="line">     &#125;</div><div class="line">jdk7写法：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="keyword">int</span> res = <span class="number">0xA</span>;</div><div class="line">         System.out.println(res);</div><div class="line">     &#125;</div><div class="line"></div><div class="line"><span class="comment">// 8进制</span></div><div class="line">jdk6写法:</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="keyword">int</span> res = Integer.parseInt(<span class="string">"11"</span>,<span class="number">8</span>);</div><div class="line">         System.out.println(res);</div><div class="line">     &#125;</div><div class="line">jdk7写法:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="keyword">int</span> res = <span class="number">011</span>;</div><div class="line">         System.out.println(res);</div><div class="line">     &#125;</div><div class="line"></div><div class="line"><span class="comment">//二进制</span></div><div class="line">jdk6写法:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="keyword">int</span> res = Integer.parseInt(<span class="string">"1100110"</span>, <span class="number">2</span>);</div><div class="line">         System.out.println(res);</div><div class="line">     &#125;</div><div class="line">jdk7写法:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="keyword">int</span> res = <span class="number">0b1100110</span>;</div><div class="line">         System.out.println(res);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>即：<br>二进制： int res = 0b110; 六（0B也行，0b01_10010_0这种加下划线也行）<br>八进制： int res = 0110; 七十二<br>十六进制： int res = 0xA;  十</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://my.oschina.net/xianggao/blog/412967">Java位运算操作全面总结</a></li>
<li><a href="http://blog.csdn.net/xiaochunyong/article/details/7748713">Java 位运算(移位、位与、或、异或、非）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;位运算的好处至少有两点，由于是直接操作bit,没有任何包装类，速度快。另外一个就是节省内存了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/8af185ed137a586be732d63425d8bcb8.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="https://haldir65.github.io/2017/07/23/2017-07-23-design-pattern/"/>
    <id>https://haldir65.github.io/2017/07/23/2017-07-23-design-pattern/</id>
    <published>2017-07-23T11:03:51.000Z</published>
    <updated>2017-08-01T14:32:19.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://odzl05jxx.bkt.clouddn.com/509bdb071f9e7040823049e3db56e7c1.jpeg?imageView2/2/w/600" alt=""><br>一般来讲设计模式有23种，这里根据菜鸟教程上的关于设计模式的总结看下来的一些读书笔记，估计要写很久。<br><a id="more"></a></p>
<p>设计模式分四大类：</p>
<ul>
<li>创建型模式</li>
<li>结构型模式</li>
<li>行为型模式</li>
<li>J2EE模式</li>
</ul>
<h2 id="1-面向对象的六大原则"><a href="#1-面向对象的六大原则" class="headerlink" title="1. 面向对象的六大原则"></a>1. 面向对象的六大原则</h2><p>这个就当背书好了。</p>
<ul>
<li>单一职责原则</li>
<li>开闭原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特原则</li>
</ul>
<h2 id="2-23中设计模式简单介绍"><a href="#2-23中设计模式简单介绍" class="headerlink" title="2. 23中设计模式简单介绍"></a>2. 23中设计模式简单介绍</h2><ol>
<li>工厂模式<br>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li>
</ol>
<p>做法： 定义一个完成某项功能的接口，功能的具体实现由子类决定，让子类实现工厂接口，返回的也是一个抽象产品。</p>
<p>实例：<br>getSystemService根据传入的参数决定返回什么样的SystemService实例。</p>
<ol>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li></li>
</ol>
<p><img src="http://odzl05jxx.bkt.clouddn.com/77a5260f0e038392414105c5bf8fdecc.jpg?imageView2/2/w/600" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://zz563143188.iteye.com/blog/1847029">设计模式大全</a></li>
<li><a href="http://www.jianshu.com/p/1a9f571ad7c0从Android代码中来记忆23种设计模式">从Android代码中来记忆23种设计模式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/509bdb071f9e7040823049e3db56e7c1.jpeg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;一般来讲设计模式有23种，这里根据菜鸟教程上的关于设计模式的总结看下来的一些读书笔记，估计要写很久。&lt;br&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
      <category term="designpattern" scheme="https://haldir65.github.io/tags/designpattern/"/>
    
  </entry>
  
  <entry>
    <title>java对象内存占用分析</title>
    <link href="https://haldir65.github.io/2017/07/23/2017-07-23-from-java-code-to-java-heap/"/>
    <id>https://haldir65.github.io/2017/07/23/2017-07-23-from-java-code-to-java-heap/</id>
    <published>2017-07-23T11:02:52.000Z</published>
    <updated>2017-08-12T03:09:58.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://odzl05jxx.bkt.clouddn.com/9b157a7acab582078ac1fabada5c8009.jpg?imageView2/2/w/600" alt=""><br>面向对象语言就意味着对象要占用内存空间，那么，java中随便new 出来的东西到底多大？还有，new出来的东西全都都放在heap上吗(有些真不是)？<br><a id="more"></a></p>
<h2 id="1-首先给出精确判断Object大小的一种方法"><a href="#1-首先给出精确判断Object大小的一种方法" class="headerlink" title="1.首先给出精确判断Object大小的一种方法"></a>1.首先给出精确判断Object大小的一种方法</h2><p>一个判断Java Object大小的方法<br>比较精准的确定一个对象的大小的<a href="https://github.com/liaohuqiu/java-object-size">方法</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSizeFetcher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation instrumentation;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation inst)</span> </span>&#123;</div><div class="line">        instrumentation = inst;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getObjectSize</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instrumentation.getObjectSize(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样通常在IDE里面跑不起来。</p>
<p>据说dump memory也行，没试过。</p>
<h2 id="2-内存对齐"><a href="#2-内存对齐" class="headerlink" title="2. 内存对齐"></a>2. 内存对齐</h2><p>JVM为了malloc与gc方便，指定分配的每个对象都需要是8字节的整数倍<a href="http://github.thinkingbar.com/alignment/">参考</a><br>简单来说，一个Object占用的内存大小是8 Byte的倍数</p>
<h2 id="3-java进程的内存占用情况"><a href="#3-java进程的内存占用情况" class="headerlink" title="3. java进程的内存占用情况"></a>3. java进程的内存占用情况</h2><h3 id="3-1-操作系统和runtime占用的内存"><a href="#3-1-操作系统和runtime占用的内存" class="headerlink" title="3.1 操作系统和runtime占用的内存"></a>3.1 操作系统和runtime占用的内存</h3><p>操作系统的内存中，一部分被操作系统和kernel所占用。对于用c或者c++写的jvm，还需要分配一部分给c runtime。操作系统和c<br>runtime占用的内存比较大，不同的操作系统上不一样，windows上默认是2GB。剩下的内存(即user space)，就是进程可以使用的内存。</p>
<h3 id="3-2-剩下的内存-user-space"><a href="#3-2-剩下的内存-user-space" class="headerlink" title="3.2 剩下的内存(user space)"></a>3.2 剩下的内存(user space)</h3><p>对于Java进程来讲，这剩下的部分分为两块:</p>
<ul>
<li>Java Heap(s)</li>
<li>Native (non-java) Heap</li>
</ul>
<p>Java Heap可以通过-Xms 和 -Xmx 来设置最小值和最大值<br>Native Heap是在分配了java maximum Heap大小之后剩下的大小(jvm占用的内存也算在这里面)</p>
<h3 id="3-3-数据类型大小"><a href="#3-3-数据类型大小" class="headerlink" title="3.3 数据类型大小"></a>3.3 数据类型大小</h3><p>基本数据类型大小很简单，其实也不简单。这张图是从ibm网站上截下来的<br><img src="http://odzl05jxx.bkt.clouddn.com/official_java_primitive_type_size_table.JPG" alt=""><br>注意一个boolean在数组中只占用一个字节，单独使用占用4个字节。<br>原理<a href="http://www.jianshu.com/p/2f663dc820d0">参考</a></p>
<p>引用的大小：<br>在 32 位的 JVM 上，一个对象引用占用 4 个字节；在 64 位上，占用 8 个字节。通过 java -d64 -version 可确定是否是 64 位的 JVM。<br>处理器能够处理的bit范围决定了操作系统能够使用的内存范围：<br>32位的cpu(2^32 = 4,294,967,296 bits = 4GB)<br>64位cpu (2^64 = 18,446,744,073,709,551,616 = 16 exabytes)<br>多数jvm是用c或者c++写的:</p>
<ul>
<li>the Java runtime creates an operating-system process — just as if you were running a C-based program. In fact, most JVMs are written largely in C or C++</li>
</ul>
<p>查看jvm是否64位的方法:</p>
<ul>
<li>java -d64 -version<br>64位上引用占用大小变大的原因是，需要管理4g以上的内存，指针(内存地址不够用了)</li>
</ul>
<h2 id="4-java对象内存布局，从一个Integer说起"><a href="#4-java对象内存布局，从一个Integer说起" class="headerlink" title="4. java对象内存布局，从一个Integer说起"></a>4. java对象内存布局，从一个Integer说起</h2><p>一个class实例占据的大小包括:</p>
<ol>
<li>自身的大小（对象头+基本数据类型数据大小） - Shadow heap size<br>Object自身的大小在不同的jvm版本和厂商之间有一些变化，但大体上包括三个部分:</li>
</ol>
<ul>
<li>Class ： 一个指针，指向对应的class，用于表明其类型。比如一个Integer就指向java.lang.Integer这个类(32位上4字节，64位上8字节)</li>
<li>Flags : A collection of flags that describe the state of the object, including the hash code for the object if it has one, and the shape of the object (that is, whether or not the object is an array).（就是存hash值和用于表示是不是数组的，32位上4字节，64位上8字节）</li>
<li>Lock 所有的Object都能lock，这部分内存用于表示当前Object是否是被synchronized(32位上4字节，64位上8字节)</li>
</ul>
<p>所以，对于java.lang.Integer来说，一个Integer的大小就是：<br>32(class信息)+32(Flags)+32(Lock))+32(int是基本数据类型，4字节) = 128bits（16字节）<br>事实上，一个Interger的大小是int（4个字节）的四倍，简单来说一个对象的头信息就占用了3个字节。</p>
<ol>
<li><p>数组的大小<br>数组和普通的object差不多，多了一个size(32字节)。也就是说。为了存储一个int值。使用一个大小为1的int[]数组的内存消耗比一个Integer还要大。（同样，32位4字节，64位8字节）。数组因为多一个size，所以4个字节起步。</p>
</li>
<li><p>8个字节变成4个字节<br>IBM和Oracle的jvm都能够提供ompressed References (-Xcompressedrefs) 和Compressed OOPs (-XX:+UseCompressedOops) 选项。这样一来，原本在64位机器上要占用8个字节的指针就只要占用4个字节了。但这只对java Heap上的内存有效，对于Native Heap这部分，64位占用内存还是要比32位多。所以同样的一份代码，在64位上占用的内存一定比32位上多。jdk 1.6.x之后好像默认是打开了的。</p>
</li>
<li><p>引用的对象的大小(递归即可) - Retained heap size(Shallow Heap大小加上引用的对象的)<br>java.lang.Integer还算比较简单的，里面除了一个int值表示value以外，没有其它的成员变量，所以并没有引用到其他对象的实例。对于复杂一点的数据类型，比如jav.lang.String呢？</p>
</li>
</ol>
<p>String本身是一个很简单的类(如果不算常量池的话)，几乎可以看成一个char数组的wrapper。除了一个普通对象的class、Flag和Locks等信息外，String内部还有一个 private int hash（用于Cache hash值），还有offset和count（这俩好像没找到），此外就是一个char数组了。<br>所以，为了存储8个字符(16个字节,128bits)。首先这个char数组对象占用了16个字节(2*8)+（对象头+数组大小）16个字节 = 256bits。<br>算到String头上，String本身的文件头是12个字节，算上hash,count,offset各自4个字节，就24个字节了。再加上数组的引用4个字节，再加上数组的大小32个字节。<br>合计60个字节（480bits）。而这里面实际有用的数据只有16个字节。73.3%的内存都是存储其他东西的。</p>
<p>说的比较乱了，这里直接照搬一段计算,<a href="http://www.yunweipai.com/archives/1092.html">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- 一般而言，Java 对象在虚拟机的结构如下：</div><div class="line">•对象头（object header）：8 个字节（保存对象的 class 信息、ID、在虚拟机中的状态）</div><div class="line">•Java 原始类型数据：如 int, float, char 等类型的数据</div><div class="line">•引用（reference）：4 个字节</div><div class="line">•填充符（padding）</div><div class="line"></div><div class="line">String定义：</div><div class="line"></div><div class="line">JDK6:</div><div class="line">private final char value[];</div><div class="line">private final int offset;</div><div class="line">private final int count;</div><div class="line">private int hash;</div><div class="line"></div><div class="line">JDK6的空字符串所占的空间为40字节</div><div class="line"></div><div class="line">JDK7:</div><div class="line">private final char value[];</div><div class="line">private int hash;</div><div class="line">private transient int hash32;</div><div class="line"></div><div class="line">JDK7的空字符串所占的空间也是40字节</div><div class="line"></div><div class="line">JDK6字符串内存占用的计算方式：</div><div class="line">首先计算一个空的 char 数组所占空间，在 Java 里数组也是对象，因而数组也有对象头，故一个数组所占的空间为对象头所占的空间加上数组长度，即 8 + 4 = 12 字节 , 经过填充后为 16 字节。</div><div class="line"></div><div class="line">那么一个空 String 所占空间为：</div><div class="line"></div><div class="line">对象头（8 字节）+ char 数组（16 字节）+ 3 个 int（3 × 4 = 12 字节）+1 个 char 数组的引用 (4 字节 ) = 40 字节。</div><div class="line"></div><div class="line">因此一个实际的 String 所占空间的计算公式如下：</div><div class="line"></div><div class="line">8*( ( 8+12+2*n+4+12)+7 ) / 8 = 8*(int) ( ( ( (n) *2 )+43) /8 )</div><div class="line"></div><div class="line">其中，n 为字符串长度。</div></pre></td></tr></table></figure></p>
<ol>
<li>小结<br>随便new一个Object就意味着12个Byte没了，数组的话16个字节没了。每添加一个成员变量（指针），4个字节没了。这些都还没算上实际存储的数据。</li>
</ol>
<h2 id="5-java-util框架中使用的那些集合类"><a href="#5-java-util框架中使用的那些集合类" class="headerlink" title="5. java.util框架中使用的那些集合类"></a>5. java.util框架中使用的那些集合类</h2><h3 id="5-1-HashSet"><a href="#5-1-HashSet" class="headerlink" title="5.1 HashSet"></a>5.1 HashSet</h3><p>A HashSet is an implementation of the Set interface。无重复元素，不保证迭代顺序，常规的add,contains等方法速度不会随着内部元素的增加而变慢。HashSet内部最多有一个null，底层实现是HashMap，这意味着其占用内存要比HashMap大。<br>默认容量 16个Entries<br>内部元素为空时的大小 144bytes<br>查找，添加，删除的时间复杂度为 O(1)，在没有Hash collisions发生的前提下</p>
<h3 id="5-2-HashMap"><a href="#5-2-HashMap" class="headerlink" title="5.2 HashMap"></a>5.2 HashMap</h3><p>A HashMap is an implementation of the Map interface.<br>HashMap是一种存储Key-Value型数据的集合，一个key最多map到一个value，key和value都可以为null，可以存储重复元素。（所以）——HashMap是HashSet的一种功能上的简化。<br>底层是Entries(Entries元素是链表)，长这样。</p>
<ul>
<li>transient HashMapEntry<K,V>[] table = (HashMapEntry<K,V>[]) EMPTY_TABLE;<br>HashMap的成员变量包括：</li>
</ul>
<p>transient HashMapEntry<K,V>[] table（HashMapEntry的数组）<br>int size<br>int threshold<br>final float loadFactor<br>transient int modCount;</p>
<p>一个HashMap刚创建时(完全为空时)的大小为128bytes，jdk 1.8在初始化时没有加载Entries，在put操作时才去分配。可能会好一点。<br>内部结构一般是这样的，一个HashMapEntry的大小为32byte。<br>int KeyHash<br>Object next<br>Object key<br>Object value<br>HashMap每次put键值对时，都使用了一个HashMap$Entry这样的包装类，这意味着整个HashMap的overhead包括：<br>This means that the total overhead of a HashMap consists of the HashMap object, a HashMap$Entry array entry, and a HashMap$Entry object for each entry.<br>直接照搬结论：对于HashMap<br>Default capacities为16个 entries</p>
<p>对于一个有10000个Entries的HashMap，光是由于HashMap，Entry数组以及每个Entry对象带来的overhead就达到了360K左右，这里还不算存储的键值对本身的大小。</p>
<h3 id="5-3-Hashtable"><a href="#5-3-Hashtable" class="headerlink" title="5.3 Hashtable"></a>5.3 Hashtable</h3><p>HashTable和HashMap的主要区别是HashTable是线程安全的，HashTable中很多方法都加上了synchronized修饰。一般来讲，jdk1.5以上如果想要线程安全，直接用synchronizedHashMap。Hashtable继承自Dictionary，后者已经被废弃了，推荐使用map接口的实现类。<br>照搬结论：要存储10k个Entries，overhead达到360k。</p>
<h3 id="5-4-LinkedList"><a href="#5-4-LinkedList" class="headerlink" title="5.4 LinkedList"></a>5.4 LinkedList</h3><p>Linkedist是典型的双向链表，除非增删操作特别频繁，否则没必要使用。<br>查找的时间复杂度为 o(n)。添加的元素被包装在一个Node节点中。<br>存储10K个元素的overhead为240K。</p>
<h3 id="5-5-ArrayList"><a href="#5-5-ArrayList" class="headerlink" title="5.5 ArrayList"></a>5.5 ArrayList</h3><p>ArrayList要好很多，value直接存在一个数组内部，查找的时间复杂度为o(1)<br>存储10K个元素的overhead为40K左右。</p>
<h3 id="5-6-StringBuffer，StringBuilder"><a href="#5-6-StringBuffer，StringBuilder" class="headerlink" title="5.6 StringBuffer，StringBuilder"></a>5.6 StringBuffer，StringBuilder</h3><p>StringBuffer直接强加synchronized，StringBuilder和StringBuffer都继承自AbstractStringBuilder。成员变量就两个一个char[] value和一个int count。</p>
<h2 id="6-集合的默认初始容量和扩系数"><a href="#6-集合的默认初始容量和扩系数" class="headerlink" title="6.集合的默认初始容量和扩系数"></a>6.集合的默认初始容量和扩系数</h2><p>以StirngBuffer为例（也算一种char的集合吧），默认容量是16，即创建了一个char[16]，空的，算上对象头，一共72bytes。这还只是StringBuffer里什么都没存储的情况。<br>StringBuffer sb = new StringBuffer(“My String”)。//算下用了多少内存<br>首先算数组，文件头12bytes，加上size 16bytes。算上数组，（数组长度为str.length+16）一共116bytes，算上内存对齐，一共120bytes。StringBuffer对象的大小：对象头+count+数组指针 = 20 bytes。<br>合计140bytes，内存对齐后144bytes，只为存储”My String”这9个字符（36bytes）。<br>上面提到的这些集合类都对外提供了可以设置初始容量的构造函数以避免内存浪费，但要注意HashMap只接受2的指数幂。</p>
<h3 id="7-high-level抽象带来的便利性及所需付出的代价"><a href="#7-high-level抽象带来的便利性及所需付出的代价" class="headerlink" title="7.high level抽象带来的便利性及所需付出的代价"></a>7.high level抽象带来的便利性及所需付出的代价</h3><p>面向对象语言推荐开发者使用一些高层抽象化的类，但更加复杂的功能意味着内存占用的增加。而内存意味着一切，所以，权衡好开发便利与内存占用对于程序的高效运行就十分重要，而这一切的前提就在于了解这些Wrapper对象工作的原理。</p>
<h2 id="一些很有意思的事情"><a href="#一些很有意思的事情" class="headerlink" title="一些很有意思的事情"></a>一些很有意思的事情</h2><ul>
<li>Integer内部缓存了一个Integer[] ，最大值可以通过(java.lang.Integer.IntegerCache.high)配置</li>
<li>不同版本jdk上String的优化很有意思，又是那个一个String占用多少字节的问题</li>
<li>关于ConcurrentModificationException，对一个集合的更改分为结构性更改和集合元素值的更改，前者会抛出ConcurrentModificationException，后者不会。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.liaohuqiu.net/cn/posts/caculate-object-size-in-java/">JAVA 对象大小</a></li>
<li><a href="http://www.cnblogs.com/zhanjindong/p/3757767.html">一个Java对象到底占用多大内存</a></li>
<li><a href="http://github.thinkingbar.com/lookup-objsize/">查看 Java 对象大小</a></li>
<li><a href="https://www.ibm.com/developerworks/library/j-codetoheap/index.html">From Java code to Java heap</a></li>
<li><a href="https://www.youtube.com/watch?v=FLcXf9pO27w">Understanding the Memory Usage of Your Application</a></li>
<li><a href="https://www.ibm.com/developerworks/library/j-nativememory-linux/index.html">Thanks for the memory, Linux</a></li>
<li><a href="http://www.jianshu.com/p/2f663dc820d0">boolean数组中一个值占用1bit</a></li>
<li><a href="http://www.yunweipai.com/archives/1092.html">不同jdk版本String做的优化</a></li>
<li><a href="http://www.cnblogs.com/xrq730/p/6928133.html">对象头里面的lock是怎么用的</a></li>
<li><a href="https://academy.realm.io/posts/360-andev-2017-romain-guy-chet-haase-android-performance/">Android里面的一个View大概0.5kb</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/9b157a7acab582078ac1fabada5c8009.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;面向对象语言就意味着对象要占用内存空间，那么，java中随便new 出来的东西到底多大？还有，new出来的东西全都都放在heap上吗(有些真不是)？&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LruCache阅读笔记</title>
    <link href="https://haldir65.github.io/2017/07/23/2017-07-23-lru-cache-and-more/"/>
    <id>https://haldir65.github.io/2017/07/23/2017-07-23-lru-cache-and-more/</id>
    <published>2017-07-23T11:02:21.000Z</published>
    <updated>2017-07-30T09:41:22.992Z</updated>
    
    <content type="html"><![CDATA[<p>LruCache在android3.1中加入，即android.util.LruCache，主要是作为一种合理的缓存策略的实现，用于替代原来的SoftReference。v4包提供了static version的实现，即android.support.v4.util.LruCache。<br>此外，还有DiskLruCache对应磁盘缓存，在OkHttp和Glide等开源项目中都有，可直接复制过来，改下包名直接用。这些类本质上都是对于Least Recently Used算法的实现。稍微看了下网上的博客，LruCache实际上就是利用了LinkedHashmap的accessorder来实现末位淘汰的。v4包里的LinkedHashmap就是java.util里面的,platform里的LinkedHashmap添加了一些方法。<br><img src="http://odzl05jxx.bkt.clouddn.com/e73669d80265feff2adcb227b7113f2d.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-使用入门"><a href="#1-使用入门" class="headerlink" title="1. 使用入门"></a>1. 使用入门</h2><p>这是最简单的一个用于缓存图片Bitmap的cache的算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().totalMemory()/<span class="number">1024</span>);</div><div class="line">        <span class="keyword">int</span> cacheSize = maxMemory/<span class="number">8</span>;</div><div class="line">        mMemoryCache = <span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> value.getRowBytes()*value.getHeight()/<span class="number">1024</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div></pre></td></tr></table></figure></p>
<p>这个sizeOf函数必须复写，用于计算单个元素大小，主要为了确保缓存不超出最大容量。</p>
<h2 id="2-简单介绍"><a href="#2-简单介绍" class="headerlink" title="2.简单介绍"></a>2.简单介绍</h2><p>LruCache是线程安全的，在内部的 get、put、remove 包括 trimToSize 都是安全的（因为都上锁了）</p>
<h2 id="简书作者写的比较好"><a href="#简书作者写的比较好" class="headerlink" title="简书作者写的比较好"></a>简书作者写的比较好</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/b49a111147ee">彻底解析Android缓存机制——LruCache</a></li>
<li><a href="http://www.jianshu.com/p/bdbfdfd0641b">Android源码解析——LruCache</a></li>
<li><a href="https://github.com/LittleFriendsGroup/AndroidSdkSourceAnalysis/blob/master/article/LruCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">LruCache 源码解析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LruCache在android3.1中加入，即android.util.LruCache，主要是作为一种合理的缓存策略的实现，用于替代原来的SoftReference。v4包提供了static version的实现，即android.support.v4.util.LruCache。&lt;br&gt;此外，还有DiskLruCache对应磁盘缓存，在OkHttp和Glide等开源项目中都有，可直接复制过来，改下包名直接用。这些类本质上都是对于Least Recently Used算法的实现。稍微看了下网上的博客，LruCache实际上就是利用了LinkedHashmap的accessorder来实现末位淘汰的。v4包里的LinkedHashmap就是java.util里面的,platform里的LinkedHashmap添加了一些方法。&lt;br&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/e73669d80265feff2adcb227b7113f2d.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://haldir65.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>从glide源码到图片加载框架设计思路</title>
    <link href="https://haldir65.github.io/2017/07/21/2017-07-21-glide-decoded/"/>
    <id>https://haldir65.github.io/2017/07/21/2017-07-21-glide-decoded/</id>
    <published>2017-07-20T16:13:02.000Z</published>
    <updated>2017-07-30T10:43:56.324Z</updated>
    
    <content type="html"><![CDATA[<p>glide的源码几个月前曾经拜读过，大致了解了其异步加载的实现原理。图片加载和网络请求很类似，就像当初看Volley，从一个Request —&gt;  CacheDispatch  —&gt; NetworkDispatcher  —-&gt;  ResponseDeliver。优秀的轮子不仅执行效率高，同时具备高的扩展性。读懂源码其实只是第一步，往下应该是利用框架提供的扩展方案，再往后应该就是能够独立设计出一套类似的框架了。</p>
<p><img src="http://odzl05jxx.bkt.clouddn.com/a11f41e0b1df95212c71920b3959cd72.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-使用入门"><a href="#1-使用入门" class="headerlink" title="1. 使用入门"></a>1. 使用入门</h2><p>印象中最早接触Glide是在cheesequare中，顿时发现，原来加载图片可以这么简单，之后的开发过程中总会对Glide有所偏倚。接近两年之后再来过一遍源码，希望能够回答那个“如果让你来设计一个图片加载框架，你会怎么设计？”的问题。<br>使用方式很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Glide.with(activity)</div><div class="line">              .load(R.drawable.image_id)</div><div class="line">              .into(mImageView);</div></pre></td></tr></table></figure>
<p>来看这里面做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</div><div class="line">        <span class="keyword">return</span> get(activity.getApplicationContext());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        assertNotDestroyed(activity);</div><div class="line">        FragmentManager fm = activity.getSupportFragmentManager();</div><div class="line">        <span class="keyword">return</span> supportFragmentGet(activity, fm);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function">SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(<span class="keyword">final</span> FragmentManager fm)</span> </span>&#123;</div><div class="line">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(</div><div class="line">        FRAGMENT_TAG);</div><div class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</div><div class="line">        current = pendingSupportRequestManagerFragments.get(fm);</div><div class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</div><div class="line">            current = <span class="keyword">new</span> SupportRequestManagerFragment();</div><div class="line">            pendingSupportRequestManagerFragments.put(fm, current);</div><div class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class="line">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> current;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>with方法只是返回了一个RequestManager，with方法可以接受Fragemnt,Activity以及Context等.以上面的activity为例，supportFragmentGet方法只是通过FragmentActivity的supportFragmentManager去findFragmentByTag，这个Tag叫做：“com.bumptech.glide.manager”，所以一般在Debug的时候，去SupportFragmentManager里面查找，有时候能够看到一个这样的Fragment。这个方法里面就是查找这样的一个Fragment，甚至我们自己也可以FindFragmentByTag去调用这个Fragment的方法(这是一个Public的class)然后从这个Fragemnt里面获得RequestManager成员变量（没有就new一个并set）。可以看出，一个Fragment只有一个RequestManager，Fragment主要是为了跟Activity生命周期挂钩的。这里有必要讲一下为什么要写两次current ==null，findFragmentByTag并不会在commitAllowingStateLoss之后就会返回添加的Fragment，只是往主线程的MessageQueue里面丢了一个消息，这个消息执行完毕之后才findFragmentByTag才不为空。这里用Handler丢一条消息，这条消息肯定要排在之前那条消息之后才被执行，所以才有这样一个Pendingmap的设计。当然到这里，最重要的还是Glide是通过commit了一个特殊的Fragment来实现生命周期监听。<br>具体来看：SupportRequestManagerFragment中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onStart();</div><div class="line">      lifecycle.onStart();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onStop();</div><div class="line">      lifecycle.onStop();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onDestroy();</div><div class="line">      lifecycle.onDestroy();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>而对应到LifeCycle的各个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">       isStarted = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class="line">           lifecycleListener.onStart();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">       isStarted = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class="line">           lifecycleListener.onStop();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">       isDestroyed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class="line">           lifecycleListener.onDestroy();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>就是把内部维护的一个集合一个个拿出来调用响应生命周期的方法。<br>而这个LifeCycleListener就是上面创建RequestManager时(构造函数传进来了fragment的lifeCycle)添加的。RequestManager还默认添加了一个ConnectivityMonitor，主要作用就是在生命周期的onStart注册了一个ConnectivityManager.CONNECTIVITY_ACTION的BroadCastReceiver，在onStop的时候unRegister，在网络状态变化的时候调用RequestManager的RequestTracker成员变量的restartRequet。</p>
<p>小结：</p>
<ul>
<li>在有权限(android.permission.ACCESS_NETWORK_STATE)的情况下，Glide已经做好了有网-&gt; 断网-&gt; 有网的恢复请求。另外，Android 7.0虽说不再发送ConnectivityManager.CONNECTIVITY_ACTION这个广播，但对于前台应用，动态注册的Receiver还是能够收到，Glide由于是在OnStart注册的，所以完全没问题。</li>
<li>在一个Activity中，RequestManager只要一个，其实开发者自己保留下来也没什么问题</li>
</ul>
<h2 id="2-RequestManager调度请求"><a href="#2-RequestManager调度请求" class="headerlink" title="2. RequestManager调度请求"></a>2. RequestManager调度请求</h2><p>来看下这个RequestManager的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lifecycle lifecycle;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestManagerTreeNode treeNode;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestTracker requestTracker;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Glide glide; <span class="comment">//全局只有一个，控制线程池，用Application的Context创建的</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OptionsApplier optionsApplier;</div><div class="line">    <span class="keyword">private</span> DefaultOptions options;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OptionsApplier</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> &lt;A, X extends GenericRequestBuilder&lt;A, ?, ?, ?&gt;&gt; <span class="function">X <span class="title">apply</span><span class="params">(X builder)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</div><div class="line">                options.apply(builder);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> builder;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面这个泛型写的非常绕，OptionApplier的意思就是，如果用户提供了一些定制(存在options里面)，就给一些定制的选择。一般这个options为null。</p>
<h3 id="2-1-各种Type的Request"><a href="#2-1-各种Type的Request" class="headerlink" title="2.1 各种Type的Request"></a>2.1 各种Type的Request</h3><p>Glide的RequestManager可以接受各种各样的来源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;Integer&gt; <span class="title">load</span><span class="params">(Integer resourceId)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (DrawableTypeRequest&lt;Integer&gt;) fromResource().load(resourceId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="keyword">public</span> DrawableTypeRequest&lt;<span class="keyword">byte</span>[]&gt; load(<span class="keyword">byte</span>[] model) &#123;</div><div class="line">        <span class="keyword">return</span> (DrawableTypeRequest&lt;<span class="keyword">byte</span>[]&gt;) fromBytes().load(model);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;File&gt; <span class="title">load</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (DrawableTypeRequest&lt;File&gt;) fromFile().load(file);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//上述方法都调用到了</span></div><div class="line">     <span class="keyword">private</span> &lt;T&gt; <span class="function">DrawableTypeRequest&lt;T&gt; <span class="title">loadGeneric</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</div><div class="line">        ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);</div><div class="line">        ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =</div><div class="line">                Glide.buildFileDescriptorModelLoader(modelClass, context);</div><div class="line">        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span> &amp;&amp; streamModelLoader == <span class="keyword">null</span> &amp;&amp; fileDescriptorModelLoader == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown type "</span> + modelClass + <span class="string">". You must provide a Model of a type for"</span></div><div class="line">                    + <span class="string">" which there is a registered ModelLoader, if you are using a custom model, you must first call"</span></div><div class="line">                    + <span class="string">" Glide#register with a ModelLoaderFactory for your custom model class"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> optionsApplier.apply(</div><div class="line">                <span class="keyword">new</span> DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</div><div class="line">                        glide, requestTracker, lifecycle, optionsApplier));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>DrawableTypeRequest接受一个泛型，可以是String(网络路径)，File(本地文件),Integer（资源文件）。所以最终返回的DrawableTypeRequet里面装的可能是String.class，Integer.class也可能是File.class。<br>比较难懂的是 streamModelLoader和fileDescriptorModelLoader的创建.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModelLoader</span>&lt;<span class="title">T</span>, <span class="title">Y</span>&gt; </span>&#123;</div><div class="line">    <span class="function">DataFetcher&lt;Y&gt; <span class="title">getResourceFetcher</span><span class="params">(T model, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModelLoader其实就是只有一个方法的接口，例如with(File)会传一个File.class进来，返回的streamModelLoader的T就是File，Y就是InputStream。<br>ModelLoader<T, Y>负责提供DataFetcher<Y>，T是数据源，可以是File,Resourse，url等等。Y用于描述类型，本地的就使用ParcelFileDescriptor（记得FileDescriptor属于Native的东西），网络上的就使用InputStream.<br>T和Y的组合可能有很多种，Cache在Glide(全局唯一)的loaderFactory（成员变量）的一个HashMap(没用ConcurrentHashMap是因为buildModelLoader方法加锁了)中。所以这份缓存也是全局唯一的。<br>T和Y的一一对应其实是在Glide的构造函数里面写好的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">register(File.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorFileLoader.Factory());</div><div class="line">register(File.class, InputStream.class, <span class="keyword">new</span> StreamFileLoader.Factory());</div><div class="line">register(<span class="keyword">int</span>.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorResourceLoader.Factory());</div><div class="line">register(<span class="keyword">int</span>.class, InputStream.class, <span class="keyword">new</span> StreamResourceLoader.Factory());</div><div class="line">register(Integer.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorResourceLoader.Factory());</div><div class="line">register(Integer.class, InputStream.class, <span class="keyword">new</span> StreamResourceLoader.Factory());</div><div class="line">register(String.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorStringLoader.Factory());</div><div class="line">register(String.class, InputStream.class, <span class="keyword">new</span> StreamStringLoader.Factory());</div><div class="line">register(Uri.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorUriLoader.Factory());</div><div class="line">register(Uri.class, InputStream.class, <span class="keyword">new</span> StreamUriLoader.Factory());</div><div class="line">register(URL.class, InputStream.class, <span class="keyword">new</span> StreamUrlLoader.Factory());</div><div class="line">register(GlideUrl.class, InputStream.class, <span class="keyword">new</span> HttpUrlGlideUrlLoader.Factory());</div><div class="line">register(<span class="keyword">byte</span>[].class, InputStream.class, <span class="keyword">new</span> StreamByteArrayLoader.Factory());</div></pre></td></tr></table></figure>
<p>左边有很多种，右边只可能是InputStream或者ParcelFileDescriptor。</p>
<h3 id="2-2-Request的继承关系"><a href="#2-2-Request的继承关系" class="headerlink" title="2.2 Request的继承关系"></a>2.2 Request的继承关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class DrawableTypeRequest&lt;ModelType&gt; extends DrawableRequestBuilder&lt;ModelType&gt; implements DownloadOptions</div><div class="line">public class DrawableRequestBuilder&lt;ModelType&gt;</div><div class="line">       extends GenericRequestBuilder&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt;</div><div class="line">       implements BitmapOptions, DrawableOptions</div><div class="line">public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable</div></pre></td></tr></table></figure>
<p>记住这个ModelType就是Glide.with(context).load(XXX) 里面传进去的Object的Class，例如File.class，那么<br>上面其实就是创建了一个DrawableTypeRequest，泛型是File ，构造函数一层层往上调用，DrawableRequestBuilder这一层调用了crossFade方法，即默认会有一个crossFade的效果，默认用的是DrawableCrossFadeFactory。注意这里把属于RequestManager的RequestTracker也传进来了。</p>
<ul>
<li>Glide.with(context).load(XX)到目前为止只是返回了一个DrawableTypeRequest<ModelType> 的实例。(还在主线程)</li>
</ul>
<h2 id="2-3-小节"><a href="#2-3-小节" class="headerlink" title="2.3 小节"></a>2.3 小节</h2><p>Glide.with返回一个RequestManger，每个Activity只会有一个RequestManager<br>load方法返回了一个DrawableTypeRequest<T>，这个T可能是File,String,Interger等。<br>到目前为止还只是构建一个Request。</p>
<h2 id="3-DrawableRequestBuilder的into方法"><a href="#3-DrawableRequestBuilder的into方法" class="headerlink" title="3. DrawableRequestBuilder的into方法"></a>3. DrawableRequestBuilder的into方法</h2><p>Glide的最后一个调用方法是into()，也是最终分发请求的方法</p>
<p>DrawableRequestBuilder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> Target&lt;GlideDrawable&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.into(view);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</div><div class="line">       Util.assertMainThread();<span class="comment">//还是在主线程对不对</span></div><div class="line">       <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null View"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!isTransformationSet &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">switch</span> (view.getScaleType()) &#123;</div><div class="line">               <span class="keyword">case</span> CENTER_CROP:</div><div class="line">                   applyCenterCrop();</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">case</span> FIT_CENTER:</div><div class="line">               <span class="keyword">case</span> FIT_START:</div><div class="line">               <span class="keyword">case</span> FIT_END:</div><div class="line">                   applyFitCenter();</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="comment">//$CASES-OMITTED$</span></div><div class="line">               <span class="keyword">default</span>:</div><div class="line">                   <span class="comment">// Do nothing.</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</div><div class="line">       <span class="comment">//这个into接收一个Target的子类的实例，而Target又继承自LifeCycleListener</span></div><div class="line">       <span class="comment">//这个TranscodeClass是每一个Request创建的时候从构造函数传进来的。</span></div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//transcodeclass可能是GlideDrawable.class，也可能是Bitmap.class也可能是Drawable.class</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">   <span class="keyword">public</span> &lt;Z&gt; <span class="function">Target&lt;Z&gt; <span class="title">buildTarget</span><span class="params">(ImageView view, Class&lt;Z&gt; clazz)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (GlideDrawable.class.isAssignableFrom(clazz)) &#123; <span class="comment">//isAssignableFrom表示左边的class是否是右边class一个类或者父类，应该和instaceof倒过来。</span></div><div class="line">           <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> GlideDrawableImageViewTarget(view);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</div><div class="line">           <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</div><div class="line">           <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled class: "</span> + clazz</div><div class="line">                   + <span class="string">", try .as*(Class).transcode(ResourceTranscoder)"</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>GlideDrawableImageViewTarget、BitmapImageViewTarget以及DrawableImageViewTarget全部继承自ImageViewTarget，后者继承自ViewTarget,再继承自BaseTarget，再 implements Target。一层层继承下来，GlideDrawableImageViewTarget等三个子类中都有一个Request，一个T extents View(看来不一定是ImageView)</p>
<h3 id="3-1-以GlideDrawableImageViewTarget为例"><a href="#3-1-以GlideDrawableImageViewTarget为例" class="headerlink" title="3.1 以GlideDrawableImageViewTarget为例"></a>3.1 以GlideDrawableImageViewTarget为例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideDrawableImageViewTarget</span> <span class="keyword">extends</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">GlideDrawable</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> SQUARE_RATIO_MARGIN = <span class="number">0.05f</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxLoopCount;</div><div class="line">    <span class="keyword">private</span> GlideDrawable resource;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>GlideDrawable是一个继承自Drawable的抽象类，添加了isAnimated(),setLoopCount以及由于实现了isAnimated所需要的三个方法(start,stop,isRunning)。子类必须实现这五个抽象方法。</p>
<p>GlideDrawableImageViewTarget往上走<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Z</span>&gt; <span class="keyword">extends</span> <span class="title">ViewTarget</span>&lt;<span class="title">ImageView</span>, <span class="title">Z</span>&gt; <span class="keyword">implements</span> <span class="title">GlideAnimation</span>.<span class="title">ViewAdapter</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着往上找父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewTarget</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">View</span>, <span class="title">Z</span>&gt; <span class="keyword">extends</span> <span class="title">BaseTarget</span>&lt;<span class="title">Z</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ViewTarget"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isTagUsedAtLeastOnce = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer tagId = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> T view;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SizeDeterminer sizeDeterminer;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下文档：A base Target for loading android.graphics.Bitmaps into Views that provides default implementations for most most methods and can determine the size of views using a android.view.ViewTreeObserver.OnDrawListener<br>To detect View} reuse in android.widget.ListView or any android.view.ViewGroup that reuses views, this class uses the View setTag(Object) method to store some metadata so that if a view is reused, any previous loads or resources from previous loads can be cancelled or reused.<br> Any calls to View setTag(Object)on a View given to this class will result in excessive allocations and<br> and/or IllegalArgumentExceptions. If you must call View#setTag(Object)on a view, consider  using BaseTarget or SimpleTarget instead.</p>
<ul>
<li>翻译一下，ViewTarget提供了将Bitmap 加载进View的大部分方法的基本实现，并且添加了onPreDrawListener以获得View的尺寸，对于Resuse View的场景，通过setTag来取消被滑出屏幕的View的request的加载。</li>
</ul>
<p>既然提供了大部分方法的默认实现，那么一定有方法没实现，其实就是<br>protected void setResource(Z resource)啦。<br>这个Z可能是Bitmap,GlideDrawable或者Drawable。直接拿来setImageBitmap或者setImageDrawable就可以了，这个方法其实在是解码完成之后了。</p>
<p>关键是default implementation是怎么实现的以及这些方法在父类中的调用时机。<br>ViewTarget的构造函数传进来一个View的子类，同时创建一个SizeDeterminer（只是通过onPreDrawListener获得View的宽和高）。</p>
<p>再往上找父类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTarget</span>&lt;<span class="title">Z</span>&gt; <span class="keyword">implements</span> <span class="title">Target</span>&lt;<span class="title">Z</span>&gt; </span>&#123; <span class="comment">//添加了一个Request成员变量，为Target中的一些方法提供了空实现，比如onLoadStarted，onLoadXXX等</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> Request request;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>到这里，还只是配置资源要加载进的对象，我倾向于把Target看成一个资源加载完毕的中转者，它管理了View（也可以没有View）和Request，在外部调用Target.onLoadStarted等方法是，调用View(如果有的话)的xxx方法。</p>
<h3 id="3-2任务分发"><a href="#3-2任务分发" class="headerlink" title="3.2任务分发"></a>3.2任务分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y target)</span> </span>&#123;</div><div class="line">    Util.assertMainThread(); <span class="comment">//还在主线程上</span></div><div class="line">    Request previous = target.getRequest();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123; <span class="comment">//每一个Target都只有一个Request，用于清除之前的请求</span></div><div class="line">        previous.clear();</div><div class="line">        requestTracker.removeRequest(previous);</div><div class="line">        previous.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = buildRequest(target);</div><div class="line">    target.setRequest(request);</div><div class="line">    lifecycle.addListener(target);</div><div class="line">    requestTracker.runRequest(request);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> target; <span class="comment">//这里返回Target的好处在于可以接着链式调用，上面只是添加到任务队列，真正被处理还得等到下一帧(onPreDraw调用时)，所以这里还可以接着对这个Target进行配置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 requestTracker.runRequest(request)方法<br>GenericRequest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line">   */</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">      startTime = LogTime.getLogTime();</div><div class="line">      <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</div><div class="line">          onException(<span class="keyword">null</span>);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      status = Status.WAITING_FOR_SIZE;</div><div class="line">      <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class="line">          onSizeReady(overrideWidth, overrideHeight);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          target.getSize(<span class="keyword">this</span>); <span class="comment">//这个方法其实就等于挂了个钩子在onPreDraw中调用，onPreDraw时会调用onSizeReady。</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</div><div class="line">          target.onLoadStarted(getPlaceholderDrawable());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">          logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>onSizeReady才是真正开始干活的时机，理由也很充分。解码Bitmap必须要知道需要多大的尺寸，否则也是白搭。<br>GenericRequest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line">  * A callback method that should never be invoked directly.</div><div class="line">  */</span></div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">     status = Status.RUNNING;</div><div class="line"></div><div class="line">     width = Math.round(sizeMultiplier * width); <span class="comment">//这个sizeMultiplier可以通过链式调用配置</span></div><div class="line">     height = Math.round(sizeMultiplier * height);</div><div class="line"></div><div class="line">     ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</div><div class="line">     <span class="keyword">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</div><div class="line"></div><div class="line">     ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</div><div class="line">     loadedFromMemoryCache = <span class="keyword">true</span>;</div><div class="line">     loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</div><div class="line">             priority, isMemoryCacheable, diskCacheStrategy, <span class="keyword">this</span>);</div><div class="line">     loadedFromMemoryCache = resource != <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">         logV(<span class="string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-缓存查找"><a href="#3-3-缓存查找" class="headerlink" title="3.3 缓存查找"></a>3.3 缓存查找</h3><p>开始查找缓存是engine.load开始的，找到了就调用Callback的onResourceReady<br>Engine.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T, Z, R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(Key signature, <span class="keyword">int</span> width, <span class="keyword">int</span> height, DataFetcher&lt;T&gt; fetcher,</div><div class="line">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</div><div class="line">        Priority priority, <span class="keyword">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</div><div class="line">    Util.assertMainThread(); <span class="comment">//还是在主线程上</span></div><div class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String id = fetcher.getId();<span class="comment">//如果是个网络图片，返回网络url，类似这种</span></div><div class="line">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</div><div class="line">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</div><div class="line">            transcoder, loadProvider.getSourceEncoder());</div><div class="line"></div><div class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</div><div class="line">    <span class="comment">//EngineResource内部wrap了真正的Resource，并使用一个int acquire表示当前正在占用资源的使用者数。当这个数为0的时候可以release。</span></div><div class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</div><div class="line">        cb.onResourceReady(cached);</div><div class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</div><div class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</div><div class="line">        cb.onResourceReady(active);</div><div class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    EngineJob current = jobs.get(key);</div><div class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">        current.addCallback(cb);</div><div class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">            logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</div><div class="line">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class="keyword">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</div><div class="line">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</div><div class="line">    EngineRunnable runnable = <span class="keyword">new</span> EngineRunnable(engineJob, decodeJob, priority);</div><div class="line">    jobs.put(key, engineJob);</div><div class="line">    engineJob.addCallback(cb);</div><div class="line">    engineJob.start(runnable);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Engine先去Cache里面查找，找到了直接调用ResourceCallback(GenericRequest)的onResourceReady(EngineResource&lt;?&gt; resource)，注意这个EngineResource里面包装了一个Resource，主要是为了引用计数。</p>
<p> Engine的loadFromCache(key, isMemoryCacheable)是第一步，从成员变量cache中获取。找到了就挪到activeResources里面。<br> Engine.java<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,</div><div class="line">        <span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</div><div class="line">        <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Engine"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Key, EngineJob&gt; jobs;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EngineKeyFactory keyFactory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EngineJobFactory engineJobFactory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceRecycler resourceRecycler;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LazyDiskCacheProvider diskCacheProvider;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果在MemoryCache这个Lru里面没找到，就调用loadFromActiveResources，从activeResources里面找到。</p>
<p><strong>所以这里已经出现两层缓存了，先去Lru(内存)找，再去activeResources(HashMap)里面找。缓存都是放在Enginel里面的，全局只有一份</strong></p>
<p>缓存里面的Value都是EngineResource。</p>
<p>这个MemoryCache是一个LruCache，大小是在MemorySizeCalculator中获得的，<br>对于一般的设备，activityManager.getMemoryClass() <em> 1024 </em> 1024获得每个App能够使用的Size,乘以0.4。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) &#123;</div><div class="line">       <span class="keyword">this</span>.context = context;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> maxSize = getMaxSize(activityManager);</div><div class="line"></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()</div><div class="line">               * BYTES_PER_ARGB_8888_PIXEL; <span class="comment">//算出占满整个屏幕的一张图的大小</span></div><div class="line"></div><div class="line">       <span class="keyword">int</span> targetPoolSize = screenSize * BITMAP_POOL_TARGET_SCREENS; <span class="comment">//乘以4就是bitmappool的大小</span></div><div class="line">       <span class="keyword">int</span> targetMemoryCacheSize = screenSize * MEMORY_CACHE_TARGET_SCREENS;</div><div class="line">       <span class="comment">//乘以2就是MemoryCache的大小</span></div><div class="line"></div><div class="line">       <span class="keyword">if</span> (targetMemoryCacheSize + targetPoolSize &lt;= maxSize) &#123;</div><div class="line">           memoryCacheSize = targetMemoryCacheSize;</div><div class="line">           bitmapPoolSize = targetPoolSize;</div><div class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">//这里判断了BitmapPool和MemoryCache的大小之和不能超出应用可以使用的内存大小的0.4倍。</span></div><div class="line">           <span class="keyword">int</span> part = Math.round((<span class="keyword">float</span>) maxSize / (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));</div><div class="line">           memoryCacheSize = part * MEMORY_CACHE_TARGET_SCREENS;</div><div class="line">           bitmapPoolSize = part * BITMAP_POOL_TARGET_SCREENS;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>所以缓存的大小综合考虑了屏幕分辨率和内存大小。只要屏幕像素不是特别高，一般都会走到第一步。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>ViewTarget里面有一个 T extends View，可见Glide不只适用于ImageView。</li>
<li>BaseTarget里带了一个private Request，其子类可以通过getRequest获得。</li>
<li>对于ListView等可以快速滑动的View，如果某一个View被滑出屏幕外，自动取消请求(通过setTagId实现)</li>
<li>“You must not call setTag() on a view Glide is targeting” setTag会崩，原因是GenericRequestBuilder的into方法会通过ViewTarget去查找previous，看看这一个ViewTarget是否已经有了request。这一点常见于循环利用View的场景，快速滑动的ViewGroup会复用View。对于同一个View，可能ViewGroup会需要它展示不同的(图片、Url)，所以Glide必须要检查previous，同时清除掉旧的请求。</li>
<li>GenericRequestBuilder的obtainRequest内部使用了一个ArrayDeque来obtain Request。这样Request实例不会多次创建，回收是在request.recycle里面做的。</li>
</ul>
<h3 id="4-离开主线程，提交任务到线程池"><a href="#4-离开主线程，提交任务到线程池" class="headerlink" title="4. 离开主线程，提交任务到线程池"></a>4. 离开主线程，提交任务到线程池</h3><p>如果上面两层缓存都没找到，去jobs里找看下有没有已经加入队列的EngineJob<br>记住上面有两层缓存</p>
<p>来看后面提交任务这几段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"> EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</div><div class="line">        DecodeJob&lt;T, Z, R&gt; decodeJob = <span class="keyword">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</div><div class="line">                transcoder, diskCacheProvider, diskCacheStrategy, priority);</div><div class="line">        EngineRunnable runnable = <span class="keyword">new</span> EngineRunnable(engineJob, decodeJob, priority);</div><div class="line">        jobs.put(key, engineJob);</div><div class="line">        engineJob.addCallback(cb);</div><div class="line">        engineJob.start(runnable); <span class="comment">//往diskCacheService提交了一个Runnable</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EngineJob</span> <span class="keyword">implements</span> <span class="title">EngineRunnable</span>.<span class="title">EngineRunnableManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EngineResourceFactory DEFAULT_FACTORY = <span class="keyword">new</span> EngineResourceFactory();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler MAIN_THREAD_HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper(), <span class="keyword">new</span> MainThreadCallback());</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_COMPLETE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_EXCEPTION = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResourceCallback&gt; cbs = <span class="keyword">new</span> ArrayList&lt;ResourceCallback&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EngineResourceFactory engineResourceFactory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EngineJobListener listener;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Key key;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService diskCacheService; <span class="comment">//线程池</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService sourceService; <span class="comment">//线程池</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isCacheable;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isCancelled;</div><div class="line">    <span class="comment">// Either resource or exception (particularly exception) may be returned to us null, so use booleans to track if</span></div><div class="line">    <span class="comment">// we've received them instead of relying on them to be non-null. See issue #180.</span></div><div class="line">    <span class="keyword">private</span> Resource&lt;?&gt; resource;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasResource;</div><div class="line">    <span class="keyword">private</span> Exception exception;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasException;</div><div class="line">    <span class="comment">// A set of callbacks that are removed while we're notifying other callbacks of a change in status.</span></div><div class="line">    <span class="keyword">private</span> Set&lt;ResourceCallback&gt; ignoredCallbacks;</div><div class="line">    <span class="keyword">private</span> EngineRunnable engineRunnable;</div><div class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; engineResource;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Future&lt;?&gt; future;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>EngineJob是通过Factory创建的，创建时会传两个线程池进来。一个管DiskCache,一个管Source获取。初始化是在Glide.createGlide里面做的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (sourceService == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cores = Math.max(<span class="number">1</span>, Runtime.getRuntime().availableProcessors());</div><div class="line">            sourceService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(cores);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (diskCacheService == <span class="keyword">null</span>) &#123;</div><div class="line">            diskCacheService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(<span class="number">1</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>在外部没有提供线程池的情况下，DiskCache一个线程池就好了，SourceService的大小为当前cpu可用核心数，还是比较高效的。<br>debug的时候可能会看见“fifo-pool-thread-1”这样的线程，就是Glide的。<br>上面是往DiskCacheService提交了一个EngineRunable，这个Runnable的run里面主要是decodeFromCache和DecodeFroSource，分别代表从<strong>磁盘缓存</strong>获取和从数据源获取。<br>首先会调用decodeFromCache，一层层往下找，如果没找到的话会调用onLoadFailed方法，并将任务提交给SourceService，去获取资源。</p>
<h3 id="4-1-CacheService这个线程池的工作以及第三层缓存的出现"><a href="#4-1-CacheService这个线程池的工作以及第三层缓存的出现" class="headerlink" title="4.1 CacheService这个线程池的工作以及第三层缓存的出现"></a>4.1 CacheService这个线程池的工作以及第三层缓存的出现</h3><p><strong>注意这里出现了第三层缓存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">File cacheFile = diskCacheProvider.getDiskCache().get(key);</div></pre></td></tr></table></figure></p>
<p>这一层缓存是给DiskCache的线程池查找用的，查找的时候分为从Result中查找和从Source中查找，其实查找的目的地都是那个DiskCache，Resul是用ResultKey去找的，Source是用ResultKey.getOriginalKey去查找的。物理位置都放在那个磁盘目录下。</p>
<p>另外在DecodeJob的cacheAndDecodeSourceData方法里，存的只是origin(因为用的是origin Key)，然后再拿着originKey去磁盘找，找出来decode。</p>
<p>DecodeFromCache又包括两步decodeResultFromCache和decodeSourceFromCache，这就让人想到Glide的DiskCacheStrategy分为Result和Source，即可以缓存decode结果也可以缓存decode之前的source。前提是在上面的diskCacheProvider.getDiskCache().get(key)方法里面找到了CachedFile。这个路径在InternalCacheDiskCacheFactory里面写了具体的路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String diskCacheName, <span class="keyword">int</span> diskCacheSize)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</div><div class="line">               File cacheDirectory = context.getCacheDir();</div><div class="line">               <span class="keyword">if</span> (cacheDirectory == <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</div><div class="line">                   <span class="comment">//就是context.getCacheDir+"image_manager_disk_cache"</span></div><div class="line">                   <span class="comment">//默认上限是250MB</span></div><div class="line">                   <span class="comment">//由于这个Cache放在CacheDir里面，其他应用拿不到</span></div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> cacheDirectory;</div><div class="line">           &#125;</div><div class="line">       &#125;, diskCacheSize);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>注意无论是decodeResultFromCache还是decodeSourceFromCache里都有类似的一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Resource&lt;T&gt; transformed = loadFromCache(resultKey);</div><div class="line">Resource&lt;Z&gt; result = transcode(transformed); <span class="comment">///把一种资源转成另一种资源，比如把Bitmap的Resource转成一个ByteResource</span></div></pre></td></tr></table></figure></p>
<h3 id="4-2-SourceService这个线程池以及BitmapPool这一层缓存的出现"><a href="#4-2-SourceService这个线程池以及BitmapPool这一层缓存的出现" class="headerlink" title="4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现"></a>4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">decodeFromSourceData</span><span class="params">(A data)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">     <span class="keyword">final</span> Resource&lt;T&gt; decoded;</div><div class="line">     <span class="keyword">if</span> (diskCacheStrategy.cacheSource()) &#123;</div><div class="line">         decoded = cacheAndDecodeSourceData(data);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">long</span> startTime = LogTime.getLogTime();</div><div class="line">         decoded = loadProvider.getSourceDecoder().decode(data, width, height); <span class="comment">// 这里面放进BitmapPool了</span></div><div class="line">         <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">             logWithTimeAndKey(<span class="string">"Decoded from source"</span>, startTime);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> decoded;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><strong>第四层缓存出现。。。LruBitmapPool</strong><br>DecodeFromSource也是类似，判断是否允许Cache，通过DataFetcher获取数据这个数据可能是InputStream，也可能是ImageVideoWrapper。。。总之是一个可以提供数据的来源。如果可以Cache的话，先把数据写到lru里面，然后从lru里面取出来，从Source decode成想要的数据类型。<br>例如从Stream转成Bitmap是这么干的<br>StreamBitmapDecoder.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(InputStream source, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">       Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);</div><div class="line">       <span class="keyword">return</span> BitmapResource.obtain(bitmap, bitmapPool);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>顺便还放进了LruBitmapPool（又一个实现了lru算法的缓存），Bitmap存在一个LruPoolStrategy接口实例的GroupedLinkedMap中。</p>
<h3 id="4-3-回到主线程"><a href="#4-3-回到主线程" class="headerlink" title="4.3 回到主线程"></a>4.3 回到主线程</h3><p>EngineRunnable的run方法跑在子线程，在run的最后就是用一个handler推到主线程了。有可能是从CacheService这个线程池里面的线程推过去的，也可能是SourceSevice这个线程池里面推过去的。</p>
<p>onResourceReady最终会走到GenericRequest的onResourceReady方法里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123;</div><div class="line"></div><div class="line">      if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,</div><div class="line">              isFirstResource)) &#123;</div><div class="line">          GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</div><div class="line">          target.onResourceReady(result, animation); //注意这句话就可以了</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>最终会调到ImageViewTarget,AppWidgetTarget等Target（持有Request和View,View可能没有），这时候，直接调用ImageView.setImagBitmap等方法就可以了。<br>图片设置完毕。</p>
<h3 id="5-Glide除了普通的加载方法，还能用什么比较有意思的玩法"><a href="#5-Glide除了普通的加载方法，还能用什么比较有意思的玩法" class="headerlink" title="5. Glide除了普通的加载方法，还能用什么比较有意思的玩法"></a>5. Glide除了普通的加载方法，还能用什么比较有意思的玩法</h3><ul>
<li>1.Glide加载Gif的原理在GifDecoder的 public synchronized Bitmap getNextFrame()方法里，Gif本质上是一帧帧的Frame数据，Glide将这些数据包装到GifFrame这个类中，每次想要获得下一帧的时候，就从bitmapPool中obtain Bitmap,同时从Frame中提取必要信息填充bitmap.<br>Gif的显示是在GifDrawable的draw方法里面通过frameLoader.getCurrentFrame()获得当前帧的bitmap。</li>
</ul>
<ul>
<li><p>2.GlideDrawableImageViewTarget中有这么一段注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(GlideDrawable resource, GlideAnimation&lt;? <span class="keyword">super</span> GlideDrawable&gt; animation)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!resource.isAnimated()) &#123;</div><div class="line">           <span class="comment">//<span class="doctag">TODO:</span> Try to generalize this to other sizes/shapes.</span></div><div class="line">           <span class="comment">// This is a dirty hack that tries to make loading square thumbnails and then square full images less costly</span></div><div class="line">           <span class="comment">// by forcing both the smaller thumb and the larger version to have exactly the same intrinsic dimensions.</span></div><div class="line">           <span class="comment">// If a drawable is replaced in an ImageView by another drawable with different intrinsic dimensions,</span></div><div class="line">           <span class="comment">// the ImageView requests a layout. Scrolling rapidly while replacing thumbs with larger images triggers</span></div><div class="line">           <span class="comment">// lots of these calls and causes significant amounts of jank.</span></div><div class="line">           <span class="keyword">float</span> viewRatio = view.getWidth() / (<span class="keyword">float</span>) view.getHeight();</div><div class="line">           <span class="keyword">float</span> drawableRatio = resource.getIntrinsicWidth() / (<span class="keyword">float</span>) resource.getIntrinsicHeight();</div><div class="line">           <span class="keyword">if</span> (Math.abs(viewRatio - <span class="number">1f</span>) &lt;= SQUARE_RATIO_MARGIN</div><div class="line">                   &amp;&amp; Math.abs(drawableRatio - <span class="number">1f</span>) &lt;= SQUARE_RATIO_MARGIN) &#123;</div><div class="line">               resource = <span class="keyword">new</span> SquaringDrawable(resource, view.getWidth());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">super</span>.onResourceReady(resource, animation);</div><div class="line">       <span class="keyword">this</span>.resource = resource;</div><div class="line">       resource.setLoopCount(maxLoopCount);</div><div class="line">       resource.start();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><ol>
<li>Glide还可以用来纯粹的解码获得Bitmap.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Glide.with(itemView.getContext()) <span class="comment">//不用担心leak,RequestManager只是通过这个context获得了ApplicationContext，保留下来的是Application的context</span></div><div class="line">               .load(R.drawable.image_41)</div><div class="line">               .asBitmap()</div><div class="line">               .centerCrop().into(<span class="keyword">new</span> SimpleTarget&lt;Bitmap&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Bitmap resource, GlideAnimation&lt;? <span class="keyword">super</span> Bitmap&gt; glideAnimation)</span> </span>&#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">super</span>.onDestroy(); <span class="comment">//其实这里面是空方法。</span></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>4.缓存路径获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Glide.with(itemView.getContext())</div><div class="line">            .load(<span class="string">""</span>)</div><div class="line">            .downloadOnly(<span class="keyword">new</span> BaseTarget&lt;File&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(File resource, GlideAnimation&lt;? <span class="keyword">super</span> File&gt; glideAnimation)</span> </span>&#123;</div><div class="line">                  Log.d(TAG, resource.getAbsoluteFile());</div><div class="line">              <span class="comment">//放心，都在主线程</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSize</span><span class="params">(SizeReadyCallback cb)</span> </span>&#123;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>根据之前的分析，打印出来的应该是context.getCacheDir+”image_manager_disk_cache”+”/xxxxxx.xxx” ，我没研究过后缀，不过这个后缀没意义吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>4层缓存（MemoryCache是内存中的一层，activeResources是一层（HashMap）,cacheService和SourceService这俩线程池干活需要一个DiskLruCache，另外decode还有一个bitmapPool，其实这不算缓存吧）。</li>
<li>默认的缓存大小考虑了屏幕尺寸和可用内存大小，科学合理。线程池的keepAlive数量上，一个是可用cpu核心数，所以快吧，一个是1。</li>
<li>全局只有一个Glide,一个页面只有一个RequestManager</li>
<li>Target是一个接口，将资源的受众抽象成一个接口。</li>
<li>setTag会崩，ListView,RecyclerView原理,加载优化(prefetcher什么的，滑动过程中不去加载图片，Glide只是取消了之前的请求，并未去prefetch,其实可以啊，网络差的时候，downloadOnly就好了嘛，下次会快一点点)</li>
<li>传进去的是context，但它只是借用context.getApplicationContext，保留下来的是ApplicationContext，哪有那么容易leak。</li>
<li>生命周期挂钩什么，创建一个没有View的SupportFragment，还是做的很巧妙的。</li>
<li>泛型写的各种绕。。。</li>
</ul>
<p><strong>现在来回答那个问题：“如果你来设计一个图片加载框架，你会怎么设计？”</strong></p>
<p>一个ImagerLoader应该具有的几个特性包括：</p>
<ol>
<li>内存缓存和磁盘缓存,lru</li>
<li>做好图片压缩和bitmap重用(不可见图片及时回收)，避免oom (bitmap的宽高要根据View的大小确定)</li>
<li>对于不同资源来源能够提供对应的DataFetcher</li>
<li>对外提供start,stop,pause,resume等功能，必要时自动跟踪应用生命周期</li>
<li>耗时操作(io，解码)挪到后台</li>
<li>内存缓存可以设计两层bitmap缓存，一层是直接拿来用的(active)，一层是lru的。根据<a href="https://dev.qq.com/topic/591d61f56793d26660901b4e">经验</a>，一张bitmap占几个MB(高分辨屏幕)，而一个App能够使用的最大heap大小（ActivityManage.getMemoryClass）一般在100多MB，取其中的40%。完全能够做到内存中cache十几张bitmap。</li>
</ol>
<p>外部调用者需要传入资源(url,File,res，etc)，及ImageView实例(我们也就有了Context)。在onPreDraw之后获得View的尺寸（这一点至关重要）。根据资源地址生成唯一的key，在bitmap pool中查找，然后在内存缓存(lru)中查找。如果还未找到的话提交DiskCache查找请求请求到DiskCache查找线程池，如果未找到提交请求到资源获取线程池(网络，文件，或者Res)，数据获取完成后cahe到disk并提交到主线程。多线程同步和生命周期追踪是难点。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://frodoking.github.io/2015/10/10/android-glide/">Android Glide源码解析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;glide的源码几个月前曾经拜读过，大致了解了其异步加载的实现原理。图片加载和网络请求很类似，就像当初看Volley，从一个Request —&amp;gt;  CacheDispatch  —&amp;gt; NetworkDispatcher  —-&amp;gt;  ResponseDeliver。优秀的轮子不仅执行效率高，同时具备高的扩展性。读懂源码其实只是第一步，往下应该是利用框架提供的扩展方案，再往后应该就是能够独立设计出一套类似的框架了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/a11f41e0b1df95212c71920b3959cd72.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://haldir65.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>网络通信手册</title>
    <link href="https://haldir65.github.io/2017/07/21/2017-07-21-network-manual/"/>
    <id>https://haldir65.github.io/2017/07/21/2017-07-21-network-manual/</id>
    <published>2017-07-20T16:05:32.000Z</published>
    <updated>2017-08-01T13:46:02.350Z</updated>
    
    <content type="html"><![CDATA[<p>网络相关的查找手册<br><img src="http://odzl05jxx.bkt.clouddn.com/b9ae1189145b4a4d9dfe4d0b89a21b47.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-URI和URL是两件事"><a href="#1-URI和URL是两件事" class="headerlink" title="1. URI和URL是两件事"></a>1. URI和URL是两件事</h2><p>根据<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6">wiki的解释</a><br>URL是URI的子集，URL的一般格式包括三部分：资源类型、存放资源的主机域名，资源文件名。语法格式上,根据<a href="https://baike.baidu.com/item/URL%E6%A0%BC%E5%BC%8F/10056474?fr=aladdin">百度百科</a>找到一个能用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protocol :// hostname[:port] / path / [;parameters][?query]#fragment</div></pre></td></tr></table></figure></p>
<ul>
<li>protocol 指使用的传输协议(http、file、https、mailto、ed2k、thunder等)<br>hostname 是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。有时候是ip,有时候前面还带账号密码<br>port http默认是80，https是443 ,ssh默认端口号是20<br>path(路径) 由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。<br>parameters（参数）这是用于指定特殊参数的可选项。<br>query(查询) 一般GET请求可以在这里面查找。可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。<br>fragment（信息片断）字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。</li>
</ul>
<h2 id="2-http请求本质上是发送了一堆字符给服务器"><a href="#2-http请求本质上是发送了一堆字符给服务器" class="headerlink" title="2. http请求本质上是发送了一堆字符给服务器"></a>2. http请求本质上是发送了一堆字符给服务器</h2><p>另外,domain(域名)是指www.wikipedia.org这种，DNS会把它转成一个ip地址<br>而在http请求的header中经常或看到<br>Host: www.baidu.com\r\n 这样的一行，其实这是<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">Http头字段</a>的标准请求字段，总之就是标准。这个Host指的是服务器的域名，就是domian。<br>wiki上的<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">http名词解释</a></p>
<h2 id="3-Header相关的"><a href="#3-Header相关的" class="headerlink" title="3. Header相关的"></a>3. Header相关的</h2><p>首先看下请求百度首页的request和response</p>
<p>Request（其实发送的时候每一行后面都跟了一个\r\n用于换行）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Host: www.baidu.com</div><div class="line">Connection: keep-alive</div><div class="line">Cache-Control: max-age=0</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line">DNT: 1</div><div class="line">Accept-Encoding: gzip, deflate, br</div><div class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</div><div class="line">Cookie: BAIDUID=B41D39A8836273546754tC7F0C5DE315B64E2:FG=1; MCITY=-289%3A;</div></pre></td></tr></table></figure>
<p>Response(同样，无线电传输的时候是没有换行的概念的，每一行末尾都有一个\r\n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Bdpagetype: 1</div><div class="line">Bdqid: 0xa1524365407b7</div><div class="line">Bduserid: 0</div><div class="line">Cache-Control: private</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Cxy_all: baidu+9bdfb3567324332546a7cb482b3</div><div class="line">Date: Sun, 23 Jul 2017 08:27:22 GMT</div><div class="line">Expires: Sun, 23 Jul 2017 08:26:51 GMT</div><div class="line">Server: BWS/1.1</div><div class="line">Set-Cookie: BDSVRTM=0; path=/</div><div class="line">Set-Cookie: BD_HOME=0; path=/</div><div class="line">Set-Cookie: H_PS_PSSID=1430_210543_17001; path=/; domain=.baidu.com</div><div class="line">Strict-Transport-Security: max-age=172800</div><div class="line">Vary: Accept-Encoding</div><div class="line">X-Powered-By: HPHP</div><div class="line">X-Ua-Compatible: IE=Edge,chrome=1</div><div class="line">Transfer-Encoding: chunked</div></pre></td></tr></table></figure>
<p>报文的<a href="http://www.cnblogs.com/klguang/p/4618526.html">语法</a>：<br>请求的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</div><div class="line">&lt;headers&gt;</div><div class="line">&lt;entity-body&gt;</div></pre></td></tr></table></figure>
<p>响应的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;</div><div class="line">&lt;headers&gt;</div><div class="line">&lt;entity-body&gt;</div></pre></td></tr></table></figure>
<p>request中常见的请求头包括：</p>
<ul>
<li><p>Accept：指定客户端能够接收的内容类型<br>示例 : Accept:image/webp,image/apng,image/<em>,</em>/*;q=0.8</p>
</li>
<li><p>Accept-Charset ：浏览器可以接受的字符编码集</p>
</li>
<li><p>Accept-Encoding:gzip, deflate, br<br>客户端浏览器可以支持的压缩编码类型。比如gzip，用于压缩数据，节省带宽。</p>
</li>
<li><p>Accept-Language 指定Http客户端浏览器用来优先展示的语言<br>示例: Accept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</p>
</li>
<li><p>Cache-Control： <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn">参考</a><br>具体操作<a href="https://baike.baidu.com/item/Cache-Control">百度百科</a>写的很清楚<br>可能的值包括：</p>
</li>
</ul>
<p>public 所有内容都将被缓存(客户端和代理服务器都可缓存)<br>private 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)<br>no-cache 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。<br>no-store 所有内容都不会被缓存到缓存或 Internet 临时文件中<br>max-age=xxx (xxx is numeric) 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高</p>
<p>实际过程中我看到了这种：<br>Cache-Control:private, no-cache, no-cache=Set-Cookie, no-store, proxy-revalidate</p>
<ul>
<li><p>Connection:keep-alive  http1.1 默认为keep-alive<br>http 1.0需要手动设置。原理就是服务器保持客户端到服务器的连接持续有效，避免了重新建立连接的开销(tcp三次握手)。这种情况下，客户端不能根据读取到EOF(-1)来判断传输完毕。有两种解决方案：对于静态文件，客户端和服务器能够知道其大小，使用content-length，根据这个判断数据是否已经接收完成；对于动态页面，不可能预先知道内容大小。可以使用Transfer-Encoding:chunked的模式进行传输。基本上就是服务器把文件分成几块，一块一块的发送过去。<a href="https://www.byvoid.com/zhs/blog/http-keep-alive-header">参考</a></p>
</li>
<li><p>Content-Type  代表文件类型。request只有POST请求中会有，Response中也会有。<br>POST里面的Content-type有两种:<br>Content-type: application/x-www-form-urlencoded;charset:UTF-8 //缺省值，表示提交表单<br>multipart/form-data //上传文件时用这种，既可以发送文本数据，也支持二进制上传。上面那个CharSet只是为了告诉服务器用的是哪种编码<br>响应头中的Content-Type示例： Content-Type:image/gif或者Content-Type: text/html;charset=utf-8 <a href="http://www.runoob.com/http/http-content-type.html">参考</a></p>
</li>
<li><p>Date:Sun, 23 Jul 2017 07:39:47 GMT 这就是当前的GMT时间</p>
</li>
<li><p>DNT: 1 Do Not Track（当用户提出启用“请勿追踪”功能后，具有“请勿追踪”功能的浏览器会在http数据传输中添加一个“头信息”（headers），这个头信息向商业网站的服务器表明用户不希望被追踪。这样，遵守该规则的网站就不会追踪用户的个人信息来用于更精准的在线广告。）</p>
</li>
</ul>
<ul>
<li><p>Etag 用于比较客户端请求的文件的内容是否发生了改变。跟Last-Modified的作用差不多。最简单的用hash值就可以了。</p>
</li>
<li><p>Expires:Mon, 01 Jan 1990 00:00:00 GMT    过期时间，这里应该是永不过期</p>
</li>
<li><p>HOST 服务器的域名(domian)或者ip地址<br>Host: www.baidu.com</p>
</li>
<li><p>If-Modified-Since:Fri, 24 Feb 2017 12:37:22 GMT 这个跟缓存有关</p>
</li>
<li><p>If-None-Match:”abf29cbe9a8ed21:0” 还是缓存</p>
</li>
<li><p>Pramga 和Cache-Control一样<br>实例： Pramga: no-cache 相当于 Cache-Control： no-cache。</p>
</li>
<li><p>User-Agent 这个代表用的是哪种浏览器(客户端)，写爬虫的时候找到一大堆<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36<br>Android设备发出来的可能长这样： Mozilla/5.0 (Linux; U; Android 4.4.4; zh-cn; HTC_D820u Build/KTU84P) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30<br>ios设备发出来的长这样: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12A365 Safari/600.1.4</p>
</li>
</ul>
<ul>
<li>Referer 一般是一个url，代表当前请求时从哪个页面发出的，写爬虫有用</li>
</ul>
<p>Header其实就是个字典，比较麻烦的就是Cache-Control了，这个还要结合If-None-Match，Etag来看。需要用的时候再看应该也不迟。</p>
<p><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">WikI上比较完整</a></p>
<h2 id="4-Cookie和Session"><a href="#4-Cookie和Session" class="headerlink" title="4. Cookie和Session"></a>4. Cookie和Session</h2><h3 id="4-1-Cookie"><a href="#4-1-Cookie" class="headerlink" title="4.1 Cookie"></a>4.1 Cookie</h3><p>先看<a href="https://zh.wikipedia.org/wiki/Cookie">Wiki</a>上的解释:</p>
<ul>
<li>指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密.主要是因为Http是无状态的，服务器不知道这一次连接和上一次连接是不是同一个客户端<br>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。</li>
</ul>
<p>Cookie的一些缺点，直接照搬WiKi了</p>
<ul>
<li>Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>
<li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）</li>
<li>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</li>
</ul>
<p>另外，不同域名是无法共享浏览器端本地信息，包括cookies，这即是跨域问题。百度是不能读取爱奇艺的Cookie的，这是安全性问题。<br>需要注意的是，虽然网站images.google.com与网站www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。必须域名一样才能操作。<br>Java中把Cookie封装成了javax.servlet.http.Cookie类，直接用就可以了。</p>
<p>Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。</p>
<p>对了，在众多的Header中Cookie一般长这样:</p>
<ul>
<li>Cookie:key1=value1;key_2=value2;key_3=value3;JSessionID=24DHFKDSFKJ324329NSANDI124EH<br>故意把最后一个JSESSION写出来是因为底下要讲Session了嘛</li>
</ul>
<h3 id="4-2-Session"><a href="#4-2-Session" class="headerlink" title="4.2 Session"></a>4.2 Session</h3><p><a href="http://lavasoft.blog.51cto.com/62575/275589">参考文章</a><br>Header(字典)里面装着一个Cookie(字典)，Cookie里面有个键值对:JSESSIONID:SESSIONID<br>宏观上就是这么个关系。</p>
<p>Cookie保存在客户端，Session保存在服务器端。Session是在客户端第一次访问的时候由服务器创建的，session一般存储在redis中（ram），客户端始终只有sessionId。第二次请求的时候(session还未过期)，浏览器会加上sessionId=XXXXX。服务器接收到请求后就得到该请求的sessionID，服务器找到该id的session返还给请求者（Servlet）使用。一个会话只能有一个session对象，对session来说是只认id不认人。</p>
<p>Session超时：超时指的是连续一定时间服务器没有收到该Session所对应客户端的请求，并且这个时间超过了服务器设置的Session超时的最大时间。<br>Session的maxAge一般为-1，表示仅当前浏览器内有效，关闭浏览器就会失效。</p>
<p>知乎上有一段比较好的<a href="https://www.zhihu.com/question/19786827/answer/66706108">描述</a>,这里直接引用了。<br>http是无状态的协议，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢，session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，web服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到 sessionid=KWJHUG6JJM65HS2K6之类的字符串。<br>javax.servlet.http.HttpServletRequest.getSession() 将会返回当前request相关联的HttpSession对象，如果不存在，将会创建一个。翻译一下，当一个浏览器请求来到之后，Servlet处理程序（Servlet容器内部实现）将会主动检查请求信息Cookie当中是否有JSESSIONID，若有，找到对应JSESSION的HttpSession对象，如果没有，创建一个，具体的机制在Servlet容器的实现当中。</p>
<p>Session就是维护会话的。</p>
<h3 id="4-3-自动登录的实现"><a href="#4-3-自动登录的实现" class="headerlink" title="4.3 自动登录的实现"></a>4.3 自动登录的实现</h3><p>一些网站的“记住密码，自动登录功能”，据说discuz直接将加密的（可逆）uid和密码保存到cookie中。<br>另外一种做法是可以尝试将Session的过期时间设置的长一点，比如一年，下次访问网站的时候就能实现自动登录了。<br>更好一点的是是本地绝不保存用户敏感信息，登录生成一个有过期时间的的cookie或者token返回给客户端，下次打开浏览器判断下过期时间就好了。另外，现在浏览器大多带有记住密码的功能，这个锅还是丢给浏览器(用户)好了。</p>
<h2 id="5-长连接"><a href="#5-长连接" class="headerlink" title="5. 长连接"></a>5. 长连接</h2><p>像即时通讯软件，或者消息推送这种场景，都得维护一个长连接。<br><a href="http://blog.csdn.net/mr_liabill/article/details/50705130">HTTP长连接和短连接</a></p>
<h3 id="5-1长连接的实现原理"><a href="#5-1长连接的实现原理" class="headerlink" title="5.1长连接的实现原理"></a>5.1长连接的实现原理</h3><ul>
<li>轮询</li>
<li>心跳</li>
<li>Tcp长连接</li>
</ul>
<h3 id="5-2-keep-Alive和WebSocket的区别"><a href="#5-2-keep-Alive和WebSocket的区别" class="headerlink" title="5.2 keep-Alive和WebSocket的区别"></a>5.2 keep-Alive和WebSocket的区别</h3><p><img src="http://odzl05jxx.bkt.clouddn.com/ed541bc1ed61ead0bf6ea8233ef01c0a.jpg?imageView2/2/w/600" alt=""></p>
<h3 id="5-3-http2可以实现推送了"><a href="#5-3-http2可以实现推送了" class="headerlink" title="5.3 http2可以实现推送了"></a>5.3 http2可以实现推送了</h3><h2 id="6-WebSocket、SPDY、Http2"><a href="#6-WebSocket、SPDY、Http2" class="headerlink" title="6. WebSocket、SPDY、Http2"></a>6. WebSocket、SPDY、Http2</h2><p>WebSocket一种在单个TCP 连接上进行全双工通讯的协议。<br>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接），是HTTP协议的的第二个主要版本<br>SPDY也就是HTTP/2的前身，一种开放的网络传输协议，由Google开发，用来发送网页内容。基于传输控制协议（TCP）的应用层协议</p>
<p>网络协议，架构，规范，spdy,http2,url规范.<br>OSI七层网络体系结构 ： 物理层、数据链路层、网络层、传输层、表示层、会话层、应用层</p>
<p>应用层面的Http，SMTP,FTP,POP,TLS/SSL,IMAP</p>
<p>tcp三次握手，四次挥手<br>udp使用</p>
<p>tls,https加密过程，sha1和sha256加密算法</p>
<p><a href="https://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/">http请求的TCP瓶颈</a></p>
<p>ping ,traceRouter</p>
<p><a href="http://www.runoob.com/w3cnote/restful-architecture.html">Restfull架构详解</a><br><a href="http://blog.csdn.net/zhuhuiby/article/details/6725951">文件断点续传原理</a><br><a href="http://lcodecorex.github.io/2016/08/01/%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8E%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/">断点续传实现</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络相关的查找手册&lt;br&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/b9ae1189145b4a4d9dfe4d0b89a21b47.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp和Okio阅读笔记</title>
    <link href="https://haldir65.github.io/2017/07/21/2017-07-21-okhttp-demisified/"/>
    <id>https://haldir65.github.io/2017/07/21/2017-07-21-okhttp-demisified/</id>
    <published>2017-07-20T16:02:56.000Z</published>
    <updated>2017-07-23T11:11:24.058Z</updated>
    
    <content type="html"><![CDATA[<p>很早的时候就知道，OkHttp在io层面上的操作是由Okio代为完成的，所以实际意义上和Socket打交道的应该是Okio。而Okio又比传统的java io要高效。所以，在分析OkHttp之前，有必要针对Okio的一些方法进行展开，作为后面读写操作的铺垫。</p>
<p>Okio -&gt; OkHttp -&gt; Picaso  -&gt; Retrofit<br>Okio版本 1.13.0<br>OkHttp版本 3.8.0</p>
<p><img src="http://odzl05jxx.bkt.clouddn.com/6da83b3b20094b044a320d1e89dfcd00.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-Okio与java-io相比的优势"><a href="#1-Okio与java-io相比的优势" class="headerlink" title="1. Okio与java io相比的优势"></a>1. Okio与java io相比的优势</h2><p>java的InputStream可以被查看成是一个数据的来源，调用read方法从中读取数据。由于有些文件特别大，我们不可能在内存中分配一个和文件大小一样大的字节数组来专门来读写文件。因此需要传入一个缓冲数组。所以一般的读写程序的代码是这么写的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span></span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="comment">// 指定要读取文件的缓冲输入字节流  </span></div><div class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\test.jpg"</span>));  </div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"E:\\test.jpg"</span>);  </div><div class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;  </div><div class="line">            file.createNewFile();  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 指定要写入文件的缓冲输出字节流  </span></div><div class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));  </div><div class="line">        <span class="keyword">byte</span>[] bb = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">// 用来存储每次读取到的字节数组  </span></div><div class="line">        <span class="keyword">int</span> n;<span class="comment">// 每次读取到的字节数组的长度  </span></div><div class="line">        <span class="keyword">while</span> ((n = in.read(bb)) != -<span class="number">1</span>) &#123;  </div><div class="line">            out.write(bb, <span class="number">0</span>, n);<span class="comment">// 写入到输出流  </span></div><div class="line">        &#125;  </div><div class="line">        out.close();<span class="comment">// 关闭流  </span></div><div class="line">        in.close();  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>BufferedInputStream和BufferedOutputStream就是提供了这样的缓冲策略，其内部默认分配了一个默认大小的字节数组，或者在read方法中传入一个字节数组，每次一个byte一个byte的读，然后将读出来的内容写进outPutStream。读到-1就是文件终止(EOF)。具体原理可以参考IBM的<a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html">深入分析 Java I/O 的工作机制</a>。<br>那么问题来了，buffer[]作为一个字节数组，其容量是恒定的。假设我们想要一次性读取特别多的数据怎么办。例如http的response header一般长这样,然而实际上在无线电传播的过程中，每一行的后面都跟了一个换行符’\r\n’,而且无线电传播的时候其实根本没有换行的概念，就是一个字节跟着一个字节。假如服务器自己定义了特别长的header字段，inputstream读到这里的时候，事先预设的字节数组(没法改了)装不下，一种简单粗暴的方式是尝试扩容，这就意味着要把数据从原始数组copy到新的数组，丢掉旧的数组，把指针指向新的数组(一个是allocate数组，一个是arrayCopy，这俩都造成了性能损耗),当然jdk肯定不是这么干的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Bdpagetype: 1</div><div class="line">Bdqid: 0xc8f942640001e753</div><div class="line">Bduserid: 0</div><div class="line">Cache-Control: private</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Date: Fri, 21 Jul 2017 15:35:58 GMT</div><div class="line">Expires: Fri, 21 Jul 2017 15:35:29 GMT</div><div class="line">Server: BWS/1.1</div><div class="line">Set-Cookie: BDSVRTM=0; path=/</div><div class="line">Set-Cookie: BD_HOME=0; path=/</div><div class="line">Set-Cookie: H_PS_PSSID=1428_21110_20930; path=/; domain=.baidu.com</div><div class="line">Strict-Transport-Security: max-age=172800</div><div class="line">Vary: Accept-Encoding</div><div class="line">X-Powered-By: HPHP</div><div class="line">X-Ua-Compatible: IE=Edge,chrome=1</div><div class="line">Transfer-Encoding: chunked</div></pre></td></tr></table></figure></p>
<p>对于Http这种频繁的读写操作，allocate数组和copy数据无形中减慢了网络访问的速度。</p>
<ul>
<li>Okio的解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Buffer buffer = new Buffer();//cheap ,allocation literal nothing</div><div class="line">buffer.writeUtf8(&quot;Hello Okio&quot;); //java中一个英文字符占一个字节(byte)，一个汉字占2个字节(byte)</div><div class="line">buffer.writeUtf8(&quot;you can &quot;); //可以想象segment中被塞进了&quot;you can &quot;这几个byte</div><div class="line">buffer.writeUtf8(&quot;Go faster&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Okio将读写操作集中到到Buffer这个类中，用Sink和Source分别代表数据的去向和来源。而数据的承载类是Segment,读取数据(read)的时候从SegmentPool中索取Segment，读到Segment的byte[]数组中，装不下了再拿一个Segment。这个过程中是没有 new byte[]操作的。</p>
<ul>
<li>Read from a source， write to a sink</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">BufferedSource</span>, <span class="title">BufferedSink</span>, <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    Segment head;</div><div class="line">    <span class="keyword">long</span> size;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Buffer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//构造函数里不分配任何对象，所以创建一个Buffer几乎没有什么性能开销</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">8192</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARE_MINIMUM = <span class="number">1024</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</div><div class="line">    <span class="keyword">int</span> pos;</div><div class="line">    <span class="keyword">int</span> limit;</div><div class="line">    <span class="keyword">boolean</span> shared;</div><div class="line">    <span class="keyword">boolean</span> owner;</div><div class="line">    Segment next;</div><div class="line">    Segment prev;  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在那个读取一个文件写到另一个文件的程序可以写成这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sink = Okio.sink(dstFile);  <span class="comment">//返回了一个Sink匿名类，write的时候使用public void write(Buffer source, long byteCount)方法进行写操作</span></div><div class="line">source = Okio.source(srcFile);</div><div class="line">   Buffer buf = <span class="keyword">new</span> Buffer();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">long</span> readCount; (readCount = source.read(buf, <span class="number">2048</span>)) != -<span class="number">1</span>; ) &#123;</div><div class="line">      sink.write(buf, readCount);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>看起来还是在数据源和数据终点之间塞了一个缓冲层，sink(dst)和source(src)都是接口，Buffer同时实现了这俩接口。<br>write是从外面拿数据塞到自己的数组中，所以每次写的时候或让Buffer的Size变大(从segment pool中借用segment)。Buffer(Source)的read方法是把数据从Buffer中拿出来，所以会让Buffer的size变小(每一个Segment读完了会返回到segment pool中)<br>在Buffer的所有readXXX方法中都能看到这么一句话<br> <strong>SegmentPool.recycle(segment)</strong><br>因为Buffer内部是通过Segment的next和prev实现了双向链表，write是在尾部添加数据，read是从头部读取数据并移除。</p>
<p><strong>Okio能够实现高效率的核心在于,在java的inputStream和BufferedInputStream中，如果两块缓冲区之间想要交换数据。前面提到的扩容情况，从一个数组把数据复制到另一个更大的数组，必须走arrayCopy。</strong><br>网上查找了很多博客，总的来说就是java io采用了装饰者模式，不同Stream之间要包一层。<br>写数据时，写原始数据要用DataOutputStream，使用带缓冲的写要用BuffedOutputStream，使用字符编码要用OutputStreamWriter,写字节数组有ByteArrayOutputStream。<br>读数据时也是，原始数据要用DataInputStream，带缓冲的要用BufferedInputStream,字符编码要用InputStreamReader，读字节数有ByteArrayInputStream。</p>
<p>来看下其中带buffer的装饰类是怎么创建的，顺便把java io批判一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ByteArrayOutPutStream baos = <span class="keyword">new</span> ByteArrayOutPutStream();</div><div class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteAarray()); <span class="comment">//toByteArry内部调用了Arrays.copyOf()，创建了新对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(in);</div><div class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size]; <span class="comment">//创建新数组</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(out);</div><div class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size]; <span class="comment">//创建数组</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>同样的事情在okio中是这么干的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">RealBufferedSource(Source source) &#123;</div><div class="line">       <span class="keyword">if</span>(source == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"source == null"</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">this</span>.source = source; <span class="comment">//其实是buffer</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  RealBufferedSink(Sink sink) &#123;</div><div class="line">       <span class="keyword">if</span>(sink == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"sink == null"</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">this</span>.sink = sink; <span class="comment">//只是挪一下指针</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>由于一个Buffer即是source也是sink，挪一下指针就行了。写的时候往链表的尾巴写，读的时候从链表的头部读，读完了segment回收。</p>
<p>BufferedInputStream要求外部调用者带着一个固定大小的byte数组来取数据，难免会有人传进来一个特别小的数组，这样永远不可能读取超过这个数组大小长度的某一行。</p>
<p>BufferedSource在读取Socket数据时，一边从socket里面拿一个Segment大小的数据，然后调用readInt,readLong等方法返回int,long(同时从segment头部清空数据)。如果读到segment最后发现剩下的byte不能组成一个int，就会从segment pool中借一个segment，并从socket中读取数据塞满，把第一个segment剩下的一点byte和第二个segment的头部一点拼成一个int。以BufferSource的readInt为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.size &lt; <span class="number">4L</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"size &lt; 4: "</span> + <span class="keyword">this</span>.size);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Segment segment = <span class="keyword">this</span>.head;</div><div class="line">        <span class="keyword">int</span> pos = segment.pos;</div><div class="line">        <span class="keyword">int</span> limit = segment.limit;</div><div class="line">        <span class="keyword">if</span>(limit - pos &lt; <span class="number">4</span>) &#123; <span class="comment">//一个int 4个byte,这时候segment中未读的数据只剩下不到4个了</span></div><div class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.readByte() &amp; <span class="number">255</span>) &lt;&lt; <span class="number">24</span> | (<span class="keyword">this</span>.readByte() &amp; <span class="number">255</span>) &lt;&lt; <span class="number">16</span> | (<span class="keyword">this</span>.readByte() &amp; <span class="number">255</span>) &lt;&lt; <span class="number">8</span> | <span class="keyword">this</span>.readByte() &amp; <span class="number">255</span>; <span class="comment">//readByte就是从链表的头部开始一个byte一个byte的读，segment读完了自动回收，直到组成一个int。</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//剩下的byte足够组成一个int</span></div><div class="line">            <span class="keyword">byte</span>[] data = segment.data;</div><div class="line">            <span class="keyword">int</span> i = (data[pos++] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">24</span> | (data[pos++] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">16</span> | (data[pos++] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">8</span> | data[pos++] &amp; <span class="number">255</span>; <span class="comment">//从byte转int</span></div><div class="line">            <span class="keyword">this</span>.size -= <span class="number">4L</span>; </div><div class="line">            <span class="keyword">if</span>(pos == limit) &#123;</div><div class="line">                <span class="keyword">this</span>.head = segment.pop();</div><div class="line">                SegmentPool.recycle(segment); <span class="comment">//读完了就把segment回收</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                segment.pos = pos;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个很有意思的现象是，java BufferedInputStream的默认buffer数组大小是8192，okio 的segment的默认size也是8192，这些都是以byte为单位的。找到一个合理的<a href="https://stackoverflow.com/questions/37404068/why-is-the-default-char-buffer-size-of-bufferedreader-8192">解释</a>。大致意思是8192 = 2^13, windows和linux上这个大小正好占用两个分页文件(8kB)。另外java io的类图确实让人眼花缭乱。</p>
<h2 id="2-OkHttp的解析"><a href="#2-OkHttp的解析" class="headerlink" title="2. OkHttp的解析"></a>2. OkHttp的解析</h2><h3 id="2-1-使用介绍"><a href="#2-1-使用介绍" class="headerlink" title="2.1 使用介绍"></a>2.1 使用介绍</h3><p>先上一张图<img src="http://odzl05jxx.bkt.clouddn.com/okHttp_chain.JPG" alt="">。这是最简单的直接用OkHttpClient请求<a href="http://www.baidu.com">百度首页</a>的堆栈调用情况。在没有做任何手动配置的情况下，至少发现了五个Interceptor:</p>
<p> RetryAndFollowUpInterceptor<br> BridgeInterceptor<br> CacheInterceptor<br> ConnectInterceptor<br> CallServerInterceptor</p>
<p> 走到CallServerInterceptor的时候，可以看到Response已经形成了。每一个Interceptor之间还有一个RealInterceptorChain，将各个Interceptor串联起来，</p>
<p>首先是调用者的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">mClient = <span class="keyword">new</span> OkHttpClient()</div><div class="line"><span class="comment">//同步执行</span></div><div class="line"> Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">                .url(<span class="string">"http:www.baidu.com"</span>)</div><div class="line">                .build();</div><div class="line">        Call call = mClient.newCall(request);</div><div class="line">        Response response = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            response = call.execute();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//异步执行代码</span></div><div class="line"> Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">                .url(<span class="string">"http:www.baidu.com"</span>)</div><div class="line">                .build();</div><div class="line">        Call call = mClient.newCall(request);</div><div class="line">        </div><div class="line">        call.enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="2-2-参数配置"><a href="#2-2-参数配置" class="headerlink" title="2.2 参数配置"></a>2.2 参数配置</h3><p>首先Request.Builder().build()方法，这里面只是使用Builder模式，和Retrofit很相似，方便链式调用。最终调用了Request的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Request(Request.Builder builder) &#123;</div><div class="line">       <span class="keyword">this</span>.url = builder.url; <span class="comment">//HttpUrl类型</span></div><div class="line">       <span class="keyword">this</span>.method = builder.method; <span class="comment">//String类型</span></div><div class="line">       <span class="keyword">this</span>.headers = builder.headers.build(); <span class="comment">//header就是个字典，内部用一个String数组维护。</span></div><div class="line">       <span class="keyword">this</span>.body = builder.body;<span class="comment">// RequestBody类型，用于POST提交表单或者Multipart上传文件。</span></div><div class="line">       <span class="keyword">this</span>.tag = builder.tag != <span class="keyword">null</span>?builder.tag:<span class="keyword">this</span>; <span class="comment">//Object类型</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>Request里面的成员代表了一个网络请求所应该有的一切可能的元素，没什么可说的。<br>OkHttpClient的构造也是Builder模式，一旦创建了不能setXX.找到一个比较丰富的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">                          .retryOnConnectionFailure(<span class="keyword">true</span>)</div><div class="line">                          .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</div><div class="line">                          <span class="comment">//设置缓存</span></div><div class="line">                          .cache(cache)</div><div class="line">                          .build();</div></pre></td></tr></table></figure></p>
<p>到这里都还只是发起真正的请求之前的configuration阶段，来看发起RealCall的过程</p>
<p> Call call = mClient.newCall(request);<br> 这里面初始化了一个RetryAndFollowUpInterceptor。这个拦截器的作用是在连接server失败后自动重连，但服务器500就不会重连,参考<a href="https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace">okhttp-is-quietly-retrying-requests-is-your-api-ready</a></p>
<h3 id="2-3-开始执行请求"><a href="#2-3-开始执行请求" class="headerlink" title="2.3 开始执行请求"></a>2.3 开始执行请求</h3><p>response = call.execute();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.executed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    Response var2;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">this</span>.client.dispatcher().executed(<span class="keyword">this</span>); <span class="comment">//这个Dispatcher负责记录当前OkHttpClient的所有Request的状态，提供线程池</span></div><div class="line">        Response result = <span class="keyword">this</span>.getResponseWithInterceptorChain();</div><div class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var2 = result;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">this</span>.client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">//记录状态</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> var2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点就在getResponseWithInterceptorChain里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">       List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList();</div><div class="line">       interceptors.addAll(<span class="keyword">this</span>.client.interceptors());</div><div class="line">       interceptors.add(<span class="keyword">this</span>.retryAndFollowUpInterceptor);</div><div class="line">       interceptors.add(<span class="keyword">new</span> BridgeInterceptor(<span class="keyword">this</span>.client.cookieJar()));</div><div class="line">       interceptors.add(<span class="keyword">new</span> CacheInterceptor(<span class="keyword">this</span>.client.internalCache()));</div><div class="line">       interceptors.add(<span class="keyword">new</span> ConnectInterceptor(<span class="keyword">this</span>.client));</div><div class="line">       <span class="keyword">if</span>(!<span class="keyword">this</span>.forWebSocket) &#123; </div><div class="line">           interceptors.addAll(<span class="keyword">this</span>.client.networkInterceptors()); </div><div class="line">       &#125;</div><div class="line"></div><div class="line">       interceptors.add(<span class="keyword">new</span> CallServerInterceptor(<span class="keyword">this</span>.forWebSocket));</div><div class="line">       Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, (StreamAllocation)<span class="keyword">null</span>, (HttpCodec)<span class="keyword">null</span>, (RealConnection)<span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">this</span>.originalRequest);</div><div class="line">       <span class="keyword">return</span> chain.proceed(<span class="keyword">this</span>.originalRequest);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>注意顺序，用户手动添加的interceptor是最先添加的。在添加完ConnectInterceptor之后，又添加了networkInterceptors(用户手动添加的，一个List)。道理也很清楚，一种是在发起Socket请求之前就拦下来，一种是连上Socket之后的拦截</p>
<p>Chain的proceed就是从List中一个个取出Inerceptor，然后执行</p>
<h2 id="3-自带的五个Interceptor"><a href="#3-自带的五个Interceptor" class="headerlink" title="3. 自带的五个Interceptor"></a>3. 自带的五个Interceptor</h2><h3 id="3-1-RetryAndFollowUpInterceptor"><a href="#3-1-RetryAndFollowUpInterceptor" class="headerlink" title="3.1 RetryAndFollowUpInterceptor"></a>3.1 RetryAndFollowUpInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">while(!this.canceled) &#123;</div><div class="line">        Response response = null;</div><div class="line">        boolean releaseConnection = true;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            response = ((RealInterceptorChain)chain).proceed(request, this.streamAllocation, (HttpCodec)null, (RealConnection)null);</div><div class="line">            releaseConnection = false;</div><div class="line">        &#125; catch (RouteException var13) &#123;</div><div class="line">            releaseConnection = false;</div><div class="line">            continue;</div><div class="line">        &#125; catch (IOException var14) &#123;</div><div class="line">            releaseConnection = false;</div><div class="line">            continue;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if(releaseConnection) &#123;</div><div class="line">                this.streamAllocation.streamFailed((IOException)null);</div><div class="line">                this.streamAllocation.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Request followUp = this.followUpRequest(response);</div><div class="line">        if(followUp == null) &#123;</div><div class="line">            return response; </div><div class="line">        &#125;</div><div class="line">        ++followUpCount;</div><div class="line">        if(followUpCount &gt; 20) &#123; </div><div class="line">            this.streamAllocation.release();</div><div class="line">            throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里面写死了一个循环，只要没有cancel，catch到特定的Exception就一直让链条走下去。</p>
<h3 id="3-2-BridgeInterceptor"><a href="#3-2-BridgeInterceptor" class="headerlink" title="3.2 BridgeInterceptor"></a>3.2 BridgeInterceptor</h3><p>这是第二个Interceptor<br>interceptors.add(new BridgeInterceptor(this.client.cookieJar()));//注意带进来了cookie，主要都是添加header什么的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request userRequest = chain.request();</div><div class="line">     <span class="keyword">if</span>(userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">        requestBuilder.header(<span class="string">"Host"</span>, Util.hostHeader(userRequest.url(), <span class="keyword">false</span>));</div><div class="line">    &#125;</div><div class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line"></div><div class="line">    okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> responseBuilder.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>都是些Host,Connection Keep-Alive,User-Agent,Content-Length等跟header有关的东西。随后将request交给链条的下一个interceptor。Response回来之后相应set-Cookie这些东西，下次请求带上cookie，这些都是Http的标准步骤。</p>
<h3 id="3-3-CacheInterceptor"><a href="#3-3-CacheInterceptor" class="headerlink" title="3.3 CacheInterceptor"></a>3.3 CacheInterceptor</h3><p>接下来轮到cache，对于response的处理也是差不多的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Response cacheCandidate = <span class="keyword">this</span>.cache != <span class="keyword">null</span>?<span class="keyword">this</span>.cache.get(chain.request()):<span class="keyword">null</span>;</div><div class="line"></div><div class="line">    Request networkRequest = strategy.networkRequest;</div><div class="line">    Response cacheResponse = strategy.cacheResponse;</div><div class="line">   </div><div class="line">        Response networkResponse = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">     networkResponse = chain.proceed(networkRequest); </div><div class="line"></div><div class="line">        Response response;</div><div class="line">        <span class="keyword">if</span>(cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(networkResponse.code() == <span class="number">304</span>) &#123;</div><div class="line">                response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class="line">                networkResponse.body().close();</div><div class="line">                <span class="keyword">this</span>.cache.trackConditionalCacheHit();</div><div class="line">                <span class="keyword">this</span>.cache.update(cacheResponse, response);</div><div class="line">                <span class="keyword">return</span> response; <span class="comment">//只针对304做了自动cache</span></div><div class="line">            &#125;</div><div class="line">            Util.closeQuietly(cacheResponse.body());</div><div class="line">        &#125;</div><div class="line">        response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里也是让请求接着走下去，response回来之后，只有304的时候才会去主动cache下来。</p>
<h3 id="3-4-ConnectInterceptor"><a href="#3-4-ConnectInterceptor" class="headerlink" title="3.4 ConnectInterceptor"></a>3.4 ConnectInterceptor</h3><p>这里的interceptor方法异常简短<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain)chain;</div><div class="line">    Request request = realChain.request();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</div><div class="line">    HttpCodec httpCodec = streamAllocation.newStream(<span class="keyword">this</span>.client, doExtensiveHealthChecks);</div><div class="line">    RealConnection connection = streamAllocation.connection();</div><div class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里重点关注 StreamAllocation这个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAllocation</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Address address;</div><div class="line">    <span class="keyword">private</span> Route route;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConnectionPool connectionPool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object callStackTrace;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteSelector routeSelector;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refusedStreamCount;</div><div class="line">    <span class="keyword">private</span> RealConnection connection;</div><div class="line">    <span class="keyword">private</span> HttpCodec codec;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从HttpCodec httpCodec = streamAllocation.newStream(this.client, doExtensiveHealthChecks); 这句话一直往下走，会走到Socket.connect()，也就是大多数人初学网络编程时被教导的如何创建Socket连接。现在想想，能够从操作系统底层的Socket封装出这么多复杂的步骤，实在是高手。<br>StreamAllocation.newStream  —-&gt; StreamAllocation.findHealthyConnection  —&gt; StreamAallocation.findConnection —&gt; new RealConnection —&gt; RealConnection.connect </p>
<p>RealConnection.connect()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">boolean</span> connectionRetryEnabled)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.protocol != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already connected"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.route.requiresTunnel()) &#123;</div><div class="line">                        <span class="keyword">this</span>.connectTunnel(connectTimeout, readTimeout, writeTimeout);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">this</span>.connectSocket(connectTimeout, readTimeout);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException var11) &#123;</div><div class="line">                    <span class="keyword">if</span>(!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(var11)) &#123;</div><div class="line">                        <span class="keyword">throw</span> routeException; <span class="comment">//这个Exception就是给RetryAndFollowupInterceptor准备的</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">           </div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最初学习Socket编程的时候，就是写了一个while(true)，是不是很像？</p>
<p>对了ConnectionPool内部使用了一个Deque保存RealConnection,findConnection里面有这么一段</p>
<ul>
<li>Internal.instance.get(this.connectionPool, this.address, this, (Route)null);//查找</li>
<li>Internal.instance.put(this.connectionPool, result);//放进pool</li>
</ul>
<p>connectSocket长这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Proxy proxy = <span class="keyword">this</span>.route.proxy();</div><div class="line">    Address address = <span class="keyword">this</span>.route.address();</div><div class="line">    <span class="keyword">this</span>.rawSocket = proxy.type() != Type.DIRECT &amp;&amp; proxy.type() != Type.HTTP?<span class="keyword">new</span> Socket(proxy):address.socketFactory().createSocket();</div><div class="line">    <span class="keyword">this</span>.rawSocket.setSoTimeout(readTimeout);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Platform.get().connectSocket(<span class="keyword">this</span>.rawSocket, <span class="keyword">this</span>.route.socketAddress(), connectTimeout); <span class="comment">//这里面就一句话socket.connect</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ConnectException var7) &#123;</div><div class="line">        ConnectException ce = <span class="keyword">new</span> ConnectException(<span class="string">"Failed to connect to "</span> + <span class="keyword">this</span>.route.socketAddress());</div><div class="line">        ce.initCause(var7);</div><div class="line">        <span class="keyword">throw</span> ce;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">this</span>.source = Okio.buffer(Okio.source(<span class="keyword">this</span>.rawSocket)); </div><div class="line">        <span class="keyword">this</span>.sink = Okio.buffer(Okio.sink(<span class="keyword">this</span>.rawSocket));</div><div class="line">    &#125; <span class="keyword">catch</span> (NullPointerException var8) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="string">"throw with null exception"</span>.equals(var8.getMessage())) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(var8);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>重点看</strong><br>this.source = Okio.buffer(Okio.source(this.rawSocket));<br>this.sink = Okio.buffer(Okio.sink(this.rawSocket));<br>通过sink往Socket里面写数据，通过source网Socket里面写数据，通过Okio包装了，虽然本质上还是socket.getOutputStream和Socket.getInputStream。到这一步，RealConnection内部sink和source初始化完成，socket已经连接上，Socket的inputStream和outPutStream都准备就绪。其实在这种状态下就已经可以开始读写了。</p>
<h3 id="3-5-CallServerInterceptor"><a href="#3-5-CallServerInterceptor" class="headerlink" title="3.5 CallServerInterceptor"></a>3.5 CallServerInterceptor</h3><p>这里已经连上了服务器，可以像操作本地文件一样读写数据了，当然要在遵守http规范的前提下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain)chain;</div><div class="line">    HttpCodec httpCodec = realChain.httpStream();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line">    RealConnection connection = (RealConnection)realChain.connection();</div><div class="line">    Request request = realChain.request();</div><div class="line">    <span class="comment">//可以看到，到这一步所需要的数据都准备就绪</span></div><div class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    httpCodec.writeRequestHeaders(request); <span class="comment">//开始写数据</span></div><div class="line"></div><div class="line">    Builder responseBuilder = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123; <span class="comment">//这里面是跟POST相关的</span></div><div class="line">        <span class="keyword">if</span>(<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</div><div class="line">            httpCodec.flushRequest();</div><div class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(responseBuilder == <span class="keyword">null</span>) &#123;</div><div class="line">            Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class="line">            BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">            request.body().writeTo(bufferedRequestBody); <span class="comment">//这里就是Okio发挥高效的地方</span></div><div class="line">            bufferedRequestBody.close();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!connection.isMultiplexed()) &#123;</div><div class="line">            streamAllocation.noNewStreams();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    httpCodec.finishRequest(); <span class="comment">//到这里，client的数据全部写完并且发送给服务器，服务器开始干活。</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">if</span>(responseBuilder == <span class="keyword">null</span>) &#123;</div><div class="line">        responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>); <span class="comment">//开始从Socket里面读取数据</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</div><div class="line">    <span class="keyword">int</span> code = response.code();</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</div><div class="line">        response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>)) || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">        streamAllocation.noNewStreams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0L</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面就是一步步的开始写数据了。这里再借用下百度,chrome按下F12，打开百度首页，看下request的raw header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Host: www.baidu.com</div><div class="line">Connection: keep-alive</div><div class="line">Cache-Control: max-age=0</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line">DNT: 1</div><div class="line">Accept-Encoding: gzip, deflate, br</div><div class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</div><div class="line">Cookie: PSTM=122178321; BIDUPSID=CF3243290400VSDG52B3859AD4AEC2; BAIDUID=5176CC0A23DB1F3423426454DRTG5EC8:FG=1; MCITY=-%3A; BD_HOME=0; H_PS_PSSID=1428_24320_20930; BD_UPN=1223214323</div></pre></td></tr></table></figure></p>
<p>看下httpCodec.writeRequestHeaders(request)的实现，就会发现真的是这么一行一行的写的<br>例如RequestLine.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(Request request, Type proxyType)</span> </span>&#123;</div><div class="line">       StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">       result.append(request.method()); <span class="comment">// GET </span></div><div class="line">       result.append(<span class="string">' '</span>); <span class="comment">//空格</span></div><div class="line">       <span class="keyword">if</span>(includeAuthorityInRequestLine(request, proxyType)) &#123;</div><div class="line">           result.append(request.url());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result.append(requestPath(request.url()));  <span class="comment">//我们访问的是百度首页，当然是'/'这个Index啦</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       result.append(<span class="string">" HTTP/1.1"</span>);  <span class="comment">//是不是和上面一模一样</span></div><div class="line">       <span class="keyword">return</span> result.toString();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>接下来轮到Http1Codec.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRequest</span><span class="params">(Headers headers, String requestLine)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"state: "</span> + <span class="keyword">this</span>.state);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.sink.writeUtf8(requestLine).writeUtf8(<span class="string">"\r\n"</span>); <span class="comment">//这是第一行，写完了加上换行符</span></div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> size = headers.size(); i &lt; size; ++i) &#123;</div><div class="line">                <span class="keyword">this</span>.sink.writeUtf8(headers.name(i)).writeUtf8(<span class="string">": "</span>).writeUtf8(headers.value(i)).writeUtf8(<span class="string">"\r\n"</span>); <span class="comment">//一个header写完就写一个换行符</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.sink.writeUtf8(<span class="string">"\r\n"</span>);</div><div class="line">            <span class="keyword">this</span>.state = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>读取Response的顺序和写Request相反，不再赘述。</p>
<h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h2><p>这里只是针对OkHttp发起的一个最简单同步的网络请求进行了分析。<br>关于异步请求再说两句：本质上不过是包装了一个回调，丢到线程池里面，相比整个Http请求，实在是不值一提。来看下这个线程池</p>
<ul>
<li>new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(“OkHttp Dispatcher”, false));</li>
</ul>
<p>照说jdk不推荐这么创建线程池，一般用jdk封装好的CachedThreadPool，FixedThreadPool等等，但想必这样做也是不为了造成过大的系统开销吧。debug的时候如果看到OkHttp Dispatcher这条线程，应该明白是为什么了吧。另外，Okio会引入一条名为Okio WatchDog的线程，这跟Okio的AsyncTimeOut有关。时间关系(已经是夜里12点了)，不打算研究了。</p>
<p>OkHttp总量过于庞大，很多方面，包括spdy,webSocket,RouterDatabase,DNS,网络执行周期触发回调，http2，http协议，太多太多，再研究一天也看不完。</p>
<p>拎出来几个比较重要的点吧：</p>
<ul>
<li>Okio放在最前面，就是为了说明在网络请求这样对于io性能要求高的场合，okio避免了memory allocation和不必要的缓存复制。</li>
<li>OkHttpClient应该是对标apache的HttpClient的，后者不清楚。</li>
<li>底层还是调用操作系统的Socket接口，从这个角度来看，Retrofit只是一个Util，包括线程调度都是用的OkHttp的线程池；Volley我记得默认是4条NetWorkDispatcher和一个CacheDispatcher和一个ContentDelivery。</li>
<li>不推荐创建多个OkHttpClient，真想创建多个的话，用newBuilder(浅复制)就好了嘛。</li>
<li>网上说Picaso内部的cache其实就是OkHttp的cache，不愧square全家桶系列</li>
<li>和Retrofit一样，也是用的Builder模式，提供了极大的自定义空间</li>
<li>Interceptor，广受业界好评的责任链模式</li>
</ul>
<p>写于2017年7月23日0:29</p>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ul>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/">Paisy</a></li>
<li><a href="http://frodoking.github.io/2015/03/12/android-okhttp/">Frodo系列</a></li>
<li><a href="https://www.youtube.com/watch?v=WvyScM_S88c">A few ok library</a></li>
<li><a href="http://jakewharton.com/forcing-bytes-downward-in-okio/">Forcing bytes downward in Okio</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早的时候就知道，OkHttp在io层面上的操作是由Okio代为完成的，所以实际意义上和Socket打交道的应该是Okio。而Okio又比传统的java io要高效。所以，在分析OkHttp之前，有必要针对Okio的一些方法进行展开，作为后面读写操作的铺垫。&lt;/p&gt;
&lt;p&gt;Okio -&amp;gt; OkHttp -&amp;gt; Picaso  -&amp;gt; Retrofit&lt;br&gt;Okio版本 1.13.0&lt;br&gt;OkHttp版本 3.8.0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/6da83b3b20094b044a320d1e89dfcd00.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://haldir65.github.io/tags/android/"/>
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>日常开发手册</title>
    <link href="https://haldir65.github.io/2017/07/12/2017-07-12-android-cookbook/"/>
    <id>https://haldir65.github.io/2017/07/12/2017-07-12-android-cookbook/</id>
    <published>2017-07-12T00:40:08.000Z</published>
    <updated>2017-08-12T03:09:58.613Z</updated>
    
    <content type="html"><![CDATA[<p>A Cookbook shall look like a collection of Recipes, or an index page from where dinner are made. And it keeps you sane.<br><img src="http://odzl05jxx.bkt.clouddn.com/Cg-4zFVJ0xGITwm_AA688WRj8n8AAXZ9wGMpd0ADr0J195.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<p>github上已经star了四百多个项目，应该复习下了。</p>
<h2 id="各个平台相关的特定的一些记录"><a href="#各个平台相关的特定的一些记录" class="headerlink" title="各个平台相关的特定的一些记录"></a>各个平台相关的特定的一些记录</h2><h3 id="布局相关的点"><a href="#布局相关的点" class="headerlink" title="布局相关的点"></a>布局相关的点</h3><p><a href="http://haldir65.github.io/2016/10/10/theme-versus-style/">theme和Style</a>  <strong>Dan lew</strong></p>
<h3 id="事件分发，动画，自定义View"><a href="#事件分发，动画，自定义View" class="headerlink" title="事件分发，动画，自定义View"></a>事件分发，动画，自定义View</h3><p><a href="http://haldir65.github.io/2016/09/23/selectableItemBackground-foreground/">android使用selectableItemBackground的一些坑</a><br><a href="http://haldir65.github.io/2016/09/27/activity-transition-pre-and-post-lollipop/">activity transition pre and post lollipop</a><br><a href="http://haldir65.github.io/2016/10/06/touch-event-distribution/">事件分发流程</a><br><a href="http://haldir65.github.io/2016/10/13/2016-10-13-Android-coordinate-System/">安卓坐标系常用方法</a><br><a href="http://haldir65.github.io/2016/10/24/2016-10-24-a-peek-on-pull-to-refresh/">android-Ultra-pull-to-refresh分析</a></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><a href="http://haldir65.github.io/2016/09/18/android-inner-class-leak/">内存泄漏</a></p>
<h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h3><p><a href="http://haldir65.github.io/2016/10/15/2016-10-15-using-loader-in-android-app/">使用Loader进行异步数据操作</a></p>
<h3 id="V4包里面的东西"><a href="#V4包里面的东西" class="headerlink" title="V4包里面的东西"></a>V4包里面的东西</h3><p><a href="http://haldir65.github.io/2016/10/20/2016-10-20-RecyclerViewAnimationStuff/">使用RecyclerView的Animation Android Dev Summit 2015</a>   <strong>yigit boyar和Chet Haase</strong><br><a href="http://haldir65.github.io/2016/10/20/2016-10-20-write-your-own-layoutmanager/">自定义LayoutManager</a>  <strong>Dave Smith</strong><br><a href="http://haldir65.github.io/2017/07/12/2017-07-12-fragment-decoded/">Fragment源码解析</a>  </p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><a href="http://haldir65.github.io/2016/10/12/2016-10-12-How-the-mainThread-work/">主线程的工作原理</a> <strong>Michael Bailey American Express, 他2016年还讲了LayoutInflater的工作原理</strong><br><a href="http://djt.qq.com/article/view/987">vsync原理解释</a><br><a href="http://haldir65.github.io/2016/10/20/2016-10-20-android-dirty-code/">让service常驻后台的方法</a><br>//下面这些已经有人写的很好了，直接看就可以了<br><a href="http://blog.csdn.net/qq_23547831/article/details/51119333">应用进程启动流程</a><br><a href="http://blog.csdn.net/qq_23547831/article/details/51112031">Launcher启动流程</a><br><a href="http://blog.csdn.net/qq_23547831/article/details/51105171">SystemServer进程启动流程</a><br><a href="http://blog.csdn.net/qq_23547831/article/details/51104873">Zygote进程启动流程</a><br><a href="http://blog.csdn.net/qq_23547831/article/details/51210682">Apk安装流程</a><br><a href="http://blog.csdn.net/qq_23547831/article/details/51224992">Activity启动流程</a><br>//这个博主写的一系列底层分析都比较清楚</p>
<h3 id="新版本适配，新特性"><a href="#新版本适配，新特性" class="headerlink" title="新版本适配，新特性"></a>新版本适配，新特性</h3><p><a href="http://haldir65.github.io/2016/10/08/android-7-0-new-features/">Android 7.0的适配</a></p>
<h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><p><a href="http://haldir65.github.io/2016/10/14/2016-10-14-Android-translucent-status-bar/">沉浸式状态栏</a><br><a href="http://haldir65.github.io/2016/09/22/replace-butterKnife-with-databinding/">replace butterKnife with databinding</a></p>
<h3 id="拆轮子"><a href="#拆轮子" class="headerlink" title="拆轮子"></a>拆轮子</h3><p><a href="http://haldir65.github.io/2017/07/21/2017-07-21-glide-decoded/">Glide源码解析</a><br><a href="http://haldir65.github.io/2017/04/23/2017-04-23-rxjava2-for-android/">Rxjava2的一些点</a> <strong>Jake Wharton</strong><br><a href="http://haldir65.github.io/2017/07/01/2017-07-01-it-began-with-a-few-bits/">Retrofit源码解析</a><br><a href="http://haldir65.github.io/2017/07/21/2017-07-21-okhttp-demisified/">OkHttp和Okio源码解析</a></p>
<h2 id="跟java相关的"><a href="#跟java相关的" class="headerlink" title="跟java相关的"></a>跟java相关的</h2><p><a href="http://haldir65.github.io/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/">java集合类的实现原理</a><br><a href="http://haldir65.github.io/2017/04/30/2017-04-30-concurrency-and-beyond/">Java线程池的一些点</a><br><a href="http://haldir65.github.io/2016/12/31/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor/">使用AnnotationProcessor自动生成代码</a><br><a href="http://haldir65.github.io/2017/05/24/2017-05-24-jvm-architecture/">翻译了一个印度口音的关于jvm架构的视频</a></p>
<ul>
<li><a href="http://haldir65.github.io/2017/07/23/2017-07-23-from-java-code-to-java-heap/">一个Java Object到底占用多少内存(from java code to java heap)</a></li>
<li><a href="http://haldir65.github.io/2017/07/23/2017-07-23-lru-cache-and-more/">LruCache的原理</a><br>-</li>
</ul>
<h2 id="工具书"><a href="#工具书" class="headerlink" title="工具书"></a>工具书</h2><p><a href="http://haldir65.github.io/2016/09/27/git-manual/">git常用操作手册</a><br><a href="http://haldir65.github.io/2016/12/10/2016-12-10-adb-command/">adb常用命令手册</a></p>
<h2 id="杂乱的点"><a href="#杂乱的点" class="headerlink" title="杂乱的点"></a>杂乱的点</h2><p><a href="http://haldir65.github.io/2017/06/17/2017-06-17-tiny-details-in-java/">java中的任何细碎的点</a></p>
<h2 id="ToDo-List"><a href="#ToDo-List" class="headerlink" title="ToDo List"></a>ToDo List</h2><p>Java相关</p>
<ul>
<li>[X] 画一下java的集合框架</li>
<li>[X] String StringBuffer StringBuilder区别(StringBuffer很多方法都加了synchronized)</li>
<li>[ ] 多线程异步断点续传框架原理,利用该原理在图片加载框架中的应用(MappedByteBuffer或者RandomAccessFile)</li>
<li>[ ] 多线程断点续传原理，大文件下载oom问题</li>
<li>[ ] java位运算，Collection框架中多次用到了</li>
<li>[ ] gson的原理，cache什么的，常规json解析器的原理</li>
<li>[ ] 垃圾回收器的分类及优缺点</li>
<li>[ ] ThreadLocal原理及可能的内存泄漏</li>
<li>[ ] Understanding Dagger2’s generated code</li>
<li>[ ] 单例模式需要考虑到jvm优化的问题（为什么要写两个synchronized）</li>
<li>[ ] java类加载机制(classLoader相关的，类的加载顺序)</li>
<li>[ ] Java四种引用</li>
<li>[ ] Future和FutureTask,CompletableFuture这些怎么用</li>
<li>[ ]<a href="http://blog.csdn.net/briblue/article/details/76223206">反射</a></li>
<li>[ ] java堆和栈的区别，如何判断堆栈上的对象死没死</li>
<li>[ ] 自己写一个一部图片加载框架，并发图像滤镜框架</li>
<li>[ ] try catch finally到底会不会执行</li>
<li>[ ] 并发编程，java.util.concurrent里面的类熟练掌握，粗略了解原理</li>
<li>[ ]写一个<a href="https://github.com/Mr-YangCheng/ForAndroidInterview/blob/master/java/%5BJava%5D%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%94%E7%A7%8D%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.md">生产者消费者</a>模型</li>
<li>[ ] HashMap和conrrentHashmap区别(分段锁比较难)</li>
<li>[ ] java的包结构：java.lang(Language核心类);java.io(I/O相关);java.util(包含collection和concurrent);java.nio(另一种I/O);java.net(网络操作)</li>
</ul>
<p>Android相关</p>
<ul>
<li>[ ] AppCompat源码解析</li>
<li>[ ] ContentProvider的启动过程</li>
<li>[ ] IPC，Binder原理</li>
<li>[ ] cookie存储位置(/webviewCookiesChromium.db),db存储位置</li>
<li>[ ] Binder的原理，Binder里面引用计数的原理，Binder底层为什么用红黑树</li>
<li>[ ] onSaveInstance,不仅仅是Activity,Fragment，View中也有，具体实现原理。View一定要有id</li>
<li>[ ] 热修复框架原理</li>
<li>[ ] WebView JS交互，WebView存在的<a href="http://www.jianshu.com/p/9f7e9ab8d2fa">漏洞</a>,通过反射可看可能存在的<a href="https://my.oschina.net/fengheju/blog/673629">安全问题</a>以及<a href="http://blog.csdn.net/xueerfei008/article/details/26750659">C代码</a></li>
<li>[ ] Media相关，视频播放etc，相机，滤镜等.<a href="https://github.com/w1123440793/VideoListDemo">Demo</a></li>
<li>[ ] UI Toolkit源码解析<ul>
<li>[ ] ViewPager的原理</li>
<li>[ ] ViewGroup，View的源码</li>
<li>[ ] View的绘制原理</li>
<li>[ ] ListView,RecyclerView原理,加载优化(prefetcher什么的，滑动过程中不去加载图片，参考我写的Glide笔记)</li>
</ul>
</li>
<li>[ ] Zygote进程启动流程</li>
<li>[ ] SystemServer进程启动流程</li>
<li>[ ] Launcher启动流程</li>
</ul>
<p>Linux相关</p>
<ul>
<li>[ ] linux进程间通信方式有哪些（信号量这种）</li>
<li>[ ] Linux command extended</li>
<li>[ ] 搭建mail服务</li>
</ul>
<p>网络通信</p>
<ul>
<li>[ ] TCP UDP的不同 TCP三次握手，wireShark抓包,抓一个App的包，模拟请求</li>
<li>[ ] 如何维持一个长连接</li>
<li>[ ] 点击一个网址底层经历哪些过程</li>
</ul>
<p>Gradle相关</p>
<ul>
<li>[ ]写一些DSL吧<a href="https://github.com/Ccixyj/JBusDriver">Old Driver</a></li>
</ul>
<p>数据库相关</p>
<ul>
<li>[ ] MySql从入门到删库跑路</li>
<li>[ ] Realm的优点</li>
</ul>
<p>C语言从入门到放弃</p>
<ul>
<li>[ ] 加载ffmpeg需要，不得不学<a href="http://blog.csdn.net/leixiaohua1020/article/details/47008825">ffmpeg教程</a></li>
</ul>
<p>数据结构，算法</p>
<ul>
<li>[ ] 数据结构，操作系统</li>
<li>[ ] 编码，底层二进制</li>
<li>[ ] 二分法查找，排序，冒泡，复杂度</li>
<li>[ ] 数组跟链表区别,数组跟链表排序时区别,数组跟链表排序时区别</li>
<li>[ ] 八大排序<a href="http://www.cnblogs.com/123hll/p/6903454.html">算法</a></li>
</ul>
<h2 id="一些需要看的演讲"><a href="#一些需要看的演讲" class="headerlink" title="一些需要看的演讲"></a>一些需要看的演讲</h2><p><a href="https://www.youtube.com/watch?v=WvyScM_S88c">Droidcon Montreal Jake Wharton - A Few Ok Libraries</a><br><a href="https://www.youtube.com/watch?v=N3J4ZFiR_3Q">Advanced Scrolling Techniques on Android</a></p>
<h2 id="一些有名的人"><a href="#一些有名的人" class="headerlink" title="一些有名的人"></a>一些有名的人</h2><p><a href="https://developers.google.com/experts/all/technology/android">GDE</a><br>Dianne Hackborn<br><a href="https://github.com/swankjesse">Jesse Wilson</a></p>
<h2 id="一些列入的规划的想法"><a href="#一些列入的规划的想法" class="headerlink" title="一些列入的规划的想法"></a>一些列入的规划的想法</h2><ul>
<li>多线程下载实例</li>
<li>自己写一个ImageLoader(主要是多线程同步的问题,queue)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A Cookbook shall look like a collection of Recipes, or an index page from where dinner are made. And it keeps you sane.&lt;br&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/Cg-4zFVJ0xGITwm_AA688WRj8n8AAXZ9wGMpd0ADr0J195.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://haldir65.github.io/tags/android/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2017-07-12-scrapy-notes</title>
    <link href="https://haldir65.github.io/2017/07/12/2017-07-12-scrapy-notes/"/>
    <id>https://haldir65.github.io/2017/07/12/2017-07-12-scrapy-notes/</id>
    <published>2017-07-12T00:37:55.000Z</published>
    <updated>2017-07-20T16:01:31.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scrappy框架学习"><a href="#Scrappy框架学习" class="headerlink" title="Scrappy框架学习"></a>Scrappy框架学习</h2><p>首先建议安装virtualenv，在env中进行操作。</p>
<p><img src="http://odzl05jxx.bkt.clouddn.com/u=3180342558,2746910171&amp;fm=214&amp;gp=0.jpg?imageView2/2/w/600" alt=""></p>
<a id="more"></a>
<p>pip install Scrappy 报错</p>
<h1 id="error-Microsoft-Visual-C-14-0-is-required-Get-it-with-“Microsoft-Visual-C-Build-Tools”-http-landinghub-visualstudio-com-visual-cpp-build-tools"><a href="#error-Microsoft-Visual-C-14-0-is-required-Get-it-with-“Microsoft-Visual-C-Build-Tools”-http-landinghub-visualstudio-com-visual-cpp-build-tools" class="headerlink" title="error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”: http://landinghub.visualstudio.com/visual-cpp-build-tools"></a>error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”: <a href="http://landinghub.visualstudio.com/visual-cpp-build-tools">http://landinghub.visualstudio.com/visual-cpp-build-tools</a></h1><p>解决办法是安装vs,4个GB左右。。。。</p>
<p>以下开始在命令行中操作：<br>安装完毕后，首先创建scrapy 项目</p>
<blockquote>
<p>scrapy startproject tutorial #创建一个project。会生成一个tutorial的文件夹，在tutorial/spiders文件夹中新建一个quotes_spider.py</p>
</blockquote>
<p>参考<a href="http://cuiqingcai.com/3952.html/2">Scrapy教程</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"quotes"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></div><div class="line">        urls = [</div><div class="line">            <span class="string">'http://quotes.toscrape.com/page/1/'</span>,</div><div class="line">            <span class="string">'http://quotes.toscrape.com/page/2/'</span>,</div><div class="line">        ]</div><div class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</div><div class="line">            <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse) </div><div class="line">     <span class="comment">#这个callback就是response拉下来之后的解析过程 </span></div><div class="line">     <span class="comment">#下面的这个做法只是把response写到一个文件中，通常还可以使用css或者xpath解析获得相应值。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        page = response.url.split(<span class="string">"/"</span>)[<span class="number">-2</span>]</div><div class="line">        filename = <span class="string">'quotes-%s.html'</span> % page</div><div class="line">        <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(response.body)</div><div class="line">        self.log(<span class="string">'Saved file %s'</span> % filename)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>scrapy crawl quotes #开始爬quotes.toscrape.com的内容,需要切换到tutorial文件夹下</p>
<p>scrapy shell ‘<a href="http://quotes.toscrape.com/page/1/">http://quotes.toscrape.com/page/1/</a>‘ #从Response中提取所需的值  </p>
</blockquote>
<p>输入就能得到大致这样的交互<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; response.css(&apos;title::text&apos;).extract()</div><div class="line">[&apos;Quotes to Scrape&apos;]</div></pre></td></tr></table></figure></p>
<p>由于没有安装vc2014，只能在virtualenv中运行,pycharm中也是显示scrapy没有安装。只能用命令行运行。想要看具体的值需要这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>response.css(<span class="string">'title::text'</span>).extract_first()</div><div class="line"><span class="string">'Quotes to Scrape'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>response.css(<span class="string">'title::text'</span>).re(<span class="string">r'Quotes.*'</span>) <span class="comment">#这里是正则了</span></div><div class="line">[<span class="string">'Quotes to Scrape'</span>]</div><div class="line"></div><div class="line"><span class="comment">#或者使用xpath</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>response.xpath(<span class="string">'//title/text()'</span>).extract_first()</div><div class="line"><span class="string">'Quotes to Scrape'</span></div></pre></td></tr></table></figure></p>
<p>处理登录请求，afterLogin<br>网站登录多数需要提交一个表单（Dict）</p>
<blockquote>
<p>formadata = {‘userName’:  ‘Bob’,’pwd’：123456}<br>中间件(MiddleWare)的作用<br>Cookie，UserAgent处理 setting.py中设置需要的参数，Cookie默认是接受的<br>PipeLine是用来持久化的，中间件用于处理Cookie,Ajax等，rules用于筛选需要跟进的url</p>
</blockquote>
<h2 id="2-MongoDB存储"><a href="#2-MongoDB存储" class="headerlink" title="2. MongoDB存储"></a>2. MongoDB存储</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Scrappy框架学习&quot;&gt;&lt;a href=&quot;#Scrappy框架学习&quot; class=&quot;headerlink&quot; title=&quot;Scrappy框架学习&quot;&gt;&lt;/a&gt;Scrappy框架学习&lt;/h2&gt;&lt;p&gt;首先建议安装virtualenv，在env中进行操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/u=3180342558,2746910171&amp;amp;fm=214&amp;amp;gp=0.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://haldir65.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Fragment源码解析记录(supportLibrary 25.3.0)</title>
    <link href="https://haldir65.github.io/2017/07/12/2017-07-12-fragment-decoded/"/>
    <id>https://haldir65.github.io/2017/07/12/2017-07-12-fragment-decoded/</id>
    <published>2017-07-12T00:37:23.000Z</published>
    <updated>2017-07-20T15:19:39.775Z</updated>
    
    <content type="html"><![CDATA[<p>We been told Fragment itself should only trust official docs, the implementation detail are prone to any change any time, don’t count on it!<br><img src="http://odzl05jxx.bkt.clouddn.com/2009528111321773591934.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<p>Fragment源码解析（support Library 25.3.0），不要以为看了源码就可以不鸟官方文档了，源码的内容经常变，只有官方的文档才是可靠的，谷歌保证会实现的效果。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Fragment的核心类有这几个:</p>
<blockquote>
<p>FragmentManager, FragmentTransaction, Fragment。而事实上前两个都是抽象类，<br>FragmentManager的实现类是FragmentManagerImpl，FragmentTransaction的实现类是BackStackRecord</p>
</blockquote>
<p>从日常使用Fragment的方式开始:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">((FragmentActivity) mActivity).getSupportFragmentManager()</div><div class="line">                    .beginTransaction().add(R.id.containerViewId,fragment).commit();</div></pre></td></tr></table></figure></p>
<h3 id="2-FragmentTransaction只是将动作添加到一个队列中了"><a href="#2-FragmentTransaction只是将动作添加到一个队列中了" class="headerlink" title="2.FragmentTransaction只是将动作添加到一个队列中了"></a>2.FragmentTransaction只是将动作添加到一个队列中了</h3><p>beginTransaction获取了一个FragmentTransaction实例，来看add方法的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(Fragment fragment, String tag)</span> </span>&#123;</div><div class="line">    doAddOp(<span class="number">0</span>, fragment, tag, OP_ADD);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment)</span> </span>&#123;</div><div class="line">    doAddOp(containerViewId, fragment, <span class="keyword">null</span>, OP_ADD);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</div><div class="line">    doAddOp(containerViewId, fragment, tag, OP_ADD);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不管是通过id还是Tag添加，都是调用同一个方法，传参不同而已<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</div><div class="line"><span class="comment">//省略部分代码</span></div><div class="line">    fragment.mFragmentManager = mManager;</div><div class="line">    <span class="keyword">if</span> (tag != <span class="keyword">null</span>) &#123;</div><div class="line">        fragment.mTag = tag;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//注意，进入这个方法的时候fragment已经实例化了，只是其中的回调方法还没有开始调用</span></div><div class="line">    <span class="keyword">if</span> (containerViewId != <span class="number">0</span>) &#123;</div><div class="line">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Op op = <span class="keyword">new</span> Op();</div><div class="line">    op.cmd = opcmd; <span class="comment">//这个cmd很重要，代表了是show、hide、add、remove等这些东西</span></div><div class="line">    op.fragment = fragment;</div><div class="line">    addOp(op);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//所有可能的操作细节都包含在这里面了。注意，这是线性的！</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_NULL = <span class="number">0</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ADD = <span class="number">1</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_REPLACE = <span class="number">2</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_REMOVE = <span class="number">3</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_HIDE = <span class="number">4</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_SHOW = <span class="number">5</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_DETACH = <span class="number">6</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ATTACH = <span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="comment">//这个OP包装了了每一次操作的具体细节。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cmd;</div><div class="line">    Fragment fragment;</div><div class="line">    <span class="keyword">int</span> enterAnim;</div><div class="line">    <span class="keyword">int</span> exitAnim;</div><div class="line">    <span class="keyword">int</span> popEnterAnim;</div><div class="line">    <span class="keyword">int</span> popExitAnim;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</div><div class="line">    mOps.add(op); <span class="comment">//往一个普通的ArrayList中添加一个op</span></div><div class="line">    op.enterAnim = mEnterAnim;</div><div class="line">    op.exitAnim = mExitAnim;</div><div class="line">    op.popEnterAnim = mPopEnterAnim;</div><div class="line">    op.popExitAnim = mPopExitAnim;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-通过FragmentTransaction-commit执行操作"><a href="#3-通过FragmentTransaction-commit执行操作" class="headerlink" title="3.通过FragmentTransaction.commit执行操作"></a>3.通过FragmentTransaction.commit执行操作</h2><p>FragmentFransaction只是将所有操作保留到一次Transaction的一个任务队列(ArrayList)中了。真正的执行需要提交事务，这和数据库的事务很像。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> commitInternal(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commitAllowingStateLoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> commitInternal(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//上面两个函数的返回值 Returns the identifier of this transaction's back stack entry, if addToBackStack(String)&#125; had been called.  Otherwise, returns a negative number. 如果调用过addToBackStack的话，返回这次操作在操作栈上的标识符。否则返回负数。</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mCommitted) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</div><div class="line">        <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) &#123;</div><div class="line">            Log.v(TAG, <span class="string">"Commit: "</span> + <span class="keyword">this</span>);</div><div class="line">            LogWriter logw = <span class="keyword">new</span> LogWriter(TAG);</div><div class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(logw);</div><div class="line">            dump(<span class="string">"  "</span>, <span class="keyword">null</span>, pw, <span class="keyword">null</span>);</div><div class="line">            pw.close();</div><div class="line">        &#125;</div><div class="line">        mCommitted = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (mAddToBackStack) &#123;<span class="comment">//如果调用过addToBackStack，这个值就为true，否则为false</span></div><div class="line">            mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);<span class="comment">// 将BackStackRecord添加到一个ArrayList的尾部，List不存在则创建</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mIndex = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss); <span class="comment">// 这里就是调用FragmnetManager的方法，添加到FragmentManager的mPendingActions中，并scheduleCommit（通过FragmnetHostCallBack往主线程post一条runnable）</span></div><div class="line">        <span class="keyword">return</span> mIndex; <span class="comment">//返回的就是本次事务的mIndex</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">       <span class="comment">// FragmentManagerImpl</span></div><div class="line">      <span class="comment">/**这里就是被推送到主线程的runnable，注意，这里是异步的</div><div class="line">     * Only call from main thread!</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execPendingActions</span><span class="params">()</span> </span>&#123;</div><div class="line">        ensureExecReady(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//这里就是不断的从mPendingAction中查找待执行的操作</span></div><div class="line">        <span class="keyword">while</span> (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123;</div><div class="line">            mExecutingActions = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                optimizeAndExecuteOps(mTmpRecords, mTmpIsPop); <span class="comment">//从方法名大致能猜到这里是执行操作的地方,两个参数，第一个是待执行的操作的List，一个是对应每项操作是pop还push(出栈还是入栈)</span></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                cleanupExec();</div><div class="line">            &#125;</div><div class="line">            didSomething = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        doPendingDeferredStart();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> didSomething;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">optimizeAndExecuteOps</span><span class="params">(ArrayList&lt;BackStackRecord&gt; records,</div><div class="line">            ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">随后调用了executeOpsTogether方法，接着调用</div><div class="line">        executeOps(records, isRecordPop, startIndex, endIndex);</div><div class="line">最终又走到了BackStackRecord的方法里面</div><div class="line"></div><div class="line">   <span class="comment">/**</div><div class="line">     * Reverses the execution of the operations within this transaction. The Fragment states will</div><div class="line">     * only be modified if optimizations are not allowed.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> moveToState &#123;<span class="doctag">@code</span> true&#125; if added fragments should be moved to their final state</div><div class="line">     *                    in unoptimized transactions</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executePopOps</span><span class="params">(<span class="keyword">boolean</span> moveToState)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> opNum = mOps.size() - <span class="number">1</span>; opNum &gt;= <span class="number">0</span>; opNum--) &#123; <span class="comment">//倒序执行,每一个ops包含了对一个Fragment的指令，遍历所有的ops</span></div><div class="line">            <span class="keyword">final</span> Op op = mOps.get(opNum);</div><div class="line">            Fragment f = op.fragment;</div><div class="line">            f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition), mTransitionStyle);</div><div class="line">            <span class="keyword">switch</span> (op.cmd) &#123;</div><div class="line">                <span class="comment">//这些操作全部只是设置一些变量的值，暂时还没到UI更改，具体的UI操作在moveToState里面</span></div><div class="line">                <span class="keyword">case</span> OP_ADD:</div><div class="line">                    f.setNextAnim(op.popExitAnim);</div><div class="line">                    mManager.removeFragment(f);  <span class="comment">//从FragmentManager的mAdded中移除该fragment，fragment的mAdded = false,mRemoving = true;</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> OP_REMOVE:</div><div class="line">                    f.setNextAnim(op.popEnterAnim);</div><div class="line">                    mManager.addFragment(f, <span class="keyword">false</span>);</div><div class="line">                    <span class="comment">/** addFragment里面有这么一段  </div><div class="line">       if (mAdded.contains(fragment)) &#123;</div><div class="line">                throw new IllegalStateException("Fragment already added: " + fragment); //就是简单的判断下List中是否存在，如果在一个Fragment已经added的情况下再去add，就会出现这种错误</div><div class="line">            &#125;**/</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> OP_HIDE:</div><div class="line">                    f.setNextAnim(op.popEnterAnim);</div><div class="line">                    mManager.showFragment(f);</div><div class="line">                    <span class="comment">// 只是将fragment的mHidden设置为false了</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> OP_SHOW:</div><div class="line">                    f.setNextAnim(op.popExitAnim);</div><div class="line">                    mManager.hideFragment(f);</div><div class="line">                    <span class="comment">// 只是将fragment的mHidden设置为true了</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> OP_DETACH:</div><div class="line">                    f.setNextAnim(op.popEnterAnim);</div><div class="line">                    mManager.attachFragment(f);</div><div class="line">                    <span class="comment">//和attach差不多，也是设定了一些标志位</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> OP_ATTACH:</div><div class="line">                    f.setNextAnim(op.popExitAnim);</div><div class="line">                    mManager.detachFragment(f);</div><div class="line">                    <span class="comment">// mFragment.mDetached = false,这里判断了manager.mAdded.contains(mFragment)，会抛出异常Fragment already added!如果正常的话把mFragment添加到mAdded里面</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</div><div class="line">            &#125;</div><div class="line">           <span class="keyword">if</span> (!mAllowOptimization &amp;&amp; op.cmd != OP_ADD) &#123;</div><div class="line">                mManager.moveFragmentToExpectedState(f);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         <span class="keyword">if</span> (!mAllowOptimization) &#123;</div><div class="line">            <span class="comment">// Added fragments are added at the end to comply with prior behavior.</span></div><div class="line">            mManager.moveToState(mManager.mCurState, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>通常我们都是在主线程往Manager添加Transaction，不过从这里看来，添加Transaction只是添加了一份BackStackRecord，最终执行还是在主线程上做的。<br>很直观的看到这里 调用了manager的removeFragment、showFragment等方法.随便挑两个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FragmentManagerImpl.java</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(Fragment fragment, <span class="keyword">boolean</span> moveToStateNow)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mAdded == <span class="keyword">null</span>) &#123;</div><div class="line">            mAdded = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</div><div class="line">        &#125;</div><div class="line">        makeActive(fragment);</div><div class="line">        <span class="keyword">if</span> (!fragment.mDetached) &#123;</div><div class="line">            <span class="keyword">if</span> (mAdded.contains(fragment)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment already added: "</span> + fragment);</div><div class="line">            &#125;</div><div class="line">            mAdded.add(fragment);</div><div class="line">            fragment.mAdded = <span class="keyword">true</span>; <span class="comment">// 记得fragment.isAdded()方法吗，在这里被设置的</span></div><div class="line">            fragment.mRemoving = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (fragment.mView == <span class="keyword">null</span>) &#123;</div><div class="line">                fragment.mHiddenChanged = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</div><div class="line">                mNeedMenuInvalidate = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (moveToStateNow) &#123;</div><div class="line">                moveToState(fragment);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        <span class="comment">// show的方法异常简单</span></div><div class="line">       <span class="comment">/**</div><div class="line">     * Marks a fragment as shown to be later animated in with</div><div class="line">     * &#123;<span class="doctag">@link</span> #completeShowHideFragment(Fragment)&#125;.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> fragment The fragment to be shown.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(Fragment fragment)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fragment.mHidden) &#123;</div><div class="line">            fragment.mHidden = <span class="keyword">false</span>; <span class="comment">//这里只是设置一下标志位</span></div><div class="line">            <span class="comment">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></div><div class="line">            <span class="comment">// it doesn't go through the animation.</span></div><div class="line">            fragment.mHiddenChanged = !fragment.mHiddenChanged;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>接下里就是FragmentManager的MoveToState方法了，非常长<br>先记住Fragment的几个状态，这些都是Adam powell说过的，这是线性的，moveToState方法也是这样走的，不会跳过中间某个state</p>
<blockquote>
<p>  static final int INITIALIZING = 0;     // Not yet created.<br>    static final int CREATED = 1;          // Created.<br>    static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.<br>    static final int STOPPED = 3;          // Fully created, not started.<br>    static final int STARTED = 4;          // Created and started, not resumed.<br>    static final int RESUMED = 5;          // Created started and resumed.</p>
</blockquote>
<p>moveToState的方法比较长，删掉一些不必要的，重点关注Fragment的那些生命周期回调是什么时候被调用的。建议看源码，我这里删除了很多还有一大坨。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FragmentImpl.java</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(Fragment f, <span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitionStyle,</div><div class="line">            <span class="keyword">boolean</span> keepActive)</span> </span>&#123;</div><div class="line"><span class="comment">//Fragment的state将提高，例如从ACTIVITY_CREATED到ACTIVITYCREATED</span></div><div class="line">        <span class="keyword">if</span> (f.mState &lt; newState) &#123;</div><div class="line">            <span class="keyword">switch</span> (f.mState) &#123;</div><div class="line">                <span class="keyword">case</span> Fragment.INITIALIZING:<span class="comment">//尚未初始化</span></div><div class="line">                    <span class="keyword">if</span> (f.mSavedFragmentState != <span class="keyword">null</span>) &#123;</div><div class="line">                      <span class="comment">//从SavedState中获取各个View的状态，尝试恢复View的状态</span></div><div class="line">                    &#125;</div><div class="line">                    f.mHost = mHost; <span class="comment">//从这一刻开始,getActivity，getContext，isAdded等和Activity相关的方法都有正确的返回</span></div><div class="line"></div><div class="line">                    f.mCalled = <span class="keyword">false</span>; <span class="comment">//这个mCalled是为了避免子类忘记调用super方法的</span></div><div class="line">                    f.onAttach(mHost.getContext()); <span class="comment">// onAttach就是在这里调用的</span></div><div class="line">                    <span class="keyword">if</span> (f.mParentFragment == <span class="keyword">null</span>) &#123;</div><div class="line">                        mHost.onAttachFragment(f);<span class="comment">//mHost其实就是Activity</span></div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        f.mParentFragment.onAttachFragment(f); <span class="comment">//这个是ChildFragment的情况</span></div><div class="line">                    &#125;</div><div class="line">                    dispatchOnFragmentAttached(f, mHost.getContext(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                        f.performCreate(f.mSavedFragmentState); <span class="comment">//这里面调用了onCreate回调，同时STATE变成CREATED</span></div><div class="line">                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, <span class="keyword">false</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        f.restoreChildFragmentState(f.mSavedFragmentState);</div><div class="line">                        f.mState = Fragment.CREATED;</div><div class="line">                    &#125;</div><div class="line">                    f.mRetaining = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (f.mFromLayout) &#123;<span class="comment">//写在XML里面的，直接在从INITIALIZING到CREATED的过程中把performCreateView和onViewCreated走一遍</span></div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.CREATED:</div><div class="line">                    <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</div><div class="line">                        <span class="keyword">if</span> (!f.mFromLayout) &#123; <span class="comment">//不是写在xml标签中的Fragment</span></div><div class="line">                            ViewGroup container = <span class="keyword">null</span>;</div><div class="line">                            <span class="keyword">if</span> (f.mContainerId != <span class="number">0</span>) &#123;</div><div class="line">                                container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);</div><div class="line">                            &#125;</div><div class="line">                            f.mContainer = container;</div><div class="line">                            f.mView = f.performCreateView(f.getLayoutInflater(</div><div class="line">                                    f.mSavedFragmentState), container, f.mSavedFragmentState);<span class="comment">// onCreateView回调</span></div><div class="line">                            <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</div><div class="line">                                f.mInnerView = f.mView;</div><div class="line">                                <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">                                    container.addView(f.mView);<span class="comment">//所以Fragment本质上只是addView到Container里</span></div><div class="line">                                &#125;</div><div class="line">                                <span class="keyword">if</span> (f.mHidden) &#123; <span class="comment">//hide就只是设置Visibility这么简单，这mHdidden是在上面的showFragment里面设置的</span></div><div class="line">                                    f.mView.setVisibility(View.GONE);</div><div class="line">                                &#125;</div><div class="line">                                f.onViewCreated(f.mView, f.mSavedFragmentState);<span class="comment">// 又是回调,onViewCreated确实是在onCreatedView之后立马添加的</span></div><div class="line">                                dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,</div><div class="line">                                        <span class="keyword">false</span>);</div><div class="line">                                <span class="comment">// Only animate the view if it is visible. This is done after</span></div><div class="line">                                <span class="comment">// dispatchOnFragmentViewCreated in case visibility is changed</span></div><div class="line">                                f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)</div><div class="line">                                        &amp;&amp; f.mContainer != <span class="keyword">null</span>;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                f.mInnerView = <span class="keyword">null</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//随后马上就调用到了onActivityCreated了，同一个Message中</span></div><div class="line">                        f.performActivityCreated(f.mSavedFragmentState);</div><div class="line">                        dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, <span class="keyword">false</span>);</div><div class="line">                        <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</div><div class="line">                            f.restoreViewState(f.mSavedFragmentState);</div><div class="line">                        &#125;</div><div class="line">                        f.mSavedFragmentState = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</div><div class="line">                    <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</div><div class="line">                        f.mState = Fragment.STOPPED;</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.STOPPED:</div><div class="line">                    <span class="keyword">if</span> (newState &gt; Fragment.STOPPED) &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto STARTED: "</span> + f);</div><div class="line">                        f.performStart(); <span class="comment">//随后开始onStart</span></div><div class="line">                        dispatchOnFragmentStarted(f, <span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.STARTED:</div><div class="line">                    <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto RESUMED: "</span> + f);</div><div class="line">                        f.performResume(); <span class="comment">//onResume</span></div><div class="line">                        dispatchOnFragmentResumed(f, <span class="keyword">false</span>);</div><div class="line">                        f.mSavedFragmentState = <span class="keyword">null</span>;</div><div class="line">                        f.mSavedViewState = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123; <span class="comment">//Fragment的STATE降低</span></div><div class="line">            <span class="keyword">switch</span> (f.mState) &#123;</div><div class="line">                <span class="keyword">case</span> Fragment.RESUMED:</div><div class="line">                    <span class="keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;</div><div class="line">                        f.performPause(); <span class="comment">//onPause</span></div><div class="line">                        dispatchOnFragmentPaused(f, <span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.STARTED:</div><div class="line">                    <span class="keyword">if</span> (newState &lt; Fragment.STARTED) &#123;</div><div class="line">                        f.performStop();<span class="comment">//调用onStop,state变成STOPPED</span></div><div class="line">                        dispatchOnFragmentStopped(f, <span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.STOPPED:</div><div class="line">                    <span class="keyword">if</span> (newState &lt; Fragment.STOPPED) &#123;</div><div class="line">                        f.performReallyStop();<span class="comment">//不调用回调，状态变成ACTIVITY_CREATED</span></div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</div><div class="line">                    <span class="keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</div><div class="line">                        f.performDestroyView(); <span class="comment">//状态变成CREATED，调用onDestoryView。最后收尾调用                            f.mContainer.removeView(f.mView);//引用置空</span></div><div class="line">                        dispatchOnFragmentViewDestroyed(f, <span class="keyword">false</span>);</div><div class="line">                        <span class="keyword">if</span> (f.mView != <span class="keyword">null</span> &amp;&amp; f.mContainer != <span class="keyword">null</span>) &#123;</div><div class="line">                            f.mContainer.removeView(f.mView);</div><div class="line">                        &#125;</div><div class="line">                        f.mContainer = <span class="keyword">null</span>;</div><div class="line">                        f.mView = <span class="keyword">null</span>;</div><div class="line">                        f.mInnerView = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Fragment.CREATED:</div><div class="line">                    <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</div><div class="line">                            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom CREATED: "</span> + f);</div><div class="line">                            <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                                f.performDestroy();</div><div class="line">                                dispatchOnFragmentDestroyed(f, <span class="keyword">false</span>);</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                f.mState = Fragment.INITIALIZING;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            f.performDetach();</div><div class="line">                            dispatchOnFragmentDetached(f, <span class="keyword">false</span>);</div><div class="line">                            <span class="keyword">if</span> (!keepActive) &#123;</div><div class="line">                                <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                                    makeInactive(f);</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    f.mHost = <span class="keyword">null</span>; <span class="comment">//Fragment可以在Activity挂了之后接着存在，这里只是避免内存泄漏，那个方法叫做setRetainState好像</span></div><div class="line">                                    f.mParentFragment = <span class="keyword">null</span>;</div><div class="line">                                    f.mFragmentManager = <span class="keyword">null</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>moveToState的方法很长，基本上可以分为state升高和state降低来看：</p>
<ol>
<li>state升高的过程中：<ul>
<li>onAttach是第一个回调，这里面给Fragment的mHost赋值；(响应Fragment.CREATED信号)</li>
<li>onCreateView,onViewCreated是在一个方法里进行的，本质上调用的是mContainer.addView方法。随后立即调用onActivityCreated方法(响应Fragment.ACTIVITY_CREATED方法)</li>
<li>onStart是第三个回调，onStart文档明确表示该方法调用时Fragment已经对用户可见。文档同时说明该方法和Activity的onStart方法挂钩，原理是FragmentActivity的onStart中调用了mFragments.dispatchStart()方法。</li>
</ul>
</li>
<li>Fragment和Activity生命周期挂钩<ul>
<li>FragmentActivity的onCreate中调用了FragmentManager的dispatchCreate方法，发出Fragment.CREATED信号</li>
<li>FragmentActivity的onStart中先调用了dispatchActivityCreated方法（发出ACTIVITY_CREATED信号），随后调用dispatchStart（发出Fragment.STARTED信号）</li>
<li>FragmentActivity的onResume中用Handler发送了一个Message，对应mFragments.dispatchResume(Fragment.RESUMED信号);FragmentActivity的onPostResume中也调用了dispatchResume方法，不过moveToState方法最后已经判断了newState&gt; currentState。</li>
<li>onPause和onStop和onDestoryView也差不多。注意，DestoryView实质只是将Fragment的mView从container中移除，设置mView为null，mContainer为null;onDestory先于onDetach调用</li>
</ul>
</li>
<li>FragmentActivity中的dispatchActivityCreated和dispatchFragmentStarted写在一个方法里，区别是onActivityCreated先于onStart调用且只会被调用一次。所以onActivityCreated存在的意义不过是为了帮助区分是初次start还是后面多次的start（Activity的onStart会被多次调用）</li>
<li>state降低的过程其实也差不多，我也懒得分析了。之前以为detach和attch方法很特殊，其实只是从FragmentManager的mAdded中移除该Fragment，并设置fragment.mAdded = false.</li>
<li>从一个state到另一个state基本的步骤就是fragment.performXXX，然后dispatchXXX，这里面顺手把state设置一下</li>
</ol>
<p>FragmentManager的核心方法应该就是这个moveToState方法了。到此，commit分析结束。说一下几个不建议使用的方法<br><strong>executePendingTransactions</strong> 看了下，这个方法里面没有异步方法，别的就不清楚了。据说是将所有的Transaction全部执行掉，首先这里面有一大堆操作，会堵住主线程，其次，这个方法里面涉及到各个状态的判断，很混乱。</p>
<p><strong>commitAllowingStateLoss</strong> 这个方法和commit的唯一区别是调用一个可能会抛出异常的方法，后面还是post了一个pendingAction,还是异步的。所以很多人纷纷调用commitAllowingStateLoss方法。然而，这个方法存在是有其意义的。安卓本身就是个异步的系统。Activity的onSaveInstanceState随时可能会被调用，调用之后所有有id的View的onSaveInstanceState都被调用了。这个时候再去尝试做任何操作都可能会重新对已经保存了状态的View造成影响。Activity重新恢复的时候会把saveState中的的UI快照恢复，这一次的操作就会造成恢复的时候不是保存时的效果.allowStateLoss的字面意思很清楚了，就是系统不保证此后View的状态能够正确被恢复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateLoss</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mStateSaved) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                   <span class="string">"Can not perform this action after onSaveInstanceState"</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (mNoTransactionsBecause != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                   <span class="string">"Can not perform this action inside of "</span> + mNoTransactionsBecause);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>commitNow</strong> 注意24.2 之后Google添加了一个单独的commitNow方法，这一点Adam Powell在2016年的IO上特别提到过。<br>内部执行了mTmpRecords(临时操作)，由于只是一项操作，外加里面还对这一次操作进行了优化，所以直接同步执行了。该方法不允许addToBackStack，因为这实质上等同于在所有pendingAction中插队。由于是同步执行，该方法保证方法返回之后，所有的Fragment都能处于所预期的state。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitNow</span><span class="params">()</span> </span>&#123;</div><div class="line">       disallowAddToBackStack();</div><div class="line">       mManager.execSingleAction(<span class="keyword">this</span>, <span class="keyword">false</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitNowAllowingStateLoss</span><span class="params">()</span> </span>&#123;</div><div class="line">     disallowAddToBackStack();</div><div class="line">     mManager.execSingleAction(<span class="keyword">this</span>, <span class="keyword">true</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><strong>commitNowAllowingStateLoss</strong> 和commitAllowingStateLoss一样的道理，开发者可能不经意在Activity保存了状态之后调用该方法，这违背了状态保存和恢复的原则。但还是开了个后门，前提是不保证UI恢复的时候出现非预期的表现。allowStateLoss的方法照说不应该调用，如果不调用这个方法的话，使用commitNow，而不是commit + executePendingTransactions。 同时，commitNow之前检查下mStateSaved是否是true,具体来说Activity的onStop和onSaveInstanceState调用之后这个值都会为true。</p>
<p>关于Activity的onSaveInstanceState什么时候会调用，找到比较好的<a href="http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html">解释</a>。 记住，旋转屏幕的时候一定会调用的。</p>
<h2 id="4-现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter"><a href="#4-现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter" class="headerlink" title="4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter"></a>4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter</h2><p>这两个类行数都不超过300行，非常简单，只是通过调用FragmentManager的相应方法实现展示View的功能。</p>
<h2 id="5-Fragment的一些不常用的API"><a href="#5-Fragment的一些不常用的API" class="headerlink" title="5. Fragment的一些不常用的API"></a>5. Fragment的一些不常用的API</h2><p>attach,detach,FragmentLifecycleCallbacks,commitNow，setAllowOptimization(26.0.0又被deprecated了)<br>onCreateView这个名字是怎么来的，其实是在dispatchFragmentsOnCreateView里面调用的。Activity实现了onCreateView(LayoutInflater定义的，会在getSytemService返回LayoutInflater时调用，获取系统服务毕竟是一个异步过程)。</p>
<h2 id="6-关于Glide是如何实现生命周期绑定的"><a href="#6-关于Glide是如何实现生命周期绑定的" class="headerlink" title="6. 关于Glide是如何实现生命周期绑定的"></a>6. 关于Glide是如何实现生命周期绑定的</h2><p>Fragment本身提供了生命周期监听回调<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">registerFragmentLifecycleCallbacks <span class="number">25.1</span>.0</div><div class="line">unregisterFragmentLifecycleCallbacks <span class="number">25.1</span>.0</div><div class="line"></div><div class="line">addOnBackStackChangedListener <span class="number">22.2</span>.0</div><div class="line">removeOnBackStackChangedListener <span class="number">22.2</span>.0</div></pre></td></tr></table></figure></p>
<p>Glide的做法是写了一个<strong>SupportRequestManagerFragment</strong> 在这个Fragment的构造函数里放了一个ActivityFragmentLifecycle<br> <a href="http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD">参考</a><br> 在这个Fragment的onStart，OnStop等方法里面调用该lifeCycle的onStart,onStop等回调(lifeCycle是接口，由RequestManager实现)<br> 关键代码<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</div><div class="line">               current = <span class="keyword">new</span> RequestManagerFragment();</div><div class="line">               pendingRequestManagerFragments.put(fm, current);</div><div class="line">               fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class="line">               handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class="line">           &#125;</div></pre></td></tr></table></figure></p>
<p> 所以经常会在Debug的时候看到FragmentManager里面有个”com.bumptech.glide.manager”的Fragment。这个Fragemnt没有实现onCreateView，所以直接返回null。Fragment本身是可以不带View的。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>Fragment的一些生命周期还是需要跟Activity的生命周期一起看，大部分是异步操作。FragmentManager类似一个管理者，也是一个容器，在Activity的生命周期中顺手实现了容器中元素所要求的UI状态。Fragment本质上是一个View的Controllers，通过FragmentManger和FragmentActivity的生命周期挂钩，并自动做好View的状态保存和恢复。具体的UI展示无非是addView，setVisibility等常规的方法，也正因为这样，support包里的Fragment才能做到3.0以下的适配。日常开发中，Fragment能够将原本堆在Activity中的逻辑承载过来,以异步的方式减轻主线程的压力，对外提供了获取(onViewCreated)，操作(Transaction)，销毁(onDestoryView)这些业务对象的回调方法。由于Android本身就是异步的系统，系统随时(asynchronous)可能会对Fragment的资源进行更改，开发者的代码也随时(asynchronous)会对这些资源进行操作。由于存在这种无法改变的’并发’现状，Fragment不得不为保证资源的一致性而主动抛出一些错误。本文有意忽略掉了一些transition动画(使用了hardwareLayer)和Loader加载的细节，希望能够对日常开发有点帮助。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://stackoverflow.com/questions/9156406/whats-the-difference-between-detaching-a-fragment-and-removing-it">Fragment的onAttach和onDetach什么时候会调用</a></li>
<li><a href="http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD">Glide是怎么跟生命周期挂钩的</a></li>
<li><a href="http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html">Activity的onSaveInstanceState什么时候会调用</a></li>
<li><a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html">Activity-LifeCycle</a></li>
<li><a href="https://developer.android.com/guide/components/fragments.html">Fragments文档</a>不要依赖Implementation Detail,源码随时会变，官方的文档才是值得依赖的。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;We been told Fragment itself should only trust official docs, the implementation detail are prone to any change any time, don’t count on it!&lt;br&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/2009528111321773591934.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://haldir65.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码阅读笔记</title>
    <link href="https://haldir65.github.io/2017/07/01/2017-07-01-it-began-with-a-few-bits/"/>
    <id>https://haldir65.github.io/2017/07/01/2017-07-01-it-began-with-a-few-bits/</id>
    <published>2017-07-01T15:03:00.000Z</published>
    <updated>2017-07-23T10:43:10.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="This-is-gonna-be-nasty……-TL-DR"><a href="#This-is-gonna-be-nasty……-TL-DR" class="headerlink" title="This is gonna be nasty…… TL;DR"></a>This is gonna be nasty…… TL;DR</h3><p><img src="http://odzl05jxx.bkt.clouddn.com/d653491fb55bec754b8471aa6a3f6eed.jpg?imageView2/2/w/600" alt=""></p>
<a id="more"></a>
<h3 id="1-Retrofit"><a href="#1-Retrofit" class="headerlink" title="1. Retrofit"></a>1. Retrofit</h3><h4 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h4><p>Retrofit本身并不局限于Andriod平台，java应用也可以用来和服务器沟通。<br>Retrofit一般的用法看上去很简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</div><div class="line">        <span class="meta">@Path</span>(<span class="string">"owner"</span>) String owner,</div><div class="line">        <span class="meta">@Path</span>(<span class="string">"repo"</span>) String repo);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">        .baseUrl(API_URL)   <span class="comment">// end_point</span></div><div class="line">        .addConverterFactory(GsonConverterFactory.create())</div><div class="line">        .build();</div><div class="line"></div><div class="line">    <span class="comment">// Create an instance of our GitHub API interface.</span></div><div class="line">    GitHub github = retrofit.create(GitHub.class);</div><div class="line"></div><div class="line">    <span class="comment">// Create a call instance for looking up Retrofit contributors.</span></div><div class="line">    Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class="string">"square"</span>, <span class="string">"retrofit"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Fetch and print a list of the contributors to the library.</span></div><div class="line">    List&lt;Contributor&gt; contributors = call.execute().body();</div><div class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</div><div class="line">      System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>关键来看这段 retroft.create ,重点都在这里面。关键的代码就在这三行里面了</p>
<blockquote>
<p>ServiceMethod serviceMethod = loadServiceMethod(method);<br>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);<br>return serviceMethod.callAdapter.adapt(okHttpCall);</p>
</blockquote>
<h3 id="1-2-第一个方法以及ServiceMethod的创建"><a href="#1-2-第一个方法以及ServiceMethod的创建" class="headerlink" title="1.2 第一个方法以及ServiceMethod的创建"></a>1.2 第一个方法以及ServiceMethod的创建</h3><p>loadServiceMethod(Method)会查找invoke的时候会查找methodCache中有没有这个方法，没有的话调用Builder方法创建一个ServiceMethod实例并放入cahce。看一看这个Builder的构造函数 ，基本上就是把Builder中的参数引用赋值给ServiceMethod实例。</p>
<p>result = new ServiceMethod.Builder(this, method).build();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>.retrofit = retrofit; <span class="comment">//client创建retrofit时可以设定一些属性</span></div><div class="line">     <span class="keyword">this</span>.method = method;</div><div class="line">     <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</div><div class="line">     <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class="line">     <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">根据ServiceMethod的变量名基本上能够猜到各自的用处，比如httpMethod（GET、POST）,</div><div class="line">contentType（MimeType）</div><div class="line"> <span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 1.创建callAdapter,调用retrofit对象设定的callAdapter,例如RxjavAdapter,注意这里面的实现是便利retrofit对象的adapterFactories，找到一个就返回。找不到的话会丢出来一个IllegalArgumentException</span></div><div class="line">      callAdapter = createCallAdapter();</div><div class="line">       <span class="comment">//callAdapter的作用 就是将retrofit.Call的Call转成一个T。例如上面就是把Call&lt;List&lt;Contributor&gt;&gt;转成一个List&lt;Contributor&gt;，这个过程是上面提到的最重要的三个方法中的第三部 adapt（okHttpCall）。可以认为是拿着一个已经创建好的okHttp的Call去做事情，在适当的时候将网络返回结果转成用户事先定义好的respose类型。</span></div><div class="line">        <span class="comment">//这一步返回一个java.lang.reflect.Type ，就个class的基本作用家就是根据泛型来确定response的class。</span></div><div class="line">      responseType = callAdapter.responseType();</div><div class="line">        <span class="comment">//2.创建用于respnse和Request的converter。</span></div><div class="line">      responseConverter = createResponseConverter();</div><div class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation); <span class="comment">//这里面就是把@GET变成"GET"这个String，表示当前方法是一个GET请求</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">      <span class="comment">//3.创建ParameterHandler</span></div><div class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">        Type parameterType = parameterTypes[p];</div><div class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line">        <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</div><div class="line">        &#125;</div><div class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">        <span class="comment">//关键看这个方法</span></div><div class="line">         <span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameter(<span class="keyword">int</span> p, Type parameterType, Annotation[] annotations)</div><div class="line">         第一个参数表示当前的数组index</div><div class="line">         第二个参数表示想要的Response类型</div><div class="line">         第三个参数表示该方法上的注解，就是@那些东西</div><div class="line">         接下来就是调用 <span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameterAnnotation(</div><div class="line">        <span class="keyword">int</span> p, Type type, Annotation[] annotations, Annotation annotation)方法来判断各种Http方法，这一段代码有<span class="number">300</span>多行。。。。看完有助于掌握Http协议。</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键是这三个方法，Buider在这个过程中完成了一些变量的赋值<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">1. createCallAdapter  ---&gt;  retrofit.callAdapter(returnType, annotations); 从adapterFactories(显然可以有多个)中遍历，找到了一个就返回。已经实现的的有三种**策略**，DefaultCallAdapterFactory、ExecutorCallAdapterFactory和RxjavaCallAdapterFactory。显然用户可以在创建retrofit实例的过程中install自己的callAdapter实现。</div><div class="line">再次强调这个CallAdater的作用，就是将Retrofit的Call adpt成对应的Response class的实例。</div><div class="line"></div><div class="line">2. createResponseConverter ---&gt;  retrofit.responseBodyConverter(responseType, annotations);</div><div class="line">Retrofit2.Converter&lt;F, T&gt; (from和To，我猜的)</div><div class="line"></div><div class="line">Convert objects to and from their representation in HTTP. Instances are created by &#123;@linkplain</div><div class="line"> * Factory a factory&#125; which is &#123;@linkplain Retrofit.Builder#addConverterFactory(Factory) installed&#125;</div><div class="line"> * into the &#123;@link Retrofit&#125; instance.</div><div class="line"></div><div class="line">从retrofit对象的converterFactories（可以有多个，原因在于server有时候会返回json，有时候会返回protocolBuffer，有时候返回xml，response回来的时候会一个个问，这一点jake Wharton多次提到过）中遍历，找到一个就返回。确切的说，是找到一个能够处理的。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">3. 创建parameterHandlers</div><div class="line">应该可以猜到，这一步就是把用户定义的注解转换成发起网络请求时需要带上的参数</div><div class="line">private ParameterHandler&lt;?&gt; parseParameterAnnotation(</div><div class="line">        int p, Type type, Annotation[] annotations, Annotation annotation)方法随便展开一点，关注第三个参数和第四个参数</div><div class="line"></div><div class="line">例如        </div><div class="line"> public interface GitHub &#123;</div><div class="line">    @GET("/repos/&#123;owner&#125;/&#123;repo&#125;/contributors")</div><div class="line">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</div><div class="line">        @Path("owner") String owner,</div><div class="line">        @Path("repo") String repo);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">ServiceMethod走到这一步，annotations就表示 @Path("owner") String owner。注意这里的@PATH是注解类，可以把它当成一个wrapper，这里面就调用了path.value()。</div><div class="line"></div><div class="line">else if (annotation instanceof Path) &#123;</div><div class="line">        Path path = (Path) annotation;</div><div class="line">        String name = path.value(); // 调用该方法时传入的String</div><div class="line">        validatePathName(p, name);</div><div class="line">        Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations);  </div><div class="line">        return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded());</div><div class="line">      &#125;</div><div class="line">ParameterHandler.Path&lt;&gt;在ParameterHandler这个类里面，看一下结构![](http://odzl05jxx.bkt.clouddn.com/ParameterHandlers.JPG)</div><div class="line">Path这个class中关键的方法apply:</div><div class="line"> @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException &#123;</div><div class="line">      builder.addPathParam(name, valueConverter.convert(value), encoded);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">再往下走：</div><div class="line">    relativeUrl = relativeUrl.replace("&#123;" + name + "&#125;", canonicalizeForPath(value, encoded));</div><div class="line">apply这个方法会在构建Request时由RequestBilder调用，以上面的实例为例子，name就是"owner" ,value就是调用该方法时传进来的值，其实就只是Stirng.replace()方法。</div><div class="line">到这里，Buidler已经完成了</div><div class="line">- 准备callAdapter，</div><div class="line">- createResponseConverter</div><div class="line">- 和填充parameterHandlers数组的任务</div><div class="line">直接new一个ServiceMethod出来就好了</div><div class="line"></div><div class="line">ServiceMethod(Builder&lt;T&gt; builder) &#123;</div><div class="line">    this.callFactory = builder.retrofit.callFactory();  // okhttp3.Call.Factory</div><div class="line">    this.callAdapter = builder.callAdapter; //</div><div class="line">    this.baseUrl = builder.retrofit.baseUrl(); //这个就是</div><div class="line">    this.responseConverter = builder.responseConverter; // GsonConverter</div><div class="line">    this.httpMethod = builder.httpMethod; //@GET</div><div class="line">    this.relativeUrl = builder.relativeUrl; //@Path</div><div class="line">    this.headers = builder.headers; //@Header</div><div class="line">    this.contentType = builder.contentType;  //application/json这种</div><div class="line">    this.hasBody = builder.hasBody;</div><div class="line">    this.isFormEncoded = builder.isFormEncoded;</div><div class="line">    this.isMultipart = builder.isMultipart;</div><div class="line">    this.parameterHandlers = builder.parameterHandlers;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">上面最重要的三个方法讲完了第一个。</div></pre></td></tr></table></figure></p>
<h3 id="1-3-第二个方法和OkHttpCall"><a href="#1-3-第二个方法和OkHttpCall" class="headerlink" title="1.3 第二个方法和OkHttpCall"></a>1.3 第二个方法和OkHttpCall</h3><p>第二个方法:<br> OkHttpCall<Object> okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</p>
<p>OkHttpCall的成员变量：<br>okhttp3.Call rawCall //用于发起请求<br>ServiceMethod<T, ?> serviceMethod;  //这就是刚才实例化的serviceMethod对象<br>这个类相对简单，主要看execute方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   okhttp3.Call call;</div><div class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">     <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</div><div class="line">     executed = <span class="keyword">true</span>;</div><div class="line">     call = rawCall;</div><div class="line">     <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">         call = rawCall = createRawCall();</div><div class="line">       &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> parseResponse(call.execute()); <span class="comment">//建立连接，发起请求，解析response都在这里了（都在一条线程上）。execute是okHttp的方法。</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>还记得最简单的Demo吗，同步执行网络请求<br>Call<List<Contributor>&gt; call = github.contributors(“square”, “retrofit”);<br>List<Contributor> contributors = call.execute().body();<br>这也是Retrofit2.Call.execute方法最终就是走到了这里</p>
<p>createRawCall方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">okhttp3.Request request = serviceMethod.toRequest(args);</div><div class="line">okhttp3.Call call = serviceMethod.callFactory.newCall(request);</div><div class="line">   <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> call;</div></pre></td></tr></table></figure></p>
<p>parseRespnse的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  ResponseBody rawBody = rawResponse.body(); <span class="comment">//有用的信息在这里</span></div><div class="line">  <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></div><div class="line">  rawResponse = rawResponse.newBuilder()</div><div class="line">      .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class="line">      .build(); <span class="comment">//根据服务器返回的contentType和contentLength创建一个新的response用于检测200</span></div><div class="line"></div><div class="line">  <span class="keyword">int</span> code = rawResponse.code();</div><div class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></div><div class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</div><div class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse); <span class="comment">//创建一个body为null的Retrofit2.Response</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      rawBody.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</div><div class="line">    rawBody.close();</div><div class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    T body = serviceMethod.toResponse(catchingBody); <span class="comment">//调用ServiceMethod的responseConverter去转换，前面说过，responseConverter是在builder初始化的时候根据策略，从Retrofit的converterFactories中遍历，找到了就返回。</span></div><div class="line">    <span class="keyword">return</span> Response.success(body, rawResponse); <span class="comment">//返回创建一个body为定义好的数据类型的Retrofit2.Response，一般情况下，调用Response.body()就能得到所要的实体数据。</span></div><div class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></div><div class="line">    <span class="comment">// a runtime exception.</span></div><div class="line">    catchingBody.throwIfCaught();</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以得知，Retrofit对于状态码的处理，1XX和3XX以上全部走到error中</p>
<p>execute是同步方法，enqueue是异步请求的方法，底层其实就调用了OkHttp.Call.enqueue()，所以说Retrofit本身并不负责创建网络请求，线程调度。只做了parseRespnse的方法，另外，OkHttp和Retrofit本身并不负责把Response推到主线程上，Android 平台可能要注意。</p>
<h3 id="1-4-第三个方法和AdapterFactory"><a href="#1-4-第三个方法和AdapterFactory" class="headerlink" title="1.4 第三个方法和AdapterFactory"></a>1.4 第三个方法和AdapterFactory</h3><p>return serviceMethod.callAdapter.adapt(okHttpCall); //这个return需要的是Object,涉及到动态代理，可以无视。</p>
<p>回头看一下serviceMethod的createCallAdapter方法，就是从retrofit对象的adapterFactories中一个个遍历：</p>
<blockquote>
<p>CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this)；</p>
</blockquote>
<p>找到之后就返回，默认的实现有DefaultCallAdapterFactory和ExecutorCallAdapterFactory以及RxjavaCallAdapterFactory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">在DefaultCallAdapterFactory中的处理方式是</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> responseType;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> &lt;R&gt; <span class="function">Call&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> call;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">ExecutorCallAdapterFactory的处理方式是</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> responseType;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>其实就是将callback丢到一个线程池callbackExecutor中，这个线程池可以通过Retrofit创建的时候配置，简单来说就是response会在这个线程池中回调。</p>
<p> RxjavaCallAdapterFactory的做法是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">    Class&lt;?&gt; rawType = getRawType(returnType);</div><div class="line">    String canonicalName = rawType.getCanonicalName();</div><div class="line">    <span class="keyword">boolean</span> isSingle = <span class="string">"rx.Single"</span>.equals(canonicalName); <span class="comment">//直接看包名。。。。。</span></div><div class="line">    <span class="keyword">boolean</span> isCompletable = <span class="string">"rx.Completable"</span>.equals(canonicalName);</div><div class="line">    <span class="keyword">if</span> (rawType != Observable.class &amp;&amp; !isSingle &amp;&amp; !isCompletable) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isCompletable &amp;&amp; !(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</div><div class="line">      String name = isSingle ? <span class="string">"Single"</span> : <span class="string">"Observable"</span>;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(name + <span class="string">" return type must be parameterized"</span></div><div class="line">          + <span class="string">" as "</span> + name + <span class="string">"&lt;Foo&gt; or "</span> + name + <span class="string">"&lt;? extends Foo&gt;"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isCompletable) &#123;</div><div class="line">      <span class="comment">// Add Completable-converter wrapper from a separate class. This defers classloading such that</span></div><div class="line">      <span class="comment">// regular Observable operation can be leveraged without relying on this unstable RxJava API.</span></div><div class="line">      <span class="comment">// Note that this has to be done separately since Completable doesn't have a parametrized</span></div><div class="line">      <span class="comment">// type.</span></div><div class="line">      <span class="keyword">return</span> CompletableHelper.createCallAdapter(scheduler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CallAdapter&lt;Observable&lt;?&gt;&gt; callAdapter = getCallAdapter(returnType, scheduler);</div><div class="line">    <span class="keyword">if</span> (isSingle) &#123;</div><div class="line">      <span class="comment">// Add Single-converter wrapper from a separate class. This defers classloading such that</span></div><div class="line">      <span class="comment">// regular Observable operation can be leveraged without relying on this unstable RxJava API.</span></div><div class="line">      <span class="keyword">return</span> SingleHelper.makeSingle(callAdapter);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> callAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-5-使用Retrofit的best-practices"><a href="#1-5-使用Retrofit的best-practices" class="headerlink" title="1.5 使用Retrofit的best practices"></a>1.5 使用Retrofit的best practices</h3><p>到这里，retrofit的工作流程就通过三个方法讲完了，接下来根据jake wharton的talk <a href="https://www.youtube.com/watch?v=t34AQlblSeE">making retrofit work for you</a>来讲几个best practice。</p>
<h4 id="1-5-1-end-point-不一样怎么办"><a href="#1-5-1-end-point-不一样怎么办" class="headerlink" title="1.5.1 end point 不一样怎么办"></a>1.5.1 end point 不一样怎么办</h4><p>默认情况下，如果不指定client,每一次都会创建一个新的OkHttpClient，这样做就丧失了disk caching,connection pooling等优势。</p>
<p><img src="http://odzl05jxx.bkt.clouddn.com/different_end_point.JPG" alt="endpoint">    </p>
<p>所以需要提取出一个OkHttpClient,解决方式很简单<br><img src="http://odzl05jxx.bkt.clouddn.com/different_end_point_teh_right_way.JPG" alt=""></p>
<h4 id="1-5-2-不要创建多个HttpClient"><a href="#1-5-2-不要创建多个HttpClient" class="headerlink" title="1.5.2 不要创建多个HttpClient"></a>1.5.2 不要创建多个HttpClient</h4><p>shallow copy<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line">OkHttpClient clientFoo = client.newBuilder().addInterceptor(<span class="keyword">new</span> FooInterceptor()).build()</div><div class="line"></div><div class="line">OkHttpClient clientBar = client.newBuilder().readTimeOut(<span class="number">20</span>,SECONDS)</div><div class="line">.writeTimeOut(<span class="number">20</span>,SECONDS).build()</div></pre></td></tr></table></figure></p>
<h4 id="1-5-3-有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）"><a href="#1-5-3-有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）" class="headerlink" title="1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）"></a>1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）</h4><p>一般可能会想到在OkHttp的Interceptor中去判断url然后手动加上header，一种更好的解决方式是，假定所有的API都需要加Header，对于登录和忘记密码的Api,这样写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@POST</span>(<span class="string">"/login"</span>)</div><div class="line"><span class="meta">@Headers</span>(<span class="string">"No-Authentication: true"</span>)</div><div class="line"><span class="function">Call&lt;User&gt; <span class="title">login</span><span class="params">(@Body LoginRequest request)</span></span></div></pre></td></tr></table></figure></p>
<p>//这个header对于server是不可见的，现在在Interceptor中，<br>只要判断request.header(“No-Authentication”)==null 即表示该接口需要加上header。<br>所以，对于特定接口的筛选可以，采用这种方式。</p>
<h4 id="1-5-4-Converters将byte变成java对象，底层的解析器不要创建多个"><a href="#1-5-4-Converters将byte变成java对象，底层的解析器不要创建多个" class="headerlink" title="1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个"></a>1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个</h4><p>addConverterFactory，和之前的创建两个httpclient一样，人们也很容易创建两个解析器。解决方法也很实在，提取出来公用即可。<br><img src="http://odzl05jxx.bkt.clouddn.com/creating%20two%20convertors.JPG" alt=""></p>
<h4 id="1-5-5-addConverterFactory可以调用多次"><a href="#1-5-5-addConverterFactory可以调用多次" class="headerlink" title="1.5.5 addConverterFactory可以调用多次"></a>1.5.5 addConverterFactory可以调用多次</h4><p>假如一个接口返回json，一个接口返回proto。不要试图创建多个retrofit实例。这样就可以了<br><img src="http://odzl05jxx.bkt.clouddn.com/different_response.JPG" alt=""></p>
<p>底层的原理是这样的。<br>User是Proto,Friend是Json。 Proto都extends一个protoType class，所以只要看下是否 instanceof proto就可以了。这一切都是在serviceMethod创建过程中判断的。这里顺序很重要。由于gson基本能够序列化一切，所以gson总是会认为自己可以成功。所以要把protoConverter放在前面。<br> GsonConverterFactory, SimpleXmlConverterFactory converters , they say yes to everyThing. 所以如果出现这种情况怎么办？<br> 首先定义自己的注解<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@interface</span> Xml &#123;&#125;</div><div class="line"> <span class="meta">@interface</span> Json &#123;&#125;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"/User"</span>) <span class="meta">@Xml</span></div><div class="line">    <span class="function">Call&lt;User&gt; <span class="title">user</span><span class="params">()</span></span>; <span class="comment">// User是XML</span></div><div class="line"></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"/Friends"</span>) <span class="meta">@Json</span></div><div class="line">    <span class="function">Call&lt;Friends&gt; <span class="title">friends</span><span class="params">()</span></span>;  <span class="comment">//Friends是Json</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlOrJsonConverterFactroy</span> <span class="title">extend</span> <span class="title">Converter</span>.<span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="keyword">final</span> Converter.Factory xml = <span class="comment">///;</span></div><div class="line">    <span class="keyword">final</span> Converter.Factory json = <span class="comment">//....;</span></div><div class="line"></div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody,?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit)&#123;</div><div class="line">        <span class="comment">// annotations就包含了刚才我们添加的注解</span></div><div class="line">        <span class="keyword">for</span> (Annotation annotation : annotations)&#123;</div><div class="line">            <span class="keyword">if</span>(annotation.getClass == Xml.class)&#123;</div><div class="line">                <span class="keyword">return</span> xml.reponseBodyConverter(type,annotations,retrofit);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(annotation.getClass == Json.class)&#123;</div><div class="line">                <span class="comment">// json</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; 都不是。 会去找下一个Converter..</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[AnnotatedConverterFactory用于自定义类型](https:<span class="comment">//github.com/square/retrofit/blob/master/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java)</span></div></pre></td></tr></table></figure></p>
<h4 id="1-5-6-服务器返回的数据中包括一些metaData"><a href="#1-5-6-服务器返回的数据中包括一些metaData" class="headerlink" title="1.5.6 服务器返回的数据中包括一些metaData"></a>1.5.6 服务器返回的数据中包括一些metaData</h4><p>使用delegate的方式去除这些metadata，只获取想要的response实体对象<br><img src="http://odzl05jxx.bkt.clouddn.com/delegaet_converters.JPG" alt=""><br>但这些metaData是有用的。。怎么处理<br>可以在convert中集中处理自定义错误码。</p>
<h4 id="1-5-7-和Rxjava配合使用"><a href="#1-5-7-和Rxjava配合使用" class="headerlink" title="1.5.7 和Rxjava配合使用"></a>1.5.7 和Rxjava配合使用</h4><p>CallAdapterFactory和ConverterFactory类似，也可以自定义，所以这样可以直接将所有的Observable返回到主线程</p>
<p><img src="http://odzl05jxx.bkt.clouddn.com/always_observe_on_mian_thread.JPG" alt=""></p>
<p>所以，Retrofit就是将HttpClient、Converter和CallAdapter这三样职能结合起来，又提供了足够的定制化。</p>
<h3 id="2-OkHttp"><a href="#2-OkHttp" class="headerlink" title="2. OkHttp"></a>2. OkHttp</h3><h3 id="3-A-few-‘ok’-libraries"><a href="#3-A-few-‘ok’-libraries" class="headerlink" title="3. A few ‘ok’ libraries"></a>3. A few ‘ok’ libraries</h3><p>why moshi ? why Retrofit call can be clone cheap？<br>why SinkedSource?<br>why protolBuffer cost less ?</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/">Paisy解析Retrofit</a></li>
<li><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit">open-sourse-projetc解析Retrofit</a></li>
<li><a href="https://www.youtube.com/watch?v=t34AQlblSeE">Making Retrofit Work For You by Jake Wharton</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;This-is-gonna-be-nasty……-TL-DR&quot;&gt;&lt;a href=&quot;#This-is-gonna-be-nasty……-TL-DR&quot; class=&quot;headerlink&quot; title=&quot;This is gonna be nasty…… TL;DR&quot;&gt;&lt;/a&gt;This is gonna be nasty…… TL;DR&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/d653491fb55bec754b8471aa6a3f6eed.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Retrofit" scheme="https://haldir65.github.io/tags/Retrofit/"/>
    
      <category term="OkHttp" scheme="https://haldir65.github.io/tags/OkHttp/"/>
    
      <category term="Okio" scheme="https://haldir65.github.io/tags/Okio/"/>
    
  </entry>
  
  <entry>
    <title>Java集合类的一些整理</title>
    <link href="https://haldir65.github.io/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/"/>
    <id>https://haldir65.github.io/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/</id>
    <published>2017-06-25T14:56:33.000Z</published>
    <updated>2017-07-15T08:56:34.194Z</updated>
    
    <content type="html"><![CDATA[<p>根据网上的大部分博客的分类，集合框架分为Collections(具有类似数组的功能)和Map(存储键值对)这两大部分。针对jdk1.8的java.util里面的一些常用的或者不常用的集合做一些分析。写这篇文章的过程中，我慢慢发现不同版本jdk的同一个class的实现是有一些差异的(LinkedList)，由于对照的是java1.8的代码，里面会多一些since 1.8的代码，这里不作论述。<br><img src="http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600" alt=""></p>
<a id="more"></a>
<p>java集合的大致框架建议参考网上博客的总结，<a href="http://www.jianshu.com/p/2cd7be850540">Java集合干货系列</a>写的比较好，图画的也不错，针对jdk 1.6源码讲的。我这里只是自己学习过程中的一些笔记。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>ArrayList (建议new出来的时候给定一个适当的size，不然每次扩容很慢的，可以放null)<br>LinkedList(not recommended，增删元素的时候快一点)<br>Vector（线程安全,重同步，不推荐）</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>HashSet (底层是HashMap)<br>TreeSet(排序存储)<br>LinkedHashSet(底层是LinkedHashMap)</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Stack ArrayDeque(不常用)</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>HashMap （键值都可以为null,底层是哈希表）<br>TreeMap(底层二叉树)<br>HashTable(线程安全，键值都不允许为null)<br>SparseArray(Android平台用)</p>
<p>关于集合，不得不提到泛型，Java 1.5引入了泛型，关于泛型，找到一篇很好的文章<br><a href="http://blog.csdn.net/lonelyroamer/article/details/7868820">类型擦除原理</a>。本质上只是提供了编译期类型检查。编译通过后都是Object，所以叫做<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">类型擦除</a>。</p>
<h2 id="1-List的解析"><a href="#1-List的解析" class="headerlink" title="1. List的解析"></a>1. List的解析</h2><h3 id="1-1-ArrayList源码解析"><a href="#1-1-ArrayList源码解析" class="headerlink" title="1.1 ArrayList源码解析"></a>1.1 ArrayList源码解析</h3><ul>
<li>先上一段崩溃代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;;</div><div class="line">    List&lt;String&gt; l = Arrays.asList(array);</div><div class="line">    l.add(<span class="string">"d"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</div><div class="line">    at java.util.AbstractList.add(AbstractList.java:<span class="number">148</span>)</div><div class="line">    at java.util.AbstractList.add(AbstractList.java:<span class="number">108</span>)</div><div class="line">    at com.example.demo.main(ConcurrentModificationListDemo.java:<span class="number">13</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>问题出在Arrays.asList返回了一个<strong>java.util.Arrays.ArrayList</strong>，而不是<strong>java.util.ArrayList</strong>。前者只实现了List接口的有限的几个方法，并且是Arrays内部的一个private class。<br>正确的用法是new 一个ArrayList，把这个有限的list的元素(的指针)copy进去，即addAll()方法<br>ArrayList.toArray(T[] a)是把所有的elements通过System.arraycopy(elementData, 0, a, 0, size);复制到a数组中。</p>
<ul>
<li>System.arraycopy可以从自己的数组复制到自己的数组<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">      rangeCheckForAdd(index);</div><div class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">      System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                       size - index);  </div><div class="line">      elementData[index] = element;</div><div class="line">      size++;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>添加到指定位置，System.arrayCopy可以从同一个数组复制到同一个数组，几乎就是挪动指针了。</p>
<ul>
<li>不常见的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面这两个是因为ArrayList implements java.io.Serializable，是序列化时会调用的</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> <span class="comment">//给一个集合，删除list与之的交集</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> <span class="comment">//  给定一个集合，从list中删除所有不在这个集合里面的元素</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> <span class="comment">// 内存压力大的时候可以释放掉一部分内存，记得那个1.5倍的默认扩容嘛，释放的就是这0.5的内存</span></span></div></pre></td></tr></table></figure>
<p>多线程场景下要注意的问题</p>
<blockquote>
<p>和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p>
</blockquote>
<h3 id="1-2-LinkedList的一些点"><a href="#1-2-LinkedList的一些点" class="headerlink" title="1.2 LinkedList的一些点"></a>1.2 LinkedList的一些点</h3><p>LinkedList是双向链表实现的，可以想象成一帮小孩左手拉右手绕成一个圈，只不过这里面的每一个小孩并不是你放进去的 T 类型数据，而是一个Node<T> 。所以LinkedList是可以放进去一个Null的。<br>LinkedList往往被人诟病的就是除了添加和删除快之外，get和set很慢。<br>来看下add的实现（jdk 1.8）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        linkLast(e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</div><div class="line">     * Links e as last element.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;  <span class="comment">//先把链表的尾巴找出来</span></div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>); <span class="comment">// 可以想象每次add都有new的操作，并将原来的尾巴作为这个新的Entry的头部</span></div><div class="line">        last = newNode; <span class="comment">//新的Node将成为新的尾巴</span></div><div class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>) <span class="comment">//这种情况是原来没有尾巴，也就是说size = 0</span></div><div class="line">            first = newNode; <span class="comment">//这时候就只有一个Node，头和尾都是Null</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            l.next = newNode; <span class="comment">//不然的话，旧的尾巴变成了倒数第二个，它的next指向了新的Entry.</span></div><div class="line"></div><div class="line">        size++;</div><div class="line">        modCount++;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>add的过程看起来很快，new一个entery，确定下前后的指针就可以了。remove也差不多，取消指针引用即可。</p>
<p>来看比较慢的get</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       checkElementIndex(index);</div><div class="line">       <span class="keyword">return</span> node(index).item;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> <span class="comment">/**</div><div class="line">    * Returns the (non-null) Node at the specified element index.</div><div class="line">    */</span></div><div class="line">   <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">       <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">           Node&lt;E&gt; x = first;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">               x = x.next; <span class="comment">//一直遍历到这个index才返回，慢</span></div><div class="line">           <span class="keyword">return</span> x;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           Node&lt;E&gt; x = last;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">               x = x.prev;</div><div class="line">           <span class="keyword">return</span> x;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>值得注意的一点小事：<br>ArrayList implement RandomAccess接口，而LinkedList并没有。RandomAccess接口的定义如下</p>
<blockquote>
<ul>
<li>Marker interface used by <tt>List</tt> implementations to indicate that<ul>
<li>they support fast (generally constant time) random access.  The primary</li>
<li>purpose of this interface is to allow generic algorithms to alter their</li>
<li>behavior to provide good performance when applied to either random or</li>
<li>sequential access lists.<br>*</li>
<li><p>The best algorithms for manipulating random access lists (such as</li>
<li><tt>ArrayList</tt>) can produce quadratic behavior when applied to</li>
<li>sequential access lists (such as <tt>LinkedList</tt>).  Generic list</li>
<li>algorithms are encouraged to check whether the given list is an</li>
<li><tt>instanceof</tt> this interface before applying an algorithm that would</li>
<li>provide poor performance if it were applied to a sequential access list,</li>
<li>and to alter their behavior if necessary to guarantee acceptable</li>
<li>performance.<br>*</li>
<li><p>It is recognized that the distinction between random and sequential</li>
<li>access is often fuzzy.  For example, some <tt>List</tt> implementations</li>
<li>provide asymptotically linear access times if they get huge, but constant</li>
<li>access times in practice.  Such a <tt>List</tt> implementation</li>
<li>should generally implement this interface.  As a rule of thumb, a</li>
<li>List implementation should implement this interface if,</li>
<li>for typical instances of the class, this loop:</li>
<li>for (int i=0, n=list.size(); i &lt; n; i++)</li>
<li>list.get(i); //get的速度应该是恒定的</li>
<li>runs faster than this loop:</li>
<li>for (Iterator i=list.iterator(); i.hasNext(); )</li>
<li>i.next();</li>
</ul>
</li>
</ul>
</blockquote>
<p>这种接口就是给外界使用者看的，用来说明该集合支持这种通过下标查找（速度不变）的快速操作</p>
<p>实践表明，对于linkedList，采用for loop的方式要很慢，但使用ListIterator<T>的方式，速度并不慢，简单来想，沿着链表的一个方向一致往下走就是了嘛。<br>一些经验表明(摘自简书作者嘟爷MD的文章)</p>
<p><a href="http://www.jianshu.com/p/d5ec2ff72b33">ArryList和LinkedList的对比结论</a></p>
<blockquote>
<p>1、顺序插入速度ArrayList会比较快<br>2、LinkedList将比ArrayList更耗费一些内存<br>3、ArrayList的遍历效率会比LinkedList的遍历效率高一些<br>4、有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：如果增加或者删除的元素在前半部分的时候，ArrayList会频繁调用System.arrayCopy方法，虽然native方法快，但高频率调用肯定慢，至少比不上移动指针。</p>
</blockquote>
<h2 id="2-Map的几个实现类"><a href="#2-Map的几个实现类" class="headerlink" title="2. Map的几个实现类"></a>2. Map的几个实现类</h2><h3 id="2-1-HashMap源码解析"><a href="#2-1-HashMap源码解析" class="headerlink" title="2.1 HashMap源码解析"></a>2.1 HashMap源码解析</h3><blockquote>
<p>public class HashMap<K,V> extends AbstractMap<K,V><br>    implements Map<K,V>, Cloneable, Serializable</p>
</blockquote>
<p>HashMap不是线程安全的，Key和Value都有可能为null，存储数据不是有序的(get的顺序不是put的顺序)</p>
<p>HashMap中有几个默认值常量</p>
<pre><code>默认初始容量是16
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

默认加载因子是0.75f ，加载因子是指Hashmap在自动扩容之前可以达到多满
static final float DEFAULT_LOAD_FACTOR = 0.75f; //一般不需要改
</code></pre><p>构造函数有好几个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span>  <span class="comment">//自定义加载因子，比较玄学</span></div><div class="line"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> <span class="comment">// 避免扩容，和ArrayList初始化指定容量类似的道理</span></div><div class="line"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> <span class="comment">//直接把初始容量设置成16</span></div><div class="line"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span></div></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity-be-a-power-of-two">注意这个初始容量必须是2的n次方</a></p>
<p>来看常见的CURD操作(jdk 1.8源码，和我在网上找到的jdk1.6源码有一些变化了)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">//HashMap允许key为null,key为null的话，直接放到数组的0的位置（hash方法返回的是0）</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">           <span class="keyword">int</span> h;</div><div class="line">           <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">//如果是null，放到数组的第一个</span></div><div class="line"><span class="comment">// 这里面就是HashMap算法的高明之处  ，</span></div><div class="line"><span class="comment">//  1. 首先算出object的hashcode，</span></div><div class="line"><span class="comment">//2.然后根据上述公式将二进制的1尽量分散的均匀一点         </span></div><div class="line"><span class="comment">// 3. 在putVal的时候将这个值跟数组的长度length-1进行位运算，得到一个比length小的正数，作为这个新元素在数组中的index.但这样仍不免会产生冲突(hash Collision)</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">/**</div><div class="line">     * Implements Map.put and related methods</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> hash hash for key</div><div class="line">     * <span class="doctag">@param</span> key the key</div><div class="line">     * <span class="doctag">@param</span> value the value to put</div><div class="line">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</div><div class="line">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</div><div class="line">     * <span class="doctag">@return</span> previous value, or null if none</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</div><div class="line">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            n = (tab = resize()).length; <span class="comment">//table为成员变量，是一个Node数组，为空的话则创建 。在resize中创建</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                e = p; <span class="comment">//Table数组中找到了这个下标的元素，直接指定</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//p可以理解为previous 。 如果发现这个节点是一棵树（红黑树？）</span></div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">//否则该节点是链表，各个元素之间手拉手的那种</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//找到这个链表的尾巴了</span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e); <span class="comment">//回调函数</span></div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);<span class="comment">//回调函数</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>get方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">      Node&lt;K,V&gt; e;</div><div class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;<span class="comment">//根据key来找value</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">/**</div><div class="line">   * Implements Map.get and related methods</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> hash hash for key</div><div class="line">   * <span class="doctag">@param</span> key the key</div><div class="line">   * <span class="doctag">@return</span> the node, or null if none</div><div class="line">   */</span></div><div class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">//table不为空说明曾经put过</span></div><div class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">              ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">              <span class="keyword">return</span> first;</div><div class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">              do &#123;</div><div class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                      <span class="keyword">return</span> e;</div><div class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">      Node&lt;K,V&gt; e;</div><div class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</div><div class="line">   * Implements Map.get and related methods</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> hash hash for key</div><div class="line">   * <span class="doctag">@param</span> key the key</div><div class="line">   * <span class="doctag">@return</span> the node, or null if none</div><div class="line">   */</span></div><div class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">              ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">              <span class="keyword">return</span> first;</div><div class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">              do &#123;</div><div class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                      <span class="keyword">return</span> e;</div><div class="line">  <span class="comment">//可以看出比较的方式就是hash（int）相等且key(指针相等)  或者key equals(所以经常说重写equals需要确保hashcode一致，这里至少反应了这一点)</span></div><div class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>回想一下平时迭代一个HashMap的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> i = <span class="number">0</span>;</div><div class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</div><div class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">    Map.Entry&lt;Integer, Integer&gt; pair = it.next(); <span class="comment">//上面的get也是这种不断查找next的方式</span></div><div class="line">    i += pair.getKey() + pair.getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>entrySet方法是Map接口定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</div><div class="line">   * Returns a Set view of the mappings contained in this map.</div><div class="line">     * The set is backed by the map, so changes to the map are</div><div class="line">     * reflected in the set, and vice-versa.  If the map is modified</div><div class="line">     * while an iteration over the set is in progress (except through</div><div class="line">     * the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</div><div class="line">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</div><div class="line">     * iterator) the results of the iteration are undefined.  The set</div><div class="line">     * supports element removal, which removes the corresponding</div><div class="line">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</div><div class="line">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</div><div class="line">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</div><div class="line">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</div><div class="line">     *</div><div class="line">     * @return a set view of the mappings contained in this map</div></pre></td></tr></table></figure></p>
<p>大致意思是： 返回一个能够反映该map元素组合的一个Set，对这个Set的操作都将反映到原map上，反之亦然。在通过entrySet迭代这个map的时候，除了remove和操作操作都是不被支持的。返回的Set支持删除对应的mapping组合。但不支持add操作</p>
<p>HashMap内部保留了一个这样的成员变量：<br>transient Set<Map.Entry<K,V>&gt; entrySet; //成员变量<br>具体实现enterySet方法的地方：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// 这个EntrySet大致长这样</span></div><div class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class="line">            Object key = e.getKey();</div><div class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</div><div class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class="line">                Object key = e.getKey();</div><div class="line">                Object value = e.getValue();</div><div class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>整理的关键在于removeNode方法，和getNode和putVal很像<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</div><div class="line">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</div><div class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">         (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">         Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</div><div class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">             node = p;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">             <span class="keyword">else</span> &#123;</div><div class="line">                 do &#123;</div><div class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                         ((k = e.key) == key ||</div><div class="line">                          (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                         node = e;</div><div class="line">                         <span class="keyword">break</span>;</div><div class="line">                     &#125;</div><div class="line">                     p = e;</div><div class="line">                 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="comment">//先把p(previous)找出来，这里的matchValue和movable都是true</span></div><div class="line">         <span class="comment">// node 就是包含了要移出对象的Node</span></div><div class="line">         <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                              (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">             <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">//数组这个位置就一个</span></div><div class="line">                 tab[index] = node.next;<span class="comment">//直接指向下一个</span></div><div class="line">             <span class="keyword">else</span></div><div class="line">                 p.next = node.next; <span class="comment">//数组这个位置指向链表下一个节点，释放引用</span></div><div class="line">             ++modCount;</div><div class="line">             --size;</div><div class="line">             afterNodeRemoval(node);</div><div class="line">             <span class="keyword">return</span> node;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>比较元素是否相同的关键是</p>
<blockquote>
<p>e.hash == hash || (key!=null &amp;&amp;key.equals(k)) //后半部分其实也是比较hashCode</p>
</blockquote>
<p>另外一些平时常用的方法包括：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>; <span class="comment">//就是检查下有没有这个key对应的Node</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">      Node&lt;K,V&gt;[] tab; V v;</div><div class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</div><div class="line">              <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                  <span class="keyword">if</span> ((v = e.value) == value ||</div><div class="line">                      (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</div><div class="line">                      <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//遍历内部的数组，仅此而已</span></div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>和ArrayList、LinkedList比起来，HashMap的源码要麻烦许多，这里面涉及到hashCode，链表，红黑树。需要一点数据结构的知识。另外，HashMap还针对hashCode冲突（hash Collision，不同的Object居然有相同的hashCode）的情况作了<a href="https://stackoverflow.com/questions/6493605/how-does-a-java-hashmap-handle-different-objects-with-the-same-hash-code">预处理</a><br>通俗的来说，HashMap内部维护了一个数组，每一个数组元素内部不一定只有一个，有可能是一个链表。每次添加(key,value)不是盲目的往这个数组里面塞，而是算下key的hash值，放到对应的节点上。如果这个节点上还没有元素，直接放就好了。如果有的话，新加入的value将被作为原有元素的Next(外部调用get的时候，先根据传入的key的hashCode找到节点，然后根据key.equals来找)。简单如此，精致如斯。</p>
<h3 id="2-2-LinkedHashMap"><a href="#2-2-LinkedHashMap" class="headerlink" title="2.2 LinkedHashMap"></a>2.2 LinkedHashMap</h3><p>public class LinkedHashMap<K,V><br>    extends HashMap<K,V><br>    implements Map<K,V><br>HashMap源码我看了下有两千多行，LinkedHashMap只有七百多行，显然这是继承带来的简便之处。<br>关键的成员变量<br>final boolean accessOrder; 默认是false</p>
<blockquote>
<p>The iteration ordering method for this linked hash map: <tt>true</tt><br>for access-order, false for insertion-order.</p>
</blockquote>
<p>LinkedHashMap常用的属性就是它支持有序，这个有序是指迭代的时候有序</p>
<h3 id="2-3-SparseArray"><a href="#2-3-SparseArray" class="headerlink" title="2.3 SparseArray"></a>2.3 SparseArray</h3><p>先来看一段崩溃日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fatal Exception: java.lang.ArrayIndexOutOfBoundsException: src.length=509 srcPos=60 dst.length=509 dstPos=61 length=-60</div><div class="line">       at java.lang.System.arraycopy(System.java:388)</div><div class="line">       at com.android.internal.util.GrowingArrayUtils.insert(GrowingArrayUtils.java:135)</div><div class="line">       at android.util.SparseIntArray.put(SparseIntArray.java:144)</div></pre></td></tr></table></figure></p>
<p>SparseArry提供了类似于HashMap的调用接口，</p>
<p>使用SparseArray的初衷还是在android这种内存比cpu金贵的平台中，使用SparseArry相比HashMap能够减轻内存压力，获得更好的性能。<br><a href="https://www.liaohuqiu.net/cn/posts/sparse-array-in-android/">liaohuqiu指出SparseArry并不是任何时候都更快</a>，主要是节省内存，避免autoBoxing，二分法查找对于cpu的消耗需要权衡。尤其是存储的量很大的时候，二分法查找的速度会很慢。</p>
<p>SparseArry类似的class有好几个，据说有八个，以SparseIntArry为例<br>SparseIntArry的几个常用方法,值得注意的是 clear方法只不过是把计数清零了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfKey</span><span class="params">(<span class="keyword">int</span> key)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfValue</span><span class="params">(<span class="keyword">int</span> value)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">       mSize = <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line"><span class="comment">//迭代一个SparseArry的方法</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArray.size(); i++) &#123;</div><div class="line">   <span class="keyword">int</span> key = sparseArray.keyAt(i);</div><div class="line">   <span class="comment">// get the object by the key.</span></div><div class="line">   Object obj = sparseArray.get(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从源码来看变量结构</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseIntArray</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mValues;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key); <span class="comment">//二分法查找</span></div><div class="line"></div><div class="line">     <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</div><div class="line">         mValues[i] = value; <span class="comment">//找到了在Value数组中的index,直接替换掉</span></div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         i = ~i;</div><div class="line">         mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</div><div class="line">         mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</div><div class="line">         mSize++;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>廖祜秋 特地强调</p>
<ol>
<li>SparseArray 是针对HashMap做的优化。<br> 1.HashMap 内部的存储结构，导致一些内存的浪费。<br> 2.在刚扩容完，SparseArray 和 HashMap 都会存在一些没被利用的内存。</li>
<li>SparseArray 并不是任何时候都会更快，有时反而会更慢</li>
</ol>
<h3 id="2-4-ArrayMap"><a href="#2-4-ArrayMap" class="headerlink" title="2.4 ArrayMap"></a>2.4 ArrayMap</h3><h2 id="3-Set的介绍"><a href="#3-Set的介绍" class="headerlink" title="3. Set的介绍"></a>3. Set的介绍</h2><p>Set用比较少，HashSet、TreeSet和LinkedHashSet是jdk的实现类</p>
<p>public class HashSet<E><br>    extends AbstractSet<E><br>    implements Set<E>, Cloneable, java.io.Serializable<br>Set的重要特点就是<strong>不能放进去重复</strong>的元素，Set中不会存在e1和e2，e1.equals(e2)的情况<br>HashSet的源码只有三百多行，内部有一个map（HashMap）相对来说是比较简单的。其实Set平时用的也不是那么多。。。</p>
<h3 id="4-一些不常用的类"><a href="#4-一些不常用的类" class="headerlink" title="4. 一些不常用的类"></a>4. 一些不常用的类</h3><pre><code>Vetor，Stack，ArrayDeque,Queue

Vector属于List,线程安全，但效率低（就是简单的在所有方法前面加上了synchronized）

Queue是一个interface，属于两端可以出入的List，通常是(FIFO模式)，实现类有
PriorityQueue，
java.util.concurrent.LinkedBlockingQueue
java.util.concurrent.LinkedBlockingQueue
java.util.concurrent.PriorityBlockingQueue
作者都是大名鼎鼎的Doug Lea

Stack是Vector的子类(属于LIFO的栈)
The Stack class represents a last-in-first-out (LIFO) stack of object

Deque(双端队列)
</code></pre><h3 id="5-concurrentHashMap等"><a href="#5-concurrentHashMap等" class="headerlink" title="5. concurrentHashMap等"></a>5. concurrentHashMap等</h3><p>jdk1.8的concurrentHashMap不是用synchronized实现的，是Doug Lea使用CAS操作写的，非常高效。</p>
<h3 id="6-WeakHaskMap"><a href="#6-WeakHaskMap" class="headerlink" title="6. WeakHaskMap"></a>6. WeakHaskMap</h3><p>WeakHashMap的Key是WeakReference，但Value不是。<br>常见用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String a = <span class="string">"a"</span>;</div><div class="line">map.put(<span class="number">1</span>,a);</div><div class="line">a = <span class="keyword">null</span>;</div><div class="line"><span class="comment">//map中的a可以出了map自身外没有其他地方被引用，a将被被gc回收</span></div></pre></td></tr></table></figure>
<p>Android <a href="https://developer.android.com/reference/java/util/WeakHashMap.html">官方开发文档</a>上指出了一点</p>
<blockquote>
<p>Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get.</p>
</blockquote>
<p>WeakHashMap的value不要持有key的强引用，否则，key永远不会被清除,value也别想被清除。</p>
<h2 id="7-java-8的一些新的方法"><a href="#7-java-8的一些新的方法" class="headerlink" title="7. java 8的一些新的方法"></a>7. java 8的一些新的方法</h2><p>list.replaceAll(String::toUpperCase) //method reference<br>can not change the elemeet type, for that you need an stream<br><a href="https://www.youtube.com/watch?v=q6zF3vf114M">Collections Refuled by Stuart Marks</a></p>
<h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>8.1 <a href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a> 是非常聪明的人，估计并发经常会牵涉到集合，所以jdk里面很多集合都有他的作品<br>8.2 jdk只是定义了这些框架，像List，Map这些全都是接口，完全可以自己去实现。Apache就有一大堆适合特定场景的集合实现类。jdk只是帮助我们实现了一些常见的类。如果有现成的满足需求的框架，不要重复造轮子。<br>8.3 平时只要记住ArrayList和HashMap的<strong>大致内部实现</strong>就可以了，至于别的，除非面试，平时没必要记录。<br>8.4 <a href="https://blogs.oracle.com/java/collections-refueled">Stuart Mark</a>特别喜欢把一个class搞成<strong>@deprecated</strong><br>8.5 就连<a href="https://www.youtube.com/watch?v=V1vQf4qyMXg">Joshua Bloch</a> 都承认，除非性能真的很重要的，平时没必要过度优化。By the way , he said Doug Lea is very smart .</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="https://www.youtube.com/watch?v=q6zF3vf114M">Collections Refuled by Stuart Marks</a></li>
<li><a href="https://www.youtube.com/watch?v=FLcXf9pO27w">From Java Code to Java Heap: Understanding the Memory Usage of Your Application</a></li>
<li><a href="http://www.jianshu.com/p/2cd7be850540">Java集合干货系列</a></li>
<li><a href="http://www.programcreek.com/2014/01/java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF/">Arrays.asList()返回的List不是jva.util.ArrayList</a></li>
<li><a href="http://blog.csdn.net/yangzl2008/article/details/6980709">WeakHashMap和HashMap的区别</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据网上的大部分博客的分类，集合框架分为Collections(具有类似数组的功能)和Map(存储键值对)这两大部分。针对jdk1.8的java.util里面的一些常用的或者不常用的集合做一些分析。写这篇文章的过程中，我慢慢发现不同版本jdk的同一个class的实现是有一些差异的(LinkedList)，由于对照的是java1.8的代码，里面会多一些since 1.8的代码，这里不作论述。&lt;br&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://haldir65.github.io/categories/blog/"/>
    
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu服务器上部署flask web app</title>
    <link href="https://haldir65.github.io/2017/06/25/2017-06-25-deploying-flask-app-on-linux-server/"/>
    <id>https://haldir65.github.io/2017/06/25/2017-06-25-deploying-flask-app-on-linux-server/</id>
    <published>2017-06-25T14:46:23.000Z</published>
    <updated>2017-07-12T00:46:25.552Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-virtualenv-install"><a href="#1-virtualenv-install" class="headerlink" title="1. virtualenv install"></a>1. virtualenv install</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenv </div><div class="line">sudo virtualenv venv</div><div class="line"><span class="built_in">source</span> venv/bin/activate </div><div class="line">sudo pip install Flask </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># sudo python __init__.py</span></div><div class="line">sudo /var/www/FlaskApp/FlaskApp/venv/bin/python2 __init__.py</div><div class="line"></div><div class="line">deactivate <span class="comment"># exit</span></div><div class="line"></div><div class="line">Windows环境下安装virtualenv类似</div><div class="line">在pycharm的cmd窗口中，</div><div class="line">执行pip install virtualenv</div><div class="line">virtualenv env <span class="comment">#会生成一个新的ENV文件夹</span></div><div class="line"><span class="built_in">cd</span> env /Scripts</div><div class="line">activate.bat <span class="comment"># 此时光标变成(env) &gt;.</span></div><div class="line">退出很简单deactivate.bat即可</div></pre></td></tr></table></figure>
<h2 id="2-install-apache2-mysql-server…-on-ubuntu"><a href="#2-install-apache2-mysql-server…-on-ubuntu" class="headerlink" title="2. install apache2 , mysql-server… on ubuntu"></a>2. install apache2 , mysql-server… on ubuntu</h2><pre><code>重启apache2服务 service apache2 restart
</code></pre><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-application-on-an-ubuntu-vps">how-to-deploy-a-flask-application-on-an-ubuntu-vps</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="https://haldir65.github.io/categories/blog/"/>
    
    
      <category term="python" scheme="https://haldir65.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令扩展</title>
    <link href="https://haldir65.github.io/2017/06/18/2017-06-18-linux-commands-extended/"/>
    <id>https://haldir65.github.io/2017/06/18/2017-06-18-linux-commands-extended/</id>
    <published>2017-06-18T08:51:49.000Z</published>
    <updated>2017-08-12T03:09:58.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一些linux的常用命令，linux环境下运行server ,bash的语法</p>
</blockquote>
<p><img src="http://odzl05jxx.bkt.clouddn.com/ChMkJ1gq00WIXw_GAA47r_8gjqgAAXxJAH8qOMADjvH566.jpg?imageView2/2/w/600" alt=""></p>
<a id="more"></a>
<ol>
<li><p>常用软件安装<br><a href="http://blog.topspeedsnail.com/archives/5752">utorrent</a><br>apache,mysql</p>
</li>
<li><p>环境变量怎么改<br>平时在shell中输入sudo XXX ,系统是如何知道怎么执行这条指令的呢。首先，可以查看which XXX ，用于查找某项指令对应的文件的位置。而像sudo这种都放在PATH位置，系统会在几个关键位置查找sudo命令。用户本身完全可以创建一个叫做sudo的文件chmod+X ，然后运行这个sudo。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">查看PATH : echo $PATH</div><div class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games (注意，系统是按照这个顺序找的，如果在第一个目录下找到一个叫sudo的东西，就会直接执行了，所以这里是有潜在的危险的)</div><div class="line">看下哪个命令对应的位置在哪里</div><div class="line">which XXXk</div><div class="line">比如sudo 就放在 /usr/bin/sudo</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>$PATH<br>环境变量修改在~./bashrc或者 ~./profile里面<br>具体来说，比如要把/etc/apache/bin目录添加到PATH中<br>PATH=$PATH:/etc/apache/bin  #只对本次回话有效<br>或者  PATH=$PATH:/etc/apache/bin #在~./bashrc或者~./profile里面添加这句话</p>
</blockquote>
<ol>
<li><p>alias设置<br>vi 中输入 /XXX 可以搜索<br>vi ~/.bashrc<br>添加 alias yourcommand=’ls -alr’<br>重开session即可生效</p>
</li>
<li><p>pushd和popd（类似于文件夹stack）</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一些linux的常用命令，linux环境下运行server ,bash的语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/ChMkJ1gq00WIXw_GAA47r_8gjqgAAXxJAH8qOMADjvH566.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://haldir65.github.io/categories/blog/"/>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>For those tiny details in Java</title>
    <link href="https://haldir65.github.io/2017/06/17/2017-06-17-tiny-details-in-java/"/>
    <id>https://haldir65.github.io/2017/06/17/2017-06-17-tiny-details-in-java/</id>
    <published>2017-06-17T13:24:48.000Z</published>
    <updated>2017-08-12T03:09:58.590Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>interesting stuff in java that don’t seem to get enough pubilicity</p>
</blockquote>
<p><img src="http://odzl05jxx.bkt.clouddn.com/34a7d57ccabb18c69d085247cf009b22.jpg?imageView2/2/w/600" alt="landscape"></p>
<a id="more"></a>
<h2 id="1-getting-the-concreate-class-from-generic-types"><a href="#1-getting-the-concreate-class-from-generic-types" class="headerlink" title="1. getting the concreate class from generic types"></a>1. getting the concreate class from generic types</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">        <span class="comment">/**</div><div class="line">     * Make a GET request and return a parsed object from JSON.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> url     URL of the request to make</div><div class="line">     * <span class="doctag">@param</span> clazz   Relevant class object, for Gson's reflection</div><div class="line">     * <span class="doctag">@param</span> headers Map of request headers</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericMoshiRequest</span><span class="params">(String url, @Nullable Class&lt;T&gt; clazz, Map&lt;String, String&gt; headers,</div><div class="line">                               Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Method.GET, url, errorListener);</div><div class="line"><span class="comment">//        this.clazz = clazz;</span></div><div class="line">        Class&lt;T&gt; entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[<span class="number">0</span>];<span class="comment">//使用反射获得泛型对应class</span></div><div class="line">        <span class="keyword">this</span>.clazz = entityClass;</div><div class="line">        <span class="keyword">this</span>.headers = headers;</div><div class="line">        <span class="keyword">this</span>.listener = listener;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="2-OkHttp-默认会自动重试失败的请求"><a href="#2-OkHttp-默认会自动重试失败的请求" class="headerlink" title="2. OkHttp 默认会自动重试失败的请求"></a>2. OkHttp 默认会自动重试失败的请求</h2><p><a href="https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace">okhttp-is-quietly-retrying-requests-is-your-api-ready</a><br>OkHttp默认会对请求进行重试，具体是在RetryAndFollowUpInterceptor中进行的。<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> RetryAndFollowUpInterceptor.java</div><div class="line"></div><div class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">  Request request = chain.request();</div><div class="line"></div><div class="line">  streamAllocation = new StreamAllocation(</div><div class="line">      client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class="line"></div><div class="line">  int followUpCount = 0;</div><div class="line">  Response priorResponse = null;</div><div class="line">  while (true) &#123; # 不停的尝试</div><div class="line">    if (canceled) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      throw new IOException("Canceled");</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = null;</div><div class="line">    boolean releaseConnection = true;</div><div class="line">    try &#123;</div><div class="line">      response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</div><div class="line">      releaseConnection = false; //默认不认可response成功</div><div class="line">    &#125; catch (RouteException e) &#123;</div><div class="line">      // The attempt to connect via a route failed. The request will not have been sent.</div><div class="line">      if (!recover(e.getLastConnectException(), false, request)) &#123;</div><div class="line">        throw e.getLastConnectException();</div><div class="line">      &#125;</div><div class="line">      releaseConnection = false;</div><div class="line">      continue;  //继续尝试</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      // An attempt to communicate with a server failed. The request may have been sent.</div><div class="line">      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</div><div class="line">      if (!recover(e, requestSendStarted, request)) throw e;</div><div class="line">      releaseConnection = false;</div><div class="line">      continue; //继续尝试</div><div class="line">    &#125; finally &#123;</div><div class="line">      // We're throwing an unchecked exception. Release any resources.</div><div class="line">      if (releaseConnection) &#123; //出现不可预料的错误，释放硬件资源，端口什么的</div><div class="line">        streamAllocation.streamFailed(null);</div><div class="line">        streamAllocation.release();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端当然可以使用retryOnConnectionFailure禁止这种自动重试策略，但不建议这么做。另外，为避免减少不必要的重试请求，<br>OkHttp 3.3.0 <a href="https://github.com/square/okhttp/issues/2394">issue</a></p>
<blockquote>
<p>Don’t recover if we encounter a read timeout after sending the request, but do recover if we encounter a timeout building a connection<br>建立连接超时可以重试(客户端到服务器的通道不可靠，当然可以重试)，连接上之后读取超时则不去重试(服务器出了问题，没有必要重试)。</p>
</blockquote>
<p>另外，GET方法本身是人畜无害的，Retry请求多次发起不会造成数据错误；但对于POST，涉及到写服务端写操作，最好带上GUID作为单次请求unique标示。（这是server和client之间需要协商好的protocol）</p>
<h2 id="3-From-Java-Code-To-Java-Heap"><a href="#3-From-Java-Code-To-Java-Heap" class="headerlink" title="3. From Java Code To Java Heap"></a>3. From Java Code To Java Heap</h2><p>   A talk from IBM Engineer, talking about optimizing the memery usage for your java application.<a href="https://www.youtube.com/watch?v=FLcXf9pO27w">youtube</a><br>   <a href="https://www.ibm.com/developerworks/java/library/j-codetoheap/index.html">ibm</a></p>
<h2 id="4-强行更改String的内容"><a href="#4-强行更改String的内容" class="headerlink" title="4. 强行更改String的内容"></a>4. 强行更改String的内容</h2><p>  String这种东西是放在常量池里面的，所以<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">String a = <span class="string">"hello"</span></div><div class="line">String b = <span class="string">"hello"</span></div><div class="line">String c = <span class="keyword">new</span> String(<span class="string">"Hello"</span>)</div><div class="line"></div><div class="line">显然ab都指向了常量池，c指向了放在堆上的对象，后者也指向常量池</div><div class="line">a==b!=c  </div><div class="line"></div><div class="line"><span class="comment">//更改这个String里面的东西</span></div><div class="line">Field a_ = String.class.getDeclaredField(<span class="string">"value"</span>);</div><div class="line">      a_.setAccessible(<span class="keyword">true</span>);</div><div class="line">      <span class="keyword">char</span>[] value=(<span class="keyword">char</span>[])a_.get(a);</div><div class="line">      value[<span class="number">3</span>]=<span class="string">'_'</span>;   <span class="comment">//修改a所指向的值</span></div><div class="line"></div><div class="line">这样a,b,c 的值都改掉了</div></pre></td></tr></table></figure></p>
<h2 id="5-注解"><a href="#5-注解" class="headerlink" title="5. 注解"></a>5. 注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Builder(Retrofit retrofit, Method method) &#123;</div><div class="line">     <span class="keyword">this</span>.retrofit = retrofit;</div><div class="line">     <span class="keyword">this</span>.method = method;</div><div class="line">     <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</div><div class="line">     <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class="line">     <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>如果不是看到Retrofit的源码，一般还真没机会了解到这几个方法。。</p>
<h2 id="6-java如何把char类型数据转成int类型数据"><a href="#6-java如何把char类型数据转成int类型数据" class="headerlink" title="6. java如何把char类型数据转成int类型数据"></a>6. java如何把char类型数据转成int类型数据</h2><p>String a = “123”<br>Stirng本质上就是一个char[]的包装类，1对应Asicii码的49,2对应50,3对应51.所以实质上就类似于char[] = new char{49,50,51} ;</p>
<p>想把1,2,3分别拿出来得这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>[] array = a.tocharArray();</div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=array.length();i++)&#123;</div><div class="line">  <span class="keyword">int</span> a = Integer.parseInt(String.valueof(array.charAt(i)));<span class="comment">//这样就能分别把1,2,3拿出来了。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据stackoverFlow的<a href="https://stackoverflow.com/questions/14342988/why-are-we-allowed-to-assign-char-to-a-int-in-java">解释</a>, char只是16bit的数字，也就是int（4个字节,32位）的子集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> word = <span class="string">'A'</span> +<span class="number">1234</span> ;<span class="comment">//编译通过</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> word2 = <span class="string">'A'</span>;</div><div class="line">word2 = word2 +<span class="number">1</span> ;<span class="comment">//编译失败</span></div></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/21317631/java-char-int-conversions">char的转换问题</a></p>
<h2 id="7-Guava就是个Util"><a href="#7-Guava就是个Util" class="headerlink" title="7. Guava就是个Util"></a>7. Guava就是个Util</h2><h2 id="8-从ArrayList的ConcurrentModificationException说起"><a href="#8-从ArrayList的ConcurrentModificationException说起" class="headerlink" title="8. 从ArrayList的ConcurrentModificationException说起"></a>8. 从ArrayList的ConcurrentModificationException说起</h2><p>ArrayList的ConcurrentModificationException一般在使用Iterator的时候会抛出，普通的get，set不会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">       <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">       <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">       <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">      <span class="comment">//简单的三个成员变量，cursor会在外部调用next方法时自增1，在</span></div><div class="line">      <span class="comment">// lastRet 会在调用next时候设置为next方法返回的Value的index，在remove时设置为-1</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//Itr的next 方法只是返回了array[cursor],cursor是从0开始的。</span></div><div class="line">     <span class="comment">// Itr的remove方法调用了ArrayList的remove方法（modeCount++），expectedModCount设置为modCount</span></div><div class="line">     <span class="comment">// 之所以调用Iterator一边迭代一边删除，一方法是hasNext方法检测了当前index不会超出数组大小。另外在remove的时候会将当前Iterator的预期下一个操作位置cursor设置为上一次操作的位置（remove里面还有一个arrayCopy）。</span></div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>假定开了十条线程，每条线程都调用ArrayList的ListIterator，各自得到一个new Itr的实例。而这些Itr的modecount都是从这一个ArrayList拿的，expectedModCount则是各自保存的。一个原则就是，对于这个集合结构性的更改，同时只能有一条线程来做。每条线程的expectedModCount都会在调用ArrayList的remove方法之后被赋值为ArrayList的modCount。next和remove方法开头都调用了这个checkForComodification。就在于next会因为其他线程的结构性更改抛出IndexOutOfBoundsException，但实际上问题并不出在next方法取错了index。同理，remove方法调用的是可能抛出IndexOutOfBoundsException的ArrayList的remove方法，但实际问题并不出在remove传错了对象。Itr本身保存的index是正确的，只是外部环境的变更使得这些index存在多线程条件下的不可靠性。<br>即迭代器对象实例保持了一些对于外界环境的预期，而并发条件下对于集合的结构性更改使得这些必要的预测信息变得不可靠。</p>
<p>ListIterator和Iterator(next,hasNext以及remove)和两个接口，前者在后者的基础上加了一些方法(add,set,remove等方法).</p>
<p>改成CopyOnWriteArrayList为什么就不会崩了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">     <span class="comment">/** Snapshot of the array */</span></div><div class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</div><div class="line">     <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></div><div class="line">     <span class="keyword">private</span> <span class="keyword">int</span> cursor;  </div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>没有了expectedModCount，成员变量就这俩。<br>CopyOnWriteArrayList直接实现List，写操作都用ReentrantLock锁上了，即同时只能有一条线程进行写操作，get没有加锁。<br>private transient volatile Object[] array;<br>注意保存数据的array是volatile的，任何一条线程写的操作都会被所有的读取线程看到(skip了cpu缓存)，set的时候，以set为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">      lock.lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          Object[] elements = getArray();</div><div class="line">          E oldValue = get(elements, index);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (oldValue != element) &#123;</div><div class="line">              <span class="keyword">int</span> len = elements.length;</div><div class="line">              Object[] newElements = Arrays.copyOf(elements, len); <span class="comment">//即CopyOnWrite</span></div><div class="line">              newElements[index] = element;</div><div class="line">              setArray(newElements);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></div><div class="line">              setArray(elements);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> oldValue;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          lock.unlock();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>CopyOnWriteArrayList内部ListIterator直接保存了一份final的之前Array的snapShot，由于是volatile，任何读操作都能读取到实时的array数据。所谓读取是安全的是指读的时候始终读到的是最实时的信息，这个通过volatile 就能保证。写入由于加锁了，所以也是线程安全的。</p>
<h2 id="9-float和long这些相互除法，会出现精确度损失"><a href="#9-float和long这些相互除法，会出现精确度损失" class="headerlink" title="9.float和long这些相互除法，会出现精确度损失"></a>9.float和long这些相互除法，会出现精确度损失</h2><p>6.8040496E7*100/68040488f 会出现1.000001这种东西</p>
<h2 id="10-int居然还可以这么写"><a href="#10-int居然还可以这么写" class="headerlink" title="10. int居然还可以这么写"></a>10. int居然还可以这么写</h2><ul>
<li>int a = 5_372_4323; 下划线只是为了具有更好的可读性，added in java 7</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=6uroXz5l7Gk">Jake Wharton and Jesse Wilson - Death, Taxes, and HTTP</a></li>
<li><a href="https://www.youtube.com/watch?v=tfD2uYjzXFo">Android Tech Talk: HTTP In A Hostile World</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;interesting stuff in java that don’t seem to get enough pubilicity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/34a7d57ccabb18c69d085247cf009b22.jpg?imageView2/2/w/600&quot; alt=&quot;landscape&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>使用Python搭建本地服务器</title>
    <link href="https://haldir65.github.io/2017/06/15/2017-06-15-python-networks/"/>
    <id>https://haldir65.github.io/2017/06/15/2017-06-15-python-networks/</id>
    <published>2017-06-15T15:56:26.000Z</published>
    <updated>2017-07-23T10:43:10.493Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://odzl05jxx.bkt.clouddn.com/c6dd030bf8cc75628fce3aec8216ba52.jpg?imageView2/2/w/600" alt="Kitty"><br>关于如何使用Python搭建后台的方法很多，这里列举出一些实例。<a id="more"></a></p>
<h2 id="1-The-Flask-Way"><a href="#1-The-Flask-Way" class="headerlink" title="1. The Flask Way"></a>1. The Flask Way</h2><h3 id="1-1-Basics"><a href="#1-1-Basics" class="headerlink" title="1.1 Basics"></a>1.1 Basics</h3><blockquote>
<p>Flask is a very simple, but extremely flexible framework Flask使用Decorator对请求进行处理</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python3</div><div class="line"># -*- coding:utf8 -*-</div><div class="line"></div><div class="line">from flask import Flask</div><div class="line">from flask import request</div><div class="line">from flask import jsonify</div><div class="line">from flask import send_file</div><div class="line"></div><div class="line"># create the flask object</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"># 处理GET请求像这样就可以了</div><div class="line"></div><div class="line">@app.route('/', methods=['GET'])</div><div class="line">def handle_get():</div><div class="line">    return 'haha ,this is http status code 200'</div><div class="line"></div><div class="line">#处理POST请求，从request中拿东西，返回response</div><div class="line">@app.route('/', methods=['POST'])</div><div class="line">def handle_post():</div><div class="line">    uid = request.form['uid'] # requets.form是一个list，从里面获取想表单的参数</div><div class="line">    name = request.form['name']</div><div class="line">    print('uid is %s ,name is %s ' % (uid, name))</div><div class="line">    return '200 Ok, or whatever you like'  </div><div class="line"></div><div class="line">if __name__ == '__main__':</div><div class="line">    app.run(port=12345, debug=True) #设置为True后，会自动检测到服务端代码更改并reload，出错了也会给client返回实际的错误堆栈， 生产环境不要打开Debug 。</div><div class="line"></div><div class="line"># 对于GET请求，获得query参数的方式</div><div class="line">http://127.0.0.1:12345/_search_user?user=111&amp;date=190</div><div class="line"></div><div class="line">@app.route('/_search_user', methods=['GET'])</div><div class="line">def query_user_profile():</div><div class="line">    user = request.args.get('user')</div><div class="line">    date = request.args.get('date')</div><div class="line">    print(user)</div><div class="line">    print(date)</div><div class="line">    return 'every Thing Ok'</div><div class="line"></div><div class="line"> 输出</div><div class="line"> 111</div><div class="line"> 190   </div><div class="line"></div><div class="line"> #返回json，作为API</div><div class="line">@app.route('/_get_current_user', methods=['GET'])</div><div class="line">def get_current_user():</div><div class="line">    return jsonify(</div><div class="line">        username='Admin',</div><div class="line">        email='Bob@gmail.com',</div><div class="line">        age=18</div><div class="line">    )    </div><div class="line"></div><div class="line">&#123;</div><div class="line">    username: 'Admin';</div><div class="line">    email: 'Bob@gamil.com';</div><div class="line">    age: 18</div><div class="line">&#125;</div><div class="line"></div><div class="line">#返回复杂一点的json，或者json数组</div><div class="line">@app.route('/_get_user_list', methods=['GET'])</div><div class="line">def get_user_list():</div><div class="line">    user_list = create_user_list()</div><div class="line">    return Response(json.dumps(user_list), mimetype='application/json')</div><div class="line"></div><div class="line"></div><div class="line">#生成数据</div><div class="line">def create_user_list():</div><div class="line">    alice = &#123;'name': 'alice', 'age': 16, 'sex': 'female'&#125;</div><div class="line">    tom = &#123;'name': 'tom', 'age': 23, 'sex': 'male'&#125;</div><div class="line">    josh = &#123;'name': 'josh', 'age': 20, 'sex': 'male'&#125;</div><div class="line">    bill = &#123;'name': 'bill', 'age': 19, 'sex': 'male'&#125;</div><div class="line">    li = [alice, tom, josh, bill]</div><div class="line">    return li</div><div class="line"></div><div class="line"></div><div class="line"># 在Postman中就能获得这样的result</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        "name": "alice",</div><div class="line">        "age": 16,</div><div class="line">        "sex": "female"</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        "name": "tom",</div><div class="line">        "age": 23,</div><div class="line">        "sex": "male"</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        "name": "josh",</div><div class="line">        "age": 20,</div><div class="line">        "sex": "male"</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        "name": "bill",</div><div class="line">        "age": 19,</div><div class="line">        "sex": "male"</div><div class="line">    &#125;</div><div class="line">]</div><div class="line"></div><div class="line"># hosting static file，image,css,etc</div><div class="line"># 提供图片什么的</div><div class="line"></div><div class="line">@app.route('/_get_image', methods=['GET'])</div><div class="line">def get_image():</div><div class="line">    filename = 'static/image/b1.jpg'</div><div class="line">    fullpath = os.path.join(os.path.curdir, filename)</div><div class="line">    print(filename, fullpath)</div><div class="line">    return send_file(fullpath, mimetype='image/jpeg')</div></pre></td></tr></table></figure>
<p>我觉得Flask的官方Doc对初学者的友好度几乎是满分</p>
<ul>
<li><a href="http://flask.pocoo.org/docs/0.12/quickstart/#accessing-request-data">accessing-request-data</a></li>
<li><a href="http://flask.pocoo.org/docs/0.12/quickstart/#cookies">cookies</a></li>
<li><a href="http://flask.pocoo.org/docs/0.12/quickstart/#sessions">sessions</a></li>
<li><a href="http://flask.pocoo.org/docs/0.12/quickstart/#static-files">static files</a><br>所有的静态文件必须放在当前目录下的static目录中，里面可以再创建image，css,404.html等文件<br>另外，如果要调试接口的话，用Postman吧，比Fiddler简单点<br>返回response的时候一定要指明mime-type，或者content-type<br>text/html、text/css、application/json什么的，<a href="http://www.runoob.com/http/http-content-type.html">详细的http-content-type表格</a><br>关于content-type,找到一篇<a href="http://homeway.me/2015/07/19/understand-http-about-content-type/">介绍</a><br>关于Http header常用字段<a href="http://zq210wl.github.io/2014/12/30/html-http-header-analysis/">理解Http Header</a><br>Http底层TCP ,ACK 等等需要tcpcump结合wireShark抓包</li>
</ul>
<blockquote>
<p>下面是几个常见的Content-Type:<br>1.text/html<br>2.text/plain<br>3.text/css<br>4.text/javascript<br>5.application/x-www-form-urlencoded<br>6.multipart/form-data<br>7.application/json<br>8.application/xml<br>…<br>前面几个都很好理解，都是html，css，javascript的文件类型，后面四个是POST的发包方式。</p>
</blockquote>
<h3 id="1-2-Flask-BluePrints"><a href="#1-2-Flask-BluePrints" class="headerlink" title="1.2 Flask BluePrints"></a>1.2 Flask BluePrints</h3><h3 id="1-3-Flask-gevent-提高web-框架的性能"><a href="#1-3-Flask-gevent-提高web-框架的性能" class="headerlink" title="1.3 Flask + gevent 提高web 框架的性能"></a>1.3 Flask + gevent 提高web 框架的性能</h3><p><a href="http://flask.pocoo.org/docs/0.12/deploying/wsgi-standalone/">docs</a></p>
<h3 id="2-The-Django-Way"><a href="#2-The-Django-Way" class="headerlink" title="2. The Django Way"></a>2. The Django Way</h3><p>Django是<strong>web framework</strong>，不是<strong>WebServer</strong></p>
<h2 id="3-Using-Tornado"><a href="#3-Using-Tornado" class="headerlink" title="3. Using Tornado"></a>3. Using Tornado</h2><h2 id="4-其他的点"><a href="#4-其他的点" class="headerlink" title="4. 其他的点"></a>4. 其他的点</h2><h3 id="4-1-Web架构"><a href="#4-1-Web架构" class="headerlink" title="4.1 Web架构"></a>4.1 Web架构</h3><p>网络库上手比较快，很重要的一点是理解其在通讯中的层级，Nigix属于代理转发，Flask处理业务逻辑，Tornado处理Http底层实现，Django负责用于高效网络应用开发</p>
<ul>
<li><a href="https://www.zhihu.com/question/41564604">Django和Flask这两个框架在设计上各方面有什么优缺点？
</a></li>
</ul>
<p>UrlLib，Socket这些属于Python底层的基础性的network库，属于基础的东西。</p>
<h3 id="4-2不服跑个分"><a href="#4-2不服跑个分" class="headerlink" title="4.2不服跑个分"></a>4.2不服跑个分</h3><p>引用一篇<a href="http://www.vimer.cn/archives/2926.html">测评</a></p>
<blockquote>
<p>可见纯框架自身的性能为:</p>
</blockquote>
<pre><code>bottle &gt; flask &gt; tornado &gt; django
</code></pre><p>结合实际使用:</p>
<pre><code>tornado 使用了异步驱动，所以在写业务代码时如果稍有同步耗时性能就会急剧下降；
bottle需要自己实现的东西太多，加上之后不知道性能会怎样；
flask性能稍微差点，但周边的支持已经很丰富了；
django就不说了，性能已经没法看了，唯一的好处就是开发的架子都已经搭好，开发速度快很多
</code></pre><p>当然这些框架不是纯粹一个功能层面上的东西，可能有所偏差。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li>xxxx</li>
<li>xxxx</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/c6dd030bf8cc75628fce3aec8216ba52.jpg?imageView2/2/w/600&quot; alt=&quot;Kitty&quot;&gt;&lt;br&gt;关于如何使用Python搭建后台的方法很多，这里列举出一些实例。
    
    </summary>
    
      <category term="blog" scheme="https://haldir65.github.io/categories/blog/"/>
    
    
      <category term="python" scheme="https://haldir65.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>jvm架构概述</title>
    <link href="https://haldir65.github.io/2017/05/24/2017-05-24-jvm-architecture/"/>
    <id>https://haldir65.github.io/2017/05/24/2017-05-24-jvm-architecture/</id>
    <published>2017-05-24T14:48:58.000Z</published>
    <updated>2017-07-28T23:49:48.666Z</updated>
    
    <content type="html"><![CDATA[<p>关于jvm运行的大致架构，最近找到一个比较合适的视频，记录要点如下<br><img src="http://odzl05jxx.bkt.clouddn.com/high_way_scene.jpg?imageView2/2/w/600" alt=""><br><a id="more"></a></p>
<h2 id="1-从MyApp-java文件开始"><a href="#1-从MyApp-java文件开始" class="headerlink" title="1.从MyApp.java文件开始"></a>1.从MyApp.java文件开始</h2><p>大家都知道最开始学习Java的时候，要用javac 来编译MyApp.java来生成一个class文件。<br>在命令行里，大致是这样的执行顺序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">javac MyApp.java</div><div class="line">java MyApp</div></pre></td></tr></table></figure></p>
<p><strong> 实际上后一句话就创建了一个jvm instance.</strong></p>
<h2 id="2-从class-loader进入Execution-Engine-再到Host-Operating-System"><a href="#2-从class-loader进入Execution-Engine-再到Host-Operating-System" class="headerlink" title="2. 从class loader进入Execution Engine 再到Host Operating System"></a>2. 从class loader进入Execution Engine 再到Host Operating System</h2><p>java MyApp会调用class loader，后者不仅要负责加载MyApp.class文件，还需要加载java API中的class文件（String,Object,Collection….）。加载的class文件（byte code）被传递给Execution Engine,后者则负责执行byte code（其实也是调用宿主操作系统的方法执行操作）</p>
<h2 id="3-where-did-class-loader-load-class-into"><a href="#3-where-did-class-loader-load-class-into" class="headerlink" title="3. where did class loader load class into ?"></a>3. where did class loader load class into ?</h2><p>classloader将class 文件加载进内存中的一部分（Runtime data areas）。到此，jvm architecture的三个主要组件：class loader subsystem,Runtime data areas 以及execution Enigne的主要功能都说清楚了。<br>所以，这篇文章主要就按照class loader subsystem -&gt; Runtime data areas -&gt; Execution Engine的顺序来讲。</p>
<h2 id="4-从classloader开始执行（class-loading-subsystem）"><a href="#4-从classloader开始执行（class-loading-subsystem）" class="headerlink" title="4.从classloader开始执行（class loading subsystem）"></a>4.从classloader开始执行（class loading subsystem）</h2><pre><code>- load 将byte code 加载进内存，来源可以是.java文件，可以是.jar文件，甚至可以是network Socket（这要看具体class loader的implementation）。load阶段包含三种不同的class loader，这也是面试时的重点。

&gt; 1. Bootstrap class loader (jre文件夹中有一个rt.jar文件，里面装的就是java的internal class) //

&gt; 2. extension class loader (jre/lib/ext) //负责加载这个文件夹中的class文件

&gt; 3. Application class loader (CLASSPATH, -cp)//加载CLASSPATH变量中描述的位置

- load完成后是link
verify(检查是否是符合jvm标准的byte code) -&gt; prepare(为class中的static variable分配内存，variable被赋默认值) -&gt; Resolve(when all the symbolic reference inside currentclass are resolved，例如引用了其他的class，例如引用了常量池里面的东西，classDefNotFoundException也是在这个时候抛出的)

注意，以上步骤都是java specification所规定的，但不同的jvm实现可能有微小的差异
</code></pre><p>class loading subsystem的最后一步是initialize<br>class vars to initiazed Value in code(比如静态代码块就是在这时执行的)</p>
<h2 id="5-Runtime-data-area五个部分的划分"><a href="#5-Runtime-data-area五个部分的划分" class="headerlink" title="5. Runtime data area五个部分的划分"></a>5. Runtime data area五个部分的划分</h2><p>Runtime data area 即java virtural machine的内存，可以划分成五部分<br>    //per jvm ,shared by all threads</p>
<pre><code>- Method Area
- Heap

// per thread
- java stack
- pc Registers
- Native method stacks
</code></pre><h3 id="1-Method-Area-方法区，用于存储class的数据，static-variable-byte-code-class-level-constant-pool都放在这里-，Method-Area也称为Perm-gen-space-永生代-，默认大小是64MB-，可以通过-XX-MaxPermSize-调节-。这里有可能抛出out-of-memory-error。"><a href="#1-Method-Area-方法区，用于存储class的数据，static-variable-byte-code-class-level-constant-pool都放在这里-，Method-Area也称为Perm-gen-space-永生代-，默认大小是64MB-，可以通过-XX-MaxPermSize-调节-。这里有可能抛出out-of-memory-error。" class="headerlink" title="1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)    ，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。"></a>1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)    ，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。</h3><h3 id="java8将method-Area移除，改为-metaspace-就是将method-area移到了Native-Memory，这样就不会有限制了，也可以人为设置上限"><a href="#java8将method-Area移除，改为-metaspace-就是将method-area移到了Native-Memory，这样就不会有限制了，也可以人为设置上限" class="headerlink" title="java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)"></a>java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)</h3><h3 id="2-Heap"><a href="#2-Heap" class="headerlink" title="2. Heap"></a>2. Heap</h3><p>日常开发中new出来的东西都放在这里</p>
<p>-Xms , minimun size<br>-Xmx , maximum size</p>
<h3 id="3-Java-Stack"><a href="#3-Java-Stack" class="headerlink" title="3. Java Stack"></a>3. Java Stack</h3><p>java stacks contains stack frames of the current execution per thread.<br>eg : method a -&gt; 调用 method b -&gt; 调用method c<br>当前线程的方法栈中就会push三个stack frame(每个Frame对应一个方法的执行环境)<br>stack Frame包含当前方法中的变量，以及返回值，etc<br>这里定义了stackoverFlowError</p>
<h3 id="4-pc-Registers"><a href="#4-pc-Registers" class="headerlink" title="4. pc Registers"></a>4. pc Registers</h3><p>这里面装的是程序计数器，后者是指向下一个将要被执行的指令的指针（每条线程都有）。</p>
<h3 id="5-Native-method-stacks"><a href="#5-Native-method-stacks" class="headerlink" title="5. Native method stacks"></a>5. Native method stacks</h3><p>Native method stacks 是由java stack中的方法调用native方法创建的，例如windows上的dll库</p>
<h2 id="6-Execution-Engine的任务"><a href="#6-Execution-Engine的任务" class="headerlink" title="6. Execution Engine的任务"></a>6. Execution Engine的任务</h2><p><img src="http://odzl05jxx.bkt.clouddn.com/starry_sky.jpg?imageView2/2/w/500" alt=""></p>
<pre><code>- Interpreter 将byte code 翻译成机器指令并执行(根据指令去调用Native方法，在windows上jre/bin/文件夹中一大堆的dll就是windows平台提供的Native库，在linux上是.so文件)

- JIT Compiler  just in time compiler（如果有某项byte code instruction被多次调用，这些byte code不会每次都被inteprete，JIT will hold on to that system level target machine code for future usage,which is fast）
- Hotspot profiler(it helps the JIT Compiler analysise the frequently used byte codess)
- GC (a lengthy talk)
</code></pre><p>调用Native Method Interface(JNI) -&gt; Native method libraries（.dll,.so etc）</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.youtube.com/watch?v=ZBJ0u9MaKtM">JVM ( java virtual machine) architecture - tutorial</a><br><a href="http://www.cnblogs.com/zhguang/p/3257367.html">Java系列笔记(3) - Java 内存区域和GC机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于jvm运行的大致架构，最近找到一个比较合适的视频，记录要点如下&lt;br&gt;&lt;img src=&quot;http://odzl05jxx.bkt.clouddn.com/high_way_scene.jpg?imageView2/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="https://haldir65.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="https://haldir65.github.io/tags/jvm/"/>
    
  </entry>
  
</feed>
