<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haldir的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haldir65.github.io/"/>
  <updated>2018-12-23T14:52:16.296Z</updated>
  <id>https://haldir65.github.io/</id>
  
  <author>
    <name>Haldir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo部署个人博客记录</title>
    <link href="https://haldir65.github.io/2217/01/08/2017-01-08-trouble-shooting-with-my-blog/"/>
    <id>https://haldir65.github.io/2217/01/08/2017-01-08-trouble-shooting-with-my-blog/</id>
    <published>2217-01-08T18:01:01.000Z</published>
    <updated>2018-12-23T14:52:16.296Z</updated>
    
    <content type="html"><![CDATA[<p>使用 hexo 写博客以来，记录下来的问题越来越多。只希望下次再碰到同样的问题时，不要再去浪费时间去查找。如果想要给自己的 blog 一个值得置顶的文章的话，我觉得一篇记录使用 hexo 过程中的一些解决问题的方法的文章是再合适不过的了。</br><br><img src="https://haldir66.ga/static/imgs/40164340_40164340_1414330224938_mthumb.jpg" alt=""></p><a id="more"></a><h2 id="1-经常更新-yilia-的-theme"><a href="#1-经常更新-yilia-的-theme" class="headerlink" title="1. 经常更新 yilia 的 theme"></a>1. 经常更新 yilia 的 theme</h2><p><a href="https://github.com/litten/hexo-theme-yilia">yilia</a>主题经常会更新，及时更新 theme 会发现很多新的特性及 bug fix</p><h2 id="2-部署相关"><a href="#2-部署相关" class="headerlink" title="2. 部署相关"></a>2. 部署相关</h2><ul><li>部署到 github</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">//清除缓存</span></span><br><span class="line">hexo g -d <span class="comment">//一步到位 = hexo g + hexo d</span></span><br><span class="line">hexo s <span class="comment">//localost:4000本地预览</span></span><br></pre></td></tr></table></figure><ul><li>部署过程中出现的一些错误</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br><span class="line">INFO  Start processing</span><br><span class="line">ERROR Process failed: _posts/<span class="number">2016</span><span class="number">-12</span><span class="number">-10</span>-adb-command.md</span><br><span class="line">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line <span class="number">3</span>, column <span class="number">11</span>:</span><br><span class="line">    categories:  [技术]</span><br><span class="line">              ^</span><br><span class="line">    at generateError (D:\Blog\github\node_modules\hexo\node_modules\js-yaml\lib\js-yaml\loader.js:<span class="number">162</span>:<span class="number">10</span>)</span><br><span class="line">    at throwError (D:\Blog\github\node_modules\hexo\node_modules\js-yaml\lib\js-yaml\loader.js:<span class="number">168</span>:<span class="number">9</span>)</span><br><span class="line">    at readBlockMapping (D:\Blog\github\node_modules\hexo\node_modules\js-yaml\lib\js-yaml\loader.js:<span class="number">1040</span>:<span class="number">9</span>)</span><br><span class="line">    at composeNode (D:\Blog\github\node_modules\hexo\node_modules\js-yaml\lib\js-yaml\loader.js:<span class="number">1326</span>:<span class="number">12</span>)</span><br><span class="line">    at readDocument (D:\Blog\github\node_modules\hexo\node_modules\js-yaml\lib\js-yaml\loader.js:<span class="number">1488</span>:<span class="number">3</span>)</span><br><span class="line">    at loadDocuments (D:\Blog\github\node_modules\hexo\node_modules\js-yaml\lib\js-yaml\loader.js:<span class="number">1544</span>:<span class="number">5</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.load (D:\Blog\github\node_modules\hexo\node_modules\js-yaml\lib\js-yaml\loader.js:<span class="number">1561</span>:<span class="number">19</span>)</span><br><span class="line">    at parseYAML (D:\Blog\github\node_modules\hexo\node_modules\hexo-front-matter\lib\front_matter.js:<span class="number">80</span>:<span class="number">21</span>)</span><br><span class="line">    at parse (D:\Blog\github\node_modules\hexo\node_modules\hexo-front-matter\lib\front_matter.js:<span class="number">56</span>:<span class="number">12</span>)</span><br><span class="line">    at D:\Blog\github\node_modules\hexo\lib\plugins\processor\post.js:<span class="number">52</span>:<span class="number">18</span></span><br><span class="line">    at tryCatcher (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\util.js:<span class="number">16</span>:<span class="number">23</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromiseFromHandler (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">507</span>:<span class="number">35</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">567</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise0 (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">612</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromises (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">691</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._fulfill (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">636</span>:<span class="number">18</span>)</span><br><span class="line">    at PromiseArray._resolve (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise_array.js:<span class="number">125</span>:<span class="number">19</span>)</span><br><span class="line">    at PromiseArray._promiseFulfilled (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise_array.js:<span class="number">143</span>:<span class="number">14</span>)</span><br><span class="line">    at PromiseArray._iterate (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise_array.js:<span class="number">113</span>:<span class="number">31</span>)</span><br><span class="line">    at PromiseArray.init [<span class="keyword">as</span> _init] (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise_array.js:<span class="number">77</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">564</span>:<span class="number">21</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise0 (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">612</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromises (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">691</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._fulfill (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">636</span>:<span class="number">18</span>)</span><br><span class="line">    at PromiseArray._resolve (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise_array.js:<span class="number">125</span>:<span class="number">19</span>)</span><br><span class="line">    at PromiseArray._promiseFulfilled (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise_array.js:<span class="number">143</span>:<span class="number">14</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">572</span>:<span class="number">26</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise0 (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">612</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromises (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">691</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._fulfill (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">636</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._resolveCallback (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">431</span>:<span class="number">57</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromiseFromHandler (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">522</span>:<span class="number">17</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">567</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromise0 (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">612</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._settlePromises (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">691</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Promise</span>._fulfill (D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">636</span>:<span class="number">18</span>)</span><br><span class="line">    at D:\Blog\github\node_modules\hexo\node_modules\bluebird\js\release\nodeback.js:<span class="number">42</span>:<span class="number">21</span></span><br><span class="line">    at D:\Blog\github\node_modules\hexo\node_modules\hexo-fs\node_modules\graceful-fs\graceful-fs.js:<span class="number">78</span>:<span class="number">16</span></span><br><span class="line">    at tryToString (fs.js:<span class="number">455</span>:<span class="number">3</span>)</span><br><span class="line">    at FSReqWrap.readFileAfterClose [<span class="keyword">as</span> oncomplete] (fs.js:<span class="number">442</span>:<span class="number">12</span>)</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> <span class="number">1.48</span> s</span><br><span class="line">INFO  Generated: sitemap.xml</span><br><span class="line">INFO  Generated: atom.xml</span><br><span class="line">INFO  Generated: <span class="number">2017</span>/<span class="number">01</span>/<span class="number">08</span>/<span class="number">2017</span><span class="number">-01</span><span class="number">-08</span>-trouble-shooting-<span class="keyword">with</span>-my-blog/index.html</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">INFO  <span class="number">4</span> files generated <span class="keyword">in</span> <span class="number">2.26</span> s</span><br><span class="line">INFO  Deploying: git</span><br></pre></td></tr></table></figure><p>找了好久，有说”_config.xml” 文件 有空格的，有说 title 被乱改的，试了好长时间，改成这样就不再报错了。所以，<strong>冒号后面一定要加空格，英文半角的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: adb常用命令手册</span><br><span class="line">date: 2016-12-10 21:14:14</span><br><span class="line">tags:</span><br><span class="line"> - android</span><br><span class="line"> - adb</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>tags 有两种写法，一种是上面这样前面加横杠另一种长这样，写成数组形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: my awesometitle</span><br><span class="line">date: 2017-05-07 16:48:01</span><br><span class="line">categories: blog</span><br><span class="line">tags: [linux,python]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="3-一些功能的实现"><a href="#3-一些功能的实现" class="headerlink" title="3. 一些功能的实现"></a>3. 一些功能的实现</h2><ul><li>置顶功能将 node_modules/hexo-generator-index/lib/generator.js 的文件内容替换成以下内容</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">"hexo-pagination"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.top &amp;&amp; b.top) &#123;</span><br><span class="line">      <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">      <span class="keyword">if</span> (a.top == b.top)</span><br><span class="line">        <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">      <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">"page"</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">""</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">"index"</span>, <span class="string">"archive"</span>],</span><br><span class="line">    format: paginationDir + <span class="string">"/%d/"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>同时在文章开头添加 top : 1 即可 ，实际排序按照这个数字从大到小排序</li></ul><p>另一种做法是手动将date改大，日期越靠后的越在前面。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> title: Hexo置顶文章</span><br><span class="line">date: <span class="number">2016</span>-<span class="number">11</span>-<span class="number">11</span> <span class="number">23</span>:<span class="number">26</span>:<span class="number">22</span></span><br><span class="line">tags:[置顶]</span><br><span class="line">categories: Hexo</span><br><span class="line">top: 0 # 0或者1</span><br></pre></td></tr></table></figure><p>个人建议：置顶不要太多</p><h2 id="4-SublimeText-的一些快捷键"><a href="#4-SublimeText-的一些快捷键" class="headerlink" title="4. SublimeText 的一些快捷键"></a>4. SublimeText 的一些快捷键</h2><p>由于文章大部分都是使用 SublimeText 写的，Typroa 这种所见即所得的编辑器也不错，但对于掌握 MardkDown 语法没有帮助。这里摘录一些 SubLimeText 的快捷键。</p><blockquote><p><strong>Ctrl+Shift+P：打开命令面板</strong><br>Ctrl+P：搜索项目中的文件<br>Ctrl+G：跳转到第几行<br>Ctrl+W：关闭当前打开文件 CTRL+F4 也可以<br>Ctrl+Shift+W：关闭所有打开文件<br>Ctrl+Shift+V：粘贴并格式化<br>Ctrl+D：选择单词，重复可增加选择下一个相同的单词<br><strong>Ctrl+L：选择行，重复可依次增加选择下一行</strong><br><strong>Alt+Shift+数字：分屏显示</strong><br><strong>Ctrl+Shift+L：选择多行</strong><br><strong>Ctrl+Shift+D：复制粘贴当前行</strong><br><strong>Ctrl+X：删除当前行</strong><br><strong>Ctrl+Shift+左箭头 往左边选择内容</strong><br><strong>Shift+向左箭头 向左选择文本</strong><br><strong>Ctrl+B 编译，markDown 生成 html 文件</strong><br><strong>Alt+2 切换到第二个 Tab（打开的文件，记得 chrome 是 ctrl+2）</strong><br><strong>Ctrl+R：前往 对应的方法的实现*</strong><br><strong>快速加上[] 选中单词按 [ 即可</strong><br><strong>批量更改当前页面相同的单词 alt+F3 </strong><br><strong>Ctrl+Enter 在下一行插入新的一行</strong><br><strong>Ctrl+Shift+Enter 在上一行插入新的一行</strong><br><strong>Shift+ 向上箭头 向上选中多行</strong></p></blockquote><p>Ctrl+Shift+D：复制粘贴当前行 Ctrl+Shift+Enter：在当前行前插入新行<br>Ctrl+M：跳转到对应括号<br>Ctrl+U：软撤销，撤销光标位置<br>Ctrl+J：选择标签内容<br>Ctrl+F：查找内容<br>Ctrl+Shift+F：查找并替换<br>Ctrl+H：替换<br>Ctrl+N：新建窗口<br>Ctrl+K+B：开关侧栏<br>Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身<br>Ctrl+F2：设置/删除标记<br>Ctrl+/：注释当前行<br>Ctrl+Shift+/：当前位置插入注释<br>Ctrl+Alt+/：块注释，并 Focus 到首行，写注释说明用的<br>Ctrl+Shift+A：选择当前标签前后，修改标签用的<br>F11：全屏<br>Shift+F11：全屏免打扰模式，只编辑当前文件<br>Alt+F3：选择所有相同<br>Alt+.：闭合标签<br>Shift+右键拖动：光标多不，用来更改或插入列内容<br>Alt+数字：切换打开第 N 个文件鼠标的前进后退键可切换 Tab 文件按 Ctrl，依次点击或选取，可需要编辑的多个位置按 Ctrl+Shift+上下键，可替换行</p><p>vscode的快捷键最重要的一个是ctrl+shift+p,ctrl+p只是在全局查找文件</p><h2 id="5-title-不能以-开头"><a href="#5-title-不能以-开头" class="headerlink" title="5. title 不能以[]开头"></a>5. title 不能以[]开头</h2><p>前面加上###确实能够让字号变大，但不要写 4 个#，后面的字母会大小写不分的</p><h2 id="6-markdown-语法"><a href="#6-markdown-语法" class="headerlink" title="6. markdown 语法"></a>6. markdown 语法</h2><p>MarkDown 页面内部跳转<br><a href="http://www.cnblogs.com/JohnTsai/p/4027229.html">MarkDown 技巧：两种方式实现页内跳转</a></p><blockquote><p><em>一个星星包起来是斜体字</em><br><strong>两个星星包起来是粗体字</strong><br><strong><em><em>那么三个星星呢</em></em></strong></p></blockquote><h2 id="7-github-提交-commit-的时候显示-Emoji"><a href="#7-github-提交-commit-的时候显示-Emoji" class="headerlink" title="7.github 提交 commit 的时候显示 Emoji"></a>7.github 提交 commit 的时候显示 Emoji</h2><p>链接<a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/">在此</a></p><h2 id="8-换电脑了怎么办"><a href="#8-换电脑了怎么办" class="headerlink" title="8.换电脑了怎么办"></a>8.换电脑了怎么办</h2><p>亲测，把整个目录下所有文件全部复制粘贴到新电脑上，装上 node，然后装上 hexo，记得勾选添加到 PATH,然后就可以了。需要注意的是小文件比较多，所以复制粘贴可能要十几分钟。</p><h2 id="9-有时候写的代码会给你在每一行前面加上-true"><a href="#9-有时候写的代码会给你在每一行前面加上-true" class="headerlink" title="9. 有时候写的代码会给你在每一行前面加上 true"></a>9. 有时候写的代码会给你在每一行前面加上 true</h2><p>比如写一段 css 的代码时候，很多时候预览会给每一行前面加上一个 true，解决办法：用 TAB 键缩进即可</p><h2 id="10-markdown-live-是一个非常好用的-node-module"><a href="#10-markdown-live-是一个非常好用的-node-module" class="headerlink" title="10. markdown-live 是一个非常好用的 node module"></a>10. markdown-live 是一个非常好用的 node module</h2><p><a href="https://www.npmjs.com/package/markdown-live">项目地址</a><br><strong>前提是安装了 node</strong></p><blockquote><p>npm install -g markdown-live</p><p>md-live</p></blockquote><p><br><br><strong><em>编辑md文件的同时，保存就会同步刷新网页预览，非常好用</em></strong></p><h2 id="11-如果运行-hexo-g-生成的-index-html-是空的"><a href="#11-如果运行-hexo-g-生成的-index-html-是空的" class="headerlink" title="11. 如果运行 hexo g 生成的 index.html 是空的"></a>11. 如果运行 hexo g 生成的 index.html 是空的</h2><p>输出</p><blockquote><p>WARN No layout: tags/service/index.html<br>原因是 themes/文件夹下没有 clone 对应的主题</p></blockquote><p>换成travis之后，在travis.yml文件中，添加了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache:</span><br><span class="line">  yarn: true</span><br><span class="line">  directories:</span><br><span class="line">  - node_modules</span><br><span class="line">  - themes</span><br></pre></td></tr></table></figure></p><p>cahe也就意味着后续，所有对于themes文件夹中的_config.yml文件的修改都不会生效。这也就是我一遍遍尝试更改theme文件夹中_config文件不生效的原因。<br>所以要么去掉cache ，要么自己写bash script一行行的改。</p><h2 id="12-markdown写表格"><a href="#12-markdown写表格" class="headerlink" title="12. markdown写表格"></a>12. markdown写表格</h2><p>直接在atom下面敲table，就会自动提示出来的</p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td>短文本</td><td>中等文本</td><td>稍微长一点的文本</td></tr><tr><td>稍微长一点的文本</td><td>短文本</td><td>中等文本</td></tr></tbody></table><p>中间的虚线左边的冒号表示下面的单元格左对齐，冒号放右边就右对齐，左右都放一个就表示居中</p><p>vscode的返回上一个文件快捷键是ctrl + -</p><h2 id="13-travis-ci自动部署的一些问题"><a href="#13-travis-ci自动部署的一些问题" class="headerlink" title="13 . travis ci自动部署的一些问题"></a>13 . travis ci自动部署的一些问题</h2><p><a href="https://github.com/travis-ci/travis.rb/issues/437">travis ci加密文件无法在travis以外的地方解密，因为key,value都存在travis的数据库了</a></p><p><a href="https://github.com/travis-ci/travis-ci/issues/9668">travis加密文件后用openssl解密出现iv undefined的错误</a></p><p>iv undefined</p><blockquote><p>travis env list<br>encrypted_476ad15a8e52_key=[secure]<br>encrypted_476ad15a8e52_iv=[secure]<br>明明是存在的</p></blockquote><p>在linux 里面运行travis endpoint<br>果然是 API endpoint: <a href="https://api.travis-ci.org/">https://api.travis-ci.org/</a><br>而新的endpoint应该是 <a href="https://api.travis-ci.com/">https://api.travis-ci.com/</a><br>于是travis encrypt-file –help</p><blockquote><p>–pro  short-cut for –api-endpoint ‘<a href="https://api.travis-ci.com/">https://api.travis-ci.com/</a>‘<br>–org short-cut for –api-endpoint ‘<a href="https://api.travis-ci.org/">https://api.travis-ci.org/</a>‘</p></blockquote><p>所以</p><blockquote><p>travis encrypt-file super_secret.txt 应该改成<br>travis encrypt-file super_secret.txt –pro</p></blockquote><p>因为默认的$encrypted_476ad15a8e52_key其实已经存储在travis-ci.org上了<br>所以在travis-ci.com上的项目当然找不到</p><p><a href="https://github.com/openwrtio/openwrtio.github.io/blob/mkdocs/.travis.yml">自动部署的另一个实例</a></p><h2 id="14-hexo-server本地预览出现的问题"><a href="#14-hexo-server本地预览出现的问题" class="headerlink" title="14. hexo server本地预览出现的问题"></a>14. hexo server本地预览出现的问题</h2><p><a href="Refused to execute script from" title="http://localhost:4000/slider.e37972.js&#39; because its MIME type (&#39;text/html">hexo s 本地预览样式加载失败</a> is not executable, and strict MIME type checking is enabled.)</p><p>hexo server的意思是类似于express的serve static功能，<a href="https://hexo.io/zh-cn/docs/server.html">默认只处理public文件下的文件，所以如果本地运行hexo s 出现404的话，直接copy到public文件夹下就可以了</a>注意hexo clear会删掉public文件夹</p><p>[Refused to Execute Script From Because Its MIME Type (Text/plain) Is Not Executable, and Strict MIME Type Checking Is Enabled]这句话的意思</p><h2 id="15-yilia的主题里面badjs-report的问题"><a href="#15-yilia的主题里面badjs-report的问题" class="headerlink" title="15. yilia的主题里面badjs report的问题"></a>15. yilia的主题里面badjs report的问题</h2><p>yilia的主题里面有一个badjs的report，去掉的方法：<br>cd 到themes/yilia里面,rm -rf source/ , 然后把source-src里面的report.js里面的东西删掉。yarn install ,yarn dist ,然后回到上层目录。hexo clean , hexo g就可以了。<br>其实看下里面，就是一个webpack的配置，自己重新编译一下就好了。编译后会在source里面重新生成需要的js文件。<br>奇怪的是在windows上编译失败，在linux上编译失败，在mac上终于成功了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://yanhuili.github.io/2016/11/21/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%8A%80%E5%B7%A7/">Hexo 博文置顶技巧</a></li><li><a href="http://www.daqianduan.com/4820.html">SublimeText 快捷键</a></li><li><a href="http://itmyhome.com/markdown/article/syntax/emphasis.html">MarkDown 语法学起来很快的</a></li><li><a href="https://blessing.studio/deploy-hexo-blog-automatically-with-travis-ci/">travis 自动部署</a></li><li><a href="https://docs.travis-ci.com/user/legacy-services-to-github-apps-migration-guide/">Legacy GitHub Services to GitHub Apps Migration Guide 2018年10月1号之后不再支持 Legacy GitHub Service</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 hexo 写博客以来，记录下来的问题越来越多。只希望下次再碰到同样的问题时，不要再去浪费时间去查找。如果想要给自己的 blog 一个值得置顶的文章的话，我觉得一篇记录使用 hexo 过程中的一些解决问题的方法的文章是再合适不过的了。&lt;/br&gt;&lt;br&gt;&lt;img src=&quot;https://haldir66.ga/static/imgs/40164340_40164340_1414330224938_mthumb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://haldir65.github.io/categories/blog/"/>
    
    
      <category term="hexo" scheme="https://haldir65.github.io/tags/hexo/"/>
    
      <category term="置顶" scheme="https://haldir65.github.io/tags/%E7%BD%AE%E9%A1%B6/"/>
    
  </entry>
  
  <entry>
    <title>即刻备忘录</title>
    <link href="https://haldir65.github.io/2046/12/18/2017-12-18-random-new-thoughts/"/>
    <id>https://haldir65.github.io/2046/12/18/2017-12-18-random-new-thoughts/</id>
    <published>2046-12-18T22:58:14.000Z</published>
    <updated>2018-12-23T14:52:16.304Z</updated>
    
    <content type="html"><![CDATA[<p>一个待办事项的仓库<br><img src="https://haldir66.ga/static/imgs/girlfriend lake green nature water cold.jpg" alt=""></p><a id="more"></a><h3 id="期待能够完成的"><a href="#期待能够完成的" class="headerlink" title="期待能够完成的"></a>期待能够完成的</h3><ul><li><a href="https://juejin.im/post/5a0c1956f265da430a501f51">个人分享–web 前端学习资源分享</a></li><li><a href="https://huangxuan.me/2017/02/09/nextgen-web-pwa/">WPA 所代表的 Web 开发应是未来</a>据说Electron要被PWA干掉</li><li><a href="https://segmentfault.com/a/1190000003818163">js 循环闭包的解决方法</a></li><li>动态类型一时爽，代码重构火葬场</li><li>iview，elementUi</li><li>[ ] rxjava是如何切换线程的以及源码解析</li><li>[ ] shadowsocks-android源码</li><li>[ ] chromium net移植到Android平台<a href="https://github.com/GoogleChromeLabs/cronet-sample">cronet是最简单的方式</a> <a href="https://console.cloud.google.com/storage/browser/chromium-cronet?pli=1">更多下载仓库</a></li><li><a href="https://css-tricks.com/NetMag/FluidWidthVideo/Article-FluidWidthVideo.php">embeed video with iframe</a><a href="https://www.youtube.com/watch?v=g3F7Imjcd4k">AC2016腾讯前端技术大会 1 1 1 H5直播那些事</a></li><li>[ ] flex,grid</li><li>[ ] Paul Irish from google</li><li>[ ] <a href="http://lokeshdhakar.com/projects/lightbox2/">lightbox一个很好看的js图片查看库</a></li><li>[ ] <a href="https://www.js-css.cn/a/jscode/album/2014/0915/1319.html">仿门户网站js相册</a>， <a href="https://www.js-css.cn/a/jscode/album/2014/0914/1318.html">js相册2</a></li><li>[ ] <a href="http://python.jobbole.com/82270/">八大排序算法的python实现</a></li><li>[ ] <a href="https://gist.github.com/quexer/3619237">如何编写 jQuery 插件</a></li><li>[ ] Redux和Flux很像,react context api</li><li>[ ] <a href="https://www.jianshu.com/p/a4ab102fa4ac">一个展示如何在宿主App中提取一个apk文件并加载代码和资源</a></li><li>[ ] nodejs ,go ,protobuf rpc</li><li>[ ] <a href="https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within?rq=1">在bash脚本中获取当前脚本所在路径</a></li><li>[ ]一致性哈希原理</li><li>[ ] <a href="http://afghl.github.io/2018/06/17/distributed-lock-and-granarity.html">使用redis实现低粒度的分布式锁</a></li><li>[ ] Coordinator behavior以及scroll原理，完善blog</li><li>[ ]Exoplayer and the MediaCodec api<a href="https://medium.com/androiddevelopers/building-a-video-player-app-in-android-part-3-5-19543ea9d416">building-a-video-player-app-in-android</a></li><li>[ ] instagram好像通过注解的方式自己写了一个json解析器<a href="https://github.com/Instagram/ig-json-parser">ig-json-parser</a></li><li>[ ] when it comes to design , how do we translate px, pt, em  into sp,dp and others(设计方面的，各种单位之间的转换)?</li><li>[ ] classloader和class的生命周期</li><li>[ ] learning how textView works is painful yet necessary</li><li>[ ] linux环境下多进程通讯方式(管道，共享内存，信号,unix domian socket)</li><li>[ ] mqtt接入实践<a href="https://github.com/mcxiaoke/mqtt">mqtt是建立在tcp基础上的应用层协议</a>，<a href="https://github.com/netty/netty">netty</a>也做了实现</li><li>[ ] render-script utility</li><li>[ ] play around with xposed</li><li>[ ] python gui编程</li><li>[ ] kotlin的coroutine[production-ready]</li><li>[ ] 宇宙第一ide熟悉使用</li><li>[ ] js的闭包等面试常谈</li><li>[ ] java的aspectJ教程，Spring AOP 与AspectJ 实现原理上并不完全一致，但功能上是相似的</li><li>[ ] autoWired, autovalue这些java 的library</li><li>[ ] code generator(代码生成器)</li><li>[ ]<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">content-disposition</a></li><li>[ ] JavaScript中new FileReader()，以及canvas api,以及<a href="https://juejin.im/post/5a98c5c26fb9a028d82b34ee">js进行图片缩放和裁剪</a></li><li>[ ] 用正则检测或者解析json(jQuery源码里有)</li><li>[ ] a new article on open-gl intro(on going)</li><li>[ ] awk，正则表达式还有数据库这些也算一门编程语言</li><li>[ ] 来来来，<a href="https://www.youtube.com/watch?v=DUNkdl0Jhgs">手写一个vm</a></li><li>[ ] <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/windows_build_instructions.md#System-requirements">chromium提供了如何在windows上编译chromium的教程</a></li><li>[ ]<a href="https://www.youtube.com/watch?v=M8LiOANu3Nk">How the JVM compiles bytecode into machine code</a></li><li>[ ] tcp-proxy实用教程</li></ul><h3 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h3><ul><li>用 express 转接一个知乎 Api，添加 Access-control-allow-origin,或许还可以用 redis 缓存数据结果（一个就好）由此想到一篇文章”How to use Pythonto build a restful Web Service”.只不过用的是 Tornado</li><li>git hook (github travis 持续集成，git push 会触发服务器的一系列操作)</li><li>基于前后端分离的理念，后台只负责提供数据，render page 的任务应该交给前端。（所以用 express-handlebars 写页面的方式写着很累）</li><li>集成 travis-ci，记得 after-success script 的结果并不会影响 build 的结果（即，after-success 执行脚本发生了错误，在日志里有输出 error，但实际显示的 build result 仍为 success），还有 travis 的输出 log 需要默认是折叠的，要展开才能看清楚，但在 afterSuccess 里面的指令的输出一定是有的。</li><li>随便放一个文件到/usr/bin/就可以直接调用这个文件名来起这个命令了吗？（实际操作只需要建立一个symbolic link就好了）</li><li>单个网卡最多65535个端口，c10K。<a href="https://www.zhihu.com/question/66553828">65536其实不是操作系统限制的，而是tcp协议就只给port留了2个bytes给source port，只留了2个bytes给destination port</a>端口号写在tcp包里，ip地址不是，ip地址是ip层的事情</li><li>oAuth2原理，其实流程上和很多客户端的微信登陆，新浪微博登陆很像的</li><li>在Android手机上尝试用一个unix domain socket用于localhost进程间ipc(其实就是保证端口号一致，给网络权限就好了)</li><li>写 groovy 用intelij全家桶就可以了，groovy的<a href="https://www.tutorialspoint.com/groovy/groovy_closures.htm">语法</a>其实没什么，主要是了解编译的流程和基本原理，这个需要看<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases">official doc</a></li><li><a href="https://github.com/JLLK/gradle-android-maindexlist-plugin">开发gradle plugin优化MultiDex</a>。长远来看，5.0以后的手机越来越多，MultiDex也不值得过于关注。</li><li>intelij 点击run 实际调用的command line是两个，一个是javac，编译出来的class文件放到了target文件夹，紧接着用java命令带上一大串classpath去调用主函数</li><li><a href="https://fucknmb.com/2017/05/11/Android-Studio-Library%E6%A8%A1%E5%9D%97%E4%B8%ADNative%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8Cdebug%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/">Android Studio 编译过程</a>，其实就是gradle assembleXXX 好了之后adb push到手机上，再安装，最后起主界面</li><li><a href="http://mouxuejie.com/blog/2016-06-21/multidex-compile-and-dex-source-analysis/">Android 编译及 Dex 过程源码分析</a></li><li><a href="http://www.wangyuwei.me/">如何调试 Android 打包流程？</a>，一个remote的事</li><li><a href="https://github.com/chenenyu/img-optimizer-gradle-plugin">一个用于优化 png 图片的 gradle 插件</a>，用来看 groovy 语法挺好的。以及 <a href="http://yuanfentiank789.github.io/2017/09/20/%E5%9C%A8AndroidStudio%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Gradle%E6%8F%92%E4%BB%B6/">How to write gradle plugin</a></li><li>XSS 攻击,DOM based和Stored XSS,基本上就是不要相信用户的输入，除了合法输入以外一律过滤掉</li></ul><ul><li>websocket nodejs，局限性就是前后台都得用socket.io的库。前端是浏览器的话还好，app的话java,Android都有对应的实现.[其实就是socket io] </li><li>[X]一直不会maven是在是太丢人了<a href="https://maven.apache.org/guides/getting-started/index.html#How_do_I_make_my_first_Maven_project">看文档就行了</a>，其他的<a href="https://www.tutorialspoint.com/maven/maven_build_life_cycle.htm">教程</a>也不错</li><li>[使用Spring boot后台提供protobuf接口实现客户端通信] 不要使用protobf-gradle-plugin了。直接写脚本用protoc去生成文件，指定生成文件的路径要和proto里面写的包名对的上。另外就是客户端和server端依赖的protobuf版本以及protoc工具的版本得一致，比如都是3.5。还有就是protoc的语法，什么import的比较烦。</li><li>[X] 使用jinja2生成文件。<a href="https://github.com/guokr/swagger-py-codegen">一个比较好玩的代码生成器</a></li><li>[X] URL Encoding,就是那个在网址里把字符转成百分号加上UTF-8的<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html">找到了阮一峰老师的解释</a></li><li>[X] 通过file input上传图片，原生ajax以及Ajax，自己搭建上传服务器<a href="https://zhuanlan.zhihu.com/p/24513281?refer=flask">大概能猜到暴风影音的局域网传输实现了</a>用flask的话自己搭建好后台最简单了，最多再使用flask-wtf和flask-upload规范操作</li><li>[X]Promise 链式调用与终止，异常处理(只是一个工具而已)</li><li>[X] Android 应用接入bugly热修复，上线之后就不用背锅了（有兴趣看看sevenZip.jar，暂时没看）</li><li>[X] <a href="http://normanmaurer.me/blog/2013/11/09/The-hidden-performance-costs-of-instantiating-Throwables/">简直碉堡了的博客</a>以及jvm 的inline等优化</li><li>[ ] <a href="https://seisman.github.io/how-to-write-makefile/introduction.html">如何写makefile</a>其实<a href="http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/">这个更加friendly</a></li><li>[X] <a href="https://www.jianshu.com/p/534741f5151c">libmp3lame移植到Android</a>,该教程针对的lame版本是3.99.5</li><li><a href="https://sspai.com/post/31500">scheme 这东西算跨客户端平台的</a>，比如在 App 中调起支付宝(用的是 alipayqr://)。其实就是一个系统内跨应用调用。<a href="http://blog.csdn.net/qq_23547831/article/details/51685310">用法</a><br>这个主要是ios app之间通信的协议，以及快速跳转某个app某个页面的功能实现，还有x-callback-URL这样类似的协议。不过有了3d-touch之后，很多app都能长按图标进入页面，所以url scheme这个功能只能说是不复往日辉煌了</li><li>[X]linux的sed命令(文本替换比较常用)</li><li><a href="https://juejin.im/post/59fffdb76fb9a0450a66bd58">nio</a> 还是netty好</li><li>[X]js 的async await,就是一个async修饰一个method，里面随便写await</li><li>[X] Linux下TCP延迟确认机制</li><li>[X]c语言的<a href="https://yq.aliyun.com/articles/413601">libevent使用教程</a> eventloop，添加回调，大致的流程就是这样</li><li>[X] <a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">indexed DB</a>,浏览器端数据库，还是用第三方库好</li><li>[X] <a href="http://forums.justlinux.com/showthread.php?3261-Block-size-vs-page-size">block size vs page size</a> Page是内存相关，block是硬盘相关的</li><li>[X] python 的asyncio(eventloop , generator, coroutine)</li><li>[X]<a href="https://vim.rtorr.com/">Vim cheet sheet</a> vim多用用就熟悉了。</li><li>[X] python dunder class复习。知道有python descriptor这回事就行了。</li><li>[X] form表单可以跨域一个是历史原因要保持兼容性（就是说跨域这件事，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。所以post的表单可以发出去，但是别指望能够拿到response）</li></ul><h3 id="Good-For-Nothing"><a href="#Good-For-Nothing" class="headerlink" title="Good For Nothing"></a>Good For Nothing</h3><ul><li>[ ] 用GDB调试程序</li><li>[ ] npm install graphql(mostly a server side javascript stuff)</li><li>使用 express 模拟网络延迟</li><li><a href="https://juejin.im/post/5a157b7a5188257bfe457ff0">基于 Docker 打造前端持续集成开发环境</a></li><li>vS Code Vender Prefix plugin =&gt; auto prefix loader</li><li>前后端分离</li><li>sql漏洞</li><li><a href="https://cloud.tencent.com/developer/article/1004755">深入浅出腾讯云 CDN：缓存篇</a>不管SSD盘或者SATA盘都有最小的操作单位，可能是512B，4KB，8KB。如果读写过程中不进行对齐，底层的硬件或者驱动就需要替应用层来做对齐操作，并将一次读写操作分裂为多次读写操作。</li><li>Android进程的<a href="https://juejin.im/post/5a646211f265da3e3f4cc997">加载流程</a></li><li>前后端同构</li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-nginx-with-ssl-as-a-reverse-proxy-for-jenkins">install nginx , jenkin ci, deploying nginx in docker(Http Load Balaning with Docker and nginx)</a></li><li>[ ] 网易云音乐API</li><li>[X] Django部署个人网站(Gunicorn，Nginx)。django写template就不是前后端分离了</li><li>[ ] Docker<a href="https://medium.com/@elye.project/intro-to-docker-building-android-app-cb7fb1b97602">intro-to-docker-building-android-app</a> 这篇文章其实是两件事，一个是Build docker image(docker build xxxx),另一个是run (docker run xxx)</li><li>[ ] <a href="https://blog.csdn.net/u013553529/article/details/53856800">和网页类似，Activity也有一个referer的概念</a>，用于判断当前页面是由谁发起请求的<br>OpenType® is a cross-platform font file format developed jointly by Adobe and Microsoft.</li><li>[ ]<a href="https://blog.securem.eu/serverside/2015/08/25/setting-up-owncloud-server-in-a-docker-container/">deploying owncloud using docker</a></li><li><a href="https://doc.owncloud.org/server/10.0/admin_manual/installation/docker/">owncloud官方的配合docker安装教程</a>网盘这种东西看个人喜好了</li><li>[ ]CloudFlare cdn解析以及DNS防护 </li><li>[ ] <a href="https://www.tutorialspoint.com/python/python_further_extensions.htm">python c extension</a> </li><li>[ ] <a href="https://github.com/elliotforbes/tutorialedge-rest-api">最简单的一个用go写出来的rest api大概长这样</a></li><li>[ ]<a href="https://lxneng.com/posts/201">分词器</a></li><li>[ ]<a href="http://www.wklken.me/posts/2015/04/26/elk-for-nginx-log.html">LOGSTASH+ELASTICSEARCH+KIBANA处理NGINX访问日志</a>ELK全家桶, logstash接管软件日志</li></ul><p><a href="https://jsonplaceholder.typicode.com/">jsonplaceholder</a>懒得自己写api的话<br>就用这个吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个待办事项的仓库&lt;br&gt;&lt;img src=&quot;https://haldir66.ga/static/imgs/girlfriend lake green nature water cold.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>bytecode基本解读</title>
    <link href="https://haldir65.github.io/2018/12/12/2018-12-12-sinking-your-teeth-into-ByteCode/"/>
    <id>https://haldir65.github.io/2018/12/12/2018-12-12-sinking-your-teeth-into-ByteCode/</id>
    <published>2018-12-12T11:11:02.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>python中可以使用diss module 轻易的查看byte code。那么在java中呢<br><img src="https://www.haldir66.ga/static/imgs/BadlandsBday_EN-AU10299777329_1920x1080.jpg" alt=""><br><a id="more"></a></p><p>interpreting the talk from<br><a href="https://jakewharton.com/sinking-your-teeth-into-bytecode/">Sinking Your Teeth Into Bytecode</a></p><p>java 有一个关键字叫做goto，在java代码中好像不能用，但是其实在生成的bytecode里面有goto关键字(c语言也有)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.youtube.com/watch?v=lP4ED_dN16g">JVM bytecode engineering 101</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中可以使用diss module 轻易的查看byte code。那么在java中呢&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/BadlandsBday_EN-AU10299777329_1920x1080.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haldir65.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>select、poll、epoll学习笔记</title>
    <link href="https://haldir65.github.io/2018/12/06/2018-12-06-select-poll-epoll/"/>
    <id>https://haldir65.github.io/2018/12/06/2018-12-06-select-poll-epoll/</id>
    <published>2018-12-06T08:38:54.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。<br><img src="https://www.haldir66.ga/static/imgs/OrionNebula_EN-AU10620917199_1920x1080.jpg" alt=""><br><a id="more"></a></p><p>用户态到内核态的内存copy的开销</p><p>mac上叫做Kqueue<br><a href="https://www.zhihu.com/question/20122137">epoll或者Kqueue的原理是什么</a></p><p>在看<a href="https://realpython.com/python-sockets/">socket programming in python</a>这篇文章时发现有selector这样的操作。其实和c语言的做法很相似。</p><p><a href="https://www.jianshu.com/p/d2f4c35cb692">Windows IOCP与Linux的epoll机制对比</a><br>系统I/O模型 可分为三类：<br>阻塞型(blocking model)，<br>非阻塞同步型(non-blocking model): “wait until any socket is available to read or write from/to buffer, then call non blocking socket function which returns immediately.”<br>以及非阻塞异步型(asynchronous aka. overlapping model): “call a socket function which returns immediately, then wait for its completion, then access the result data object”<br>IOCP基于非阻塞异步模型，而epoll基于非阻塞同步模型。</p><p><a href="https://www.slideshare.net/sm9kr/iocp-vs-epoll-perfor">Windows IOCP vs Linux EPOLL Performance Comparison</a><br><a href="https://www.cnblogs.com/Anker/p/3263780.html">IO多路复用之epoll总结</a><br><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a><br><a href="https://my.oschina.net/hosee/blog/730598">epoll浅析以及nio中的Selector</a><br><a href="https://cloud.tencent.com/developer/article/1005481">大话 Select、Poll、Epoll</a><br><a href="https://news.ycombinator.com/item?id=8526264">There is no Windows equivalent to epoll/kqueue , but there is Overlapped IO</a> 简单说就是windows在这方面设计的更优秀，只是开发者并未买账</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/OrionNebula_EN-AU10620917199_1920x1080.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>tcp和udp包结构分析</title>
    <link href="https://haldir65.github.io/2018/12/03/2018-12-03-packet-structure-of-tcp-and-udp/"/>
    <id>https://haldir65.github.io/2018/12/03/2018-12-03-packet-structure-of-tcp-and-udp/</id>
    <published>2018-12-03T13:42:25.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>本文只针对ipv4网络进行分析<br><img src="https://www.haldir66.ga/static/imgs/AlanTuringNotebook_EN-AU7743633207_1920x1080.jpg" alt=""><br><a id="more"></a></p><blockquote><p>多数内容来自<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/chapter2.html">TCP 报文结构</a><br>同一台机器上的两个进程，可以通过管道，共享内存，信号量，消息队列等方式进行通信。通信的一个基本前提是每个进程都有唯一的标识，在同一台机器上，使用pid就可以了。两台不同的计算机之间通信，可以使用<strong>ip地址 + 协议 +协议端口号</strong> 来标识网络中的唯一进程。<br>tcp用16位端口号来标识一个端口，也就是两个bytes(65536就这么来的)。</p></blockquote><p>什么是报文？<br>例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。<br>而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。<br>一共四个 TCP 报文，发送到另外一个端。<br>另外一端收到数据包，然后再剔除 TCP 首部，组装起来。<br>等到四个数据包都收到了，就能还原出来一个完整的 HTML 文档了。<br>在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。<br>TCP 报文 (Segment)，包括首部和数据部分。</p><p>TCP 报文段首部的前20个字节是固定的，后面有 4N 字节是根据需要而增加的。<br>TCP 的首部包括以下内容：</p><ul><li>源端口 source port</li><li>目的端口 destination port</li><li>序号 sequence number</li><li>确认号 acknowledgment number</li><li>数据偏移 offset</li><li>保留 reserved</li><li>标志位 tcp flags</li><li>窗口大小 window size</li><li>检验和 checksum</li><li>紧急指针 urgent pointer</li><li>选项 tcp options</li></ul><h3 id="连接建立过程"><a href="#连接建立过程" class="headerlink" title="连接建立过程"></a>连接建立过程</h3><p>TCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫客户端（Client），被动等待连接建立的一方叫服务器（Server）。<br>最初的时候，两端都处于 CLOSED 的状态，然后服务器打开了 TCP 服务，进入 LISTEN 状态，监听特定端口，等待客户端的 TCP 请求。<br>第一次握手： 客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 SYN_SEND 状态，等待服务器发回确认报文。<br>这时首部的同步位 SYN = 1，同时初始化一个序号 Sequence Number = J。<br>TCP 规定，SYN 报文段不能携带数据，但会消耗一个序号。<br>第二次握手： 服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 SYN_RCVD 状态。<br>这时首部的 SYN = 1，ACK = 1，而确认号 Acknowledgemt Number = J + 1，同时也为自己初始化一个序号 Sequence Number = K。<br>这个报文同样不携带数据。<br>第三次握手：<br>客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 ESTABLISHED 状态。<br>这时首部的 SYN 不再置为 1，而 ACK = 1，确认号 Acknowledgemt Number = K + 1，序号 Sequence Number = J + 1。<br>第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 ESTABLISHED 状态。 此时，TCP 连接已经建立。<br>对于建立连接的三次握手，主要目的是初始化序号 Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，所以这个过程也叫 SYN。<br>这个序号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，因为TCP 会用这个序号来拼接数据。</p><h3 id="TCP-Flood-攻击"><a href="#TCP-Flood-攻击" class="headerlink" title="TCP Flood 攻击"></a>TCP Flood 攻击</h3><p>知道了 TCP 建立一个连接，需要进行三次握手。<br>但如果你开始思考「三次握手的必要性」的时候，就会知道，其实网络是很复杂的，一个信息在途中丢失的可能性是有的。<br>如果数据丢失了，那么，就需要重新发送，这时候就要知道数据是否真的送达了。<br>这就是三次握手的必要性。<br>但是再向深一层思考，你给我发信息，我收到了，我回复，因为我是君子。<br>如果是小人，你给我发信息，我就算收到了，我也不回复，你就一直等我着我的回复。<br>那么很多小人都这样做，你就要一直记住你在等待着小人1号、小人2号、小人3号……直到你的脑容量爆棚，烧坏脑袋。<br>黑客就是利用这样的设计缺陷，实施 TCP Flood 攻击，属于 DDOS 攻击的一种。</p><h3 id="四次挥手，释放连接"><a href="#四次挥手，释放连接" class="headerlink" title="四次挥手，释放连接"></a>四次挥手，释放连接</h3><p>TCP 有一个特别的概念叫做半关闭，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。<br>客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。<br>释放连接过程<br>在结束之前，通信双方都是处于 ESTABLISHED 状态，然后其中一方主动断开连接。<br>下面假如客户端先主动断开连接。<br>第一次挥手：<br>客户端向服务器发送结束报文段，然后进入 FIN_WAIT_1 状态。<br>此报文段 FIN = 1， Sequence Number = M。<br>第二次挥手：<br>服务端收到客户端的结束报文段，然后发送确认报文段，进入 CLOSE_WAIT 状态。<br>此报文段 ACK = 1， Sequence Number = M + 1。<br>客户端收到该报文，会进入 FIN_WAIT_2 状态。<br>第三次挥手：<br>同时服务端向客户端发送结束报文段，然后进入 LAST_ACK 状态。<br>此报文段 FIN = 1，Sequence Number = N。<br>第四次挥手：<br>客户端收到服务端的结束报文段，然后发送确认报文段，进入 TIME_WAIT 状态，经过 2MSL 之后，自动进入 CLOSED 状态。<br>此报文段 ACK = 1, Sequence Number = N + 1。<br>服务端收到该报文之后，进入 CLOSED 状态。<br>关于 TIME_WAIT 过渡到 CLOSED 状态说明：<br>从 TIME_WAIT 进入 CLOSED 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 CLOSED 状态。</p><h3 id="这里还只是tcp层面，如果加上tls初始化握手，这个速度会更慢一些"><a href="#这里还只是tcp层面，如果加上tls初始化握手，这个速度会更慢一些" class="headerlink" title="这里还只是tcp层面，如果加上tls初始化握手，这个速度会更慢一些"></a>这里还只是tcp层面，如果加上tls初始化握手，这个速度会更慢一些</h3><p>下面从<a href="https://www.infoq.cn/article/2018%2F03%2Fweibo-quic">QUIC 在微博中的落地思考</a>文中摘抄一部分批判tcp</p><blockquote><p>TCP 协议在建立连接时，需要经历较为漫长的三次握手行为，而在关闭时，也有稍显冗余的 4 次摆手。而 HTTPS 初始连接需要至少 2 个 RTT 交互（添加了握手缓存就会变成了 1-RTT，这里指的是 TLS 1.2），外加 TCP 自身握手流程，最少需要 3 次 RTT 往返，才能够完整建立连接。而 QUIC 协议层面界定了 1-2 个 RTT 握手流程，再次连接为 0-RTT 握手优化流程（但需要添加握手缓存）</p></blockquote><p>关于tcp read/write buffer，shadowsocks的参数优化提到了一些东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># max open files</span><br><span class="line">fs.file-max = 1024000</span><br><span class="line"># max read buffer</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"># max write buffer</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"># default read buffer</span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"># default write buffer</span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"># max processor input queue</span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"># max backlog</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"># resist SYN flood attacks</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"># reuse timewait sockets when safe</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"># turn off fast timewait sockets recycling</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"># short FIN timeout</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"># short keepalive time</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"># outbound port range</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"># max SYN backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"># max timewait sockets held by system simultaneously</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"># TCP receive buffer</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"># TCP write buffer</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"># turn on path MTU discovery</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line"># for high-latency network</span><br><span class="line">net.ipv4.tcp_congestion_control = hybla</span><br><span class="line"># forward ipv4</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cyberciti.biz/files/linux-kernel/Documentation/networking/ip-sysctl.txt">内核文档对于这些参数的定义</a><br>注意，这些参数修改了会影响所有的进程，修改还是慎重一些</p><h3 id="tcp-buffer"><a href="#tcp-buffer" class="headerlink" title="tcp buffer"></a>tcp buffer</h3><p>关键字： tcp read buffer and write buffer<br>这里要分congestion window（发送方的window，对应congestion control）和receive window(接收方的window，对应flow control)<br>receive window</p><blockquote><p>Your Network Interface Card (NIC) is performing all of the necessary tasks of collecting packets and waiting for your OS to read them. Ultimately, when you do a stream read you’re pulling from the memory that your OS has reserved and constantly stores the incoming information copy into.<br>To answer your question, yes. You are definitely doing a copy. A copy of a copy, the bits are read into a buffer within your NIC, your OS puts them somewhere, and you copy them when you do a stream read.</p></blockquote><p>用wireshark抓包的话，在tcp header里面有个”window size value”，比方说这个数是2000，也就是发来这个包的一方告诉当前接受方，你下一次最多再发2000byte的数据过来，再多就装不下了。如果接收方处理速度跟不上，buffer慢慢填满，就会在ack包里调低window size，告诉对方发慢一点。<br>client处理速度够快的时候是这样的<br><img src="https://www.haldir66.ga/static/imgs/TCP-window-syn.png" alt=""></p><p>如果不够快的话,这时候就是client在ack包里告诉server自己跟不上了<br><img src="https://www.haldir66.ga/static/imgs/TCP-window-http.png" alt=""></p><h2 id="TCP-Window-Scaling"><a href="#TCP-Window-Scaling" class="headerlink" title="TCP Window Scaling"></a>TCP Window Scaling</h2><p>注意，window size是在ack包里的,另外,tcp header里面为这个window size准备的空间是2 bytes（65536 bytes,所以一个包最大也就65K?）。这样对于那些大带宽高延迟的连接来说是不利的。事实当然没这么简单，<a href="https://www.ietf.org/rfc/rfc1323.txt">RFC 1323</a> enable the TCP receive window to be increased exponentially(指数增长)。这个功能是在握手的时候互相商定了一个增长的倍数(在tcp握手的header里面有一个window size scaling factor,比如下图这样的，一次乘以4)<br><img src="https://www.haldir66.ga/static/imgs/Transmission-control-protocol-window-scaling.png" alt=""></p><blockquote><p>In the image above, the sender of this packet is advertising a TCP Window of 63,792 bytes and is using a scaling factor of four. This means that that the true window size is 63,792 x 4 (255,168 bytes). Using scaling windows allows endpoints to advertise a window size of over 1GB. To use window scaling, both sides of the connection must advertise this capability in the handshake process. If one side or the other cannot support scaling, then neither will use this function. The scale factor, or multiplier, will only be sent in the SYN packets during the handshake and will be used for the life of the connection. This is one reason why it is so important to capture the handshake process when performing TCP analysis.</p></blockquote><p>就是说4这个数只会出现在握手的syn包中，并且只有在双方都能支持scaling的前提下才会用，而且这个4将会在这条连接的生命周期中一直是这个数，所以要分析的话，逮这个syn包去抓。</p><h3 id="TCP-Zero-window"><a href="#TCP-Zero-window" class="headerlink" title="TCP Zero window"></a>TCP Zero window</h3><p><img src="https://www.haldir66.ga/static/imgs/TCP-Zero-Window-Performance-Vision.png" alt=""><br>意思就是说，这个window size变成0了。通常不会出现这种情况，一般是接收方的进程出问题了，这时候server会等着，随着client的应用层开始处理数据，client会慢慢发TCP Keep-Alive包，带上新的window size，告诉server说，自己正在处理数据，快了快了。</p><blockquote><p>The throughput of a communication is limited by two windows: the congestion window and the receive window. The congestion window tries not to exceed the capacity of the network (congestion control); the receive window tries not to exceed the capacity of the receiver to process data (flow control). The receiver may be overwhelmed by data if for example it is very busy (such as a Web server). Each TCP segment contains the current value of the receive window. If, for example, a sender receives an ack which acknowledges byte 4000 and specifies a receive window of 10000 (bytes), the sender will not send packets after byte 14000, even if the congestion window allows it.<br>总的来说，tcp传输的速度是由congestion window and the receive window控制的，前者控制发送方的发送速度，后者限制接收方的接收速度。</p></blockquote><h3 id="可靠性交付的实现到这里也就清楚了"><a href="#可靠性交付的实现到这里也就清楚了" class="headerlink" title="可靠性交付的实现到这里也就清楚了"></a>可靠性交付的实现到这里也就清楚了</h3><p>滑动窗口(sliding window)<br>超时重传<br>流量控制 (flow control)<br>拥塞控制（congestion control）</p><h2 id="一个tcp-udp或者ip包最大多大，最小多大"><a href="#一个tcp-udp或者ip包最大多大，最小多大" class="headerlink" title="一个tcp,udp或者ip包最大多大，最小多大"></a>一个tcp,udp或者ip包最大多大，最小多大</h2><p>最小我们知道<br>传送TCP数据包的時候，TCP header 占 20 bytes， IPv4 header 占 20 bytes，所以最小40byte。<br>那么最大呢<a href="https://blog.csdn.net/caoshangpa/article/details/51530685">TCP、UDP数据包大小的限制</a><br>应用层udp最大1500-20-8 = 1472 字节(多了会被分片重组，万一分片丢失导致重组失败，就会被丢包)，1500是硬件决定的,20是ip头，8是udp的头<br>结论<br>UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)<br>TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)<br>UDP数据报的长度是指包括报头和数据部分在内的总字节数，其中报头长度固定，数据部分可变。数据报的最大长度根据操作环境的不同而各异。从理论上说，包含报头在内的数据报的最大长度为65535字节(64K)。<br>用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) - UDP头(8)＝65507字节。用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。<br>MTU 最大传输单元（英语：Maximum Transmission Unit，缩写MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位），怎么看</p><blockquote><p>ping -l 1472 -f www.baidu.com ##根据提示去调小这个数就是了，一般1350以上是有的</p></blockquote><p>从csdn搞来的图<br><img src="https://haldir66.ga/static/imgs/tcp_and_udp_size_limit.png" alt=""><br>传输层：<br>对于UDP协议来说，整个包的最大长度为65535，其中包头长度是65535-20=65515；<br>对于TCP协议来说，整个包的最大长度是由最大传输大小（MSS，Maxitum Segment Size）决定，MSS就是TCP数据包每次能够传<br>输的最大数据分段。为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需<br>要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值<br>确定为这次连接的最大MSS值。<br>IP层：<br>对于IP协议来说，IP包的大小由MTU决定（IP数据包长度就是MTU-28（包头长度）。 MTU值越大，封包就越大，理论上可增加传送速率，但<br>MTU值又不能设得太大，因为封包太大，传送时出现错误的机会大增。一般默认的设置，PPPoE连接的最高MTU值是1492, 而以太网<br>（Ethernet）的最高MTU值则是1500,而在Internet上，默认的MTU大小是576字节</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/">TCP 报文结构</a><br><a href="https://www.google.com/search?q=tcp%E5%8C%85%E7%BB%93%E6%9E%84">tcp包结构</a><br><a href="https://accedian.com/enterprises/blog/tcp-receive-window-everything-need-know/">推广商业软件的文章，当做关于tcp协议的一整个series来看还是很好的</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文只针对ipv4网络进行分析&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/AlanTuringNotebook_EN-AU7743633207_1920x1080.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>page-size and block size</title>
    <link href="https://haldir65.github.io/2018/12/02/2018-12-02-page-size-and-block-size/"/>
    <id>https://haldir65.github.io/2018/12/02/2018-12-02-page-size-and-block-size/</id>
    <published>2018-12-02T21:42:24.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>page size（内存相关）和block size(文件系统相关)的一些点<br><img src="https://www.haldir66.ga/static/imgs/scenery1511100718415.jpg" alt=""><br><a id="more"></a><br>wiki上说<br>Page size常由processor的架构决定的，操作系统管理内存的最小单位是一个Page size(应用程序申请分配内存时，操作系统实际分配的内存是page-size的整数倍)</p><p><a href="http://forums.justlinux.com/showthread.php?3261-Block-size-vs-page-size">Block size vs. page size</a></p><blockquote><p> block size concerns storage space on a filesystem.<br>Page size is, I believe, architecture-dependent, 4k being the size for IA-32 (x86) machines. For IA-64 architecture, I’m pretty sure you can set the page size at compile time, with 8k or 16k considered optimal. Again, I’m not positive, but I think Linux supports 4,8,16, and 64k pages.<br>Block size is a function of the filesystem in use. Many, if not all filesystems allow you to choose the block size when you format, although for some filesystems the block size is tied to/dependent upon the page size.<br>Minimun block size is usually 512 bytes, the allowed values being determined by the filesystem in question.</p></blockquote><p>unix系统中查看系统的page size</p><blockquote><p>getconf PAGESIZE ## X86架构的cpu上一般是4096byte</p></blockquote><p>一个很有意思的现象是，java BufferedInputStream的默认buffer数组大小是8192，okio 的segment的默认size也是8192，这些都是以byte为单位的。找到一个合理的<a href="https://stackoverflow.com/questions/37404068/why-is-the-default-char-buffer-size-of-bufferedreader-8192">解释</a>。大致意思是8192 = 2^13, windows和linux上这个大小正好占用两个分页文件(8kB)。</p><h2 id="block-size-硬盘块"><a href="#block-size-硬盘块" class="headerlink" title="block size(硬盘块)"></a>block size(硬盘块)</h2><p>摘抄一段来自<a href="https://zhuanlan.zhihu.com/p/26077257">深入浅出腾讯云CDN：缓存篇</a>的话：</p><blockquote><p>不管SSD盘或者SATA盘都有最小的操作单位，可能是512B，4KB，8KB。如果读写过程中不进行对齐，底层的硬件或者驱动就需要替应用层来做对齐操作，并将一次读写操作分裂为多次读写操作。</p></blockquote><p><a href="https://www.zfl9.com/c-struct.html">什么是内存对齐，为什么要对齐？</a></p><p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。<br>对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失。<br>比如有些平台每次读都是从偶地址开始，如果一个 int 型（假设为32位）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多，这也是空间和时间的博弈。<br>“内存对齐”应该是编译器的“管辖范围”。<br>编译器为程序中的每个“数据单元”安排在适当的位置上。<br><strong>但是C语言的一个特点就是太灵活，太强大，它允许你干预“内存对齐”</strong></p><p>对齐规则(内存相关)<br>每个特定平台上的编译器都有自己默认的“对齐系数”，我们可以通过预处理指令#pragma pack(n), n=1, 2, 4, 8, 16…来改变这一系数，这个 n 就是对齐系数</p><p>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在 offset 为 0 的地方，以后的每个数据成员的对齐按照#pragma pack(n)指定的 n 值和该数据成员本身的长度 len = sizeof(type) 中，较小的那个进行，如果没有显示指定n值，则以len为准，进行对齐<br>结构/联合整体对齐规则：在数据成员对齐完成之后，结构/联合本身也要对齐，对齐按照#pragma pack(n)指定的n值和该结构/联合最大数据成员长度max_len_of_members中，较小的那个进行，如果没有显示指定n值，则以max_len_of_members为准，进行对齐<br>结合1、2可推断：当n值均超过(或等于)所有数据成员的长度时，这个n值的大小将不产生任何效果</p><h3 id="从fsize看block"><a href="#从fsize看block" class="headerlink" title="从fsize看block"></a>从fsize看block</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1024</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fsize</span><span class="params">(FILE *fp)</span></span>&#123;</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">return</span> ftell(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter the file absolute path: \n "</span>);</span><br><span class="line">    <span class="keyword">char</span> str[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n the file name you choose is: %s\n "</span>,str);</span><br><span class="line">    FILE *fp = fopen(str, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error opening file \n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len: %ld bytes\n"</span>, fsize(fp));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的一个用fsize函数获取文件的bytes数的函数</p><p>./a.out sample.txt ## len: 2527 bytes<br>du sample.txt<br>4 sample.txt<br>du -b sample.txt<br>2527 sample.txt</p><p>简单的来说，fsize获取的大小和du的结果不一致。但du -b 就一样了。这事主要是因为block size的缘故,文件系统分配磁盘存储的时候是以block为单位的。所以经常看到windows里面显示一个文件的大小和“占用的磁盘空间”。就是因为block的原因。<a href="https://unix.stackexchange.com/questions/120311/why-are-there-so-many-different-ways-to-measure-disk-usage">更详细的解释在这里</a></p><blockquote><p>For files, ls -l file shows (among other things) the size of file in bytes, while du -k file shows the space occupied by file on disk (in units of 1 kB = 1204 bytes). Since disk space is allocated in blocks, the size indicated by du -k is always slightly larger than the space indicated by  ls -kl (which is the same as ls -l, but in 1 kB units).</p><p>For directories, ls -ld dir shows (among other things) the size of the list of filenames (together with a number of attributes) of the files and subdirectories in dir. This is just the list of filenames, not the files’ or subdirectories’ contents. So this size increases when you add files to dir (even when files are empty), but it stays unchanged when one of the files in dir grows.</p><p>However, when you delete files from dir the space from the list is not reclaimed immediately, but rather the entries for deleted files are marked as unused, and are later recycled (this is actually implementation-dependent, but what I described is pretty much the universal behavior these days). That’s why you may not see any changes in ls -ld output when you delete files until much later, if ever.</p><p>Finally, du -ks dir shows (an estimate of) the space occupied on disk by all files in dir, together with all files in all of dir’s subdirectories, in 1 kB = 1024 bytes units. Taking into account the description above, this has no relation whatsoever with the output of ls -kld dir.</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[ ] <a href="https://www.youtube.com/watch?v=0Rf5Jc61ArM">Paging Technique : Memory management in Operating System</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;page size（内存相关）和block size(文件系统相关)的一些点&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/scenery1511100718415.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>TextView测量及渲染原理</title>
    <link href="https://haldir65.github.io/2018/11/29/2018-11-29-how-is-text-drawn-on-android/"/>
    <id>https://haldir65.github.io/2018/11/29/2018-11-29-how-is-text-drawn-on-android/</id>
    <published>2018-11-29T16:11:54.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>Android上的TextView分为java层和native层，java层包括<br>Layout,Paint,Canvas<br>native层包括各种开源库，Minikin,ICU,HarfBuzz,FreeType<br>关于文字的形体,排版等信息是native层计算出来的。</p><p><img src="https://www.haldir66.ga/static/imgs/textview_architecture.png" alt=""></p><a id="more"></a><p>[tbd]</p><p>TextView是一个很重的控件，由于measure耗时通常很多，Android P提出了Precomputed Text的概念。类似的概念早几年instagram也提出过（如果只是想要展示一段文字，在一个子线程用Layout去计算。<br>我碰到的情况是：<br>layout.getDesiredwidth(“一个字”) &gt; layout.getDesiredwidth(“一”) + layout.getDesiredwidth(“个”)+ layout.getDesiredwidth(“字”)。<br>多数情况下，左边的值和右边的width之和是相等的，但是出现中英文夹杂的时候左边会小于右边。不清楚这是否是提前换行的原因。</p><p>Layout有BoringLayout(一行文字),StaticLayout(多行文字)和DynamicLayout(文字会变)这三个子类</p><p>在某些版本的Android上，TextView碰到中英文夹杂的时候，会出现提前换行(普遍的看法是Layout这个类里面处理全角符号的时候算错了)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/27631736/meaning-of-top-ascent-baseline-descent-bottom-and-leading-in-androids-font">Textview的高度ascent,descent这些的详细解说</a><br><a href="http://ragnraok.github.io/textview-pre-render-research.html">TextView预渲染研究</a><br><a href="https://instagram-engineering.com/improving-comment-rendering-on-android-a77d5db3d82e">instagram的文章</a><br><a href="https://www.youtube.com/watch?v=x-FcOX6ErdI">Best practices for text on Android (Google I/O ‘18)</a><br><a href="https://www.youtube.com/watch?v=vXqwRhjd7b4">Use Android Text Like a Pro (Android Dev Summit ‘18)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android上的TextView分为java层和native层，java层包括&lt;br&gt;Layout,Paint,Canvas&lt;br&gt;native层包括各种开源库，Minikin,ICU,HarfBuzz,FreeType&lt;br&gt;关于文字的形体,排版等信息是native层计算出来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/textview_architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://haldir65.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>浏览器indexedDb使用示例</title>
    <link href="https://haldir65.github.io/2018/11/27/2018-11-27-indexed-db-tutorial/"/>
    <id>https://haldir65.github.io/2018/11/27/2018-11-27-indexed-db-tutorial/</id>
    <published>2018-11-27T10:33:01.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器indexedDb使用方式及注意的点<br><img src="https://www.haldir66.ga/static/imgs/black-mountains.jpg" alt=""><br><a id="more"></a></p><p><a href="https://medium.com/@filipvitas/indexeddb-with-promises-and-async-await-3d047dddd313">浏览器上可供使用的数据持久化选择就这些</a></p><blockquote><p>1) Store all data on server database (SQL or NoSQL)<br>2) LocalStorage / SessionStorage - limited memory (around 5MB)<br>3) WebSQL - it has been deprecated in favor of IndexedDB<br>4) IndexedDB - designed as “one true” browser database with 50MB and more<br>tl;dr Use some library from conclusion section to make your life easier.</p></blockquote><h2 id="一些重要的概念"><a href="#一些重要的概念" class="headerlink" title="一些重要的概念"></a>一些重要的概念</h2><p>Database(通常一个app只有一个database)<br>127.0.0.1:8080和127.0.0.1：8000 是两个不同的Application<br>创建出来的数据库在Application-&gt;Storage-&gt;IndexedDB里面有</p><p>Object Stores(就像数据库里的table或者collections一样，但是同一个store中存储的数据类型不一定是相同的)</p><p>transaction（所有对IndexDb的操作必须通过transaction）</p><p>接下来是CURD的实例</p><p>db.open返回的是一个IDBRequest对象，没有promise的方式是这样使用的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let us open our database</span></span><br><span class="line"><span class="keyword">var</span> DBOpenRequest = <span class="built_in">window</span>.indexedDB.open(<span class="string">"toDoList"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// these two event handlers act on the database being</span></span><br><span class="line"><span class="comment">// opened successfully, or not</span></span><br><span class="line">DBOpenRequest.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  note.innerHTML += <span class="string">'&lt;li&gt;Error loading database.&lt;/li&gt;'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  note.innerHTML += <span class="string">'&lt;li&gt;Database initialised.&lt;/li&gt;'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// store the result of opening the database.</span></span><br><span class="line">  db = DBOpenRequest.result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Create-创建db的代码"><a href="#Create-创建db的代码" class="headerlink" title="(Create)创建db的代码:"></a>(Create)创建db的代码:</h3><p>indexedDB.open(‘db-name’, 1) //第二个参数是数据库版本</p><h3 id="添加数据的方式"><a href="#添加数据的方式" class="headerlink" title="添加数据的方式"></a>添加数据的方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putSomeData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> indexedDB = <span class="built_in">window</span>.indexedDB || <span class="built_in">window</span>.mozIndexedDB || <span class="built_in">window</span>.webkitIndexedDB || <span class="built_in">window</span>.msIndexedDB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> open = indexedDB.open(<span class="string">'db-name'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    open.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> db = open.result</span><br><span class="line">        db.createObjectStore(<span class="string">'objectStoreName'</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> db = open.result</span><br><span class="line">        <span class="keyword">let</span> tx = db.transaction(<span class="string">'objectStoreName'</span>, <span class="string">'readwrite'</span>)</span><br><span class="line">        <span class="keyword">let</span> store = tx.objectStore(<span class="string">'objectStoreName'</span>)</span><br><span class="line"></span><br><span class="line">        store.put(&#123; <span class="attr">firstname</span>: <span class="string">'John'</span>, <span class="attr">lastname</span>: <span class="string">'Doe'</span>, <span class="attr">age</span>: <span class="number">33</span> &#125;)</span><br><span class="line"></span><br><span class="line">        tx.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            db.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真啰嗦，还是用第三方库吧，用<a href="https://github.com/jakearchibald/idb">idb</a>好了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">putSomeData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">await</span> idb.open(<span class="string">'db-name'</span>, <span class="number">1</span>, upgradeDB =&gt; upgradeDB.createObjectStore(<span class="string">'objectStoreName'</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tx = db.transaction(<span class="string">'objectStoreName'</span>, <span class="string">'readwrite'</span>)</span><br><span class="line">    <span class="keyword">let</span> store = tx.objectStore(<span class="string">'objectStoreName'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> store.put(&#123; <span class="attr">firstname</span>: <span class="string">'John'</span>, <span class="attr">lastname</span>: <span class="string">'Doe'</span>, <span class="attr">age</span>: <span class="number">33</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> tx.complete</span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAllData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">await</span> idb.open(<span class="string">'db-name'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tx = db.transaction(<span class="string">'objectStoreName'</span>, <span class="string">'readonly'</span>)</span><br><span class="line">    <span class="keyword">let</span> store = tx.objectStore(<span class="string">'objectStoreName'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add, clear, count, delete, get, getAll, getAllKeys, getKey, put</span></span><br><span class="line">    <span class="keyword">let</span> allSavedItems = <span class="keyword">await</span> store.getAll()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(allSavedItems)</span><br><span class="line"></span><br><span class="line">    db.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扯一点关于存储的东西"><a href="#扯一点关于存储的东西" class="headerlink" title="扯一点关于存储的东西"></a>扯一点关于存储的东西</h3><p>当浏览器进入私人模式(private browsing mode，Google Chrome 上对应的应该是叫隐身模式)的时候，会创建一个新的、临时的、空的数据库，用以存储本地数据(local storage data)。当浏览器关闭时，里面的所有数据都将被丢弃。</p><p>判断方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐身模式下和localStorage满了都会报同样的错误</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">'test'</span>, <span class="string">'test'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e)  &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e) <span class="comment">//QuotaExceddedError(DOM Exception 22):The quota has been exceeded.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器indexedDb使用方式及注意的点&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/black-mountains.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://haldir65.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javaScript" scheme="https://haldir65.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>cmake实用手册</title>
    <link href="https://haldir65.github.io/2018/11/26/2018-11-26-cmake-intro/"/>
    <id>https://haldir65.github.io/2018/11/26/2018-11-26-cmake-intro/</id>
    <published>2018-11-26T13:42:16.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>当我们敲下cmake命令的时候，cmake会在当前目录下找CMakeLists.txt这个文件，找不到会报错的</p><p><img src="https://www.haldir66.ga/static/imgs/fresh-sparkle-dew-drops-on-red-flower-wallpaper-53861cf580909.jpg" alt=""><br><a id="more"></a></p><p>下面就是最简单的一个CMakeLists.txt的例子，project(hello_cmake)是一个函数，该函数生成了PROJECT_NAME这个变量，所以下面直接用了。add_executable（）第一个参数是要生成的可执行文件的名字，第二个参数(其实可以包括所有编译需要的源文件)</p><blockquote><p>cmake_minimum_required(VERSION 3.5)<br>project (hello_cmake)<br>add_executable(${PROJECT_NAME} main.cpp)</p></blockquote><p>这个更简单</p><blockquote><p>cmake_minimum_required(VERSION 2.8)<br>project(app_project)<br>add_executable(myapp main.c)<br>install(TARGETS myapp DESTINATION bin)</p></blockquote><p>生成Makefile<br>mkdir _build &amp;&amp; cd _build &amp;&amp; cmake .. -DCMAKE_INSTALL_PREFIX=../_install<br>生成的Makefile拿来用:<br>make &amp;&amp; make install<br>省的手写Makefile了</p><p>cmake支持In-Place Build和Out-of-Source Build。前者是直接在当前文件夹（CMAKE_BINARY_DIR）中生成一大堆文件（太乱了），后者则是在一个指定的文件夹中生成文件。<br>Out-of-source build其实很简单<br>mkdir build &amp;&amp; cd build/ &amp;&amp; cmake .. (在build文件夹中会生成一个Makefile)<br>make &amp;&amp; ./hello_cmake </p><p>一堆内置的变量供参考</p><table><thead><tr><th>Variable</th><th>Info</th></tr></thead><tbody><tr><td>CMAKE_SOURCE_DIR</td><td>The root source directory</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>The current source directory if using sub-projects and directories.</td></tr><tr><td>PROJECT_SOURCE_DIR</td><td>The source directory of the current cmake project.</td></tr><tr><td>CMAKE_BINARY_DIR</td><td>The root binary / build directory. This is the directory where you ran the cmake command.</td></tr><tr><td>CMAKE_CURRENT_BINARY_DIR</td><td>The build directory you are currently in.</td></tr><tr><td>PROJECT_BINARY_DIR</td><td>The build directory for the current project.</td></tr></tbody></table><h3 id="header文件的处理"><a href="#header文件的处理" class="headerlink" title="header文件的处理"></a>header文件的处理</h3><p>可以指定多个源文件</p><blockquote><p>set(SOURCES<br>    src/Hello.cpp<br>    src/main.cpp<br>)<br>add_executable(${PROJECT_NAME} ${SOURCES})<br>//或者直接把src文件夹下面的所有.cpp文件加入进来<br>file(GLOB SOURCES “src/*.cpp”)</p></blockquote><h3 id="对于include文件夹"><a href="#对于include文件夹" class="headerlink" title="对于include文件夹"></a>对于include文件夹</h3><blockquote><p>target_include_directories(target<br>    PRIVATE<br>        ${PROJECT_SOURCE_DIR}/include<br>)<br>这样编译器就会在编译参数上加上-I/directory/path这种东西</p></blockquote><h3 id="static-library的处理"><a href="#static-library的处理" class="headerlink" title="static library的处理"></a>static library的处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line">project(hello_library)</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line"># Create a library</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">#Generate the static library from the library sources</span><br><span class="line">add_library(hello_library STATIC </span><br><span class="line">    src/Hello.cpp //创建一个libhello_library.a 的static library</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">target_include_directories(hello_library</span><br><span class="line">    PUBLIC </span><br><span class="line">        $&#123;PROJECT_SOURCE_DIR&#125;/include</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line"># Create an executable</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line"># Add an executable with the above sources</span><br><span class="line">add_executable(hello_binary </span><br><span class="line">    src/main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># link the new hello_library target with the hello_binary target</span><br><span class="line">target_link_libraries( hello_binary</span><br><span class="line">    PRIVATE </span><br><span class="line">        hello_library</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="shared-library的处理"><a href="#shared-library的处理" class="headerlink" title="shared library的处理"></a>shared library的处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line">project(hello_library)</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line"># Create a library</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">#Generate the shared library from the library sources</span><br><span class="line">add_library(hello_library SHARED </span><br><span class="line">    src/Hello.cpp  // 用传入该函数的文件创建一个 libhello_library.so Library</span><br><span class="line">)</span><br><span class="line">add_library(hello::library ALIAS hello_library)</span><br><span class="line"></span><br><span class="line">target_include_directories(hello_library //hello_library需要这个include directory</span><br><span class="line">    PUBLIC </span><br><span class="line">        $&#123;PROJECT_SOURCE_DIR&#125;/include  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line"># Create an executable</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line"># Add an executable with the above sources</span><br><span class="line">add_executable(hello_binary</span><br><span class="line">    src/main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># link the new hello_library target with the hello_binary target</span><br><span class="line">target_link_libraries( hello_binary // 接下来就是Link了，这里使用了上面的一个alias</span><br><span class="line">    PRIVATE </span><br><span class="line">        hello::library</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="接下来是make-install-将生成的可执行文件安装到系统中，似乎就是复制到-usr-bin里面"><a href="#接下来是make-install-将生成的可执行文件安装到系统中，似乎就是复制到-usr-bin里面" class="headerlink" title="接下来是make install (将生成的可执行文件安装到系统中，似乎就是复制到/usr/bin里面)"></a>接下来是make install (将生成的可执行文件安装到系统中，似乎就是复制到/usr/bin里面)</h3><p>默认情况下cmake会把生成的可执行文件安装到系统中，我们可以指定安装到特定的位置<br>cmake .. -DCMAKE_INSTALL_PREFIX=/install/location</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">install (TARGETS cmake_examples_inst_bin</span><br><span class="line">    DESTINATION bin)</span><br><span class="line">// target cmake_examples_inst_bin target to the destination $&#123;CMAKE_INSTALL_PREFIX&#125;/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">install (TARGETS cmake_examples_inst</span><br><span class="line">    LIBRARY DESTINATION lib) </span><br><span class="line">//install the shared library generated from the target cmake_examples_inst target to the destination $&#123;CMAKE_INSTALL_PREFIX&#125;/lib</span><br></pre></td></tr></table></figure><blockquote><p>$ ls /usr/local/bin/<br>cmake_examples_inst_bin</p><p>$ ls /usr/local/lib<br>libcmake_examples_inst.so</p><p>$ ls /usr/local/etc/<br>cmake-examples.conf</p><p>$ LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib cmake_examples_inst_bin<br>Hello Install! //把生成的bin文件复制到/sur/local/bin目录下，再修改LDPATH,就能去/usr/locallib这个目录去找生成的library了</p></blockquote><h2 id="Autoconf-Automake教程"><a href="#Autoconf-Automake教程" class="headerlink" title="Autoconf/Automake教程"></a>Autoconf/Automake教程</h2><p>GNU Autotools 一般指的是3个 GNU 工具包：Autoconf，Automake 和 Libtool (本文先介绍前两个工具，Libtool留到今后介绍)<br>它们能解决什么问题，要先从 GNU 开源软件的 Build 系统说起。一般来说。GNU 软件的安装过程都是：</p><p>解压源代码包<br>./configure<br>make<br>make install（可能要切root用户）<br>这个过程中， 需要有一个 configure 脚本，同时也需要一个 Makefile 文件。</p><p>而 Autoconf 和 Automake 就是一套自动生成 configure 脚本和 Makefile 文件的工具。</p><p>在ubuntu上安装autoconf,automake,libtool:</p><blockquote><p>sudo apt install build-essential autoconf automake libtool libtool-bin autotools-dev</p></blockquote><p>configure文件是用autoconf根据configure.ac创建出来的，而configure.ac能用autoscan自动创建出来</p><p>随便创建一个文件夹</p><p>$ ls<br>epoch.c Makefile</p><p>$ cat epoch.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_epoch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sec;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_GETTIMEOFDAY</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">     gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">     sec = tv.tv_sec;</span><br><span class="line">     sec += tv.tv_usec / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     sec = time(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, get_epoch());</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么写的原因是gettimeofday()这个函数不是在所有的平台上都有，这种时候就要用time()函数了。</p><p>$ cat Makefile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Makefile: A standard Makefile for epoch.c</span><br><span class="line">all: epoch</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm ­f epoch</span><br></pre></td></tr></table></figure></p><p>这样其实已经可以直接make生成可执行文件了。但是我们用autoconf来生成试一下</p><ol><li>生成config.h文件<br>config.h文件是configure命令根据config.h.in文件生成的，config.h.in文件是由autoheader（C的source code）中生成的（总之也是自动的）<br>$ ls<br>epoch.c Makefile<br>$ autoscan<br>$ ls<br>autoscan.log  configure.scan  epoch.c  Makefile<br>$  mv configure.scan configure.ac<br>$ ls<br>autoscan.log  configure.ac  epoch.c  Makefile<br>$ autoheader<br>$ ls<br>autom4te.cache  autoscan.log  config.h.in  configure.ac  epoch.c  Makefile<br>$  mv Makefile Makefile.in<br>$ autoconf<br>$ ls<br>autom4te.cache  autoscan.log  config.h.in  configure  configure.ac  epoch.c  Makefile.in<br>$ ./configure<br>checking for gcc… gcc<br>checking whether the C compiler works… yes<br>checking for C compiler default output file name… a.out<br>checking for suffix of executables…<br>checking whether we are cross compiling… no<br>checking for suffix of object files… o<br>checking whether we are using the GNU C compiler… yes<br>checking whether gcc accepts -g… yes<br>checking for gcc option to accept ISO C89… none needed<br>checking how to run the C preprocessor… gcc -E<br>checking for grep that handles long lines and -e… /bin/grep<br>checking for egrep… /bin/grep -E<br>checking for ANSI C header files… yes<br>checking for sys/types.h… yes<br>checking for sys/stat.h… yes<br>checking for stdlib.h… yes<br>checking for string.h… yes<br>checking for memory.h… yes<br>checking for strings.h… yes<br>checking for inttypes.h… yes<br>checking for stdint.h… yes<br>checking for unistd.h… yes<br>checking sys/time.h usability… yes<br>checking sys/time.h presence… yes<br>checking for sys/time.h… yes<br>checking for gettimeofday… yes<br>configure: creating ./config.status<br>config.status: creating Makefile<br>config.status: creating config.h<br>$  ls<br>autom4te.cache  autoscan.log  config.h  config.h.in  config.log  config.status  configure  configure.ac  epoch.c  Makefile  Makefile.in<br>$ make<br>$ ls<br>autom4te.cache  config.h     config.log     configure     epoch    Makefile<br>autoscan.log    config.h.in  config.status  configure.ac  epoch.c  Makefile.in<br>$  ./epoch<br>1544345416.704451</li></ol><p>//到此结束（这样做的意义在于一份代码就能够拥有多平台兼容性）</p><p>另一种方式<br>手动创造“Makefile.am”文件<br>$ cat Makefile.am</p><h1 id="Makefile-am-for-epoch-c"><a href="#Makefile-am-for-epoch-c" class="headerlink" title="Makefile.am for epoch.c"></a>Makefile.am for epoch.c</h1><p>bin_PROGRAMS=epoch<br>epoch_SOURCES=epoch.c</p><p>$ ls<br>epoch.c  Makefile.am</p><p>$ autoscan<br>$  mv configure.scan configure.ac<br>$ autoheader<br>$ ls<br>autom4te.cache  autoscan.log  config.h.in  configure.ac  epoch.c  Makefile.am<br>$ vim configure.ac<br>改成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#                                               -*- Autoconf -*-</span><br><span class="line"># Process this file with autoconf to produce a configure script.</span><br><span class="line"></span><br><span class="line">AC_PREREQ([2.69])</span><br><span class="line">AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])</span><br><span class="line">AM_INIT_AUTOMAKE</span><br><span class="line">AC_CONFIG_SRCDIR([epoch.c])</span><br><span class="line">AC_CONFIG_HEADERS([config.h])</span><br><span class="line"></span><br><span class="line"># Checks for programs.</span><br><span class="line">AC_PROG_CC</span><br><span class="line"></span><br><span class="line"># Checks for libraries.</span><br><span class="line"></span><br><span class="line"># Checks for header files.</span><br><span class="line">AC_CHECK_HEADERS([sys/time.h])</span><br><span class="line"></span><br><span class="line"># Checks for typedefs, structures, and compiler characteristics.</span><br><span class="line">AC_HEADER_TIME</span><br><span class="line"></span><br><span class="line"># Checks for library functions.</span><br><span class="line">AC_CHECK_FUNCS([gettimeofday])</span><br><span class="line"></span><br><span class="line">AC_CONFIG_FILES([Makefile])</span><br><span class="line">AC_OUTPUT</span><br></pre></td></tr></table></figure></p><p>其实就是加了AM_INIT_AUTOMAKE这一行还有AC_HEADER_TIME<br>$ aclocal<br>$ automake ­­add­missing ­­copy<br>$ autoconf<br>$ ./configure 在这一步因为没有生成Makefile.in所以停下来了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mirkokiefer.com/cmake-by-example-f95eb47d45b1">cmake的教程，非常好</a><br><a href="https://github.com/ttroy50/cmake-examples">Useful CMake Examples</a>本文来自这里的实例<br><a href="http://www.lugod.org/presentations/autotools/presentation/autotools.pdf">autotools教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们敲下cmake命令的时候，cmake会在当前目录下找CMakeLists.txt这个文件，找不到会报错的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/fresh-sparkle-dew-drops-on-red-flower-wallpaper-53861cf580909.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="C" scheme="https://haldir65.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>opengl学习笔记</title>
    <link href="https://haldir65.github.io/2018/11/15/2018-11-15-opengl-related-topics/"/>
    <id>https://haldir65.github.io/2018/11/15/2018-11-15-opengl-related-topics/</id>
    <published>2018-11-15T22:53:55.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>topics relating opengl stuff<br><img src="https://www.haldir66.ga/static/imgs/scenery151110074347.jpg" alt=""></p><a id="more"></a><p>首先，<a href="https://medium.com/@wrongway4you/opengl-learning-in-2018-d556d96d7e7">不要学旧的版本</a>。<br>It is much better to start from the “modern” OpenGL versions: Learn OpenGL &gt;3.0.</p><p>opengl device support on android</p><ul><li>OpenGL ES 1.0 &amp; 1.1 since Android 1.0 (API 4)</li><li>OpenGL ES 2.0 since Android 2.2 (API 8)</li><li>OpenGL ES 3.0 since Android 4.3 (API 18) (almost)</li><li>OpenGL ES 3.1 since Android 5.0 (API 21)</li></ul><p>OpenGL ES is a variant of OpenGL’s specifications for embedded system. </p><p>##<br><a href="https://developer.android.com/guide/topics/graphics/opengl">opengles guide on android</a></p><p><a href="https://github.com/doggycoder/AndroidOpenGLDemo">real sample</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;topics relating opengl stuff&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/scenery151110074347.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python中多进程、多线程以及GIL记录</title>
    <link href="https://haldir65.github.io/2018/11/11/2018-11-11-python-gil-and-what-you-can-do-about-it/"/>
    <id>https://haldir65.github.io/2018/11/11/2018-11-11-python-gil-and-what-you-can-do-about-it/</id>
    <published>2018-11-11T22:21:52.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.haldir66.ga/static/imgs/1102533137-5.jpg" alt=""></p><ul><li>If your code has a lot of I/O or Network usage:<br>Multithreading is your best bet because of its low overhead</li><li>If you have a GUI<br>Multithreading so your UI thread doesn’t get locked up</li><li>If your code is CPU bound:<br>You should use multiprocessing (if your machine has multiple cores)</li></ul><a id="more"></a><p>Python Global Interpreter Lock(GIL)<br>对于CPython，所有的python bytecode在执行前都需要获得interpreter的lock,one vm thread at a time。(java实现的python似乎没有这个烦恼)<br>GIL的出现似乎是历史原因（为了方便的直接使用当时现有的c extension）。而没有在python3中被移除的原因是因为这会造成单线程的程序在python3中跑的反而比python2中慢。</p><p>因为GIL的存在，python中的线程并不能实现cpu的并发运行(同时只能有一条线程在运行)。但对于I/O intensive的任务来说，cpu都在等待I/O操作完成，所以爬虫这类操作使用多线程是合适的。根据<a href="https://www.youtube.com/watch?v=7SSYhuk5hmc">A Jesse Jiryu Davis</a>在pycon2017上的演讲，在多线程python程序中，如果某条线程开始进行I/O操作，就会主动放弃GIL(这是在socket module的源码中)，或者在cpu-intensive程序中，一条线程连续执行1000次(python2中是一个常数)后就会被夺走gil。<a href="https://github.com/python/cpython/blob/master/Modules/socketmodule.c">socket里面找关键字Py_BEGIN_ALLOW_THREADS和Py_END_ALLOW_THREADS</a></p><h2 id="多线程以及一些同步的问题"><a href="#多线程以及一些同步的问题" class="headerlink" title="多线程以及一些同步的问题"></a>多线程以及一些同步的问题</h2><p>单线程的版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># single_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">countdown(COUNT)</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start)</span><br></pre></td></tr></table></figure></p><p>多线程的版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># multi_threaded.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line">t2 = Thread(target=countdown, args=(COUNT//<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start)</span><br></pre></td></tr></table></figure></p><p>多线程虽然同一时刻只能有一条线程运行，但牵涉到数据共享的时候还是要加锁<br><img src="https://haldir66.ga/static/imgs/lockExplanation.jpg" alt=""></p><p>比如这个例子，照说打印出来的应该是0，但实际操作中可能打出来正数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure></p><p>上述过程的原因在于<br>balance = balance + n<br>这一步其实需要至少两条cpu语句：<br>x = balance +n<br>balance = x </p><p>正常顺序是t1 (+5,-5) t2 (+8, -8) 这样的顺序<br>不正常的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">初始值 balance = 0</span><br><span class="line"></span><br><span class="line">t1: x1 = balance + 5  # x1 = 0 + 5 = 5</span><br><span class="line"></span><br><span class="line">t2: x2 = balance + 8  # x2 = 0 + 8 = 8</span><br><span class="line">t2: balance = x2      # balance = 8</span><br><span class="line"></span><br><span class="line">t1: balance = x1      # balance = 5</span><br><span class="line">t1: x1 = balance - 5  # x1 = 5 - 5 = 0</span><br><span class="line">t1: balance = x1      # balance = 0</span><br><span class="line"></span><br><span class="line">t2: x2 = balance -8 # x2 =-8</span><br><span class="line">t2: balance = x2 # balance = -8</span><br><span class="line"></span><br><span class="line">结果 balance = -8</span><br></pre></td></tr></table></figure></p><p>所以是有可能打印出-8这样的错误的结果的</p><p>这种情况下只要加锁就可以了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure></p><p>改成每一次对共享变量进行操作都需要加锁之后，打印结果就正常了<br><a href="https://hackernoon.com/synchronization-primitives-in-python-564f89fee732">多进程之间的同步方式包括queue,Event,Semaphores，Conditions等</a></p><p>从bytecode来看，<a href="https://www.youtube.com/watch?v=7SSYhuk5hmc&amp;t=890s">increment这一操作并不是atomic的</a><br>python里面很方便<br>incremnt-is-not-atomic.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br></pre></td></tr></table></figure></p><p>python incremnt-is-not-atomic.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3           0 LOAD_GLOBAL              0 (n)</span><br><span class="line">             2 LOAD_CONST               1 (1)</span><br><span class="line">             4 INPLACE_ADD</span><br><span class="line">             6 STORE_GLOBAL             0 (n)</span><br><span class="line">             8 LOAD_CONST               0 (None)</span><br><span class="line">            10 RETURN_VALUE</span><br></pre></td></tr></table></figure></p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>多进程的版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(processes=<span class="number">2</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    r1 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    r2 = pool.apply_async(countdown, [COUNT//<span class="number">2</span>])</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Time taken in seconds -'</span>, end - start)</span><br></pre></td></tr></table></figure></p><p>多进程之间内存不共享，同步方式是使用Queue(fifo)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    q.put(os.getpid())</span><br><span class="line">    print(<span class="string">"[&#123;0&#125;] Hello!"</span>.format(n))</span><br><span class="line"></span><br><span class="line">processes = [ ]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = multiprocessing.Process(target=hello, args=(i,))</span><br><span class="line">    processes.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> one_process <span class="keyword">in</span> processes:</span><br><span class="line">    one_process.join()</span><br><span class="line"></span><br><span class="line">mylist = [ ]</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    mylist.append(q.get())</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Done!"</span>)</span><br><span class="line">print(len(mylist))</span><br><span class="line">print(mylist)</span><br></pre></td></tr></table></figure></p><p>更加Pythonic的方式是使用asyncio</p><h2 id="Asyncio"><a href="#Asyncio" class="headerlink" title="Asyncio"></a>Asyncio</h2><p>优点包括</p><ul><li>Based on futures</li><li>Faster than threads</li><li>Massive I/O concurrency</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_url</span><span class="params">(url)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> aiohttp.request(<span class="string">'GET'</span> , url) <span class="comment">## you get the future, the function is not executed immediatedly</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_two</span><span class="params">(url_a,url_b)</span>:</span></span><br><span class="line">        future_a = fetch_url(url_a)</span><br><span class="line">        future_b = fetch_url(url_b)</span><br><span class="line">        a ,b = <span class="keyword">await</span> asyncio.gather(future_a, future_b)  <span class="comment">## 一旦开始await这个future,这个coroutine才会被加入event loop</span></span><br><span class="line">        <span class="keyword">return</span> a, b</span><br></pre></td></tr></table></figure><p>上述代码虽然还是在同一个进程中运行，还受到GIL制约，但是由于是I/O操作，所以也没什么问题。只是在process返回的结果是，就会受到GIL的影响了。（实际操作中你会发现coroutine还没执行就timeout了）<br>也就是说，I/O操作用asyncio，数据处理使用multi-processing，这是最好的情况。<br>由于coroutine和multi-processing是两个相对独立的模块，所以需要自己把两者结合起来。用多进程进行数据处理，每个进程中各自有独立的coroutine在运行。<br><a href="https://www.youtube.com/watch?v=0kXaLh8Fz3k">John Reese - Thinking Outside the GIL with AsyncIO and Multiprocessing - PyCon 2018</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_loop</span><span class="params">(tx, rx)</span>:</span></span><br><span class="line">        ... <span class="comment">## real work here </span></span><br><span class="line">        limit = <span class="number">10</span></span><br><span class="line">        pending = set()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">while</span> len(pending) &lt; limit:</span><br><span class="line">                        task = tx.get_nowait()</span><br><span class="line">                        fn ,args, kwargs = task</span><br><span class="line">                        pending.add(fn(args,kwargs))</span><br><span class="line">                done, pending = <span class="keyword">await</span> asyncio.wait(pending, ..)        </span><br><span class="line">                <span class="keyword">for</span> future <span class="keyword">in</span> done:</span><br><span class="line">                        rx.put_nowait(<span class="keyword">await</span> future)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bootstrap</span><span class="params">(tx, rx)</span>:</span></span><br><span class="line">        loop = asyncio.new_event_loop()</span><br><span class="line">        asyncio.set_event_loop(loop)</span><br><span class="line">        loop.run_untile_complete(run_loop(tx, rx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>        </span><br><span class="line">        p = multiprocessing.Process(target = bootstrap, args = (tx, rx))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure></p><p>实际操作可能看起来像这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_url</span><span class="params">(url)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> aiohttp.request(<span class="string">'GET'</span> , url) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_all</span><span class="params">(urls)</span>:</span></span><br><span class="line">       tx, rx = Queue(), Queue()</span><br><span class="line">       Process(</span><br><span class="line">               target=bootstrap,</span><br><span class="line">               args=(tx,rx)</span><br><span class="line">       ).start()</span><br><span class="line">       <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">           task = fetch_url,(url,), &#123;&#125;</span><br><span class="line">           tx.put_nowait(task)</span><br></pre></td></tr></table></figure></p><p>已经开源 pip install aiomultiprocess<br><a href="https://github.com/dano/aioprocessing">aioprocessing</a></p><h2 id="关于协程"><a href="#关于协程" class="headerlink" title="关于协程"></a>关于协程</h2><p>coroutine是一个在很多编程语言中都有的概念，在python中coroutine一般指的是generator based coroutines。<br>首先，因为协程是一种能暂停的函数，那么它暂停是为了什么？一般是等待某个事件，比如说某个连接建立了；某个 socket 接收到数据了；某个计时器归零了等。而这些事件应用程序只能通过轮询的方式得知是否完成，<strong>但是操作系统（所有现代的操作系统）可以提供一些中断的方式通知应用程序，如 select, epoll, kqueue 等等</strong>。<br><a href="https://lotabout.me/2017/understand-python-asyncio/">understand-python-asyncio</a></p><p>基础是generator(任何包含yield expression的函数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$ &gt;&gt;&gt;def gen_fn():</span><br><span class="line">        print(&apos;start&apos;)</span><br><span class="line">        yiled 1</span><br><span class="line">        print(&apos;middle&apos;)</span><br><span class="line">        yield 2</span><br><span class="line">        print(&apos;done&apos;)</span><br><span class="line">$ &gt;&gt;&gt; gen = gen_fn()</span><br><span class="line">$ &gt;&gt;&gt; gen</span><br><span class="line">$ &lt;generator object gen_fn at 0x7f83cddc0b48&gt;</span><br><span class="line">&gt;&gt;&gt; gen.gi_code.co_code //对应的bytecode</span><br><span class="line">b&apos;t\x00d\x01\x83\x01\x01\x00d\x02V\x00\x01\x00t\x00d\x03\x83\x01\x01\x00d\x04V\x00\x01\x00t\x00d\x05\x83\x01\x01\x00d\x00S\x00&apos;</span><br><span class="line">&gt;&gt;&gt; len(gen.gi_code.co_code)</span><br><span class="line">40</span><br><span class="line">&gt;&gt;&gt; gen.gi_frame.f_lasti //instruction pointer , 说明当前执行到哪个指令了，-1说明还没有开始执行</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; next(gen)</span><br><span class="line">start</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; ret = next(gen)</span><br><span class="line">middle</span><br><span class="line">&gt;&gt;&gt; ret</span><br><span class="line">2 // next方法返回的是yield里面的值</span><br><span class="line">&gt;&gt;&gt; next(gen)</span><br><span class="line">done</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration // 这是正常的，说明generator执行完毕</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(gen)</span><br><span class="line">  2           0 LOAD_GLOBAL              0 (print)</span><br><span class="line">              2 LOAD_CONST               1 (&apos;start&apos;)</span><br><span class="line">              4 CALL_FUNCTION            1</span><br><span class="line">              6 POP_TOP</span><br><span class="line"></span><br><span class="line">  3           8 LOAD_CONST               2 (1)</span><br><span class="line">             10 YIELD_VALUE</span><br><span class="line">             12 POP_TOP</span><br><span class="line"></span><br><span class="line">  4          14 LOAD_GLOBAL              0 (print)</span><br><span class="line">             16 LOAD_CONST               3 (&apos;middle&apos;)</span><br><span class="line">             18 CALL_FUNCTION            1</span><br><span class="line">             20 POP_TOP</span><br><span class="line"></span><br><span class="line">  5          22 LOAD_CONST               4 (2)</span><br><span class="line">             24 YIELD_VALUE</span><br><span class="line">             26 POP_TOP</span><br><span class="line"></span><br><span class="line">  6          28 LOAD_GLOBAL              0 (print)</span><br><span class="line">             30 LOAD_CONST               5 (&apos;done&apos;)</span><br><span class="line">             32 CALL_FUNCTION            1</span><br><span class="line">             34 POP_TOP</span><br><span class="line">             36 LOAD_CONST               0 (None)</span><br><span class="line">             38 RETURN_VALUE</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>python3.3中开始出现yield关键字，python3.4中开始引入asyncio标准库，python 3.5标准库中出现的async await关键字只是基于generator的sytatic sugar，那么<a href="https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython">generator是如何实现的</a>.</p><ul><li>The yield instruction takes the current executing context as a closure, and transforms it into an own living object. This object has a <strong>iter</strong> method which will continue after this yield statement.<br>So the call stack gets transformed into a heap object.</li></ul><p><a href="https://hackernoon.com/the-magic-behind-python-generator-functions-bc8eeea54220">解释generator实现原理的文章</a></p><p><a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">python 2.5开始，generator能够返回数据，这之前还只是iteratble的</a> 还可以通过gen.send函数往generator传参数<br><a href="https://github.com/AndreLouisCaron/a-tale-of-event-loops">event-loop的实现原理简述</a></p><p>python3.4需要使用@coroutine的decorator，3.5之后直接使用async await关键字，确实更加方便<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">speak_async</span><span class="params">()</span>:</span> </span><br><span class="line">    print(<span class="string">'starting===='</span>) </span><br><span class="line">    r = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment">##这里不能使用time.sleep(1)</span></span><br><span class="line">    print(<span class="string">'OMG asynchronicity!'</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(speak_async())  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></p><h3 id="多线程环境下对资源的操作需要考虑线程安全问题"><a href="#多线程环境下对资源的操作需要考虑线程安全问题" class="headerlink" title="多线程环境下对资源的操作需要考虑线程安全问题"></a>多线程环境下对资源的操作需要考虑线程安全问题</h3><p>有些操作不是原子性的<br><a href="https://www.youtube.com/watch?v=Bv25Dwe84g0">Thinking about Concurrency, Raymond Hettinger, Python core developer</a><br>java中最初的设计是有kill thread的method的，但是后来被deprecated了（假设你kill了一个获取了锁的线程，程序将进入死锁状态）。 python中理论上是可以kill一个线程的，但是kill一个线程这件事本身就是不应该的。</p><p>一个最简单的多线程资源竞争的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line"></span><br><span class="line">    counter += <span class="number">1</span> </span><br><span class="line">    print(<span class="string">'The count is %d'</span> % counter)</span><br><span class="line">    print(<span class="string">'------------'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Starting up --------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    threading.Thread(target=worker).start()</span><br><span class="line">print(<span class="string">'Finishing up'</span>)</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Starting up --------</span><br><span class="line"></span><br><span class="line">The count is 1</span><br><span class="line">------------</span><br><span class="line">The count is 2</span><br><span class="line">------------</span><br><span class="line">The count is 3</span><br><span class="line">------------</span><br><span class="line">The count is 4</span><br><span class="line">------------</span><br><span class="line">The count is 5</span><br><span class="line">------------</span><br><span class="line">The count is 6</span><br><span class="line">------------</span><br><span class="line">The count is 7</span><br><span class="line">------------</span><br><span class="line">The count is 8</span><br><span class="line">------------</span><br><span class="line">The count is 9</span><br><span class="line">------------</span><br><span class="line">The count is 10</span><br><span class="line">------------</span><br><span class="line">Finishing up</span><br></pre></td></tr></table></figure></p><p>数据量比较小的时候不容易发现这里存在的race condition。如果在每一次对资源进行操作之间都插入一段thread.sleep，问题就出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time, random</span><br><span class="line"></span><br><span class="line">FUZZ = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuzz</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> FUZZ:</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    fuzz()</span><br><span class="line">    oldcnt = counter</span><br><span class="line">    fuzz()</span><br><span class="line">    counter = oldcnt +<span class="number">1</span></span><br><span class="line">    fuzz()</span><br><span class="line">    print(<span class="string">'The count is %d'</span> % counter)</span><br><span class="line">    fuzz()</span><br><span class="line">    print(<span class="string">'------------'</span>)</span><br><span class="line">    fuzz()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Starting up --------\n'</span>)</span><br><span class="line">fuzz()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=worker)</span><br><span class="line">    t.start()</span><br><span class="line">    fuzz()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Finishing up'</span>)  </span><br><span class="line">fuzz()</span><br></pre></td></tr></table></figure><p>资源竞争场景下，问题就出来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Starting up --------</span><br><span class="line"></span><br><span class="line">The count is 1</span><br><span class="line">------------</span><br><span class="line">The count is 2</span><br><span class="line">The count is 3</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">The count is 5</span><br><span class="line">The count is 5</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">The count is 5</span><br><span class="line">------------</span><br><span class="line">Finishing up</span><br><span class="line">The count is 7</span><br><span class="line">The count is 8</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">The count is 8</span><br><span class="line">------------</span><br><span class="line">The count is 8</span><br><span class="line">------------</span><br></pre></td></tr></table></figure></p><p>多线程之间的同步问题，一种是加锁，另一种是使用atomic message queue.<br>python中有些module内部已经加了锁，logging,decimal(thread local),databases(reader locks and writer locks),email(atomic message queue)。<br>锁在写operating system的时候非常有用，但是其他时候不要用。<br>所有的资源都应该只能同时被一条线程操作。<br>threading中的join就属于一种barrier（主线程调用t.join，就是等t跑完了之后，主线程再去干接下来的事情） </p><h3 id="Raymond-Hettinger提到message-queue的task-done方法是他created的。-还是atomic-measge-queue-好像是内部加了锁，操作queue中资源的只有那么一条线程，当然不存在并发问题-其实raymod也提到了，你也可以用RabbitMQ等-ZEROMQ-甚至是database（内部有read-write-lock）"><a href="#Raymond-Hettinger提到message-queue的task-done方法是他created的。-还是atomic-measge-queue-好像是内部加了锁，操作queue中资源的只有那么一条线程，当然不存在并发问题-其实raymod也提到了，你也可以用RabbitMQ等-ZEROMQ-甚至是database（内部有read-write-lock）" class="headerlink" title="Raymond Hettinger提到message queue的task_done方法是他created的。(还是atomic measge queue, 好像是内部加了锁，操作queue中资源的只有那么一条线程，当然不存在并发问题). 其实raymod也提到了，你也可以用RabbitMQ等,ZEROMQ 甚至是database（内部有read write lock）"></a>Raymond Hettinger提到message queue的task_done方法是他created的。(还是atomic measge queue, 好像是内部加了锁，操作queue中资源的只有那么一条线程，当然不存在并发问题). 其实raymod也提到了，你也可以用RabbitMQ等,ZEROMQ 甚至是database（内部有read write lock）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        do_work(item)</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_worker_threads):</span><br><span class="line">     t = Thread(target=worker)</span><br><span class="line">     t.daemon = <span class="keyword">True</span></span><br><span class="line">     t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> source():</span><br><span class="line">    q.put(item)</span><br><span class="line"></span><br><span class="line">q.join()       <span class="comment"># block until all tasks are done</span></span><br></pre></td></tr></table></figure><p>爬虫简单的多线程版本是每个线程创建的时候，就给出一个args = [someurl] ，然后有多少任务就创建多少线程。但是这样做迟早会碰上操作系统对最大线程数的设置[据说400+]，于是又想到用threadPool,自己实现threadpool的也是大有人在（内部持有一个任务队列，不停去队列里获取任务）。(<a href="https://www.shanelynn.ie/using-python-threading-for-multiple-results-queue/">https://www.shanelynn.ie/using-python-threading-for-multiple-results-queue/</a>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: can&apos;t start new thread</span><br><span class="line">File &quot;/usr/lib/python2.5/threading.py&quot;, line 440, in start</span><br><span class="line">    _start_new_thread(self.__bootstrap, ())</span><br></pre></td></tr></table></figure></p><p>那么比较实用的使用场景是，spawn 10条线程去进行while not queue.empty() -&gt; requests.get()操作，各自在完成之后丢到一个通用的容器中，再由message queue独立完成所有response的processing.</p><h2 id="牵涉到一些celery的点"><a href="#牵涉到一些celery的点" class="headerlink" title="牵涉到一些celery的点"></a>牵涉到一些celery的点</h2><p>celery能够利用好多进程<br>todo</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://codewithoutrules.com/2018/09/04/python-multiprocessing/">多进程还可以牵涉到进程池的概念</a><br><a href="https://realpython.com/python-gil/">What is the Python Global Interpreter Lock (GIL)?</a><br><a href="https://timber.io/blog/multiprocessing-vs-multithreading-in-python-what-you-need-to-know/">multiprocessing-vs-multithreading-in-python-what-you-need-to-know</a><br><a href="https://emptysqua.re/blog/links-for-how-python-coroutines-work/">A. Jesse Jiryu Davis</a><br><a href="https://www.youtube.com/watch?v=7sCu4gEjH5I">How Do Python Coroutines Work</a><br><a href="https://www.youtube.com/watch?v=7SSYhuk5hmc">A Jesse Jiryu Davis Grok the GIL Write Fast And Thread Safe Python PyCon 2017</a> the only thing two threads cann’t do in once in Python is run python</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/1102533137-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If your code has a lot of I/O or Network usage:&lt;br&gt;Multithreading is your best bet because of its low overhead&lt;/li&gt;
&lt;li&gt;If you have a GUI&lt;br&gt;Multithreading so your UI thread doesn’t get locked up&lt;/li&gt;
&lt;li&gt;If your code is CPU bound:&lt;br&gt;You should use multiprocessing (if your machine has multiple cores)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://haldir65.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>tcpdump和wireshark使用手册</title>
    <link href="https://haldir65.github.io/2018/11/10/2018-11-10-tcpdump-and-wireshark-etc/"/>
    <id>https://haldir65.github.io/2018/11/10/2018-11-10-tcpdump-and-wireshark-etc/</id>
    <published>2018-11-10T20:57:53.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.haldir66.ga/static/imgs/osi-model.png" alt=""><br><a href="http://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf">wireshark expression cheetsheet</a><br><a href="http://packetlife.net/media/library/12/tcpdump.pdf">tcpdump cheet</a><br>wireshark能抓tcp,arp,http,dns,udp,icmp,dhcp…</p><a id="more"></a><p>先从wireshark说起，在win10上安装wireshark需要顺带装上winpacp，不过现在的安装包默认都会提示去安装，所以也都很简单<br>tcpdump在Linux上比较容易安装，类似于wireshark的command line tool</p><h3 id="wireshark的filter"><a href="#wireshark的filter" class="headerlink" title="wireshark的filter"></a>wireshark的filter</h3><p>现在wireshark的filter都会自动提示了，所以基本上随手敲几个就行了</p><p>http ##只看http的<br>http.request<br>tcp.dstport == 443 ## 只看https的<br>tcp.port == 113 ## 不管是source还是destination，只要是port 113的都筛出来(113是一个特殊的端口 Identification Protocol, Ident)<br>udp.port== 53 ## 筛选出所有的dns查询<br>ip.addr eq 192.168.1.3 and ip.addr eq 192.168.1.1 //假设本机ip是192.168.1.3并且路由器是192.168.1.1的话，这个可以筛选出所有的ipv4包<br>ip.src == 192.168.1.3 &amp;&amp; tcp.port == 80 //两个命令串联起来也是可以的<br>ip.addr //既包含src也包含dst<br>udp ||http // udp或者http的包<br>frame.len &lt;=128 //显示所有体积小于128个字节的包</p><p>//如果一开始就只对特定协议感兴趣<br>capture -&gt; filters 里面可以选择只抓某些协议的包。因为默认是什么都抓，这样会少很多</p><h3 id="一些有用的操作"><a href="#一些有用的操作" class="headerlink" title="一些有用的操作"></a>一些有用的操作</h3><p>选中一个column，右键 -&gt; follow -&gt;tcpstream ，可以查看这个packet的来回信息。（如果是http的话，request和response都给出来了）<br>菜单栏上的Statistics -&gt; conversatitons （查看所有的会话）<br>wireshark的结果可以save成.cap文件，下次可以打开<br>菜单栏上的Statistics -&gt; protocol Hierarchy(查看所有的协议)<br>菜单栏view -&gt; coloring rule（直接将特定的协议变成特定颜色的背景，方便识别）<br>view -&gt; time displayformat(格式化packet的时间显示成便于识别的时间，因为默认的显示单位是毫秒)<br>Statistics -&gt; endpoints // 查看所有连接过的ip</p><p>Statistics -&gt; packet length //查看所有的packet length（多数时候包的大小在40-79和1280-2559这个区间里面，没有小于40的，因为最少得40个字节）</p><ul><li>arp(addression resolution protocol)<br>一台电脑在发出去一个包之前，已经知道dest的ip地址，但是不知道这个ip地址对于的mac地址是多少，于是会发出一份arp request。<br>在局域网内部，是这样的</li><li>who has 192.168.1.1 ? Tell 192.168.1.7  //电脑发出arp请求</li><li>192.168.1.1 is at 00:xx:00:xe:b5 //很快得到了回应</li></ul><p><a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">arp包结构</a></p><p>一个ipv4地址需要32个bit表示,192.168.1.1这种写法叫做base10<br>一般情况下，192.168这俩一般表示的是network address, .1.1这俩一般表示的是Host address(physical computer)<br>net mask(255.255.0.0) 192.168.1/16。</p><h3 id="选中一个tcp包，查看Internet-Protocol-Version4-这里就是第三层-network层了-。"><a href="#选中一个tcp包，查看Internet-Protocol-Version4-这里就是第三层-network层了-。" class="headerlink" title="选中一个tcp包，查看Internet Protocol Version4 ..(这里就是第三层,network层了)。"></a>选中一个tcp包，查看Internet Protocol Version4 ..(这里就是第三层,network层了)。</h3><p><img src="https://haldir66.ga/static/imgs/wire_shark_internet_protocol_version4.png" alt=""><br>从上到下依次是<br>version: 4<br>Header length 20bytes<br>Differentiated Services Filed(不懂)<br>Total Length(这个是包含了)<br>Identification(类似于id)<br>Flags : 0x4000, Dont’t fragment(这个牵涉到mtu,maximum transmission unit size, 这个数值在ethernet上是1500bytes。假如一个包大小超过这个数，切成两个,也就是fragment.这个Flags里面可以看到More fragment: not set （0），意思就是说这个包没有被切成两个。有两种情况下这个标志设为0，一是没有分包，而是这个包恰好是最后一个)<br>Fragment offset：0 (假如被切成两个了，这里就表示当前这个包是被切完之后的第一个还是第二个，就当是index吧)。<br>这个包是访问google时留下的</p><p>有一个Time to live:128 (就是说这个包最多走128hop，就是最多经手128个router就丢掉)</p><h3 id="再看第四层（Transport-layer），也就是tcp-udp这类了。"><a href="#再看第四层（Transport-layer），也就是tcp-udp这类了。" class="headerlink" title="再看第四层（Transport layer），也就是tcp,udp这类了。"></a>再看第四层（Transport layer），也就是tcp,udp这类了。</h3><p>还是上面这个包<br><img src="https://haldir66.ga/static/imgs/wire_shark_capture_transmission_control_protocol.png" alt=""><br>从上到下依次是<br>Source Port<br>Destination Port :443 //https无疑<br>stream index: 4<br>sequence number 496 //确保数据没有丢失<br>Acknowledgement number : 4043 //下一个包的sequence number<br>Flags(urg:urgent,push:push,rst:reset,sin&amp;fin(finished))这张图里面写的是Acknowledgment(显然是ack包)<br>window size value: 2053(这个是tcp receiver buffer，单位是byte，这个数值变来变去的)<br>checksum(检查数据完整)</p><h2 id="说一说handshake"><a href="#说一说handshake" class="headerlink" title="说一说handshake"></a>说一说handshake</h2><p>tcp packets始于一个handshake<br>检查端口，发送一个sequence number(随机的),客户端会发送一个syn packet到接受方。接受方会返回一个syn ack packet,接下来客户端发送一个ack packet。上述步骤每一次sequence number都会+1<br><img src="https://haldir66.ga/static/imgs/wireshark_tcp_handshake.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Client 发送 SYN 包（seq: x），告诉 Server：我要建立连接；Client 进入SYN-SENT状态；</span><br><span class="line">2. Server 收到 SYN 包后，发送 SYN+ACK 包（seq: y; ack: x+1），告诉它：好的；Server 进入SYN-RCVD状态；</span><br><span class="line">3. Client 收到 SYN+ACK 包后，发现 ack=x+1，于是进入ESTABLISHED状态，同时发送 ACK 包（seq: x+1; ack: y+1）给 Server；Server 发现 ack=y+1，于是也进入ESTABLISHED状态；</span><br><span class="line">接下来就是互相发送数据、接收数据了……</span><br></pre></td></tr></table></figure></p><h3 id="tcp-teardown-四次挥手告别"><a href="#tcp-teardown-四次挥手告别" class="headerlink" title="tcp teardown(四次挥手告别)"></a>tcp teardown(四次挥手告别)</h3><p>host发送给destination一个fin acknowledge packet<br>destination发挥一个ack packet和一个fin ack packet<br>host再发送一个ack(这些都可以从flags里面看到)<br><img src="https://haldir66.ga/static/imgs/wireshark_tcp_wave.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意，可以是连接的任意一方主动 close，这里假设 Client 主动关闭连接：</span><br><span class="line"></span><br><span class="line">1. Client 发送 FIN 包，告诉 Server：我已经没有数据要发送了；Client 进入FIN-WAIT-1状态；</span><br><span class="line">2. Server 收到 FIN 包后，回复 ACK 包，告诉 Client：好的，不过你需要再等会，我可能还有数据要发送；Server 进入CLOSE-WAIT状态；而 Client 收到 ACK 包后，继续等待 Server 做好准备， Client 进入FIN-WAIT-2状态；</span><br><span class="line">3. Server 准备完毕后，发送 FIN 包，告诉 Client：我也没有什么要发送了，准备关闭连接吧；Server 进入LAST-ACK状态；</span><br><span class="line">4. Client 收到 FIN 包后，知道 Server 准备完毕了，于是给它回复 ACK 包，告诉它我知道了，于是进入TIME-WAIT状态；而 Server 收到 ACK 包后，即进入CLOSED状态；Client 等待 2MSL 时间后，没有再次收到 Server 的 FIN 包，于是确认 Server 收到了 ACK 包并且已关闭，于是 Client 也进入CLOSED状态；</span><br></pre></td></tr></table></figure></p><p>MSL即报文最大生存时间，RFC793 中规定 MSL 为 2 分钟，但这完全是从工程上来考虑，对于现在的网络，MSL=2分钟可能太长了一些。实际应用中常用的是 30 秒、1 分钟、2 分钟等；可以修改/etc/sysctl.conf内核参数，来缩短TIME_WAIT的时间，避免不必要的资源浪费。</p><p>所以整个tcp传输的过程看起来像这样<br><img src="https://haldir66.ga/static/imgs/wireshark_tcp_handwave.jpg" alt=""></p><p>有时候会看到rest，意味着连接突然中断了（tcp会断掉这个sequence的所有packet，把flags里面的reset设置为1）</p><h3 id="DHCP-Dynamic-Host-Configuration-Protocol-这个位于第7层"><a href="#DHCP-Dynamic-Host-Configuration-Protocol-这个位于第7层" class="headerlink" title="DHCP (Dynamic Host Configuration Protocol)这个位于第7层"></a>DHCP (Dynamic Host Configuration Protocol)这个位于第7层</h3><h3 id="DNS包结构"><a href="#DNS包结构" class="headerlink" title="DNS包结构"></a>DNS包结构</h3><p>DNS走的是udp的53端口，发出去的请求的dst.port=53，收到的response的src.port = 53.<br>在局域网内,dst就是路由ip(192.168.1.1)</p><p>访问tmall主页<br><img src="https://haldir66.ga/static/imgs/dns_query_round_trip.png" alt=""><br>一来一回的</p><p>先看request<br><img src="https://haldir66.ga/static/imgs/dns_query_request_detail.png" alt=""><br>在Domain Name System query的<br>Flags下有一个opcode(这个值可能是standard query，也可能是authoritated answers,如果response是从name server回来的话)<br>Flags下面还有一个Truncated(意思就是你发出的这个包是不是太大了，太大了塞不进一个packet)<br>还有Recursion desire:Do query recursively(这意味着servername支持recursive query，就是当前dns server找不到的话，会往上继续查找)</p><p>再来看response<br><img src="https://haldir66.ga/static/imgs/dns_query_response_detail.png" alt=""><br>结果在Answers里面</p><h3 id="https结构"><a href="#https结构" class="headerlink" title="https结构"></a>https结构</h3><p>wireshark上显示成tlsv1.2<br>找application data，在secure socket layer里面有encrypted Application Data(加密过的)<br>如果是http的话，在hypertext transfer protocol里面最底下会显示html encoded的post的data</p><h3 id="tcp-retransmission"><a href="#tcp-retransmission" class="headerlink" title="tcp retransmission"></a>tcp retransmission</h3><p>网速慢的时候(latency高)tcp会发现这些问题，重发<br>如果一个packet始终没有收到ack(在限定的时间内)，重发<br>两个packet之间的时间叫做round-trip time,每当出现retransmission的时候，z这个packet的rto直接double（windows上默认尝试5次，linux上有的达到15次），一直这样double的操作超过5次后，直接丢包</p><p>如果找到一个retransmission的包<br>rto time在transmission control protocol下面的expert info，里面有个<br>(the rto for this segment was: 0.220 seconds)<br>如果这次重发还不成功,0.44s后,0.88秒后。直到超过5次尝试</p><h3 id="tcp-duplicates"><a href="#tcp-duplicates" class="headerlink" title="tcp  duplicates"></a>tcp  duplicates</h3><p>duplicate ack，这通常出现在receiver收到了out of order packet。<br>所有的tcp连接都有一个isn( initial sequence number)，就是初始序列号了。后续的packet会在这个数字的基础上,data payload传递了多少，这个数就加多少。比方说src这边的isn是1000，发送了200bytes的数据，那么我收到的ack应该是1200.</p><p>上述是一切正常的情况，但是假如src这边的isn是1000，发出去200bytes，dst那边返回1200的sequence number的ack。此时，src这边出了问题，发出去一个1400的packet，dst那边就会认为，你这不对，重来一遍（发回一个1200的ack，一直尝试3次，直到src终于反应过来发出1200的包，这个正确的包叫做fast retransmission）。<br>在wireshark里面，dst发回来的重复的ack会显示为tcp dup ack。src最后一次正确的packet显示为tcp fast retransmission</p><p>所以一旦出现了skip isn的情况，要么dst发回dup ack，要么src发出fast retransmission</p><h3 id="tcp-flow-control"><a href="#tcp-flow-control" class="headerlink" title="tcp flow control"></a>tcp flow control</h3><p>即sliding window mechanism，原理是调整retransmission的速度（根据dst的recive window），因为dst那边是有一个tcp buffer space的，万一这个buffer溢出，就会造成丢包<br>wireshark中，在transmission control protocol下面，有一个window size.<br>比方说，src发送了一个isn =1的packet，window size = 8760。dst返回一个ack number = 2921的ack,同时window size变成5840.<br>这么来来回回，这个window迟早被小号玩，tcp zero window（正常情况下dst的应用层能够读走这部分数据，但是如果接收方读取速度跟不上的话，会发送一个ack包，告诉src发送慢一点,src接收到了之后，就会一直发keep-alive packet(非常小的包，66byte).如果dst那边还没处理好的话，会一直返回Tcp Zero window 的ack，这样往返数次）<br>在wireshark里面,tcp zero window的ack包里面会显示window size value: 0</p><h3 id="high-latency"><a href="#high-latency" class="headerlink" title="high latency"></a>high latency</h3><p>这个主要的标志是time这一栏超过1秒，延迟的原因很多。可以分析是去程慢还是返程慢。也有可能是服务器处理很慢。<br>network baseline(正常的延迟是多少，比如国内到美国一般150ms以上是起码的，这是物理决定的)</p><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>安装</p><blockquote><p>sudo apt-get install tcpdump</p></blockquote><p>使用<br>sudo tcpdump -i wlan0 ##i的意思是指定某个网络接口，输出非常多<br>sudo tcpdump -D ##哪些接口可用<br>sudo tcpdump -i 2 ##只看-D显示的第二个设备<br>sudo tcpdump -v -A ## A的意思是ASCII，至少内容容易辨识<br>sudo tcpdump -i 2 -c 4 ##只抓4个包<br>sudo tcpdump -i 2 -c -4 -n arp ##只抓arp的包,n的意思是supress host name,也能用来指定协议<br>sudo tcpdump -i 2 -c -4 -n tcp ##只抓4个tcp<br>sudo tcpdump -i 2 -c -4 -n icmp ##只抓4个icmp<br>sudo tcpdump -i 2 -c -4 src 192.168.1.1 ##指定src</p><p>sudo tcpdump -i 2 -c -4 -w filename.pcap ##保存到文件,这个文件用tcpdump打开也是可以的<br>sudo tcpdump -r  filename.pcap ##读取这个文件</p><p>可以和egrep一起用<br>sudo tcpdump -A -i 2 | egrep -i ‘pass=|pwd=|password=|username=’ –color=auto –line-buffered<br>//比方说抓到了md5过的密码，随便找个解密网站，就能解出来了</p><p><a href="https://segmentfault.com/a/1190000009562333">ARP欺骗</a> arp cache poisoning attack<br><a href="http://packetlife.net/media/library/23/common_ports.pdf">常用的端口号</a><br><a href="https://github.com/chrissanders/packets">各种可能的pcap文件</a><br><a href="https://www.zfl9.com/c-socket.html">本文大量文字图片出处</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/osi-model.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf&quot;&gt;wireshark expression cheetsheet&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://packetlife.net/media/library/12/tcpdump.pdf&quot;&gt;tcpdump cheet&lt;/a&gt;&lt;br&gt;wireshark能抓tcp,arp,http,dns,udp,icmp,dhcp…&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>tcp-nagel-algorithm-and-delay-ack</title>
    <link href="https://haldir65.github.io/2018/11/06/2018-11-06-nagel-algorithm-and-delay-ack/"/>
    <id>https://haldir65.github.io/2018/11/06/2018-11-06-nagel-algorithm-and-delay-ack/</id>
    <published>2018-11-06T13:25:55.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>Nagle’s Algorithm 和 Delayed ACK 一起用在特定场景下可能会造成网速不必要的延迟<br>傳送 TCP 封包的時候， TCP header 占 20 bytes， IPv4 header 占 20 bytes，若傳送的資料太小， TCP/IPv4 headers 造成的 overhead (40bytes) 並不划算。想像傳送資料只有 1 byte，卻要另外傳 40 bytes header，這是很大的浪費。若網路上有大量小封包，會占去網路頻寬，可能會造成網路擁塞 。这个是针对发送方而言的。</p><p><img src="https://www.haldir66.ga/static/imgs/nature-grass-wet-plants-high-resolution-wallpaper-573f2c6413708.jpg" alt=""><br><a id="more"></a></p><p>一个TCP数据包的传输至少需要固定的40字节头部信息(20字节TCP + 20字节IP)，如果数据包实际负载都比较小的话，那么传输的效率就非常低，但是如果将这些小包的负载都尽量集中起来，封装到一个TCP数据包中进行传输，那么传输效率势必将会大大提高。此处我们再次强调，TCP传输的是一个字节流，本身不存在所谓的离散形式的数据包的概念，协议可以任意组合、拆分每次调用实际传输的数据长度。</p><p>Nagle算法的思路在<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95">wiki</a>上也能找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if there is new data to send</span><br><span class="line"></span><br><span class="line">  if the window size &gt;= MSS and available data is &gt;= MSS</span><br><span class="line"></span><br><span class="line">    send complete MSS segment now</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">    if there is unconfirmed data still in the pipe</span><br><span class="line"></span><br><span class="line">      enqueue data in the buffer until an acknowledge is received</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">      send data immediately</span><br><span class="line"></span><br><span class="line">    end if</span><br><span class="line"></span><br><span class="line">  end if</span><br><span class="line"></span><br><span class="line">end if</span><br></pre></td></tr></table></figure></p><p>如果发送内容大于1个MSS， 立即发送；<br>如果之前没有包未被确认， 立即发送；<br>如果之前有包未被确认， 缓存发送内容；<br>如果收到ack， 立即发送缓存的内容。</p><p>概括地说来，其流程表述为：(a)不考虑窗口流量控制的限制，一旦累积的数据达到MSS就立即执行传输；(b)否则如果当前有未ACK的数据，就将数据堆积到发送队列里延迟发送；(c)如果没有待需要ACK的数据，就立即发送。简单说来，就是在数据没有累积到MSS的大小情况下，整个连接中允许有未ACK的数据。<br>　　Nagel算法本质上就是个时间换带宽的方法，所以对于那些带宽要求不大但对实时性要求高的程序，比如类似网络游戏类，需要使用TCP_NODELAY这个socket选项来关闭这个特性以减小延时发生。不过话外说来，对于这类程序或许使用UDP协议也是个选择。</p><p>想象一下，同时丢出去一大堆只有50个字节的包还是会造成带宽的浪费，还不如攒在一起发出去。</p><p>在Nagle算法中参数MSS(maximum segment size，IPv4默认值是576-20-20 = 536)<br><a href="https://en.wikipedia.org/wiki/Maximum_segment_size">Maximum_segment_size在wiki上还有专门的介绍</a></p><p>一些关键词：</p><p>acknowledged: TCP 傳送封包時會帶有流水號 ，起始值隨機，後面每傳 1 byte 就 +1。對方收到後會回傳 ACK 封包，帶有最後收到 byte 的數字。比方說收到 100 bytes，再收到 200 bytes，只要 ACK「起始值+300」即可。</p><p>sliding window: 允許傳送 unacked bytes 的最大值，確保在網路不佳的情況下，傳送端不會傳送過多封包加重擁塞。sliding window 的最大值是 2¹⁶ = 64 (KB)</p><h3 id="Delay-ACK"><a href="#Delay-ACK" class="headerlink" title="Delay ACK"></a>Delay ACK</h3><p>ACK 也是小封包，為了避免產生太多小封包，所以接收端不會每次收到封包都立即發 ACK，如果之後剛好需要送資料 ，順便帶上 ACK去可以省去小封包。實例: telnet server 會回傳使用者剛打的字，順便送 ACK 就可以省去小封包。</p><p>Linux的实现在 <a href="https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_input.c#L5066">__tcp_ack_snd_check</a>这个方法</p><p>通常最多延遲 200ms，RFC 規定不能超過 500ms。<br>每收到兩個 full-sized packet，一定要回一次 ACK。</p><h3 id="兩者合用的問題"><a href="#兩者合用的問題" class="headerlink" title="兩者合用的問題"></a>兩者合用的問題</h3><p>假設傳送端有開 Nagle’s Algorithm，接收端有開 delayed ACK (兩者在 Linux 都是預設值)。</p><p>以 HTTP 為例，若 server 的 response 被切成兩次 send，一次送 header，一次送 body，兩者都 &lt;MSS。</p><p>server 送完 header 後，因為 client 沒有回 ACK (delayed ACK)，server 也不會送 body (應用層覺得它已經送出了，但 kernel 還沒送)。<br>client 過了 200ms，送出收到 header 的 ACK。<br>server 收到 ACK 後，送出 body。<br>於是 client 多等了 200ms 才收到完整的 response。</p><h3 id="tcp缓冲的概念"><a href="#tcp缓冲的概念" class="headerlink" title="tcp缓冲的概念"></a>tcp缓冲的概念</h3><p><a href="https://www.cnblogs.com/promise6522/archive/2012/03/03/2377935.html">tcp缓冲</a><br>这些东西对于应用层来说是无感的</p><p>socket支持blocking(默认)和non-blocking模式，读写都存在阻塞问题<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p><p>牵涉到tcp缓冲层大小</p><p>首先，write成功返回，只是buf中的数据被复制到了kernel中的TCP发送缓冲区。至于数据什么时候被发往网络，什么时候被对方主机接收，什么时候被对方进程读取，系统调用层面不会给予任何保证和通知。<br>已经发送到网络的数据依然需要暂存在send buffer中，只有收到对方的ack后，kernel才从buffer中清除这一部分数据，为后续发送数据腾出空间。接收端将收到的数据暂存在receive buffer中，自动进行确认。但如果socket所在的进程不及时将数据从receive buffer中取出，最终导致receive buffer填满，由于TCP的滑动窗口和拥塞控制，接收端会阻止发送端向其发送数据。这些控制皆发生在TCP/IP栈中，对应用程序是透明的，应用程序继续发送数据，最终导致send buffer填满，write调用阻塞。</p><p>一般来说，由于接收端进程从socket读数据的速度跟不上发送端进程向socket写数据的速度，最终导致发送端write调用阻塞。</p><p>而read调用的行为相对容易理解，从socket的receive buffer中拷贝数据到应用程序的buffer中。read调用阻塞，通常是发送端的数据没有到达。</p><ul><li>read总是在接收缓冲区有数据时立即返回，而不是等到给定的read buffer填满时返回。只有当receive buffer为空时，blocking模式才会等待，而nonblock模式下会立即返回-1（errno = EAGAIN或EWOULDBLOCK）</li><li>blocking的write只有在缓冲区足以放下整个buffer时才返回（与blocking read并不相同）</li><li><p>nonblock write则是返回能够放下的字节数，之后调用则返回-1（errno = EAGAIN或EWOULDBLOCK）</p><p>对于blocking的write有个特例：当write正阻塞等待时对面关闭了socket，则write则会立即将剩余缓冲区填满并返回所写的字节数，再次调用则write失败（connection reset by peer）</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>启示就是应用层进行开发的时候不要零零散散的发数据，尽量攒成一个大一点的包再发出去。不要让系统层去做这件事。<br>TCP_NODELAY 是可以关闭Nagle算法的</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>window congestion<br>超时重传<br>阻塞，超时，</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://taozj.net/201808/nagle-and-delayed-ack.html">Nagle和Delayed ACK优化算法合用导致的死锁问题</a><br><a href="https://medium.com/fcamels-notes/nagles-algorithm-%E5%92%8C-delayed-ack-%E4%BB%A5%E5%8F%8A-minshall-%E7%9A%84%E5%8A%A0%E5%BC%B7%E7%89%88-8fadcb84d96f">Nagle’s Algorithm 和 Delayed ACK 以及 Minshall 的加強版</a><br><a href="https://cloud.tencent.com/developer/article/1004431">再说TCP神奇的40ms</a><br><a href="https://www.cnblogs.com/promise6522/archive/2012/03/03/2377935.html">tcp缓冲非常好的文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nagle’s Algorithm 和 Delayed ACK 一起用在特定场景下可能会造成网速不必要的延迟&lt;br&gt;傳送 TCP 封包的時候， TCP header 占 20 bytes， IPv4 header 占 20 bytes，若傳送的資料太小， TCP/IPv4 headers 造成的 overhead (40bytes) 並不划算。想像傳送資料只有 1 byte，卻要另外傳 40 bytes header，這是很大的浪費。若網路上有大量小封包，會占去網路頻寬，可能會造成網路擁塞 。这个是针对发送方而言的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/nature-grass-wet-plants-high-resolution-wallpaper-573f2c6413708.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何写shell脚本</title>
    <link href="https://haldir65.github.io/2018/11/04/2018-11-04-how-to-write-shell-scripts/"/>
    <id>https://haldir65.github.io/2018/11/04/2018-11-04-how-to-write-shell-scripts/</id>
    <published>2018-11-04T08:50:58.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>linux下shell脚本语句的语法<br>，脚本以<a href="https://en.wikipedia.org/wiki/Shebang_(Unix">Shebang</a>)开始</p><blockquote><p>#!/bin/sh</p></blockquote><p><img src="https://www.haldir66.ga/static/imgs/timg.jpg" alt=""><br><a id="more"></a></p><h3 id="linux下shell脚本语句的语法"><a href="#linux下shell脚本语句的语法" class="headerlink" title="linux下shell脚本语句的语法"></a>linux下shell脚本语句的语法</h3><p>linux大小写敏感</p><p>eg: echo类似于print<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##例：myvar=“Hi there！”</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$myvar</span>  <span class="comment">## Hi there！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$myvar</span>"</span>  <span class="comment">## Hi there!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">' $myvar'</span> <span class="comment">## $myvar</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> \<span class="variable">$myvar</span> <span class="comment">## $myvar</span></span><br></pre></td></tr></table></figure></p><p>eg:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">myPath=<span class="string">"/var/log/httpd/"</span></span><br><span class="line">myFile=<span class="string">"/var /log/httpd/access.log"</span></span><br><span class="line"><span class="comment">#这里的-x 参数判断$myPath是否存在并且是否具有可执行权限</span></span><br><span class="line"><span class="keyword">if</span> [ ! -x <span class="string">"<span class="variable">$myPath</span>"</span>]; <span class="keyword">then</span></span><br><span class="line">mkdir <span class="string">"<span class="variable">$myPath</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#这里的-d 参数判断$myPath是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$myPath</span>"</span>]; <span class="keyword">then</span></span><br><span class="line">mkdir <span class="string">"<span class="variable">$myPath</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#这里的-f参数判断$myFile是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">"<span class="variable">$myFile</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">touch <span class="string">"<span class="variable">$myFile</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#其他参数还有-n,-n是判断一个变量是否是否有值</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$myVar</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$myVar</span> is empty"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#两个变量判断是否相等</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$var1</span>"</span> == <span class="string">"<span class="variable">$var2</span>"</span> ]; <span class="keyword">then</span>  //<span class="keyword">if</span> 后面必须加<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$var1 eq $var2'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$var1 not eq $var2'</span></span><br><span class="line"><span class="keyword">fi</span> //<span class="keyword">else</span>后面必须加<span class="keyword">fi</span></span><br><span class="line">       <span class="keyword">if</span> list <span class="keyword">then</span></span><br><span class="line">           <span class="keyword">do</span> something here</span><br><span class="line">       <span class="keyword">elif</span> list <span class="keyword">then</span></span><br><span class="line">           <span class="keyword">do</span> another thing here</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">do</span> something <span class="keyword">else</span> here</span><br><span class="line">       <span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bashbash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello there"</span></span><br><span class="line">foo=<span class="string">"Hello"</span></span><br><span class="line">foo=<span class="string">"<span class="variable">$foo</span> World"</span>  <span class="comment">## 拼接一个现成的string到另一个string的尾部，用冒号跟美元符号就好了</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Number of files in this directory: `ls | wc -l`"</span>  <span class="comment">## 但是将ls | wc -l的输出作为一个String拼接到一个string中，用单引号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"all the files under the directory `ls  /usr/*/g* | head -n3`"</span></span><br></pre></td></tr></table></figure><p>一个把文件夹（/public/imgs）下所有文件重命名为img-x.jpg的shell脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">FORMAT_JPG=<span class="string">"jpg"</span></span><br><span class="line">FORMAT_JPEG=<span class="string">"jpeg"</span></span><br><span class="line">index=1</span><br><span class="line">dir=$(<span class="built_in">eval</span> <span class="built_in">pwd</span>)/public/imgs</span><br><span class="line">ALLIMGES=$(ls <span class="variable">$dir</span> | grep  <span class="string">".<span class="variable">$FORMAT_JPEG</span>\|.<span class="variable">$FORMAT_JPG</span>"</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$ALLIMGES</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        name=img-<span class="variable">$&#123;index&#125;</span>.jpg</span><br><span class="line">        <span class="built_in">echo</span> renaming <span class="variable">$dir</span>/<span class="variable">$file</span> to  <span class="variable">$dir</span>/<span class="variable">$name</span></span><br><span class="line">        mv <span class="variable">$dir</span>/<span class="variable">$file</span> <span class="variable">$dir</span>/<span class="variable">$name</span></span><br><span class="line">        ((index++))</span><br><span class="line">        <span class="comment"># name=$(ls $file | cut -d. -f1)</span></span><br><span class="line">        <span class="comment"># mv $dir/public/imgs/$file $&#123;name&#125;.$suffix</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"renaming <span class="variable">$index</span> image files =====&gt; x.jpg done!"</span></span><br></pre></td></tr></table></figure></p><p>同时grep多种文件的时候，比如又想要jpg又想要jpeg的话，grep 要加上反斜杠，或者下面这三种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;aaa\|bbb&quot;</span><br><span class="line">grep -E &quot;aaa|bbb&quot;</span><br><span class="line">grep -E aaa\|bbb</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cyberciti.biz/faq/howto-use-grep-command-in-linux-unix/">how to grep</a></p><p>想要在bash中设置一个variable为一个命令的输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">OUTPUT=<span class="string">"<span class="variable">$(ls -1)</span>"</span>  <span class="comment">## 注意，这里等于号前后不能有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;OUTPUT&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##那如果就是平时在terminal里面随便敲敲呢，下面这些亲测无误</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$(ls -al | wc)</span>"</span></span><br><span class="line"><span class="string">"<span class="variable">$(which java)</span>"</span> -h</span><br><span class="line"><span class="comment">## 比如说我想把java的路径填充到一段命令中间</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$(which java)</span>"</span>/something</span><br><span class="line">&gt;&gt; /usr/bin/java/something</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">java_stuff=<span class="string">"<span class="variable">$(which java)</span>"</span></span><br><span class="line"><span class="variable">$&#123;java_stuff&#125;</span> --version</span><br></pre></td></tr></table></figure></p><p>经常会在别人的bash脚本最前面看到一行 <a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html">set-e</a>：在阮一峰老师的博客中找到了解释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">set -e ## 这个set -e的原因，因为bash一般对错误容忍度比较高，一行命令出了错还能往下走，可是实际生产中，我们希望出了错就此打住。在文件前面写这个就行了</span><br><span class="line"></span><br><span class="line">## 总比下面这些这么写好吧</span><br><span class="line">command || exit 1 </span><br><span class="line">command || &#123; echo &quot;command failed&quot;; exit 1; &#125;</span><br><span class="line"></span><br><span class="line">set -eo pipefail ##set -e对于管道无效，这么写就连管道的错误都拦下来了</span><br></pre></td></tr></table></figure></p><p>$ set -e</p><p>这行代码之后的任何代码，如果返回一个非0的值，那么整个脚本立即退出，官方的说明是为了防止错误出现滚雪球的现象</p><p>$ set -o pipefail</p><p>原文解释如下：</p><p>If set, the return value of a pipeline is the value of the last (rightmost) command to exit with a non-zero status,or zero if all commands in the pipeline exit successfully. This option is disabled by default.</p><p>可理解为：</p><p>告诉 bash 返回从右到左第一个以非0状态退出的管道命令的返回值，如果所有命令都成功执行时才返回0</p><h3 id="变量-其实就是美元符号了"><a href="#变量-其实就是美元符号了" class="headerlink" title="变量($其实就是美元符号了)"></a>变量($其实就是美元符号了)</h3><p>变量调用符号($)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LI=date</span><br><span class="line"><span class="variable">$LI</span> <span class="comment">##</span></span><br><span class="line"><span class="comment"># Tue Dec  5 04:06:18 EST 2017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以经常会有这样的脚本</span></span><br><span class="line"><span class="comment"># Check if user is root</span></span><br><span class="line"><span class="keyword">if</span> [ $(id -u) != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" Not the root user! Try using sudo Command ! "</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Pass the test! You are the root user!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 亲测下面这种可用</span></span><br><span class="line"><span class="keyword">if</span> [ `whoami` = <span class="string">"root"</span> ];<span class="keyword">then</span>  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"root用户！"</span>  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"非root用户！"</span>  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>变量分为用户自定义的和环境变量（其实就是系统预设的）,有些区别</p><blockquote><p>用户自定义变量只在当前的shell中生效，环境变量在当前shell和这个shell的所有子shell中生效。<br>环境变量是全局变量，用户自定义变量是局部变量。<br>对系统生效的环境变量名和变量作用是固定的。</p></blockquote><h3 id="常用的环境变量"><a href="#常用的环境变量" class="headerlink" title="常用的环境变量"></a>常用的环境变量</h3><blockquote><p>HOSTNAME：主机名<br>SHELL：当前的shell<br>TREM：终端环境<br>HISTSIZE：历史命令条数<br>SSH_CLIENT：当前操作环境是用ssh链接的，这里记录客户端的ip<br>SSH_TTY：ssh连接的终端是pts/1<br>USER:当前登录的用户</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOSTNAME</span></span><br><span class="line"><span class="comment">## unbutu</span></span><br><span class="line">$? 最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值非0（具体是哪个数，由命令自己决定），则证明上一个命令执行不正确了。</span><br><span class="line">$$ 当前进程的进程号（PID）</span><br><span class="line">$! 后台运行的最后一个进程的进程号（PID）</span><br></pre></td></tr></table></figure><p>linux下查看环境变量命令：<br>export</p><p>直接把一个curl的脚本导到bash去执行的方式</p><ul><li>bash &lt;(curl -L -s <a href="https://install.direct/go.sh">https://install.direct/go.sh</a>)</li></ul><p><a href="http://blog.51cto.com/litaotao/1187983">LINUX下的21个特殊符号</a><br><a href="https://notes.wanghao.work/2015-06-02-Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">Shell学习笔记</a><br><a href="https://www.youtube.com/watch?v=Lu-xzWajbFo">how to use variables in shell scripts</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux下shell脚本语句的语法&lt;br&gt;，脚本以&lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix&quot;&gt;Shebang&lt;/a&gt;)开始&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;#!/bin/sh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/timg.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令(三)</title>
    <link href="https://haldir65.github.io/2018/11/04/2018-11-04-linux-affiliated-commands/"/>
    <id>https://haldir65.github.io/2018/11/04/2018-11-04-linux-affiliated-commands/</id>
    <published>2018-11-04T08:44:22.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.haldir66.ga/static/imgs/green_forset_alongside_river_2.jpg" alt=""></p><a id="more"></a><h3 id="linux-sed命令"><a href="#linux-sed命令" class="headerlink" title="linux sed命令"></a>linux sed命令</h3><p><a href="https://www.digitalocean.com/community/tutorials/the-basics-of-using-the-sed-stream-editor-to-manipulate-text-in-linux">basic sed</a></p><blockquote><p> sed operates on a stream of text that it reads from either standard input or from a file.</p></blockquote><p>基本命令格式<br>sed [options] commands [file-to-edit]</p><h2 id="默认情况下-sed会把结果输出到standoutput里面"><a href="#默认情况下-sed会把结果输出到standoutput里面" class="headerlink" title="默认情况下,sed会把结果输出到standoutput里面"></a>默认情况下,sed会把结果输出到standoutput里面</h2><p>sed ‘’ BSD ##等同于cat<br>cat BSD | sed ‘’ ##操作cat的输出流<br>sed ‘p’ BSD ##p是命令，明确告诉它要去print，这会导致每一行都被打印两遍<br>sed -n ‘p’ BSD ##我不希望你自动打印，每行只被打印一遍<br>sed -n ‘1p’ BSD ##只打印第一行<br>sed -n ‘1,5p’ BSD ##打印前5行<br>sed -n ‘1,+4p’ BSD ##这个也是打印前五行<br>sed -n ‘1~2p’ BSD ##every other line，打印一行跳过一行，从第一行开始算<br>sed ‘1~2d’ BSD ##也是隔一行进行操作，只不过这里的d表示删除，结果就是1，3，5…行被从cat的结果中删掉</p><p>默认情况下,sed不会修改源文件，加上-i就能改了<br>sed -i ‘1~2d’ everyother.txt ##第1，3，5，…行被删掉<br>sed -i.bak ‘1~2d’ everyother.txt ##在编辑文件之前保存一份.bak文件作为备份</p><p>sed最为常用的命令就是substituting text了<br>echo “<a href="http://www.example.com/index.html">http://www.example.com/index.html</a>“ | sed ‘s_com/index<em>org/home</em>‘<br><a href="http://www.example.org/home.html">http://www.example.org/home.html</a></p><p>命令是这么用的,首先s表示substitute<br>‘s/old_word/new_word/‘</p><p>准备好这么一份text文件<br>echo “this is the song that never ends<br>yes, it goes on and on, my friend<br>some people started singing it<br>not knowing what it was<br>and they’ll continue singing it forever<br>just because…” &gt; annoying.txt</p><p>sed ‘s/on/forward/‘ annoying.txt ##把所有的on换成forward，同时打印出结果。但如果当前行已经替换过一次了，就跳到下一行。所以可能没有替换干净</p><p>sed ‘s/on/forward/g’ annoying.txt ## 加上g就好了<br>sed ‘s/on/forward/2’ annoying.txt ##每一行只替换第二个匹配上的<br>sed -n ‘s/on/forward/2p’ annoying.text ## n是supress自动print，只打印出哪些被换了的<br>sed ‘s/SINGING/saying/i’ annoying.txt ##希望大小写不敏感<br>sed ‘s/^.<em>at/REPLACED/‘ annoying.txt ##从每一行的开头到”at”<br>sed ‘s/^.</em>at/(&amp;)/‘ annoying.txt ## 把那些会匹配上的文字用括号包起来</p><p><a href="https://www.digitalocean.com/community/tutorials/intermediate-sed-manipulating-streams-of-text-in-a-linux-environment">intermediate training</a></p><p>linux下查看一个文件的时间戳</p><blockquote><p>stat test</p></blockquote><p>c语言下对应的函数在sys/stat.h头文件中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">filestat</span>;</span></span><br><span class="line">    stat(<span class="string">"/etc/sysctl.conf"</span>, &amp;filestat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size: %ld bytes, uid: %d, gid: %d, mode: %#o\n"</span>, filestat.st_size, filestat.st_uid, filestat.st_gid, filestat.st_mode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>windows的换行符是 \r\l，linux的是 \l，mac的是 \r<br>从根本上讲，二进制文件和文本文件在磁盘中没有区别，都是以二进制的形式存储<br>二进制和文本模式的区别在于对换行符和一些非可见字符的转化上，如非必要，是使用二进制读取会比较安全一些</p></blockquote><p>因为 Windows 和 Linux 中的换行符不一致，前者使用CRLF(即\r\n)表示换行，后者则使用LF(即\n)表示换行<br>而C语言本身使用LF(即\n)表示换行，所以在文本模式下，需要转换格式(如Windows)，但是在 Linux 下，文本模式和二进制模式就没有什么区别</p><p>另外，以文本方式打开时，遇到结束符CTRLZ(0x1A)就认为文件已经结束<br>所以，若使用文本方式打开二进制文件，就很容易出现文件读不完整，或內容不对的错误<br>即使是用文本方式打开文本文件，也要谨慎使用，比如复制文件，就不应该使用文本方式</p><h3 id="signal处理"><a href="#signal处理" class="headerlink" title="signal处理"></a>signal处理</h3><p><a href="https://www.youtube.com/watch?v=XUhGdORXL54">HakTip - Linux Terminal 101: Controlling Processes</a></p><p>linux上信号有32种，多数在C语言中都有默认的处理方式（并且这种默认的处置方式也是可以更改的），除了SIGKILL(强行terminate)和SIGSTOP(debug遇到断点)不允许开发者更改处理方式。(kill -9也就是强杀非常有效)<br>c程序可以通过signal(比较老了)函数或者sigaction(推荐)函数注册收到信号之后的动作</p><p><a href="https://unix.stackexchange.com/questions/6593/force-directory-to-always-be-in-cache">Linux by default use the RAM as disk cache</a><br>这里的回答解释了系统会默认在内存中缓存磁盘节点的信息，下一次进行find的操作时候，就会快很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/green_forset_alongside_river_2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://haldir65.github.io/categories/blog/"/>
    
    
      <category term="linux" scheme="https://haldir65.github.io/tags/linux/"/>
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>网络传输的字节序问题</title>
    <link href="https://haldir65.github.io/2018/11/03/2018-11-03-idea-byte-endianness/"/>
    <id>https://haldir65.github.io/2018/11/03/2018-11-03-idea-byte-endianness/</id>
    <published>2018-11-03T10:38:04.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>字节序（Endianness），在计算机科学领域中，是跨越<strong><em>多字节</em></strong>的程序对象的存储规则。 </p><p><img src="https://haldir66.ga/static/imgs/ship_docking_along_side_bay.jpg" alt=""><br><a id="more"></a></p><h2 id="首先确认下c语言下基本数据类型大小"><a href="#首先确认下c语言下基本数据类型大小" class="headerlink" title="首先确认下c语言下基本数据类型大小"></a>首先确认下c语言下基本数据类型大小</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(int)= %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(char)= %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(long)= %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(float)= %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(short)= %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br></pre></td></tr></table></figure><blockquote><p>sizeof(int)= 4<br>sizeof(char)= 1<br>sizeof(long)= 8<br>sizeof(float)= 4<br>sizeof(short)= 2</p></blockquote><h2 id="来看一下c语言这边用socket以int，long的形式发送数据，Python这边接收会是怎么样的"><a href="#来看一下c语言这边用socket以int，long的形式发送数据，Python这边接收会是怎么样的" class="headerlink" title="来看一下c语言这边用socket以int，long的形式发送数据，Python这边接收会是怎么样的"></a>来看一下c语言这边用socket以int，long的形式发送数据，Python这边接收会是怎么样的</h2><p>c语言的server长这样<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; // socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  // 基本数据类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // read write</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; // open close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 7037</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV <span class="meta-string">"0.0.0.0"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[ ])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        signal(SIGINT,handle_signal);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数</span></span><br><span class="line">        <span class="comment">// 定义 socket</span></span><br><span class="line">        sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 定义 sockaddr_in</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">skaddr</span>;</span></span><br><span class="line">        skaddr.sin_family = AF_INET; <span class="comment">// ipv4</span></span><br><span class="line">        skaddr.sin_port   = htons(PORT);</span><br><span class="line">        skaddr.sin_addr.s_addr = inet_addr(SERV);</span><br><span class="line">        <span class="comment">// bind，绑定 socket 和 sockaddr_in</span></span><br><span class="line">        <span class="keyword">if</span>( bind(sockfd,(struct sockaddr *)&amp;skaddr,<span class="keyword">sizeof</span>(skaddr)) == <span class="number">-1</span> )&#123;</span><br><span class="line">                perror(<span class="string">"bind error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// listen，开始添加端口</span></span><br><span class="line">        <span class="keyword">if</span>( listen(sockfd,QUEUE) == <span class="number">-1</span> )&#123;</span><br><span class="line">                perror(<span class="string">"listen error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端信息</span></span><br><span class="line">        <span class="keyword">char</span> buff[BUFF_SIZE];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">claddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(claddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> sock_client = accept(sockfd,(struct sockaddr *)&amp;claddr, &amp;length);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,++count);</span><br><span class="line">                <span class="keyword">if</span>( sock_client &lt;<span class="number">0</span> )&#123;</span><br><span class="line">                        perror(<span class="string">"accept error"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//在这里发送出byte数组</span></span><br><span class="line">                send(sock_client,(<span class="keyword">char</span>*)a,<span class="keyword">sizeof</span>(a),<span class="number">0</span>);</span><br><span class="line">                close(sock_client);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"have a nice day"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>python的client长这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 创建一个socket:</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">'192.168.1.45'</span>, <span class="number">7037</span>))</span><br><span class="line">s.send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n'</span>)</span><br><span class="line"><span class="comment"># 接收数据:</span></span><br><span class="line">buffer = []</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 每次最多接收1个字节:</span></span><br><span class="line">    d = s.recv(<span class="number">1</span>)</span><br><span class="line">    t = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> d:</span><br><span class="line">        print(format(x,<span class="string">'b'</span>))</span><br><span class="line">    <span class="keyword">if</span> d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">data = <span class="string">b''</span>.join(buffer)</span><br><span class="line">print(data)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></p><p>在局域网内的两台电脑,server跑在mac上,client跑在win10<br>client这边打印出了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1    </span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">===我是四个byte等于一个int的手动分割线===</span><br><span class="line">10</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">===我是四个byte等于一个int的手动分割线===</span><br><span class="line">11</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>按照server端(intel cpu)是小端的理论，把上面接收到的横过来掉个头<br>前四个字节是”1”<br>1   0   0   0<br>0   0   0   1  -&gt; 显然是1</p><p>中间四个字节是”2”<br>10  0   0   0<br>0   0   0   10 -&gt; 显然是2</p><p>最后四个字节是”3”<br>11  0   0   0<br>0   0   0   11 -&gt; 显然是3</p><p>教科书诚不我欺也</p><p>这里如果把c语言的server改一下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//在这里发送出byte数组</span></span><br><span class="line">send(sock_client,(<span class="keyword">char</span>*)a,<span class="keyword">sizeof</span>(a),<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>client一字不改，得到的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">10000000</span><br><span class="line">111111</span><br><span class="line">===我是四个byte等于一个float的手动分割线===</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1000000</span><br><span class="line">===我是四个byte等于一个float的手动分割线===</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1000000</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure></p><p>这个其实跟float是如何表示小数有关了，float有几个bit是专门给小数点后面的数值和指数准备的。<br>float是4个byte，这32位是这么分的：<br>1bit（符号位） 8bits（指数位） 23bits（尾数位）（内存中就长这样）</p><p>改成long呢，short呢？<br>改成long<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1    </span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">===我是八个byte等于一个long的手动分割线===</span><br><span class="line">10</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">===我是八个byte等于一个long的手动分割线===</span><br><span class="line">11</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>问题已经很清楚了。<br>上述是把数字当做int,long,float这种数据类型来发送，但如果是把123这三个数字当做”123”这种字符串，数字1其实只用一个byte就解决了，也就不存在什么字节序的问题了</p><p>如C编写的进程和Java编写的进程间通信，(JVM也是大端）。在主机和网络字节序的互相转化主要涉及IP地址和端口。c语言写server要老老实实去转换ip地址和端口的字节序，这也是为了遵守规范<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netstat/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure></p><p>网络字节序是一种规定，它规定了传输的数据应该按照大端，因为通信双方的字节序其实是不确定的，但是按照规定我们都认为接收到的数据都是大端，即遵守规定的顺序，这样老老实实地通过htons系列函数处理格式化的数据（如int）保证了不会出现任何错误。</p><p>但是，我们自己写的C/S因为都是小端，所以即使没有遵守规定，依然可以用，但这样并不规范，有潜在的隐患。</p><p>而对于IP地址或者端口，因为这些数据的处理全部是在应用层以下，是路由器，网卡进行处理，它们在设计时自然遵守规定全部依照网络字节序对数据进行处理，而你自己不把IP地址转换顺序，交给下层处理时自然会出错。</p><p>所以，在应用层，也应该遵守规定，对于int double 这样的数据也应该转换字节序，当然字符串也挺好（这大概也就是Json的优势了，而像protobuf这种传输时就要注意顺序）。</p><p><a href="https://blog.csdn.net/XiyouLinux_Kangyijie/article/details/72991235">抓包看ip地址字节序转换</a><br>utf-8还有一个byte-order-mark(bom)的问题</p><p>C语言下可以把一个byte按照binary的方式打印出来(就是把一个byte的每一个bit输出来),int也可以。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_bin</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> byte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = CHAR_BIT; <span class="comment">/* however many bits are in a byte on your platform */</span></span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'0'</span> + ((byte &gt;&gt; i) &amp; <span class="number">1</span>)); <span class="comment">/* loop through and print the bits */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_bin_int</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> integer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = CHAR_BIT * <span class="keyword">sizeof</span> integer; <span class="comment">/* however many bits are in an integer */</span></span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'0'</span> + ((integer &gt;&gt; i) &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkCPUendian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line">  &#125;c;</span><br><span class="line">  c.a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %a , b= %a \n"</span>,c.a , c.b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %X , b= %X \n"</span>,c.a , c.b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %p , b= %p \n"</span>,c.a , c.b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %u , b= %u \n"</span>,c.a , c.b);</span><br><span class="line">  print_bin(c.b);</span><br><span class="line">  print_bin_int(c.a);</span><br><span class="line">  <span class="keyword">return</span> (c.b == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkCPUendian())&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Little endian platform!\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Big Endian platform!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出，这里是从高地址内存开始往低地址的内存读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 0x0.07fcbc8474a98p-1022 , b= 0x0p+0</span><br><span class="line">a = 1 , b= 1</span><br><span class="line">a = 0x1 , b= 0x1</span><br><span class="line">a = 1 , b= 1</span><br><span class="line">00000001</span><br><span class="line"></span><br><span class="line">00000000000000000000000000000001</span><br><span class="line"></span><br><span class="line">Little endian platform!</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字节序（Endianness），在计算机科学领域中，是跨越&lt;strong&gt;&lt;em&gt;多字节&lt;/em&gt;&lt;/strong&gt;的程序对象的存储规则。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haldir66.ga/static/imgs/ship_docking_along_side_bay.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>读物</title>
    <link href="https://haldir65.github.io/2018/10/28/2018-10-28-idea-for-good-reading/"/>
    <id>https://haldir65.github.io/2018/10/28/2018-10-28-idea-for-good-reading/</id>
    <published>2018-10-28T21:43:40.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>好的博客，好的文章的收藏夹<br><img src="https://www.haldir66.ga/static/imgs/ripe-grapes-macro-wallpaper-1920x1080-538350f32e183.jpg" alt=""><br><a id="more"></a></p><p><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/index.html">Linux C编程一站式学习</a></p><p><a href="http://normanmaurer.me/">author of netty</a><br><a href="http://cmsblogs.com/?cat=189">死磕java</a><br><a href="https://droidyue.com/">技术小黑屋</a><br><a href="https://imququ.com/">Jerry Qu 专注 WEB 端开发</a></p><p><a href="https://realpython.com/python-sockets/">非常非常全的关于python socket编程的文章，文章本身也很长</a></p><p><a href="https://www.zfl9.com/categories/c/">关于c语言写的很好的博客</a><br><a href="https://wizardforcel.gitbooks.io/network-basic/content/6.html">关于网络基本功的</a></p><p><a href="https://hackernoon.com/">how hackers start their afternoons.</a> 很像medium的一个网站</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好的博客，好的文章的收藏夹&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/ripe-grapes-macro-wallpaper-1920x1080-538350f32e183.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty及nio知识手册</title>
    <link href="https://haldir65.github.io/2018/10/13/2018-10-13-netty-and-nio-intro/"/>
    <id>https://haldir65.github.io/2018/10/13/2018-10-13-netty-and-nio-intro/</id>
    <published>2018-10-13T21:34:19.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.haldir66.ga/static/imgs/cute_cat_sleepy.jpg" alt=""><br><a id="more"></a></p><p>都说netty要比nio好用，先从官方的intro page看起。</p><p>ByteBuff是reference counted的，netty的作者说：<br>java给人一种不需要清理garbage的illusion<br>allocating stuff is no big deal , garbage collecting it is.</p><p>selectors</p><p><a href="https://netty.io/4.1/xref/overview-summary.html">netty的example非常多，http2,cors,upload等等都有</a></p><p><a href="https://www.youtube.com/watch?v=DKJ0w30M0vg">Netty - One Framework to rule them all by Norman Maurer</a><br><a href="https://www.youtube.com/watch?v=_GRIyCMNGGI">netty best practices with norman maurer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/cute_cat_sleepy.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从Socket入手实现http协议</title>
    <link href="https://haldir65.github.io/2018/10/13/2018-10-13-implementing-http-server-via-socket/"/>
    <id>https://haldir65.github.io/2018/10/13/2018-10-13-implementing-http-server-via-socket/</id>
    <published>2018-10-13T21:30:36.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.haldir66.ga/static/imgs/sun_rise_dim_grass.jpg" alt=""></p><p>收集几种语言中使用socket实现httpServer和httpClient的主要步骤<br><a id="more"></a></p><p>OSI七层网络体系结构 ： 物理层(IEEE 802.2)、数据链路层(ARP,RARP)、网络层(ip,icmp)、传输层(tcp,udp)、表示层、会话层(SSL,TLS)、应用层(HTTP,FTP,SMTP,POP3).<br>这里面Socket比较特殊，Socket是一组编程接口（API）。介于传输层和应用层，向应用层提供统一的编程接口。应用层不必了解TCP/IP协议细节,直接通过对Socket接口函数的调用完成数据在IP网络的传输。SOCKET 算不上是个协议，应该是应用层与传输层间的一个抽象层，是个编程接口。</p><p>tcp包结构是不包含ip地址的，只有source port(2个byte)和destination port(65536这么来的)的. ip address是ip层的工作。</p><p><a href="https://tools.ietf.org/html/rfc7230">HTTP 1.1的RFC非常长</a></p><blockquote><p>在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。(在wireShark的抓包结果就是这么展示的)</p></blockquote><p><a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/chapter1.html">tcp包结构，udp的也有</a></p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>用java实现一个httpclient怎么样?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket mSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpSocketClient client = <span class="keyword">new</span> HttpSocketClient();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.sendGet(<span class="string">"www.baidu.com"</span>,<span class="number">80</span>,<span class="string">"/"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpSocketClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mSocket = <span class="keyword">new</span> Socket();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在百度服务器面前，这就是一个正常的浏览器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendGet</span><span class="params">(String host, <span class="keyword">int</span> port, String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketAddress dest = <span class="keyword">new</span> InetSocketAddress(host, port);</span><br><span class="line">        mSocket.connect(dest);</span><br><span class="line">        OutputStreamWriter streamWriter = <span class="keyword">new</span> OutputStreamWriter(mSocket.getOutputStream());</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(streamWriter);</span><br><span class="line"></span><br><span class="line">        bufferedWriter.write(<span class="string">"GET "</span> + path + <span class="string">" HTTP/1.1\r\n"</span>);</span><br><span class="line">        bufferedWriter.write(<span class="string">"Host: "</span> + host + <span class="string">"\r\n"</span>);</span><br><span class="line">        bufferedWriter.write(<span class="string">"Connection: "</span> + <span class="string">"keep-alive"</span> + <span class="string">"\r\n"</span>);</span><br><span class="line">        bufferedWriter.write(<span class="string">"User-Agent: "</span> + <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36"</span> + <span class="string">"\r\n"</span>);</span><br><span class="line">        bufferedWriter.write(<span class="string">"Accept: "</span> + <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span> + <span class="string">"\r\n"</span>);</span><br><span class="line">        bufferedWriter.write(<span class="string">"Accept-Language: "</span> + <span class="string">"zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7"</span> + <span class="string">"\r\n"</span>);</span><br><span class="line">        bufferedWriter.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        bufferedWriter.flush(); <span class="comment">//flush一下很重要，等于说已经写完了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BufferedInputStream stream = <span class="keyword">new</span> BufferedInputStream(mSocket.getInputStream());</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(stream));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        mSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Date: Sat, 24 Mar 2018 06:44:20 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 225</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Set-Cookie: BAIDUID=259D5F393E329E8E44651C589037C093:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BIDUPSID=259D5F393E329E8E44651C589037C093; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: PSTM=1521873860; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BD_LAST_QID=10107339987852007720; path=/; Max-Age=1</span><br><span class="line">P3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">Location: https://www.baidu.com/</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">X-UA-Compatible: IE=Edge,chrome=1</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;65d90fa34a5e777be72b3e20c859c335f9198cc2</span><br><span class="line">Time : Thu Mar 15 16:20:59 CST 2018&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>当然因为访问的是http，302是临时重定向（另外，几乎没见过谁返回301的，301的结果会被浏览器缓存），注意上面返回了Location字段，所以是符合规范的</p><p>server这边普遍用的是netty，正好netty的官网上也有相关的教程.<br><a href="https://netty.io/4.1/xref/overview-summary.html">netty的example非常多，http2,cors,upload等等都有</a></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><a href="https://github.com/Haldir65/Jimmy/blob/rm/basics/simpleHttpServer/httpServer.py">我自己抄来的简易版</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## server </span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> codecs,logging</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((HOST, <span class="number">18004</span>))</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># infinite loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># maximum number of requests waiting</span></span><br><span class="line">    conn, addr = sock.accept()</span><br><span class="line">    request = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> isinstance(request,bytes):</span><br><span class="line">        request = str(request)</span><br><span class="line">        logging.error(request)</span><br><span class="line"></span><br><span class="line">    splited = request.split(<span class="string">' '</span>)    </span><br><span class="line">    <span class="keyword">if</span>(len(splited)&lt;<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    method = request.split(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">    src = request.split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Connect by: '</span>, addr)</span><br><span class="line">    print(<span class="string">'Request is:\n'</span>, request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># deal wiht GET method</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">'GET'</span> <span class="keyword">or</span> method.__contains__(<span class="string">'GET'</span>):</span><br><span class="line">        <span class="keyword">if</span> src == <span class="string">'/index.html'</span>:</span><br><span class="line">            content = index_content</span><br><span class="line">        <span class="keyword">elif</span> src == <span class="string">'/image/image_12.jpg'</span>:</span><br><span class="line">            content = pic_content</span><br><span class="line">        <span class="keyword">elif</span> src == <span class="string">'/reg.html'</span>:</span><br><span class="line">            content = reg_content</span><br><span class="line">        <span class="keyword">elif</span> re.match(<span class="string">'^/\?.*$'</span>, src):</span><br><span class="line">            entry = src.split(<span class="string">'?'</span>)[<span class="number">1</span>]  <span class="comment"># main content of the request</span></span><br><span class="line">            content = <span class="string">'HTTP/1.x 200 ok\r\nContent-Type: text/html\r\n\r\n'</span></span><br><span class="line">            content += entry</span><br><span class="line">            content += <span class="string">'&lt;br /&gt;&lt;font color="green" size="7"&gt;register successs!&lt;/p&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deal with POST method</span></span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">'POST'</span>:</span><br><span class="line">        form = request.split(<span class="string">'\r\n'</span>)</span><br><span class="line">        entry = form[<span class="number">-1</span>]  <span class="comment"># main content of the request</span></span><br><span class="line">        content = <span class="string">'HTTP/1.x 200 ok\r\nContent-Type: text/html\r\n\r\n'</span></span><br><span class="line">        content += entry</span><br><span class="line">        content += <span class="string">'&lt;br /&gt;&lt;font color="green" size="7"&gt;register successs!&lt;/p&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">######</span></span><br><span class="line">    <span class="comment"># More operations, such as put the form into database</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment">######</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span>(type(content) <span class="keyword">is</span> str):</span><br><span class="line">        content = content.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    conn.sendall(content)</span><br><span class="line">    <span class="comment"># close connection</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure></p><p>本地浏览器访问localhost:10086应该就能看到结果了，值得一提的是自己在chrome里面访问”<a href="http://localhost:18004/index.html&quot;这个地址的时候，事实上浏览器发送的数据是这样的">http://localhost:18004/index.html&quot;这个地址的时候，事实上浏览器发送的数据是这样的</a></p><blockquote><p>b’GET /index.html HTTP/1.1\r\nHost: localhost:18004\r\nConnection: keep-alive\r\nCache-Control: max-age=0\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\nDNT: 1\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\r\nCookie: _ga=GA1.1.dsadsa.dsadas; _gid=GA1.1.dsadsa.dsadasda\r\n\r\n’</p></blockquote><p>对了，浏览器默认会请求favicon，所以在服务器这边看到了另一个请求</p><blockquote><p>b’GET /favicon.ico HTTP/1.1\r\nHost: localhost:18004\r\nConnection: keep-alive\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\nDNT: 1\r\nAccept: image/webp,image/apng,image/<em>,</em>/*;q=0.8\r\nReferer: <a href="http://localhost:18004/index.html\r\nAccept-Encoding">http://localhost:18004/index.html\r\nAccept-Encoding</a>: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\r\nCookie: _ga=GA1.1.dsadsa.dsadas; _gid=GA1.1.dsadsa.dsadasda\r\n\r\n’</p></blockquote><p>平时用的都是<a href="https://github.com/requests/requests/">requests</a>这个库,不过自己写也还是很简单<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 导入socket库:</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket:</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">'www.sina.com.cn'</span>, <span class="number">80</span>))</span><br><span class="line">s.send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n'</span>)</span><br><span class="line"><span class="comment"># 接收数据:</span></span><br><span class="line">buffer = []</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 每次最多接收1k字节:</span></span><br><span class="line">    d = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">data = <span class="string">b''</span>.join(buffer)</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line">header, html = data.split(<span class="string">b'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">print(header.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 把接收的数据写入文件:</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'sina.html'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure></p><p>上述代码，server和client都不能很好的处理并发或者利用多进程</p><p><a href="https://realpython.com/python-sockets/">高阶版</a></p><h2 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h2><p>C语言的应该最接近底层,C语言实现HTTP的GET和POST请求<br><a href="http://pminkov.github.io/blog/socket-programming-in-linux.html">似乎有很多现成的例子可以直接拿来抄</a></p><p>一个简单的httpServer.c(unix环境下运行)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; // socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  // 基本数据类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // read write</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; // open close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV <span class="meta-string">"0.0.0.0"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">doc_type</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> *key;</span><br><span class="line">        <span class="keyword">char</span> *value;</span><br><span class="line">&#125;HTTP_CONTENT_TYPE;</span><br><span class="line"></span><br><span class="line">HTTP_CONTENT_TYPE http_content_type[] = &#123;</span><br><span class="line">        &#123; <span class="string">"html"</span>,<span class="string">"text/html"</span> &#125;,</span><br><span class="line">        &#123; <span class="string">"gif"</span> ,<span class="string">"image/gif"</span> &#125;,</span><br><span class="line">        &#123; <span class="string">"jpeg"</span>,<span class="string">"image/jpeg"</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> *http_res_tmpl = <span class="string">"HTTP/1.1 200 OK\r\n"</span></span><br><span class="line">        <span class="string">"Server: Cleey's Server V1.0\r\n"</span></span><br><span class="line">    <span class="string">"Accept-Ranges: bytes\r\n"</span></span><br><span class="line">        <span class="string">"Content-Length: %d\r\n"</span></span><br><span class="line">        <span class="string">"Connection: close\r\n"</span></span><br><span class="line">        <span class="string">"Content-Type: %s\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> sign)</span></span>; <span class="comment">// 退出信号处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_send</span><span class="params">(<span class="keyword">int</span> sock,<span class="keyword">char</span> *content)</span></span>; <span class="comment">// http 发送相应报文</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">joinString</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> *s2)</span></span>;<span class="comment">//字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[ ])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        signal(SIGINT,handle_signal);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数</span></span><br><span class="line">        <span class="comment">// 定义 socket</span></span><br><span class="line">        sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 定义 sockaddr_in</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">skaddr</span>;</span></span><br><span class="line">        skaddr.sin_family = AF_INET; <span class="comment">// ipv4</span></span><br><span class="line">        skaddr.sin_port   = htons(PORT);</span><br><span class="line">        skaddr.sin_addr.s_addr = inet_addr(SERV);</span><br><span class="line">        <span class="comment">// bind，绑定 socket 和 sockaddr_in</span></span><br><span class="line">        <span class="keyword">if</span>( bind(sockfd,(struct sockaddr *)&amp;skaddr,<span class="keyword">sizeof</span>(skaddr)) == <span class="number">-1</span> )&#123;</span><br><span class="line">                perror(<span class="string">"bind error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// listen，开始添加端口</span></span><br><span class="line">        <span class="keyword">if</span>( listen(sockfd,QUEUE) == <span class="number">-1</span> )&#123;</span><br><span class="line">                perror(<span class="string">"listen error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端信息</span></span><br><span class="line">        <span class="keyword">char</span> buff[BUFF_SIZE];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">claddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(claddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> sock_client = accept(sockfd,(struct sockaddr *)&amp;claddr, &amp;length);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,++count);</span><br><span class="line">                <span class="keyword">if</span>( sock_client &lt;<span class="number">0</span> )&#123;</span><br><span class="line">                        perror(<span class="string">"accept error"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">                <span class="keyword">int</span> len = recv(sock_client,buff,<span class="keyword">sizeof</span>(buff),<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">fputs</span>(buff,<span class="built_in">stdout</span>);</span><br><span class="line">                <span class="comment">//send(sock_client,buff,len,0);</span></span><br><span class="line">                <span class="keyword">char</span> *re = joinString(<span class="string">"&lt;h2&gt;the client said&lt;/h2&gt; &lt;br&gt;  "</span>,buff);</span><br><span class="line">                http_send(sock_client,re);</span><br><span class="line">                close(sock_client);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Bye Cleey"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_send</span><span class="params">(<span class="keyword">int</span> sock_client,<span class="keyword">char</span> *content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> HTTP_HEADER[BUFF_SIZE],HTTP_INFO[BUFF_SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(content);</span><br><span class="line">        <span class="built_in">sprintf</span>(HTTP_HEADER,http_res_tmpl,len,<span class="string">"text/html"</span>);</span><br><span class="line">        len = <span class="built_in">sprintf</span>(HTTP_INFO,<span class="string">"%s%s"</span>,HTTP_HEADER,content);</span><br><span class="line"></span><br><span class="line">        send(sock_client,HTTP_INFO,len,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"\nSIGNAL INTERRUPT \nBye Cleey! \nSAFE EXIT\n"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">joinString</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *result = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s1)+<span class="built_in">strlen</span>(s2)+<span class="number">1</span>);<span class="comment">//+1 for the zero-terminator</span></span><br><span class="line">    <span class="comment">//in real code you would check for errors in malloc here</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">strcpy</span>(result, s1);</span><br><span class="line">    <span class="built_in">strcat</span>(result, s2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用方式:</p><blockquote><p>curl -X GET -d  –header “Content-Type:application/json” –header “Authorization:JWT somerandomjwtstringandstuffs” “<a href="http://127.0.0.1:8888/user">http://127.0.0.1:8888/user</a>“</p></blockquote><p>一个类似于简易的curl的c语言httpClient可能长这样<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ip_by_domain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *domain, <span class="keyword">char</span> *ip)</span></span>; <span class="comment">// 根据域名获取ip</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input host name %s ipn"</span>,argv[<span class="number">0</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> * host = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">int</span> len; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> </span><br><span class="line"><span class="keyword">int</span> result; </span><br><span class="line"><span class="keyword">char</span> httpstring[<span class="number">1000</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * server_ip[<span class="number">100</span>];</span><br><span class="line">get_ip_by_domain(host,server_ip);</span><br><span class="line"><span class="built_in">strcat</span>(httpstring,<span class="string">"GET / HTTP/1.1\r\n"</span>);</span><br><span class="line"><span class="built_in">strcat</span>(httpstring,<span class="string">"Host: "</span>);</span><br><span class="line"><span class="built_in">strcat</span>(httpstring,host);</span><br><span class="line"><span class="built_in">strcat</span>(httpstring,<span class="string">"\r\n"</span>);</span><br><span class="line"><span class="built_in">strcat</span>(httpstring,</span><br><span class="line"><span class="string">"Connection: keep-alive\r\n"</span></span><br><span class="line"><span class="string">"Cache-Control: max-age=0\r\n"</span></span><br><span class="line"><span class="string">"Upgrade-Insecure-Requests: 1\r\n"</span></span><br><span class="line"><span class="string">"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36\r\n"</span></span><br><span class="line"><span class="string">"DNT: 1\r\n"</span></span><br><span class="line"><span class="string">"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n"</span></span><br><span class="line"><span class="string">"Accept-Encoding: gzip, deflate, br\r\n"</span></span><br><span class="line"><span class="string">"Accept-Language: zh-CN,zh;q=0.9\r\n\r\n"</span>); </span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">address.sin_family = AF_INET; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the server host is %s and the ip is %s\n"</span>,argv[<span class="number">1</span>],server_ip);</span><br><span class="line">address.sin_addr.s_addr = inet_addr(server_ip); </span><br><span class="line">address.sin_port = htons(<span class="number">80</span>); </span><br><span class="line">len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">result = connect(sockfd,(struct sockaddr *)&amp;address,len); </span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">-1</span>)&#123; </span><br><span class="line">    perror(<span class="string">"oops: client connect error"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"befor connect!!"</span>);</span><br><span class="line">write(sockfd,httpstring,<span class="built_in">strlen</span>(httpstring)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"after write!!\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(read(sockfd,&amp;ch,<span class="number">1</span>))&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, ch); </span><br><span class="line">&#125; </span><br><span class="line">close(sockfd); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n"</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_SIZE16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据域名获取ip</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ip_by_domain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *domain, <span class="keyword">char</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **pptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line">    hptr = gethostbyname(domain);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == hptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"gethostbyname error for host:%s/n"</span>, domain);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(pptr = hptr-&gt;h_addr_list ; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != inet_ntop(hptr-&gt;h_addrtype, *pptr, ip, IP_SIZE) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只获取第一个 ip</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用方式:</p><blockquote><p>./bin/client www.baidu.com ##这时候，在百度服务器看来，这个程序和普通的浏览器没有区别。试了下主流的网站，都没有什么问题。优酷返回了一大串奇怪的字符串，看了下，应该是content-encoding: gzip了，所以在终端里面看上去乱七八糟的。</p></blockquote><p>上面这段会卡在read里面，因为读到最后一个字节的时候，客户端并不知道是没有更多数据还是网络不好堵住了。需要在每一次读完之后去找那个”\r\n\r\n”的结束标志。</p><p>一个使用libevent的版本的客户端可以这样写<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;evhttp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/http.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_request_done</span><span class="params">(struct evhttp_request *req, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8196</span>]; <span class="comment">//这里没处理了</span></span><br><span class="line">    <span class="keyword">int</span> s = evbuffer_remove(req-&gt;input_buffer, &amp;buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">    buf[s] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">    <span class="comment">// terminate event_base_dispatch()</span></span><br><span class="line">    event_base_loopbreak((struct event_base *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">get_tcp_socket_for_host(<span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">ev_uint16_t</span> port)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> port_buf[<span class="number">6</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evutil_addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evutil_addrinfo</span> *<span class="title">answer</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">evutil_socket_t</span> sock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Convert the port to decimal. */</span></span><br><span class="line">    evutil_snprintf(port_buf, <span class="keyword">sizeof</span>(port_buf), <span class="string">"%d"</span>, (<span class="keyword">int</span>)port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the hints to tell getaddrinfo how to act. */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_UNSPEC; <span class="comment">/* v4 or v6 is fine. */</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_protocol = IPPROTO_TCP; <span class="comment">/* We want a TCP socket */</span></span><br><span class="line">    <span class="comment">/* Only return addresses we can use. */</span></span><br><span class="line">    hints.ai_flags = EVUTIL_AI_ADDRCONFIG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the hostname. */</span></span><br><span class="line">    err = evutil_getaddrinfo(hostname, port_buf, &amp;hints, &amp;answer);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error while resolving '%s': %s"</span>,</span><br><span class="line">                  hostname, evutil_gai_strerror(err));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there was no error, we should have at least one answer. */</span></span><br><span class="line">    assert(answer);</span><br><span class="line">    <span class="comment">/* Just use the first answer. */</span></span><br><span class="line">    sock = socket(answer-&gt;ai_family,</span><br><span class="line">                  answer-&gt;ai_socktype,</span><br><span class="line">                  answer-&gt;ai_protocol);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (connect(sock, answer-&gt;ai_addr, answer-&gt;ai_addrlen)) &#123;</span><br><span class="line">        <span class="comment">/* Note that we're doing a blocking connect in this function.</span></span><br><span class="line"><span class="comment">         * If this were nonblocking, we'd need to treat some errors</span></span><br><span class="line"><span class="comment">         * (like EINTR and EAGAIN) specially. */</span></span><br><span class="line">        EVUTIL_CLOSESOCKET(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( answer-&gt;ai_family == AF_INET)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">sin</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">answer</span>-&gt;<span class="title">ai_addr</span>;</span></span><br><span class="line">        s = evutil_inet_ntop(AF_INET, &amp;<span class="built_in">sin</span>-&gt;sin_addr, buf, <span class="number">128</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( answer-&gt;ai_family == AF_INET6)&#123;</span><br><span class="line">        struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)answer-&gt;ai_addr;</span><br><span class="line">        s = evutil_inet_ntop(AF_INET6, &amp;sin6-&gt;sin6_addr, buf, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  -&gt;%s\n"</span> , s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(res,s);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *ip_addresss = get_tcp_socket_for_host(<span class="string">"www.taobao.com"</span>,<span class="number">80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the ip address of taobao is  %s \n"</span>,ip_addresss);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evhttp_connection</span> *<span class="title">conn</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evhttp_request</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    base = event_base_new();</span><br><span class="line"> </span><br><span class="line">    conn = evhttp_connection_base_new(base, <span class="literal">NULL</span>, ip_addresss, <span class="number">80</span>);</span><br><span class="line">    req = evhttp_request_new(http_request_done, base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是写request 的 header</span></span><br><span class="line">    evhttp_add_header(req-&gt;output_headers, <span class="string">"Host"</span>, <span class="string">"www.taobao.com"</span>);</span><br><span class="line">    evhttp_add_header(req-&gt;output_headers, <span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>);</span><br><span class="line">    evhttp_add_header(req-&gt;output_headers, <span class="string">"Accept"</span>, <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>);</span><br><span class="line">    evhttp_add_header(req-&gt;output_headers, <span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"</span>);</span><br><span class="line"></span><br><span class="line">    evhttp_make_request(conn, req, EVHTTP_REQ_GET, <span class="string">"/index.html"</span>);</span><br><span class="line">    evhttp_connection_set_timeout(req-&gt;evcon, <span class="number">600</span>);</span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>网络通信显然还要注意一个字节序的问题，简单来讲,java是大端的,c++是跟着平台走的且多数为小端<br><a href="https://blog.csdn.net/windshg/article/details/12956107">c++的服务器和java的客户端之间的通信</a></p><blockquote><p>C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的 x86 处理器是 Little Endian<br>JAVA编写的程序则唯一采用 Big Endian 方式来存储数据</p></blockquote><p>htons();//将short类型的值从主机字节序转换为网络字节序(上面就是把端口号转化一下)<br>inet_addr();//将IP地址字符串转换为long类型的网络字节序（接受一个字符串，返回一个long）<br>gethostbyname();//获得与该域名对应的IP地址<br>inet_ntoa();//将long类型的网络字节序转换成IP地址字符串<br>//这些转换字节序的函数是必须的，因为ip地址，端口这些东西不是应用层处理，而是由路由器这些东西去处理的，后者遵照网络标准使用的是big-endian，所以必须转换字节序。</p><p>读函数read<br>ssize_t read(int fd,void *buf,size_t nbyte)<br>read函数是负责从fd中读取内容.当读成功 时,read返回实际所读的字节数,如果返回的值是0 表示已经读到文件的结束了,小于0表示出现了错误.如果错误为EINTR说明读是由中断引起 的, 如果是ECONNREST表示网络连接出了问题. </p><p>写函数write<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p><p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数.失败时返回-1. 并设置errno变量. 在网络程序中,当我们向套接字文件描述符写时有两可能.<br>1)write的返回值大于0,表示写了部分或者是全部的数据. 这样我们用一个while循环来不停的写入，但是循环过程中的buf参数和nbyte参数得由我们来更新。也就是说，网络写函数是不负责将全部数据写完之后在返回的。<br>2)返回的值小于0,此时出现了错误.我们要根据错误类型来处理.<br>如果错误为EINTR表示在写的时候出现了中断错误.<br>如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接).</p><p>除了read和write之外<br>还有<br>int recv(int sockfd,void <em>buf,int len,int flags)<br>int send(int sockfd,void </em>buf,int len,int flags)<br>这两个函数，功能差不多，只是多了第四个参数</p><ul><li><p>简单版本的参考<br><a href="http://www.cleey.com/blog/single/id/789.html">使用Linux c语言编写简单的web服务器</a><br><a href="http://www.voidcn.com/article/p-xieequox-bat.html">socket http文件下载器c语言实现</a></p></li><li><p>高阶版本的参考<br><a href="https://www.geeksforgeeks.org/socket-programming-in-cc-handling-multiple-clients-on-server-without-multi-threading/">高阶一点，处理并发的</a><br><a href="https://github.com/pminkov/webserver">多线程的server和client源码</a></p></li></ul><p>需要记住的是，read是从系统的缓冲区读取的,write是写到tcp buffer里面的</p><p><strong>还有实现websocket协议的，实现sock5协议的</strong></p><p>见过的一个websocket的请求长这样<br>GET wss://nexus-websocket-b.xxx.io/pubsub/xxx?X-Nexus-New-Client=true&amp;X-Nexus-Version=0.4.53 HTTP/1.1<br>Host: nexus-websocket-b.xxx.io<br>Connection: Upgrade<br>Pragma: no-cache<br>Cache-Control: no-cache<br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3538.77 Safari/537.36<br>Upgrade: websocket<br>Origin: <a href="https://app.xxx.io">https://app.xxx.io</a><br>Sec-WebSocket-Version: 13<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9<br>Sec-WebSocket-Key: xaxsasdasdas==<br>Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</p><p>Response长这样<br>HTTP/1.1 101 Switching Protocols<br>Date: Thu, 25 Oct 2018 06:07:10 GMT<br>Connection: upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Accept: sasasasaD/tA=</p><p>这样也就完成了protocol upgrade的过程</p><ul><li>js并不支持对操作系统socket的直接控制，可能是安全因素(websocket倒是有，不过那是另外一回事了)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p>read这个函数返回的是读取的byte数，(On success, the number of bytes read is returned (zero indicates end of file), and the file position is advanced by this number;On error, -1 is returned, and errno is set appropriately.  In this case, it is left unspecified whether the file position (if any) changes.)</p><p>如果read的时候一直统计当前总的read到的bytes数，应该是要比content-length长不少的。<br><a href="https://stackoverflow.com/questions/4850241/how-many-bits-in-a-character">那么一个字符到底多少个byte呢</a><br>首先要明白，read出来的东西是byte(是被utf-8编码过的)。几乎所有的语言在接收到之后都要重新解码一下，所以在这里decode一下，用c语言decode怎么弄？</p><ul><li><p>It depends what is the character and what encoding it is in:</p></li><li><p>An ASCII character in 8-bit ASCII encoding is 8 bits (1 byte), though it can fit in 7 bits.</p></li><li><p>An ISO-8895-1 character in ISO-8859-1 encoding is 8 bits (1 byte).</p></li><li><p>A Unicode character in UTF-8 encoding is between 8 bits (1 byte) and 32 bits (4 bytes).</p></li><li><p>A Unicode character in UTF-16 encoding is between 16 (2 bytes) and 32 bits (4 bytes), though most of the common characters take 16 bits. This is the encoding used by Windows internally.</p></li><li><p>A Unicode character in UTF-32 encoding is always 32 bits (4 bytes).</p></li><li><p>An ASCII character in UTF-8 is 8 bits (1 byte), and in UTF-16 - 16 bits.</p></li><li><p>The additional (non-ASCII) characters in ISO-8895-1 (0xA0-0xFF) would take 16 bits in UTF-8 and UTF-16.</p></li></ul><p><a href="https://stackoverflow.com/questions/3996026/what-is-the-default-encoding-for-c-strings">what-is-the-default-encoding-for-c-strings</a> 结论就是c语言的标准并没有规定用什么encoding    </p><blockquote><p>A c string is pretty much just a sequence of bytes. That means, that it does not have a well-defined encoding, it could be ASCII, UTF8 or anything else, for that matter. Because most operating systems understand ASCII by default, and source code is mostly written with ASCII encoding, so the data you will find in a simple (char<em>) will very often be ASCII as well. Nonetheless, there is no guarantee that what you get out of a (char</em>) will be UTF8 or even KOI8.</p></blockquote><p><a href="https://stackoverflow.com/questions/45893641/output-difference-in-c-implementation-of-java-code">java用utf-8,c用了ascii</a></p><p> 用上面的c语言的server发出这样一个字符串<br> “你好啊\r\n”</p><p> python的client每次读取一个字节,然后打印出0101这样的形式<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 每次最多接收1个字节:</span></span><br><span class="line">    d = s.recv(<span class="number">1</span>)</span><br><span class="line">    t = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> d:</span><br><span class="line">        t+= format(ord(x),<span class="string">'b'</span>)</span><br><span class="line">        print(t)</span><br><span class="line">    <span class="keyword">if</span> d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">data = <span class="string">b''</span>.join(buffer)</span><br><span class="line">print(data);</span><br></pre></td></tr></table></figure></p><p>//在python的socket client这边接收到了<br>11100100<br>10111101<br>10100000<br>11100101<br>10100101<br>10111101<br>11100101<br>10010101<br>10001010</p><p> b’\xe4’<br> b’\xbd’<br> b’\xa0’<br> b’\xe5’<br> b’\xa5’<br> b’\xbd’<br> b’\xe5’<br> b’\x95’<br> b’\x8a’<br> ‘\r’<br> ‘\n’<br> 因为tcp是有序的，所以发送端的字节以什么顺序排列的，接受端就是受到完全一样顺序排列的字节。这里因为网络传输是以字节为单位的。而sizeof(char) = 1 ，但是sizeof(int) = 4, 以上都还只是text-based content，字节序这回事只跟多字节类型的数据有关的比如int,short,long这类数字类型有关，所以基于文本传输的协议当然不存在字节序问题(当然content-length这种数字还是要注意一下的)。</p><p> //在console里面还能够正常的打印出“你好啊”这三个字（包括换行也做了）</p><p>ut-8是变长的<br>Unicode符号范围        | UTF-8编码方式<br>(十六进制)             | （二进制）<br>———————-+———————————————<br>      0 &lt;–&gt; 0x7f     | 0xxxxxxx<br>   0x80 &lt;–&gt; 0x7FF    | 110xxxxx 10xxxxxx<br>  0x800 &lt;–&gt; 0xFFFF   | 1110xxxx 10xxxxxx 10xxxxxx<br>0x10000 &lt;–&gt; 0x10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p><p>//来看这三个字的unicode码<br>你 -&gt; u4f60 —–&gt; 转换成二进制就是 0100 1111 0110 0000(位于上表的第三行，也就是三个字节) 把0100 1111 0110 0000塞进1110xxxx 10xxxxxx 10xxxxxx的xxx里面<br>得到11100100 10111101 10100000（E4 BD A0）<br>好 -&gt; u597d —–&gt; 同上，不再赘述<br>啊 -&gt; u554a —–&gt; 同上，不再赘述</p><p>在浏览器console里面输入<br>encodeURI(‘你好啊’)<br>“%E4%BD%A0%E5%A5%BD%E5%95%8A” //是不是和python那边收到的东西很像</p><p>所以，c语言这边关键函数<br>send(sock_client,”你好啊”,len,0);<br>看上去是发送了6个字节(每个汉字unicode两个字节)，实际上send调用下层在发送出去的时候回把这个6个字节的数据分散在9个字节长度的utf-8 byte array上。<br>可以认为发送6个字节，耗费9个字节的流量(如果发送的全部是ascii字符就不会这么浪费了，但其实utf-8已经很节省了)</p><p><strong>结论就是utf-8 encode的工作是底层根据locale做的，跟application无关。</strong></p><p><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/apas03.html">libc只是当作以0结尾的字符串原封不动地write给内核，识别汉字的工作是由终端的驱动程序做的。</a>也就是基于当前的locale<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"你好\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述程序源文件是以UTF-8编码存储的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ od -tc nihao.c </span><br><span class="line">0000000   #   i   n   c   l   u   d   e       &lt;   s   t   d   i   o   .</span><br><span class="line">0000020   h   &gt;  \n  \n   i   n   t       m   a   i   n   (   v   o   i</span><br><span class="line">0000040   d   )  \n   &#123;  \n  \t   p   r   i   n   t   f   (   &quot; 344 275</span><br><span class="line">0000060 240 345 245 275   \   n   &quot;   )   ;  \n  \t   r   e   t   u   r</span><br><span class="line">0000100   n       0   ;  \n   &#125;  \n</span><br><span class="line">0000107</span><br></pre></td></tr></table></figure></p><blockquote><p>其中八进制的344 375 240（十六进制e4 bd a0）就是“你”的UTF-8编码，八进制的345 245 275（十六进制e5 a5 bd）就是“好”。把它编译成目标文件，”你好\n”这个字符串就成了这样一串字节：e4 bd a0 e5 a5 bd 0a 00，汉字在其中仍然是UTF-8编码的，一个汉字占3个字节，这种字符在C语言中称为多字节字符（Multibyte Character）。运行这个程序相当于把这一串字节write到当前终端的设备文件。如果当前终端的驱动程序能够识别UTF-8编码就能打印出汉字，如果当前终端的驱动程序不能识别UTF-8编码（比如一般的字符终端）就打印不出汉字。也就是说，像这种程序，识别汉字的工作既不是由C编译器做的也不是由libc做的，C编译器原封不动地把源文件中的UTF-8编码复制到目标文件中，libc只是当作以0结尾的字符串原封不动地write给内核，识别汉字的工作是由终端的驱动程序做的。</p></blockquote><p><a href="https://www.cprogramming.com/tutorial/unicode.html">Unicode in C and C++: What You Can Do About It Today</a></p><p>##不知道为什么,百度首页的response中没有content-length字段<br>read from socket , and write it to local file ,how about that?<br><a href="https://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html">这篇文章提到</a>，由于http keep-alive的存在，读取server的response已经读不到EOF了，所以也就不能以EOF作为读取完毕的标志。分两种情况：有Content-length的，Transfer-Encoding：chunked（复杂一点点）这两种。<br>chunked简单说就是把一个大文件切分成N个小包，每个包(chunk)里面包括header和body。这个header里面也是有body的长度的。</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>** <a href="https://github.com/gwuhaolin/lightsocks">sock5协议的解释</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/sun_rise_dim_grass.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;收集几种语言中使用socket实现httpServer和httpClient的主要步骤&lt;br&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://haldir65.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>CoordiantorLayout及滑动原理解析</title>
    <link href="https://haldir65.github.io/2018/09/24/2018-09-24-mastering-scrolling-techniques/"/>
    <id>https://haldir65.github.io/2018/09/24/2018-09-24-mastering-scrolling-techniques/</id>
    <published>2018-09-24T19:35:11.000Z</published>
    <updated>2018-12-23T14:52:16.308Z</updated>
    
    <content type="html"><![CDATA[<p>在Android平台上，掌握滑动事件是一件让人头疼的事情。<br><img src="https://www.haldir66.ga/static/imgs/1513521623756.jpg" alt=""></p><a id="more"></a><h3 id="1-关于CoordinateLayout里面的东西（针对supportLibrary27-1-0代码）"><a href="#1-关于CoordinateLayout里面的东西（针对supportLibrary27-1-0代码）" class="headerlink" title="1.关于CoordinateLayout里面的东西（针对supportLibrary27.1.0代码）"></a>1.关于CoordinateLayout里面的东西（针对supportLibrary27.1.0代码）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">       &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways|snap"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>剔除一些无关的属性后，可以观察到:<br>app:layout_scrollFlags是写给AppBarLayout看的<br>app:layout_behavior是写给CoordinatorLayout看的</p><p>app:layout_scrollFlags = scroll的时候，手指上滑下滑，加了flag的View只会在外层的ScrollingView(这里就是ViewPager了)滑动到头了才开始滑动</p><p>app:layout_scrollFlags = scroll|enterAlways的时候，手指上下滑动时，加了flag的view会立刻响应（还不等外部的ScrollingView滑到头就开始滑动，当然这里没有动画，手指慢慢的挪的话，可以让它停在一半的位置）。可以理解为手指上下滑动时，只要加了flag的view会优先消费完滑动距离</p><p>app:layout_scrollFlags = scroll|enterAlways|snap的时候，就加上动画了（手指往下拖，把toolbar拖出来不到一半的时候它会缩回去，超出一半的时候会动画弹出来）<br>这段动画的代码在AppBarLayout.Behavior的onStopNestedScroll方法里面判断了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((flags &amp; LayoutParams.FLAG_SNAP) == LayoutParams.FLAG_SNAP) &#123;<span class="comment">//所以flag这个东西其实是AppbarLayout.LayoutParams的一个属性。可以进行位运算操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    animateOffsetTo(coordinatorLayout, abl,</span><br><span class="line">                            MathUtils.clamp(newOffset, -abl.getTotalScrollRange(), <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那个snap的动画长这样</span></span><br><span class="line"><span class="keyword">if</span> (mOffsetAnimator == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mOffsetAnimator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    mOffsetAnimator.setInterpolator(AnimationUtils.DECELERATE_INTERPOLATOR);</span><br><span class="line">    mOffsetAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            setHeaderTopBottomOffset(coordinatorLayout, child,</span><br><span class="line">                    (<span class="keyword">int</span>) animation.getAnimatedValue()); <span class="comment">//做动画的过程中调用AppbarLayout(其实就是一个LinearLayout)的offsetTopAndBottom方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mOffsetAnimator.cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mOffsetAnimator.setDuration(Math.min(duration, MAX_OFFSET_ANIMATION_DURATION));</span><br><span class="line">mOffsetAnimator.setIntValues(currentOffset, offset);</span><br><span class="line">mOffsetAnimator.start();</span><br></pre></td></tr></table></figure></p><p>在Cheesequare的首页，RecyclerView准备滑动(ActionMove)还没滑动时调用了<br>RecyclerView.dispatchNestedPreScroll -&gt; CoordinateLayout.onNestedPreScroll -&gt;<br>AppbarLayout.Beahvior.onNestedPreScroll -&gt;AppbarLayout.offsetTopAndBottom</p><p>在RecyclerView的scrollByInternal里面调用了RecyclerView.dispatchNestedScroll -&gt;<br>CoordinateLayout.onNestedScroll -&gt;CoordinatorLayout.onChildViewChanged -&gt; AppbarLayoutBehavior.onDependentViewChanged -&gt;AppbarLayout.onNestedScroll -&gt; AppbarLayout.Behavior.onNestedScroll</p><p>RecyclerView(Action_UP)的时候调用顺序:<br>RecyclerView.stopNestedScroll(这个其实不是让RecyclerView停下来，而是告诉parent应该停下来了)<br>CoordinateLayout.onStopNestedScroll<br>AppbarLayout.onStopNestedScroll<br>AppbarLayout.Behavior.onStopNestedScroll<br>AppbarLayout.Behavior.snapToChildIfNeeded(就是上面说的如果 scroll|enterAlways|snap都在时候的动画了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意AppbarLayout是有一个默认的behavior的</span></span><br><span class="line"><span class="meta">@CoordinatorLayout</span>.DefaultBehavior(AppBarLayout.Behavior.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBarLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在AppbarLayout的语义里，上下滑动的距离用的是offset这个关键字</span></span><br><span class="line"><span class="comment">//这又是一个public static class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在AppBarLayout.Behavior里面有这么一段</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We depend on any AppBarLayouts</span></span><br><span class="line">    <span class="keyword">return</span> dependency <span class="keyword">instanceof</span> AppBarLayout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        View dependency)</span> </span>&#123;</span><br><span class="line">    offsetChildAsNeeded(parent, child, dependency);<span class="comment">//child就是底部在加了behavior的ViewPager,dependency是AppbarLayout.这里面就是调用了child.offsetTopAndBottom</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从调用顺序来看，是加了behavior的View(底部的ViewPager)滑动时dispatchNestedPreScroll -&gt; CoordinatorLayout.onNestedPreScroll -&gt; CoordinatorLayout会一个个child去查，发现一个behavior不为Null的就会调用onChildViewsChanged-&gt; 这里面还是一个个遍历child(一个个问layoutDependsOn，内部实现是遍历每个child，然后针对每个child，拿着当前加上了behavior的views一个个(mDependencySortedChildren)来问，询问加了behavior的child的behavior，这个child是否感兴趣。。。一旦感兴趣就走onDependentViewChanged)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在cheesequare的主页面，mDependencySortedChildren这个List&lt;View&gt;默认有三个元素AppBarLayout,ViewPager,FloatingActionButton(ViewPager是我们手动加上去的，其他两个都是default配备了behavior的)。由此看来，自己可以写一个behavior，加在CoordinatorLayout的child中，这样就能参与到mDependencySortedChildren这个过程中了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在mDependencySortedChildren中，ViewPager是dependend on AppBarLayout的。也就是说加在ViewPager上的behavior</span></span><br><span class="line"><span class="comment">// :app:layout_behavior="@string/appbar_scrolling_view_behavior"  这玩意其实写在AppbarLayout中</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollingViewBehavior</span> <span class="keyword">extends</span> <span class="title">HeaderScrollingViewBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//调用顺序</span></span><br><span class="line"> RecyclerView.onTouchEvent(ACTION_MOVE)</span><br><span class="line"> RecyclerView.dispatchNestedPreScroll()</span><br><span class="line"> NestedScrollChildHelper.dispatchNestedPreScroll()</span><br><span class="line">CoordinatorLayout.onNestedPreScroll(View 那个RecyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>  type)<span class="comment">//这里面一个个遍历child找加上了behavior的，调用behavior的onNestedPreScroll</span></span><br><span class="line">CoordinatorLayout.onChildViewsChanged(EVENT_NESTED_SCROLL)<span class="comment">//这里面就是一个个遍历child，拿着child去问加了bahavior的view“这是你想要的吗”，如果是肯定答复，会走到onDependentViewChanged（CoordinatorLayout,View 加了behavior的view,View behavior感兴趣的View）.所以多数的实现都可以在这里动手。又因为加了bahavior的view事实上是一个list，事实上可以随便加任意多个带behavior的view。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/saulmm/CoordinatorBehaviorExample中的实现如下。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, CircleImageView child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dependency <span class="keyword">instanceof</span> Toolbar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, CircleImageView child, View dependency)</span> </span>&#123;</span><br><span class="line">    maybeInitProperties(child, dependency);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxScrollDistance = (<span class="keyword">int</span>) (mStartToolbarPosition);</span><br><span class="line">    <span class="keyword">float</span> expandedPercentageFactor = dependency.getY() / maxScrollDistance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expandedPercentageFactor &lt; mChangeBehaviorPoint) &#123;</span><br><span class="line">        <span class="keyword">float</span> heightFactor = (mChangeBehaviorPoint - expandedPercentageFactor) / mChangeBehaviorPoint;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> distanceXToSubtract = ((mStartXPosition - mFinalXPosition)</span><br><span class="line">                * heightFactor) + (child.getHeight()/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">float</span> distanceYToSubtract = ((mStartYPosition - mFinalYPosition)</span><br><span class="line">                * (<span class="number">1f</span> - expandedPercentageFactor)) + (child.getHeight()/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        child.setX(mStartXPosition - distanceXToSubtract);</span><br><span class="line">        child.setY(mStartYPosition - distanceYToSubtract);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> heightToSubtract = ((mStartHeight - mCustomFinalHeight) * heightFactor);</span><br><span class="line"></span><br><span class="line">        CoordinatorLayout.LayoutParams lp = (CoordinatorLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">        lp.width = (<span class="keyword">int</span>) (mStartHeight - heightToSubtract);</span><br><span class="line">        lp.height = (<span class="keyword">int</span>) (mStartHeight - heightToSubtract);</span><br><span class="line">        child.setLayoutParams(lp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">float</span> distanceYToSubtract = ((mStartYPosition - mFinalYPosition)</span><br><span class="line">                * (<span class="number">1f</span> - expandedPercentageFactor)) + (mStartHeight/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        child.setX(mStartXPosition - child.getWidth()/<span class="number">2</span>);</span><br><span class="line">        child.setY(mStartYPosition - distanceYToSubtract);</span><br><span class="line"></span><br><span class="line">        CoordinatorLayout.LayoutParams lp = (CoordinatorLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">        lp.width = (<span class="keyword">int</span>) (mStartHeight);</span><br><span class="line">        lp.height = (<span class="keyword">int</span>) (mStartHeight);</span><br><span class="line">        child.setLayoutParams(lp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述一个个询问加了behavior的child的过程其实叫做onChildViewChanged(EVENT_NESTED_SCROLL),该方法会在<br>CoordinatorLayout的onNestedFling,onNestedPreScroll,onNestedScroll,onChildViewRemoved,onPreDraw中都会调用到。<br>所以在这里相应滑动是足够的。上述例子里面就是在onDependentViewChanged中获取当前target的getY，对此作出textView的缩放。</p><p>接下来看一大堆接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(@NonNull View target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onNestedFling</span><span class="params">(@NonNull View target, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onNestedPreFling</span><span class="params">(@NonNull View target, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNestedScrollAxes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(@NonNull View target, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 似乎就是添加了一个NestedScrollType</span></span><br><span class="line"><span class="meta">@IntDef</span>(&#123;TYPE_TOUCH, TYPE_NON_TOUCH&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@RestrictTo</span>(LIBRARY_GROUP)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NestedScrollType &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNestedScrollingEnabled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(@ScrollAxis <span class="keyword">int</span> axes)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @Nullable <span class="keyword">int</span>[] offsetInWindow)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @Nullable <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable <span class="keyword">int</span>[] offsetInWindow)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(@ScrollAxis <span class="keyword">int</span> axes, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @Nullable <span class="keyword">int</span>[] offsetInWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @Nullable <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable <span class="keyword">int</span>[] offsetInWindow, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//似乎也只是加了一个NestedScrollType，2是1的子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//看一下继承关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwipeRefreshLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">NestedScrollingParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedScrollView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">NestedScrollingParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">NestedScrollingChild2</span>, <span class="title">ScrollingView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">ScrollingView</span>, <span class="title">NestedScrollingChild2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinatorLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">NestedScrollingParent2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://saulmm.github.io/mastering-coordinator">关于CoordinatorLayout的比较好的教程</a></p><h3 id="SwipeRefreshLayout里面有一个OnChildScrollUpCallback用于决定是否可以拦截实践，比setEnabled要好很多"><a href="#SwipeRefreshLayout里面有一个OnChildScrollUpCallback用于决定是否可以拦截实践，比setEnabled要好很多" class="headerlink" title="SwipeRefreshLayout里面有一个OnChildScrollUpCallback用于决定是否可以拦截实践，比setEnabled要好很多"></a>SwipeRefreshLayout里面有一个OnChildScrollUpCallback用于决定是否可以拦截实践，比setEnabled要好很多</h3><p>CoordinateLayout inside SwipeRefreshLayout的问题似乎可以从这里去解决</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android平台上，掌握滑动事件是一件让人头疼的事情。&lt;br&gt;&lt;img src=&quot;https://www.haldir66.ga/static/imgs/1513521623756.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://haldir65.github.io/tags/android/"/>
    
  </entry>
  
</feed>
