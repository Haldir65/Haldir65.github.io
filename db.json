{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":0,"renderable":1},{"_id":"source/assets/blogImg/zhangzhe.jpg","path":"assets/blogImg/zhangzhe.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"source/assets/blogImg/getX.png","path":"assets/blogImg/getX.png","modified":0,"renderable":0},{"_id":"source/assets/blogImg/service_binding_tree_lifecycle.png","path":"assets/blogImg/service_binding_tree_lifecycle.png","modified":0,"renderable":0},{"_id":"source/assets/blogImg/service_lifecycle.png","path":"assets/blogImg/service_lifecycle.png","modified":0,"renderable":0},{"_id":"source/assets/blogImg/cat.jpg","path":"assets/blogImg/cat.jpg","modified":0,"renderable":0},{"_id":"source/assets/blogImg/colorAccent.jpg","path":"assets/blogImg/colorAccent.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/favicon.png","hash":"12f8cb4e7a7f19abacb2f972df6166a804669327","modified":1483838532000},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1483801970358},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1483801970361},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1496576413762},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1483801970352},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1474160201663},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1496576413813},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1496576413860},{"_id":"themes/yilia/_config.yml","hash":"30e915f3cf5c08f9985240917f11fd81a14508df","modified":1500809211099},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1474160201658},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1483801970348},{"_id":"source/_posts/2016-10-12-How-the-mainThread-work.md","hash":"4a83374ac80d596cae8dfd55c9c61fe4b3c77844","modified":1500806590430},{"_id":"source/_posts/2016-10-13-Android-coordinate-System.md","hash":"2c5b4b4101ee4d3e236ff4c414b3c90a4e2fa985","modified":1492944609399},{"_id":"source/_posts/2016-10-14-Android-translucent-status-bar.md","hash":"400cc4b83b1625d2568ce2bdd2eec7c5542d04ac","modified":1500108994194},{"_id":"source/_posts/2016-10-15-using-loader-in-android-app.md","hash":"908161e4392c10b9ab0f3dca11c2616bda14696a","modified":1492944617675},{"_id":"source/_posts/2016-10-20-RecyclerViewAnimationStuff.md","hash":"8b151f73a4af8bb8448ab6f5ef626b91a3c3c7f3","modified":1492944629288},{"_id":"source/_posts/2016-10-20-android-dirty-code.md","hash":"c1ae0c44ee2903b666f3cf19bd3926dd4b5d66b0","modified":1492944624549},{"_id":"source/_posts/2016-10-20-write-your-own-layoutmanager.md","hash":"2fd32e4a7e319e6eb753b254f8f830775db6286f","modified":1500806590446},{"_id":"source/_posts/2016-10-24-a-peek-on-pull-to-refresh.md","hash":"61118e943de0aeb88b3da960797a9b2c039c5fc2","modified":1492944645703},{"_id":"source/_posts/2016-10-31-install-lxml-on-windows.md","hash":"db5b8cd44c4b108386200743ba8a00c5a3b2dc9b","modified":1497541169896},{"_id":"source/_posts/2016-11-27-the-size-of-wrap-content.md","hash":"6b29f755fd8e5285b1d3993a74f99dfd770089f3","modified":1500806590446},{"_id":"source/_posts/2016-12-10-adb-command.md","hash":"335f6db66851072edf9fe88c2384de5769d253ff","modified":1497753172366},{"_id":"source/_posts/2016-12-24-Python-UnicodeEncodeError.md","hash":"b8f9323716b02715a60a390fd0d973b548302aa8","modified":1500806590462},{"_id":"source/_posts/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor.md","hash":"8eb335c1b5a00f866234d2ee5d85bdb7490da007","modified":1492944682005},{"_id":"source/_posts/2017-01-07-Linux-Basic-Commands.md","hash":"ee1b0d171d67ebdf69b55342e946b328bd57ac04","modified":1500809040414},{"_id":"source/_posts/2017-01-08-trouble-shooting-with-my-blog.md","hash":"e05b20fab4abbea25d615974a6304d08d72f095c","modified":1500566318847},{"_id":"source/_posts/2017-01-13-embracing-kotlin.md","hash":"3b65ef84a0972e5863cb08d858a01f5199c318d3","modified":1498402891077},{"_id":"source/_posts/2017-03-11-utilizing-the-terminal-in-android-studio.md","hash":"f8eab15e1b8cba077189cfe1e1ebe0f2b0c32e9d","modified":1492944706777},{"_id":"source/_posts/2017-04-03-properties-of-view.md","hash":"45863cc7788f1b52e43b5c4b33dbe6e1ce18c662","modified":1500808992376},{"_id":"source/_posts/2017-04-23-rxjava2-for-android.md","hash":"ac8bd044ee2644c35c78c59ef001f510b907f7fe","modified":1500806590477},{"_id":"source/_posts/2017-04-30-concurrency-and-beyond.md","hash":"11666a240bbd84e6c522afd5c0556e6a5ac710c9","modified":1497776666928},{"_id":"source/_posts/2017-05-01-python-server-test.md","hash":"5e86bce1bf93055f5b1bda242a246873eef7fd10","modified":1498401899886},{"_id":"source/_posts/2017-05-07-download-video-from-vps.md","hash":"b26b66a811b6ca53a435203612c936a9307a3e7f","modified":1497762656769},{"_id":"source/_posts/2017-05-24-jvm-architecture.md","hash":"fcdb4fc6942ced7e18d9b9f78fb562641a42b99e","modified":1501285788666},{"_id":"source/_posts/2017-06-12-Collections-Refuled-by-Stuart-Marks.md","hash":"b3cd359675923adb61e4351a1bab2a922cb9c9ad","modified":1500108994194},{"_id":"source/_posts/2017-06-15-python-networks.md","hash":"be226a89de2b63e4f4e3a2b58a10f42d3bbf1344","modified":1500806590493},{"_id":"source/_posts/2017-06-17-tiny-details-in-java.md","hash":"3171d8b3f26a9bdb53627a84021b7c9b4ea570f2","modified":1500806590493},{"_id":"source/_posts/2017-06-18-linux-commands-extended.md","hash":"4d5458b9f6d026da088ebfa6c0aa143fb00cdfab","modified":1499526098640},{"_id":"source/_posts/2017-06-25-deploying-flask-app-on-linux-server.md","hash":"ddfc181ec027262dc895d706151ce6f87737788a","modified":1499820385552},{"_id":"source/_posts/2017-07-01-it-began-with-a-few-bits.md","hash":"6290a389fc120a62cb496c3aa01980093d7f93f2","modified":1500806590509},{"_id":"source/_posts/2017-07-12-android-cookbook.md","hash":"c05274d5f3eb4dfaf83134218b7376991e45b873","modified":1500807682833},{"_id":"source/_posts/2017-07-12-fragment-decoded.md","hash":"154019ef1af69de22e8894d0f7404119c8bca2a9","modified":1500563979775},{"_id":"source/_posts/2017-07-12-scrapy-notes.md","hash":"71a8179132cc4da2d965a49ca826fb2f4fe1a346","modified":1500566491205},{"_id":"source/_posts/2017-07-21-glide-decoded.md","hash":"754f3b5e8ce19fa7a28e8d0fdfb7f983902c5739","modified":1501306883814},{"_id":"source/_posts/2017-07-21-network-manual.md","hash":"6e7e03ded5a29ed38d9a8e2f224dc84a79e8611e","modified":1500808359421},{"_id":"source/_posts/2017-07-21-okhttp-demisified.md","hash":"13a98dde3bfb4331a42061c324514f9abfa0ee1e","modified":1500808284058},{"_id":"source/_posts/2017-07-23-design-pattern.md","hash":"28d1860b842c341d20bf0a503c53bc5cc7c4a600","modified":1501285788687},{"_id":"source/_posts/2017-07-23-from-java-code-to-java-heap.md","hash":"8cb5be44cea77cac888e3d4bb8149cdae887aef2","modified":1501285788698},{"_id":"source/_posts/2017-07-23-lru-cache-and-more.md","hash":"8e8ba7bcb635e867ba3a56da26cdbd951b59d459","modified":1501285788705},{"_id":"source/_posts/activity-transition-pre-and-post-lollipop.md","hash":"2ff44259a21484a194123b8712eb25710ed5957d","modified":1492944721011},{"_id":"source/_posts/2017-07-23-manipulating-bits.md","hash":"e98a486f333514172f2b08f776aa598d85909bee","modified":1501285788712},{"_id":"source/_posts/android-7-0-new-features.md","hash":"aa22a2c97f74d58019cd1daab2dd5cbb8b8c8958","modified":1492944727720},{"_id":"source/_posts/android-inner-class-leak.md","hash":"6d47bb039c71395fed723ad1546fb67a1fb8c6ef","modified":1497540106986},{"_id":"source/_posts/git-manual.md","hash":"c66a6d48dba9618af9c7e1e9967453bdf54f3c4a","modified":1500809025421},{"_id":"source/_posts/replace-butterKnife-with-databinding.md","hash":"bad4b2ea7be53a2d146bf8087d57fd40f24912df","modified":1498925230866},{"_id":"source/_posts/selectableItemBackground-foreground.md","hash":"147e1d4c7d5ac3c62c8380931138e630e6a84327","modified":1500108994335},{"_id":"source/_posts/service-activity-communication.md","hash":"59a4b48e8e91eeec7f3d7e30a31870bac7f45fe7","modified":1492944752678},{"_id":"source/_posts/theme-versus-style.md","hash":"f80c321955e4835bd7f5750c6fe2227d64ab1d48","modified":1500806590540},{"_id":"source/_posts/touch-event-distribution.md","hash":"bef1ac98d48db89fcfd1392d1a22ae065869631d","modified":1492944770056},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1496576573797},{"_id":"themes/yilia/.git/config","hash":"316bc92d9936dc739c39161838a28fb4641cbea2","modified":1474160201638},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"699e6e00432c30e1781533afd65f490dc99187a5","modified":1496576411416},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"89ab87ea9e4463a047b96655a4f4d5bf1547a726","modified":1496577190960},{"_id":"themes/yilia/.git/COMMIT_EDITMSG","hash":"f45b45e75dc7c192cd2d67e90d5f7744185ea60b","modified":1496576914200},{"_id":"themes/yilia/.git/index","hash":"c738dbb6c6d6ac64a2999aa5dffc7d93ffda2ac2","modified":1496577333422},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1474160185901},{"_id":"themes/yilia/.git/packed-refs","hash":"9295e7df400c6b3bc71309059e20d92171362302","modified":1474160201595},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1474160201684},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1474160201679},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1474160201688},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1474160201693},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1474160201701},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1474160201706},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1474160201865},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1474160201865},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1474160201865},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1474160201895},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1474160201893},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1496576413852},{"_id":"themes/yilia/source/slider.445162.js","hash":"a727717abfd319c5de84b425331f55aa709c9276","modified":1496576413858},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1474160201697},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1486891118374},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1483801970597},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1474160201898},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1486891118457},{"_id":"themes/yilia/source/main.b3331d.js","hash":"5fcc25cc1650f4ebe5d29ac9744f6d2d3a8be677","modified":1496576413854},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"0873195fea8d34db7233dab3591d41558fb7388b","modified":1496576413856},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1474160185916},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1474160185916},{"_id":"source/assets/blogImg/zhangzhe.jpg","hash":"d5f7cfd5cc970932ecb9e6ee9cd534e7079b08dc","modified":1475744693791},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1474160185932},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1474160185948},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1474160185948},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1474160185963},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1474160185932},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1474160185963},{"_id":"themes/yilia/.git/logs/HEAD","hash":"a931f7a1fc5ff273b08998211c65c02e940e9272","modified":1496577190968},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1474160185932},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1474160185963},{"_id":"themes/yilia/.git/refs/stash","hash":"09eed3d5c8880e19ed7442ccb82a435bff8f510d","modified":1496576590683},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1474160201717},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"61c95c49baa2c1bfd99cf88c55ba205b44bf3d97","modified":1483801970386},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1496576413768},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1474160201765},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1474160201736},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1474160201771},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1483801970430},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"6f3f8c1dc25a9a1ffe4051344b5516fa713f1666","modified":1496576693549},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1474160201802},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1483801970461},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1483801970454},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1483801970484},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8bbf5db9e4d3c1037bbeaa16f9d7ea0dc281d23c","modified":1496576413766},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1483801971328},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1483801970581},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1496576413848},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1496576413849},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1496576413811},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1483801971387},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1483801971389},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1496576413851},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1483801971392},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1474160201909},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1483801971390},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1496576413847},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1474160201913},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1496576413816},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1496576413820},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1496576413818},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1483801970616},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"768e77b775923c53f974a15fe9ab04d0e05198a5","modified":1496576413823},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"2d1c70bb606c0d87e4f68ec2e600e08b27f32b99","modified":1496576413821},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1483801970626},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1474160202005},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1474160202005},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1483801970689},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1486891118413},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1496576413835},{"_id":"themes/yilia/source-src/css/main.scss","hash":"1bc3240d693f190f86bf5e258cc5846e09be9ec1","modified":1496576413837},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"7c24ea86d95c86b82337177559d78ce56d8912e0","modified":1496576413839},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1483801970735},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1483801970936},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1474160202052},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1474160202052},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1483801970990},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1474160202067},{"_id":"themes/yilia/source-src/css/social.scss","hash":"7c4c54bcc4cd0bd69162745ae2a2357dcc54f5cd","modified":1496576413841},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1483801971010},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1483801971081},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1483801971125},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1483801971105},{"_id":"themes/yilia/source-src/js/main.js","hash":"93ca570a646c6087821d7b14cb1646bb2a0274f4","modified":1483801971157},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1483801971178},{"_id":"themes/yilia/source-src/js/fix.js","hash":"0b434b658abad220459b1e3ee962ebfa4f8f88ca","modified":1496576413845},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1483801971217},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1486891118432},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1483801971260},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1483801971199},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"6932c642bf8191768d7090982a91c8c1f1c4ed1e","modified":1496576413843},{"_id":"source/assets/blogImg/getX.png","hash":"2bff0efbd620f1911193fe255038939beb001fbf","modified":1475744693777},{"_id":"source/assets/blogImg/service_binding_tree_lifecycle.png","hash":"eda090eefdd0ad8c9324caa1977d351b7d0633bb","modified":1475744693780},{"_id":"source/assets/blogImg/service_lifecycle.png","hash":"8f58fa262d06b6ea8e20ca738da45a6c06d42ecb","modified":1475744693784},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1483801971033},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"eaa2c1cb8165dee6fb10127a0de8dcfcd1799c2e","modified":1496576413809},{"_id":"themes/yilia/.git/logs/refs/stash","hash":"3ddd4e1bffa20abac4713b7f94bfa43b8f1b434f","modified":1496576590683},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1483801971277},{"_id":"themes/yilia/.git/objects/00/d210706283d552672b60f13c1b5f4a2788dee3","hash":"79e4bda63c6d2439adaa9460fd3cf85fd793bfd3","modified":1496576573443},{"_id":"themes/yilia/.git/objects/05/025ec79ca5adfedc028478dd58557e5043468b","hash":"76d8e2f223039aebc37d53972e6a8ecb5951eaa4","modified":1486743707438},{"_id":"themes/yilia/.git/objects/09/61c12d1b380f5d1517874840d5c82ab47f09cf","hash":"8e424abdcc9379c97b8da8f41552cca8b8bcf078","modified":1486743707530},{"_id":"themes/yilia/.git/objects/0b/fd1471da4da98b4eaf0b412c33fd7753108dff","hash":"6320a32eac886668be8514093849fb20fcb123cf","modified":1486743707912},{"_id":"themes/yilia/.git/objects/10/9ab32b07728319b6c46dc54ccbbdcd485dceb5","hash":"45954493b23333d73c3de150899308de52b27e34","modified":1486743707638},{"_id":"themes/yilia/.git/objects/0f/3a4763bf649cbcf6e6c6ef4bde3e42aa77adf0","hash":"9b60f138dabe89dd7aab0805ee8d296c331117f4","modified":1483801956255},{"_id":"themes/yilia/.git/objects/06/3dfa9878a9c19e05633e028bcec3814eb470d0","hash":"3b2cdbe822b66dd6af3512e0065f32e70bc53da2","modified":1486743707801},{"_id":"themes/yilia/.git/objects/10/ee4df83a9c5d37e6888bf3a60a680cc6015b80","hash":"7eb1e2da4983d31090375ad8977590ff2a61e0ca","modified":1483801956240},{"_id":"themes/yilia/.git/objects/11/83f2d3d454c6bbe67b0950599f6c1a04c7ff9a","hash":"b2be8fa9c82665ad541de66060cbd1070e24e551","modified":1486743707904},{"_id":"themes/yilia/.git/objects/11/e2487f354cef47abac97cc3e167286bfa42b93","hash":"6ab1d405de64c7bda14122badbcabd3cdc8066eb","modified":1486743707656},{"_id":"themes/yilia/.git/objects/14/42379f0180d8008ad4ed215f7639ebcabe405c","hash":"c4653de6c8d1f91403e8661923cb66f6f81b7214","modified":1483801956110},{"_id":"themes/yilia/.git/objects/24/f14ff59246d21f33882004f76c5c2124ec31e2","hash":"803ee79fed803df01449a7f8780a16c0e43185fe","modified":1486891107423},{"_id":"themes/yilia/.git/objects/25/49187a507493705d53f5587ee1ee0e9fcadd5b","hash":"6c696b75f0f3e1734676f7f6d77bb9c2d093f3e3","modified":1496576414711},{"_id":"themes/yilia/.git/objects/2a/36a9d491751c872c55726434f73d446d3d9cee","hash":"30176c7f01acfb50d58e397d3fbb80c48433dd50","modified":1486743707479},{"_id":"themes/yilia/.git/objects/2a/03f5bde06c2cfdb34d0a283f2d9a992ae10e26","hash":"05380b6d336928350b26c3e1a52a0135816c4bf0","modified":1486891107383},{"_id":"themes/yilia/.git/objects/2f/2e30a294975e0daf737e420a036fa1febf1185","hash":"2e4ff622ed5a011bfe5cb283b637daa07808e5b5","modified":1496576414709},{"_id":"themes/yilia/.git/objects/2d/43e67af6a67697a1b4e36cbda4c68501a4dd89","hash":"7712ac70c3335b1119b0a153ed4155d69d1a19f6","modified":1486743707939},{"_id":"themes/yilia/.git/objects/31/66cb4c763f76dedcf34dd5c4de70e40d8791b6","hash":"d484d7f763d279bf5ebb1f5aa2eef074123907e8","modified":1486743707742},{"_id":"themes/yilia/.git/objects/38/75bf4046886d3963f6c7b0438d34bf9ed14116","hash":"38d63375093e900dfb1b2e3b696ad5e90d8b2290","modified":1486743707679},{"_id":"themes/yilia/.git/objects/38/ae77e6a3357cf264d7002c54c1308e6e42a0a1","hash":"a96e0f32f31ce45e9198133d822178ef75f7a18c","modified":1483801955669},{"_id":"themes/yilia/.git/objects/3d/6b83835a5c055065f67a8d374c6050fb69d06a","hash":"f329cfad00c916ab9c87f3e1d26766886e0ccb4f","modified":1486743707928},{"_id":"themes/yilia/.git/objects/40/29d31c6bd2a50de5671ce2343c8ebc7e017e20","hash":"ef91720fbdf396a23f811c947b976ee877e1ef69","modified":1486891119761},{"_id":"themes/yilia/.git/objects/48/001c5fd8fb0652b41234591fd98799f6eba85f","hash":"29a2b87845ec6354ee9422d9129d1042a5f1c379","modified":1486743707396},{"_id":"themes/yilia/.git/objects/48/d135bdfe407a89f76ab0734eb17a0c5cce9d50","hash":"455a19569170606e42753023983ef0bc967669e6","modified":1496576914194},{"_id":"themes/yilia/.git/objects/41/1f23f1b55f6c32aa77c06fa2540f7875502ce1","hash":"98091c26213db8f203789f18b7bbe80c09b68d75","modified":1496576693000},{"_id":"themes/yilia/.git/objects/4a/d661b8ce7070eafdb5ff45d63f393b38bbc079","hash":"17235197d81d7db30472308bd3fb8732cd7087ad","modified":1496576914000},{"_id":"themes/yilia/.git/objects/4b/a44bf39d288008e300a019a4aced136d4b0fbd","hash":"3a09bfe087a02d36d774bbd0bc63de57dca08f7d","modified":1486743707825},{"_id":"themes/yilia/.git/objects/22/28034fda3da70a07872c69f318f8455a4fd84b","hash":"e0acb2718ed5135be440a62fb7a297292d04135f","modified":1486743707842},{"_id":"themes/yilia/.git/objects/4e/2ae7bfd8f5aefbb0e2c2e349033450d278a297","hash":"0f2849682c8a37e6fe67bec6e8233d126fc5a16b","modified":1486743707672},{"_id":"themes/yilia/.git/objects/4d/602011bad3b0b4bc0f0a8c707c94bcc743f135","hash":"18cd53a50ddf9955f4e3f1cef8a2a7d5817aaa65","modified":1486743707412},{"_id":"themes/yilia/.git/objects/4f/c01d68e68d8bce11091bcfd7a5c1d11911e4bf","hash":"593dd9612a6a43e2a298497a23e53a9e6fe14cde","modified":1496576914212},{"_id":"themes/yilia/.git/objects/52/0b360c8934af5f1b3f4c96b4d20b627f6d29a8","hash":"0d334d71bf1e51e0bfdf9c96541724ce8d74c819","modified":1496576402828},{"_id":"themes/yilia/.git/objects/54/63f0b8bd19c23cfc7616eb6f71e247e3810fbe","hash":"c136390b9e9673f1112a303de6332aa2374b03d6","modified":1496576403207},{"_id":"themes/yilia/.git/objects/54/cfe555508b683a56769d16ab08306be9250938","hash":"5241971b7d22ec98b23a3270cd598afe2d6184fc","modified":1486891119777},{"_id":"themes/yilia/.git/objects/55/08f1da3427819cd9176b8657f4c4645eaadab2","hash":"63e416ec0b5e699880e03159e69a5b4b09c8f224","modified":1486743707497},{"_id":"themes/yilia/.git/objects/53/96bb299000725cc5650fc494fbdd044d70525c","hash":"c970919e6698e20088951f7a53251fb2689e9042","modified":1483801992058},{"_id":"themes/yilia/.git/objects/55/1793c73d63bf32f91b003a72ad1ca5990fcf83","hash":"875653cb02c1a0bfe5a3d9fd4f3112bb9a8ef5a7","modified":1486743707883},{"_id":"themes/yilia/.git/objects/3d/2bbdee04e794bcd1181059429961634a1e3561","hash":"d1715a193aac1fbdc34635c84dec9ed6b4eb8a7a","modified":1486743707727},{"_id":"themes/yilia/.git/objects/55/f5325951b03246222e0e2adea866ab06380263","hash":"15a672ea7f865d7d3dc32ce986983859251fb388","modified":1486743707388},{"_id":"themes/yilia/.git/objects/56/8c99e2f518f08656d668cf5c8f67e0e49886dd","hash":"7dc11de4f1668eadfb6a52bf894235111e8a0322","modified":1486743707489},{"_id":"themes/yilia/.git/objects/5a/d1743e3d4d5342ed8525cd68d13cbf22d1f3e7","hash":"c29c11a647e523fb1d93945630996e5f8f0dd1c6","modified":1483801956249},{"_id":"themes/yilia/.git/objects/5e/f1e9ee8a3ed2d9fd21e56a9cb775b81ebecca7","hash":"6d9692a9484a0882852d7e6b9ccf5bef291e5236","modified":1486743707749},{"_id":"themes/yilia/.git/objects/5b/c4936212a103a23b15248dea6a33933ad5f5e5","hash":"96bad09ecde105983f22b143cd7909b0c18d4c92","modified":1496576403518},{"_id":"themes/yilia/.git/objects/65/a11aecf014f26951d48ab0c2ade6796bc385ff","hash":"54b78f19afee6e65aed82d9785dcd0ba39489d0b","modified":1486743707771},{"_id":"themes/yilia/.git/objects/64/bc75993607d1a0bea853e7daa2c181118c786f","hash":"632e6d47147365a0c951ab4986953ce42004141f","modified":1486743707920},{"_id":"themes/yilia/.git/objects/60/23ab1c64378edcb8e94771007c263a76a44215","hash":"e05c7426d5a62a77db7454f43b81780c11d2e29a","modified":1483801956103},{"_id":"themes/yilia/.git/objects/6b/5c0466179e4754e954341cffd37ea15a17a11e","hash":"713997b8f422f2d9b8829d292a55ab08f8245594","modified":1496576414596},{"_id":"themes/yilia/.git/objects/66/d20a0e5a923f25c09dc8266845395086eb3111","hash":"f590b575619d8804741f0d40f6d7d3c986d866ad","modified":1486891107332},{"_id":"themes/yilia/.git/objects/69/b6b1e9ccd684211e2f5dc96384545aafa7f58a","hash":"536f31625fd217bd4f4c31e56de229f3e4d9036f","modified":1486743708014},{"_id":"themes/yilia/.git/objects/75/8c2b3736197c79a96a6749b89a8e0785bf5ee5","hash":"d84fc0c212cfdbb365b889c3fa2b0d1754576c40","modified":1486743707546},{"_id":"themes/yilia/.git/objects/6f/a2baebf2e6fbf306e471ef993e4ffd7f05b585","hash":"a57d90e35d0c60d9c487cc133729e69bed8fa021","modified":1486743707816},{"_id":"themes/yilia/.git/objects/73/910c28904210af81a807bc87f5c32eee98b4df","hash":"3aaaa340a9c17d6a0c9bff7ddb18f0e0a0b8db4d","modified":1496576414000},{"_id":"themes/yilia/.git/objects/77/1e3b2bf84dd3d6c29b655cb050ac249ca970b6","hash":"4d7b4124e912e0be5f3a1f98a4398bfc537b2b45","modified":1486743707430},{"_id":"themes/yilia/.git/objects/6d/1ab9bea03ffb649f08c35364047126283d2363","hash":"ca391bcfc472e0e2fde757948a4e02f98d61beb7","modified":1486743707471},{"_id":"themes/yilia/.git/objects/79/1f6757defe5ec1f4fb32a2e20c39159363f2b6","hash":"28d45b9f3f63e72626d090b1f219afbd0b8db95b","modified":1486891107391},{"_id":"themes/yilia/.git/objects/81/34ab3943c88b2bef3f7045a82d6eaa5144581f","hash":"2725d135406f0447e0b87a1109ca8d71b5b4bf50","modified":1496576414599},{"_id":"themes/yilia/.git/objects/83/5bb9c710fbd563419820eba7709c5b797e16b2","hash":"1383b37f3d0dc37d1bb6085088f696f34fdec241","modified":1486743707589},{"_id":"themes/yilia/.git/objects/78/d41a51c0fac47ef4b72f8163e1707fc7007551","hash":"9ae2c05c65d25707d851a111fbca7c337cbc3f2b","modified":1496576414713},{"_id":"themes/yilia/.git/objects/87/4759aba64a9bddb910fdf76202615a0e496b5b","hash":"d3e6516d07a99d7582d73d5f0731f2c8d3bc0813","modified":1486743707734},{"_id":"themes/yilia/.git/objects/84/f0154faebaab317b141e2b0c6baa8b44dddaa2","hash":"99b33ea4979599b673d181553cb4625902913545","modified":1496576901146},{"_id":"themes/yilia/.git/objects/88/ddf22453bf198599a188d4de4f292bb294ff72","hash":"6f7ac6c82fad4f10fba5e95992dda25905be9156","modified":1486743707895},{"_id":"themes/yilia/.git/objects/8a/34e2d5d47c75dcbf4cc06ae84ba9a72a98158c","hash":"dd88baad5ea91e63b574f4a147c62155dafd2881","modified":1486743707520},{"_id":"themes/yilia/.git/objects/8f/f6b52c3adedc5619cd346855611fbea2ac35d1","hash":"f8df1d8a635deb875c136b4bde9bf385876fe815","modified":1486743707380},{"_id":"themes/yilia/.git/objects/98/1d89125a78b6e2d58f24b173417107c5209604","hash":"ca8f13c04063ae195c83e284fc2b55df5c0c09ba","modified":1486743707851},{"_id":"themes/yilia/.git/objects/9a/89ff73c05630c252ea6c6469d2e02d297173f6","hash":"f9234ef0a6fa146557eaf20a3d752cc7e21c9238","modified":1486743707420},{"_id":"themes/yilia/.git/objects/86/51d03ccf648e8856134613ecf439feab07b487","hash":"7cd7ccda78a2c047fe08a17ae07afcee5cdaf966","modified":1483801956537},{"_id":"themes/yilia/.git/objects/a8/84cdad4c7dca22f1a8c03696e9cf9f87bc093e","hash":"d885ba581a99fbb870a54253340bad6401fc4697","modified":1486743707664},{"_id":"themes/yilia/.git/objects/8e/af7d5cb4b5a250a09788fcac314418bb07f111","hash":"09f197e16cfd2b973cbda8a8e01f19d3b371e5f0","modified":1486743707597},{"_id":"themes/yilia/.git/objects/98/d3764cfb1894bdff480de5c3cce0dec3a057f3","hash":"404512a8af64a021251b0d4cc46dd13c922e158e","modified":1483801992076},{"_id":"themes/yilia/.git/objects/ac/4a5bdd32081403d6ca252de1e31660544ed92c","hash":"861d10882f67847a74035cb08c445467dcea900b","modified":1486743707764},{"_id":"themes/yilia/.git/objects/b1/ef8ee3d83078c8c7ce57d8d09fedc752800fa2","hash":"0bcbc7807a265e5d702dbdb4b391b879abf87960","modified":1486743707554},{"_id":"themes/yilia/.git/objects/b4/bb072930d06b2bdbd262f65e146f764ffd622b","hash":"1496db9b160c38881548195fea4a3b26fa3ead59","modified":1486743707404},{"_id":"themes/yilia/.git/objects/b5/a7f05066ff20f7effab133f9b7eaa8175789fb","hash":"1881b4231d5fe44b062461a2856623ac7869470b","modified":1496576414840},{"_id":"themes/yilia/.git/objects/b6/39c53065e5d6b2b4c3ae2b5737e8cf0d28eb31","hash":"7cc9e09791ec5264dd9c40211ac370fb569b943e","modified":1496576914000},{"_id":"themes/yilia/.git/objects/ab/81fb546b29bf20beeafc885d1d58f264c04494","hash":"166630c6914036ec921b25e5b598ef4ad40f8e0b","modified":1496576403315},{"_id":"themes/yilia/.git/objects/b1/8588fd602f25aa4de4d37cbd94279327144705","hash":"3428a9db26e8d54830f7344d92d95bab9b52d4ca","modified":1486891119740},{"_id":"themes/yilia/.git/objects/ba/02ee12137c4545b7a6cec743f92f04fc8e2180","hash":"4f79fc3cf8b967d44983bb94b68d753f5bde3491","modified":1486743707949},{"_id":"themes/yilia/.git/objects/ba/ee4fe970d2690e6c9bc17eba91d4c76528d66d","hash":"60f7781c7e897ccfc7a3ca620e36c2900d034e5b","modified":1486743707579},{"_id":"themes/yilia/.git/objects/c0/2c66a827b811061271e9bafa82259700b400f7","hash":"de6cbf00e6299d11184392d375a54e7fc9032470","modified":1496576414601},{"_id":"themes/yilia/.git/objects/c5/3ba41ca08f8f57d8714f43df158b2e839a9935","hash":"bc7744b8406db187470c36fa804f87e4fb08ed4d","modified":1496576573428},{"_id":"themes/yilia/.git/objects/c4/67fc262ce24443b8a3fee09833f4b7f0218c2d","hash":"8929df9363ffd97dff13c09ab249f58af5169ccd","modified":1486891119809},{"_id":"themes/yilia/.git/objects/c4/40551cbbc088c9d8ffa24834b7f5b4be23f85d","hash":"5e31c2c1a3f71a4bb2920aad08c4e500c9bec942","modified":1486743707539},{"_id":"themes/yilia/.git/objects/d0/dbe8ca88f1c599ffa705063f43f8dc14e6b65c","hash":"e83981073d7c6bf9d425b0dcfac557be59b38f11","modified":1486743707993},{"_id":"themes/yilia/.git/objects/ce/93b026f74fecc44e6e33c4075947c9ded8d70b","hash":"b31a401e7de6f1904051edf730e7dfc3bcb02d6c","modified":1486743707873},{"_id":"themes/yilia/.git/objects/d5/7b0eae6dada964063006c541f5fba224607ce4","hash":"b07bb055e7d76844b3c355c5ff02796bbbe0570c","modified":1486743707794},{"_id":"themes/yilia/.git/objects/d9/91752461929aa048210155bf03e12a55cf1cef","hash":"769e2fb8be08d70a7bb0ab9089d7bf091f7bff7e","modified":1486743707834},{"_id":"themes/yilia/.git/objects/e3/365ace247b2d64eb046fb3fd441f3214eb84e6","hash":"0b11fc6b49261342cfba245ec9d320b949b6d388","modified":1486743708003},{"_id":"themes/yilia/.git/objects/dc/971b1128be4c963d7f3a7bfed48bc2bda7d8eb","hash":"39b2c0159da1e5c959f4cd65b255598705fc0263","modified":1486743707463},{"_id":"themes/yilia/.git/objects/e4/28fe8be69057e1bd61a022da60f9dafea83bd5","hash":"e069b56a99023637b54e6142a93d64e2c85e83fc","modified":1486743707570},{"_id":"themes/yilia/.git/objects/e9/1d2b6d6dc36e8ad37e2020ea0323425bb8dee3","hash":"2e0afde47f7d93faa6f60d8c726bb670619dea3e","modified":1496576693552},{"_id":"themes/yilia/.git/objects/d5/dac81af164244a12940348fda4566208433fc1","hash":"1619c77c967b00280547c8821b73255f1a8908a0","modified":1496576693391},{"_id":"themes/yilia/.git/objects/e6/6c3ddaedc49103b8a7fc4a4cbfe0080ff76d94","hash":"5655f4ed7a19126bf198a21232a67c476740daaf","modified":1486743707447},{"_id":"themes/yilia/.git/objects/ed/a627ad59997a0a76c0774ca8d488ca11229000","hash":"9bacc2cc1ccc48dc15ea99b2cd28376edcfc086e","modified":1486743707506},{"_id":"themes/yilia/.git/objects/cf/8ac4b4f4903dfb644362e3dde58a189adbca9a","hash":"4bbacfc23add7cd59ae9a62b39382e961e15a681","modified":1486743707981},{"_id":"themes/yilia/.git/objects/f3/b736e430437deee212634d7c70c0d6ac2699b3","hash":"cda62e2c47cb24c4bf707cd28a994648d9f277fa","modified":1496576564584},{"_id":"themes/yilia/.git/objects/f6/98a183936552664f4cc598543f18332538e5a8","hash":"fd1b25a1a29c797eae2bf74f71ea5afa19e61301","modified":1486743707809},{"_id":"themes/yilia/.git/objects/f7/c2ce3af119542aca91b43917eb3885ee9a1de3","hash":"39d5343debe5565e239dbe414989bada799f59a3","modified":1486743707562},{"_id":"themes/yilia/.git/objects/f8/2cbc282bef56c081f182df7073683c749feef2","hash":"16c9b58ec4d85ae4b118fb5161bcec13808d47bf","modified":1486743707756},{"_id":"themes/yilia/.git/objects/f8/86801f04cbfd5f42431dde09f9ae3bce74908b","hash":"004549faa179c857e9516eb9f4ad5709c9182738","modified":1486743707454},{"_id":"themes/yilia/.git/objects/pack/pack-3b74d4d5eacba667205d38a328b396d955aa76f5.idx","hash":"405f48d45c00bfdcad973f9942ddc5bc86a14c77","modified":1483801917334},{"_id":"themes/yilia/.git/objects/fe/16f80a4186284110ed181ab4acb4f6a20dbc9b","hash":"59d6a597f38c3656054a81e5195a5b8c5a6af1ae","modified":1496576684000},{"_id":"themes/yilia/.git/objects/pack/pack-738a1f3d6e80940080d7c136fe21fb101c01581f.idx","hash":"1893614a5c7482065b8a04f0ea835eebf32b3e16","modified":1496576395446},{"_id":"themes/yilia/.git/refs/heads/master","hash":"597a0d14c701a189e5d74eaa70341e78e3ad7c80","modified":1496577190963},{"_id":"themes/yilia/.git/objects/pack/pack-f287423bdddd0dae090311153706b8ee09994797.idx","hash":"6a16af275dd353c57c9afec2d28157e5c5453a57","modified":1474160201396},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1474160201818},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1483801970499},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1486891118292},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1483801970509},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1474160201849},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1483801970518},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1496576413806},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1474160201818},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1483801970634},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1474160201963},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1483801970644},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1474160201976},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1474160201982},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1496576413828},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1496576413833},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1496576413830},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1483801970693},{"_id":"source/assets/blogImg/cat.jpg","hash":"07ec243a561640c379d2d088caedbb0789f3d5b1","modified":1475744693764},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1474160202020},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1474160202036},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"58df4db931098df2c1dee050092693d155a2f453","modified":1496577190967},{"_id":"themes/yilia/.git/refs/remotes/origin/master","hash":"597a0d14c701a189e5d74eaa70341e78e3ad7c80","modified":1496576395618},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1474160201613},{"_id":"themes/yilia/.git/refs/remotes/origin/myself","hash":"d9893970a3f49fee45d449931381c471db51e5ec","modified":1483801917546},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"cc384aeaed9ffde92efdf192c26db4da3fe5858f","modified":1496576413805},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1496576413825},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/master","hash":"23299dd467ea84f400ccea1f6e260ea1e913b484","modified":1496576395621},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"7d87cc956364bc48669ad14fff337d9216febbf2","modified":1474160201609},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/myself","hash":"d9ca225efb2648a9df6003eaa2ea26d3097271b6","modified":1483801917551},{"_id":"source/assets/blogImg/colorAccent.jpg","hash":"6712969d1eb8357224faaf2525178d73969d7d05","modified":1475744693772},{"_id":"themes/yilia/.git/objects/pack/pack-738a1f3d6e80940080d7c136fe21fb101c01581f.pack","hash":"63fa7a5f2aed404ec1de3550581eb0bc2fa763c7","modified":1496576914000},{"_id":"themes/yilia/.git/objects/pack/pack-3b74d4d5eacba667205d38a328b396d955aa76f5.pack","hash":"0e1370e63b603ecbfd227d3e2cf1d51ba08b91d6","modified":1496576914000},{"_id":"themes/yilia/.git/objects/pack/pack-f287423bdddd0dae090311153706b8ee09994797.pack","hash":"10edfacb4a22e329c5cd4e6d5826dc65034d84ae","modified":1496576914000},{"_id":"public/atom.xml","hash":"80bfffc103d41072d31299157e0be807d67b158f","modified":1500809225559},{"_id":"public/content.json","hash":"1075674baa9306f15ad95ed57de8b0c4902f8cd3","modified":1500809227405},{"_id":"public/sitemap.xml","hash":"b517faa4a7cbd29f52259b1e863af3926bc15a97","modified":1500809227553},{"_id":"public/2017/07/21/2017-07-21-glide-decoded/index.html","hash":"10cb16dba179e368fa089fa2feb1a45f8bd108a4","modified":1500809227734},{"_id":"public/2017/07/21/2017-07-21-network-manual/index.html","hash":"fb801709e26e7798b61a0a39efbde6ea084d010c","modified":1500809227859},{"_id":"public/2017/07/21/2017-07-21-okhttp-demisified/index.html","hash":"bc68e6e320c7bb9b61403e81c6b565ea05ba94c4","modified":1500809227877},{"_id":"public/2017/07/12/2017-07-12-android-cookbook/index.html","hash":"cfbc832094335fe3838e0868efe791b414996f18","modified":1500809227877},{"_id":"public/2017/07/12/2017-07-12-scrapy-notes/index.html","hash":"db76f36bd495db1626a175fc8915c5b1f36be551","modified":1500809227878},{"_id":"public/2017/07/12/2017-07-12-fragment-decoded/index.html","hash":"6dd758ead6a41b695f13900060d78ccd7e01255d","modified":1500809227878},{"_id":"public/2017/07/01/2017-07-01-it-began-with-a-few-bits/index.html","hash":"96fd19d37cc1d3dd18dcd5c95a8ebb4bc86cb506","modified":1500809227878},{"_id":"public/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/index.html","hash":"8c0bf388ca9bea61021ee8306b187b4af5ede75a","modified":1500809227879},{"_id":"public/2017/06/25/2017-06-25-deploying-flask-app-on-linux-server/index.html","hash":"b48a0abcb5a42659c36a2d632efc66bb43b39208","modified":1500809227879},{"_id":"public/2017/06/17/2017-06-17-tiny-details-in-java/index.html","hash":"770e5ef9fdb4bb552427a39a11ab8232924badab","modified":1500809227879},{"_id":"public/2017/06/18/2017-06-18-linux-commands-extended/index.html","hash":"a4a382d12aa1012eb74540bf46806d2182bda871","modified":1500809227879},{"_id":"public/2017/06/15/2017-06-15-python-networks/index.html","hash":"fea6445612f17f82e80fc615f2ebf9afe48e632b","modified":1500809227880},{"_id":"public/2017/05/24/2017-05-24-jvm-architecture/index.html","hash":"3bc3bb03f46289d628109820e99db770df0c8779","modified":1500809227880},{"_id":"public/2017/05/07/2017-05-07-download-video-from-vps/index.html","hash":"bb7410998a836cba83e705e2768edd1e87511370","modified":1500809227881},{"_id":"public/2017/05/01/2017-05-01-python-server-test/index.html","hash":"d5211c4fb5d06df30d8058ce1ea4daaa4f0fe4f9","modified":1500809227881},{"_id":"public/2017/04/30/2017-04-30-concurrency-and-beyond/index.html","hash":"d9369a1477e2f0d078df23161b57f2e31e77eed7","modified":1500809227881},{"_id":"public/2017/04/23/2017-04-23-rxjava2-for-android/index.html","hash":"8fc06ec19c1560e84df91b47e6c9aebca64f46a0","modified":1500809227881},{"_id":"public/2017/04/03/2017-04-03-properties-of-view/index.html","hash":"aa9f916964f93aed22a12994974a1cc0b7a781e4","modified":1500809227882},{"_id":"public/2017/03/11/2017-03-11-utilizing-the-terminal-in-android-studio/index.html","hash":"32c8eb5d476c1b99f2e087c27976abe88477004a","modified":1500809227882},{"_id":"public/2017/01/13/2017-01-13-embracing-kotlin/index.html","hash":"36b334492e9fe21c902bd0e596bc5f5f752d0c1c","modified":1500809227882},{"_id":"public/2017/01/08/2017-01-08-trouble-shooting-with-my-blog/index.html","hash":"b4b948add24eb96fff7c98c070d710a94d9ee27b","modified":1500809227882},{"_id":"public/2017/01/07/2017-01-07-Linux-Basic-Commands/index.html","hash":"e3be6fe8aa028b731b1df7039b1858089be11488","modified":1500809227882},{"_id":"public/2016/12/31/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor/index.html","hash":"44d1c9fa7c4c4a5f3c5ba239dd46af7983fb2079","modified":1500809227882},{"_id":"public/2016/12/24/2016-12-24-Python-UnicodeEncodeError/index.html","hash":"97fa6e7a06caa41f61a15c25a0ac519ca2a9012f","modified":1500809227883},{"_id":"public/2016/12/10/2016-12-10-adb-command/index.html","hash":"c4aeada2cdb2a077154206292254e9d25b39b09f","modified":1500809227883},{"_id":"public/2016/11/27/2016-11-27-the-size-of-wrap-content/index.html","hash":"c56a6c6ff5b0c822b6c85efd5c7780b7d7d304f4","modified":1500809227883},{"_id":"public/2016/10/31/2016-10-31-install-lxml-on-windows/index.html","hash":"a69a775c7ca7de96cf74417f2b66d29ddeffe780","modified":1500809227883},{"_id":"public/2016/10/24/2016-10-24-a-peek-on-pull-to-refresh/index.html","hash":"4e6ec7b8bdacbf1755ed82aba449bb5660e6f8ae","modified":1500809227884},{"_id":"public/2016/10/20/2016-10-20-android-dirty-code/index.html","hash":"84b85bb65a0f823dae338cd4090d8164993e6900","modified":1500809227884},{"_id":"public/2016/10/20/2016-10-20-write-your-own-layoutmanager/index.html","hash":"ff8bc5d49284a4de8b764414c80b7c707435560a","modified":1500809227884},{"_id":"public/2016/10/20/2016-10-20-RecyclerViewAnimationStuff/index.html","hash":"832f757cabeda56688a4eb21cf2c53373ba10a3b","modified":1500809227884},{"_id":"public/2016/10/15/2016-10-15-using-loader-in-android-app/index.html","hash":"94efa3d6ebe343d314815bfc476a2ad9ac26964e","modified":1500809227885},{"_id":"public/2016/10/14/2016-10-14-Android-translucent-status-bar/index.html","hash":"bd805e9602eb1ee8c0c86d87f8e3b5f31e7e0824","modified":1500809227885},{"_id":"public/2016/10/13/2016-10-13-Android-coordinate-System/index.html","hash":"e76d502bc60fd1babb2dcb956c6030974247526b","modified":1500809227885},{"_id":"public/2016/10/12/2016-10-12-How-the-mainThread-work/index.html","hash":"050f068f4fce9ca44adcc8740f77f69f6cfd3695","modified":1500809227885},{"_id":"public/2016/10/10/theme-versus-style/index.html","hash":"2e72d01e252369ffd0489f26869a73cbfb597a43","modified":1500809227885},{"_id":"public/2016/10/08/android-7-0-new-features/index.html","hash":"27e7aad9a245996e19615e020f812dec8b105328","modified":1500809227886},{"_id":"public/2016/10/06/touch-event-distribution/index.html","hash":"6bd2791ee8405d437bd701255240f9f0e3d7dc0c","modified":1500809227886},{"_id":"public/2016/09/30/service-activity-communication/index.html","hash":"89a336d2e50054a01d313847b53368c72cf6afeb","modified":1500809227886},{"_id":"public/2016/09/27/git-manual/index.html","hash":"a1a1c2ec20b10d059bc17fd4c570ecaded980926","modified":1500809227886},{"_id":"public/2016/09/27/activity-transition-pre-and-post-lollipop/index.html","hash":"008cb849691f5e68aa22646af7e3f4c46c365415","modified":1500809227886},{"_id":"public/2016/09/23/selectableItemBackground-foreground/index.html","hash":"059ccfb7e7f3a9675f2412173a3018d6b0a52755","modified":1500809227886},{"_id":"public/2016/09/22/replace-butterKnife-with-databinding/index.html","hash":"05438d195cd1d600a63f098d3b54ec4831ca7f99","modified":1500809227888},{"_id":"public/2016/09/18/android-inner-class-leak/index.html","hash":"472d15c145025f7f05e4741a0b2ce56fff3a527d","modified":1500809227888},{"_id":"public/archives/index.html","hash":"8253ce7ff75353e01917618f88e9f9bd2c2c8ddb","modified":1500809227889},{"_id":"public/archives/page/2/index.html","hash":"64bf2a7877ad8e6ead9825d1e2b4e4ca0cea35fb","modified":1500809227889},{"_id":"public/archives/page/3/index.html","hash":"846abc6617a7123345dac32fead3d6c2792a05a2","modified":1500809227889},{"_id":"public/archives/page/4/index.html","hash":"33817c487a029633ef5ef12d17d53dd0eb0c4f58","modified":1500809227889},{"_id":"public/archives/page/5/index.html","hash":"dd4978e3c0bf17f69d74ced18cba1483e0cf85e8","modified":1500809227889},{"_id":"public/archives/page/6/index.html","hash":"1013578c20752d28d525b56ba63d50c05c8905df","modified":1500809227889},{"_id":"public/archives/page/7/index.html","hash":"1a93e621ac0b246ca25b9a2a9fe68c02481e72f7","modified":1500809227890},{"_id":"public/archives/page/8/index.html","hash":"026aef3eb90ed699c3ae789f5bf4edc1a4705c9e","modified":1500809227890},{"_id":"public/archives/page/9/index.html","hash":"c9e370f416157ec6a57d787d004c732722a87377","modified":1500809227890},{"_id":"public/archives/page/10/index.html","hash":"8661f56322f581fe984f3069a7e77f6ee87cbd3d","modified":1500809227890},{"_id":"public/archives/page/11/index.html","hash":"f138c04b64ab72bc7c06842eab6d6056ce165988","modified":1500809227890},{"_id":"public/archives/2016/index.html","hash":"b29fd65b44bd9f965d52ef0a478a2cc902487a8b","modified":1500809227891},{"_id":"public/archives/2016/page/2/index.html","hash":"58c034e1218d0b24339ff380f49688d936d09fc4","modified":1500809227891},{"_id":"public/archives/2016/page/3/index.html","hash":"87567c84fb1c1f077cacb52e45384e544129afba","modified":1500809227891},{"_id":"public/archives/2016/page/4/index.html","hash":"811b0b2f982fd138b5ab9a5543ccada59fcedaa2","modified":1500809227891},{"_id":"public/archives/2016/page/5/index.html","hash":"ca06dd6640038eeafb595032327630c1ef4eacc6","modified":1500809227891},{"_id":"public/archives/2016/page/6/index.html","hash":"516ec4adcc268457cad38f95717f0b435628bed0","modified":1500809227891},{"_id":"public/archives/2016/09/index.html","hash":"5dfddc2cd0565d7026bd62fac64d03d2c2f06ef6","modified":1500809227892},{"_id":"public/archives/2016/09/page/2/index.html","hash":"0a66ca892f33b4d03d32dd563e870ca70a341c35","modified":1500809227892},{"_id":"public/archives/2016/10/index.html","hash":"3dde89223d461531f721ec3fb268115c70c1e8f8","modified":1500809227892},{"_id":"public/archives/2016/10/page/2/index.html","hash":"405951f427177094d73175cd35125896784c9e3a","modified":1500809227892},{"_id":"public/archives/2016/10/page/3/index.html","hash":"d88b53bca7e790ea6d30b0e26986cc787df869e9","modified":1500809227892},{"_id":"public/archives/2016/11/index.html","hash":"d7e9602e1b2dada2efbfd993347fb04e9336b34d","modified":1500809227892},{"_id":"public/archives/2016/12/index.html","hash":"66a1fbc2f1de287abb46605b845ab5ce3594e1c4","modified":1500809227892},{"_id":"public/archives/2017/index.html","hash":"16693391b87fa20b43340027f9c743351c17189e","modified":1500809227893},{"_id":"public/archives/2017/page/2/index.html","hash":"f1b2a13bcf1b441a691cd055e5370345fb597661","modified":1500809227893},{"_id":"public/archives/2017/page/3/index.html","hash":"8ae92488713227e1478673aa75b92639cd332235","modified":1500809227893},{"_id":"public/archives/2017/page/4/index.html","hash":"2868ec535cfd58fe125e3932ad56f693121aa591","modified":1500809227893},{"_id":"public/archives/2017/page/5/index.html","hash":"8b2f6a4b929e97ae3cdfb97051f7a8ae157382e1","modified":1500809227893},{"_id":"public/archives/2017/page/6/index.html","hash":"cb67e02bcc54f7300131f0bb6e8ab39d03e19d61","modified":1500809227893},{"_id":"public/archives/2017/01/index.html","hash":"f9a7b6bfa6d9e2ce9b51ef318afbfe657539ddb6","modified":1500809227893},{"_id":"public/archives/2017/03/index.html","hash":"f27577ea54f162c28da1dd235209788cd95b0b1f","modified":1500809227894},{"_id":"public/archives/2017/04/index.html","hash":"8b32f5edd7f46e93106c87d40b48722e965e9c36","modified":1500809227894},{"_id":"public/archives/2017/05/index.html","hash":"c99b769369766371d71beb896d7047d2dc28b0ef","modified":1500809227894},{"_id":"public/archives/2017/06/index.html","hash":"6addc4a438dbd768bf99518b26377e9c5668abe7","modified":1500809227894},{"_id":"public/archives/2017/06/page/2/index.html","hash":"6e1f01fc73c12a553fe33cc54cae8d7b64abfbcc","modified":1500809227894},{"_id":"public/archives/2017/07/index.html","hash":"535d437e6ee3a11e9f04942b01058b5c1686b58a","modified":1500809227894},{"_id":"public/archives/2017/07/page/2/index.html","hash":"e203b7d793fe5131daa1d513b180eb7b8d6cd191","modified":1500809227894},{"_id":"public/categories/blog/index.html","hash":"15944104cb872ac6c2a906fbea0817062a678e94","modified":1500809227895},{"_id":"public/categories/blog/page/2/index.html","hash":"2ca9b5009a451fd03b9de4f0e1ebafb2bf869d01","modified":1500809227895},{"_id":"public/categories/blog/page/3/index.html","hash":"a6553b43288eea5b84a3e05f4f3d9449ce167f8c","modified":1500809227895},{"_id":"public/categories/blog/page/4/index.html","hash":"f0aff01f4910d0faf298985cc2099ccc1c4fdc7f","modified":1500809227896},{"_id":"public/categories/blog/page/5/index.html","hash":"4615ad16e3196759349396e004e2130bc719d514","modified":1500809227896},{"_id":"public/categories/blog/page/6/index.html","hash":"9cbd755695ab74027f979eed1da6e12fbb3545fe","modified":1500809227896},{"_id":"public/categories/blog/page/7/index.html","hash":"d797e3e7257c3274813b4cb5086dfb5e2f044815","modified":1500809227896},{"_id":"public/categories/blog/page/8/index.html","hash":"b8aa06bb3ffbfb12cfeb23e58cf813292f43619b","modified":1500809227896},{"_id":"public/categories/blog/page/9/index.html","hash":"977a670e8e88ab4261b2a8aebe3bb8268db666f0","modified":1500809227896},{"_id":"public/index.html","hash":"537213609a4ff087c4529d682986ce607e51dfa0","modified":1500809227896},{"_id":"public/page/2/index.html","hash":"ce198c74e07665f4650de5a5dc934adffff874d3","modified":1500809227897},{"_id":"public/page/3/index.html","hash":"b797de41b1f302999331962ebe41f2f39761e301","modified":1500809227897},{"_id":"public/page/4/index.html","hash":"6017f18b120439d6db274cef2f84a319fb789156","modified":1500809227897},{"_id":"public/page/5/index.html","hash":"abb1fc9646dbd3229cd0d65584b937abd1a8dddf","modified":1500809227897},{"_id":"public/page/6/index.html","hash":"db765f92a6ebf9fc82238119ed41821a755684c4","modified":1500809227897},{"_id":"public/page/7/index.html","hash":"9d49c37ac1d133b282886bf3b8ba067301077347","modified":1500809227897},{"_id":"public/page/8/index.html","hash":"bd9caace2f036a8d7ba16e97a53623e2607d4ffb","modified":1500809227898},{"_id":"public/page/9/index.html","hash":"e8be4d1c258f5d1258e5e3885fab804b122bf5f4","modified":1500809227898},{"_id":"public/page/10/index.html","hash":"d3c2137b91f5f94df4d2be1160bcc231590efb62","modified":1500809227898},{"_id":"public/page/11/index.html","hash":"a55802e66d8ff1f37e4f9d61f8c43abb5619ffc4","modified":1500809227898},{"_id":"public/tags/Handler-Message/index.html","hash":"3f5a83bc971f7528a28734ea597cc7b668c6fd6e","modified":1500809227898},{"_id":"public/tags/android/index.html","hash":"cf893d603af5d0e2e708f647828272bc7cf3ebbd","modified":1500809227898},{"_id":"public/tags/android/page/2/index.html","hash":"4e1b6cefd25c521ab6c45d0386d099dd11f48e84","modified":1500809227899},{"_id":"public/tags/android/page/3/index.html","hash":"624f281bb0fc3605c1fcbf92e323341bc9b92d75","modified":1500809227899},{"_id":"public/tags/android/page/4/index.html","hash":"c918f386c3642585487ebda1222116fb7a049e9a","modified":1500809227899},{"_id":"public/tags/android/page/5/index.html","hash":"04d37b063d900c1ce761562d5359337245336393","modified":1500809227900},{"_id":"public/tags/android/page/6/index.html","hash":"79c69ab725b0cb086f1baa059b5247e0841240c7","modified":1500809227904},{"_id":"public/tags/TouchEvent/index.html","hash":"e94d398631b905acffad1e958803c1bd2f378491","modified":1500809227905},{"_id":"public/tags/Window/index.html","hash":"66f4494a94fa2d15ef061e7d9c9f0210f7ba4577","modified":1500809227905},{"_id":"public/tags/statusBar/index.html","hash":"11b4a1540a95b5469887863a01878c0082ed287f","modified":1500809227905},{"_id":"public/tags/RecyclerView/index.html","hash":"6a0dbbfd3bbe498d3f3ed95b42fc6687d96676aa","modified":1500809227905},{"_id":"public/tags/置顶/index.html","hash":"b62d99d36ea26ac7c26a23880af52ac7773368ec","modified":1500809227905},{"_id":"public/tags/python/index.html","hash":"3c953371349f8461c508b29bec320109eacda818","modified":1500809227906},{"_id":"public/tags/python/page/2/index.html","hash":"4ed67fe5f93c27c27c011061f2a64528e6e936ce","modified":1500809227906},{"_id":"public/tags/adb/index.html","hash":"6e956218e63a52343407b3c7489db7361ea50284","modified":1500809227906},{"_id":"public/tags/annotation/index.html","hash":"e744f32418bfae170f3223e3ef30e7da2e5829fc","modified":1500809227906},{"_id":"public/tags/linux/index.html","hash":"db4fdf34836402af15cf4b87646a72448a4842d4","modified":1500809227907},{"_id":"public/tags/hexo/index.html","hash":"a735c86215550d37ae1943c8a1d2a7a63b575678","modified":1500809227907},{"_id":"public/tags/kotlin/index.html","hash":"bd1e31a57a4cae2b5703bcf3c31fbb57fe17eeec","modified":1500809227907},{"_id":"public/tags/rxjava2/index.html","hash":"943536bdacc99f4d7d38329682ddceb7227d6c47","modified":1500809227907},{"_id":"public/tags/concurrency/index.html","hash":"db46fbc1c3092faa08c29e4b0de4b47f0289d974","modified":1500809227907},{"_id":"public/tags/jvm/index.html","hash":"d15e6265ef97dca2fe74c5fe992f47159349bb00","modified":1500809227908},{"_id":"public/tags/java/index.html","hash":"18797a475465514397ab5c5bddbface610f097da","modified":1500809227908},{"_id":"public/tags/Retrofit/index.html","hash":"f437098efef3979931424e2ec48bed77f49dff51","modified":1500809227908},{"_id":"public/tags/OkHttp/index.html","hash":"cfdbab67084a2e81cfb9295773257ddb20e8dfec","modified":1500809227908},{"_id":"public/tags/Okio/index.html","hash":"8555d738a5b06465549736b17635b88047828516","modified":1500809227908},{"_id":"public/tags/transition/index.html","hash":"c3b35ea43fad734d68143097016c396d369014b9","modified":1500809227909},{"_id":"public/tags/git/index.html","hash":"cf1d836a5811015d96887d0d2fc676818ab95569","modified":1500809227909},{"_id":"public/tags/databinding/index.html","hash":"f44086ace4e7ee20f3d7a8cf16432a6c82e93bb6","modified":1500809227910},{"_id":"public/tags/Butterknife/index.html","hash":"0d0994208d341e859a3620d3d2603745de7b4526","modified":1500809227911},{"_id":"public/tags/service/index.html","hash":"863d9af330ec489ccc72b7c65422c8dc8856ca6e","modified":1500809227911},{"_id":"public/tags/foreground/index.html","hash":"5cb388167c429d3b5314954c204fb639be19c5b7","modified":1500809227912},{"_id":"public/2017/07/23/2017-07-23-manipulating-bits/index.html","hash":"c4d97bdb81204d3fc9225fd943a460c7413db64a","modified":1500809227932},{"_id":"public/2017/07/23/2017-07-23-design-pattern/index.html","hash":"dd396fc335cfc8d2e66dd62aaa0a93d7883179c8","modified":1500809227932},{"_id":"public/2017/07/23/2017-07-23-from-java-code-to-java-heap/index.html","hash":"8327cb69aff978b0685ac99e1e88d97969f08440","modified":1500809227932},{"_id":"public/2017/07/23/2017-07-23-lru-cache-and-more/index.html","hash":"03af7e1132042304f1cbac1e60c93170dfa42d3d","modified":1500809227933},{"_id":"public/archives/page/12/index.html","hash":"4a3f3ff63199c9271887aba3592e1aae82c86113","modified":1500809227933},{"_id":"public/archives/2017/page/7/index.html","hash":"2b9591bf6555a230a6c0b62fe03bafa6430936e1","modified":1500809227933},{"_id":"public/archives/2017/07/page/3/index.html","hash":"81c8809bef4c34d30a8a34616b603da384bda346","modified":1500809227933},{"_id":"public/page/12/index.html","hash":"78595937d20c0b0352a168faaf3270d71b1b4dc2","modified":1500809227933},{"_id":"public/tags/android/page/7/index.html","hash":"2bbdfbc0617b40cb64dad64c98cff2a0613621ec","modified":1500809227934},{"_id":"public/tags/java/page/2/index.html","hash":"13613a65a2f3d721aac45702447bf7f409498f88","modified":1500809227934},{"_id":"public/tags/tools/index.html","hash":"6dfe9e12d6d5554b3aa20d069d1b7e74ee0a06b7","modified":1500809227934},{"_id":"public/tags/tools/page/2/index.html","hash":"1c2a80eba4bc470f68be94bf0b9e74495ccb167b","modified":1500809227934},{"_id":"public/tags/designpattern/index.html","hash":"12fcbd6aa8cda8d9d3e73f324453c0070d11e07b","modified":1500809227934}],"Category":[{"name":"blog","_id":"cj5gmdnfg0002bovr9mpbrh45"}],"Data":[],"Page":[],"Post":[{"title":"主线程的工作原理","date":"2016-10-12T08:47:42.000Z","_content":"\n![](http://odzl05jxx.bkt.clouddn.com/writing%20code%20that%20nobody%20else%20can%20read.jpg)\n\n​\t今天突然找到这样一个问题: \"Handler的postDelayed会阻塞线程吗？\"。基于自己之前对于Handler的线程间通讯机制的理解，还是不能给出明确的答案。正好打算把一篇关于主线程的工作原理的文章写出来，顺带看下能否把这个问题从源码的角度解释清楚。<!--more-->\n\n### 1. 从线程（Thread）开始\n通常，一个Process会有一个主线程, 而在Android中，UI控件相关的方法和一些系统callback都会发生在主线程上(onResume,onCreate,onStartCommand,onDraw, etc)。 如果App中使用了多个Process，则每个Process都会有一个主线程，但这不是今天的重点。\nAndroid应用是如何启动的?\n启动一个应用时，系统会从Zygote Process fork出一个新的Process，最终走到ActivityThread 的main方法\n```java\n public static void main(String[] args) {\n //省略部分无关代码\n        Looper.prepareMainLooper();\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n        // End of event ActivityThreadMain.\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");//从这里可以猜到Looper.loop方法会一直执行下去\n    }\n```\n看一下Looper.prepareMainLooper()方法：\n```java\n\n    /**\n     * Initialize the current thread as a looper, marking it as an\n     * application's main looper. The main looper for your application\n     * is created by the Android environment, so you should never need\n     * to call this function yourself.  See also: {@link #prepare()}\n     */\n    public static void prepareMainLooper() {\n        prepare(false);\n        synchronized (Looper.class) {\n            if (sMainLooper != null) {\n                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n            }\n            sMainLooper = myLooper();\n        }\n    }\n```\n大致意思就是为当前Thread添加一个Looper。\nLooper.java是一个普通的class，其大致作用就是**为当前Thread维持一个message loop**，默认情况下一个Thread并没有一个Looper，要想添加一个，需要在该线程中调用Looper.prepare()，然后调用Looper.loop()方法即可让消息循环一直持续下去。大部分和message Loop的交互都是通过Handler这个类来进行的。例如\n```java\nclass LooperThread extends Thread {\n  *      public Handler mHandler;\n  *\n  *      public void run() {\n  *          Looper.prepare();\n  *\n  *          mHandler = new Handler() {\n  *              public void handleMessage(Message msg) {\n  *                  // 在这里处理消息\n  *              }\n  *          };\n  *\n  *          Looper.loop();\n    \t\t//这里面发送消息\n  *      }\n  *  }\n```\nLooper持有一个MessageQueue(消息队列)成员变量，消息循环时，Looper就不断地从消息队列中拿出消息进行处理。\n下面来看Looper.loop()方法里所做的事：\n```java\n  /** 删除了部分不相关的代码\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\n    public static void loop() {\n        final Looper me = myLooper();//返回当前线程中对应的Looper，看看下面的Exception就知道了\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            try {\n                msg.target.dispatchMessage(msg);\n            } finally {\n               ....省略\n            }\n        }\n    }\n```\n简单解释一下，也就是从消息队列中取出新的消息(msg)。交给msg.target.dispatchMessage(msg)\n这个trarget是个Handler\n来看下Handler里面的dispatchMessage方法\n```java\n /**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n很明显是一个either or 的过程：\nMessage这个类里面有个Runnable callback，如果这个message有callback的话，就执行这个runnable，否则执行handler.callBack.handleMessage。也就是我们经常用的\n```java\nHandler handler = new Handler(){\n            @Override\n            public void handleMessage(Message msg) {\n                super.handleMessage(msg);\n            }\n        };\n```\n这种内部类的形式了\n需要注意的是，Message最好不要用new，使用obtain方法获得，使用release方法释放，这里面有一个消息池的概念，我也不太理解。\nMessageQueue中没有太多的公共方法，其中next()方法会返回\n> message that should be processed. Will not return message that will be processed at future times.\n> Message有一个long类型的变量Message.when，指的是这条消息最早可以被执行的时间，这个时间是基于SystemClock.uptimeMills()的。所以如果消息队列中没有一条message到达自己的可执行时间, 这个next()方法就会一直block。值得注意的是SystemClock.uptimeMills是基于CPU活动时间的，如果cpu处于sleep状态，这个sleep时间是不算的。所以如果你postDelayed了10s，假设cpu5s后开始休眠，10s后醒来，睡眠的这段时间是不算的。所以真正执行的时间可能还会往后延迟。\n\n### 2. Handler\nHandler基本上就做两件事\n1. add message to the messageQueue of the Looper it's associated with\n- post()  //把一条消息添加到所有可以被执行的消息的最后面，但在还没到时间的消息的前面\n- postDelayed()/postAtTime() //一个相对时间，一个绝对时间\n- postAtFrontOfQueue() // @piwai 插队行为，不要用\n2. Handle message when this message doesn't have callback\n   Handler的构造方法有7个,初始化时需要获得一个Looper\n   常用的Handler handler = new Handler() 会创建一个基于当前线程的Looper的Handler,如果当前线程没有调用Looper.Prepare，会抛出一个异常，这些在源代码里都能看到。\n   一些好用的构造函数\n> Handler (Looper.getMainLooper()) //往主线程的Looper的消息队列里发消息\n> Hanlder(Looper.myLooper()) //往当前线程Looper的消息队列里添加消息\n\n### Choreographer\n使用Android studio时，经常会在Logcat里看到这样的 info:\n> Skipped 60 frames! The application may be doing too much work on its main thread\n\n这段log出自Chreographer ，大意就是主线程上做的事太多或者做了太多不该在主线程上做的事。至于为什么不要在主线程上做太多的事，来看看主线程都有哪些工作:\nSystem Events , Input Events ,Application callback ,Services, Alarm ,UI Drawing....另外，当屏幕内容发生变化，或者在Animation运行中，系统将会尝试每隔16ms来Draw a Frame。而这部分工作是由Choregrapher来完成的，而其内部是通过一个Handler来进行Frame更新的。\n\n```java\nFrameHandler mHandler = new FrameHandler(Looper.myLooper());\nMessage msg = mHandler.obtainMessage(MSG_DO_FRAME);\nmsg.setAsynchronous(true);\nmHandler.sendMessageAtTime(msg,nextFrameTime)\n\n private final class FrameHandler extends Handler {\n        public FrameHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_DO_FRAME:\n                    doFrame(System.nanoTime(), 0);\n                    break;\n                case MSG_DO_SCHEDULE_VSYNC:\n                    doScheduleVsync();\n                    break;\n                case MSG_DO_SCHEDULE_CALLBACK:\n                    doScheduleCallback(msg.arg1);\n                    break;\n            }\n        }\n    }\n```\n假设你在onMeasure,onLayout,onDraw这些方法中耽误主线程太多时间，Choregrapher将不能及时的更新Frame，哪怕你只耽误了1ms，系统也只能在16ms(大约)之后才能更新下一Frame。\n\n### 3. 为了在开发中发现不应该在主线程中进行的操作(IO，网络)，可以使用StrictMode：\n```java\nif (BuildConfig.DEBUG) {\n            StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()\n                    .detectDiskReads()\n                    .detectDiskWrites()\n                    .detectNetwork()   // or .detectAll() for all detectable problems\n                    .penaltyLog()\n                    .build());\n            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()\n                    .detectLeakedSqlLiteObjects()\n                    .detectLeakedClosableObjects()\n                    .penaltyLog()\n                    .penaltyDeath()\n                    .build());\n        }\n```\n### 4 .Activity LifeCycle Events\n- Activity LifeCycle Events(startActivity(), finishi()) go out of your process through Binder IPC to the ActivityManager //有时候startActivity启动的Activity不是自己Process的,比如调用系统相机这种\n- Then back on to your main queue in the form of lifeCycle callbacks(onCreate(),onDestory() et_al) // 异步，异步！\n\n\n\n最后回到文章开头的那个问题：Handler.postDelay会阻塞线程吗？\n答案在[这里](http://www.dss886.com/android/2016/08/17/17-18)找到了\npostDelayed本身就是把一条消息推迟到相对时间多久之后。关键在Looper取出这条消息时，用的是\n> Message msg = queue.next();  // might block\n\n注释已经暗示了可能会阻塞，看下next方法做了什么:\n```java\n    Message next() {\n    .....省略\n        for (;;) {\n            if (nextPollTimeoutMillis != 0) {\n                Binder.flushPendingCommands();\n            }\n\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n\n            synchronized (this) {\n                // Try to retrieve the next message.  Return if found.\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\t....省略部分\n```\n首先进来 调用了nativePollOnce(ptr,nextPollTimeoutMillis);\n这是个native方法，类似于线程的wait方法，不过使用了Native的方法会更加精准。可以认为是用native方法让这个queue.next的方法耗时延长了，所以return时返回的Message也就满足合适的时间。\n往下看\n>  // Next message is not ready.  Set a timeout to wake up when it is ready.       \n>  nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n\n所以确实是blocked了。但这并不意味着从postDelayed(r,10)开始，接下来的10ms就真的完全堵塞了(queue.next阻塞)\nPostDelayed最终会调用到enqueMessage方法，看一下:\n```java\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n```\n注意nativeWake方法，在满足一定情况下会唤醒线程\n总结一下就是postDelayed确实调用了阻塞线程的方法，但一旦消息队列前面插入了可执行的message，会调用唤醒线程的方法。这些大部分在MessageQueue这个class中，看一下基本都能明白。\n\n### 回顾一下整个过程:\n\n主线程作为一个Thread，持有一个Looper对象，Looper持有一个MessageQueue的消息队列，并一个一个地从中取出满足执行时间条件的Message，执行Messgae的callback或者交给Handler的handleMessage去处理。\n\n### Reference\n1. [Handler.postDelayed()是如何精确延迟指定时间的](http://www.dss886.com/android/2016/08/17/17-18)\n2. [How the Main Thread works](https://www.youtube.com/watch?v=aFGbv9Ih9qQ)\n3. [安卓中为什么主线程不会因为Looper中的死循环而卡死？](http://www.cnblogs.com/linguanh/p/6412042.html)\n","source":"_posts/2016-10-12-How-the-mainThread-work.md","raw":"---\ntitle: 主线程的工作原理\ndate: 2016-10-12 16:47:42\ntag:\n    Handler\n    Message\ncategories: blog\n---\n\n![](http://odzl05jxx.bkt.clouddn.com/writing%20code%20that%20nobody%20else%20can%20read.jpg)\n\n​\t今天突然找到这样一个问题: \"Handler的postDelayed会阻塞线程吗？\"。基于自己之前对于Handler的线程间通讯机制的理解，还是不能给出明确的答案。正好打算把一篇关于主线程的工作原理的文章写出来，顺带看下能否把这个问题从源码的角度解释清楚。<!--more-->\n\n### 1. 从线程（Thread）开始\n通常，一个Process会有一个主线程, 而在Android中，UI控件相关的方法和一些系统callback都会发生在主线程上(onResume,onCreate,onStartCommand,onDraw, etc)。 如果App中使用了多个Process，则每个Process都会有一个主线程，但这不是今天的重点。\nAndroid应用是如何启动的?\n启动一个应用时，系统会从Zygote Process fork出一个新的Process，最终走到ActivityThread 的main方法\n```java\n public static void main(String[] args) {\n //省略部分无关代码\n        Looper.prepareMainLooper();\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n        // End of event ActivityThreadMain.\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");//从这里可以猜到Looper.loop方法会一直执行下去\n    }\n```\n看一下Looper.prepareMainLooper()方法：\n```java\n\n    /**\n     * Initialize the current thread as a looper, marking it as an\n     * application's main looper. The main looper for your application\n     * is created by the Android environment, so you should never need\n     * to call this function yourself.  See also: {@link #prepare()}\n     */\n    public static void prepareMainLooper() {\n        prepare(false);\n        synchronized (Looper.class) {\n            if (sMainLooper != null) {\n                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n            }\n            sMainLooper = myLooper();\n        }\n    }\n```\n大致意思就是为当前Thread添加一个Looper。\nLooper.java是一个普通的class，其大致作用就是**为当前Thread维持一个message loop**，默认情况下一个Thread并没有一个Looper，要想添加一个，需要在该线程中调用Looper.prepare()，然后调用Looper.loop()方法即可让消息循环一直持续下去。大部分和message Loop的交互都是通过Handler这个类来进行的。例如\n```java\nclass LooperThread extends Thread {\n  *      public Handler mHandler;\n  *\n  *      public void run() {\n  *          Looper.prepare();\n  *\n  *          mHandler = new Handler() {\n  *              public void handleMessage(Message msg) {\n  *                  // 在这里处理消息\n  *              }\n  *          };\n  *\n  *          Looper.loop();\n    \t\t//这里面发送消息\n  *      }\n  *  }\n```\nLooper持有一个MessageQueue(消息队列)成员变量，消息循环时，Looper就不断地从消息队列中拿出消息进行处理。\n下面来看Looper.loop()方法里所做的事：\n```java\n  /** 删除了部分不相关的代码\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\n    public static void loop() {\n        final Looper me = myLooper();//返回当前线程中对应的Looper，看看下面的Exception就知道了\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            try {\n                msg.target.dispatchMessage(msg);\n            } finally {\n               ....省略\n            }\n        }\n    }\n```\n简单解释一下，也就是从消息队列中取出新的消息(msg)。交给msg.target.dispatchMessage(msg)\n这个trarget是个Handler\n来看下Handler里面的dispatchMessage方法\n```java\n /**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n很明显是一个either or 的过程：\nMessage这个类里面有个Runnable callback，如果这个message有callback的话，就执行这个runnable，否则执行handler.callBack.handleMessage。也就是我们经常用的\n```java\nHandler handler = new Handler(){\n            @Override\n            public void handleMessage(Message msg) {\n                super.handleMessage(msg);\n            }\n        };\n```\n这种内部类的形式了\n需要注意的是，Message最好不要用new，使用obtain方法获得，使用release方法释放，这里面有一个消息池的概念，我也不太理解。\nMessageQueue中没有太多的公共方法，其中next()方法会返回\n> message that should be processed. Will not return message that will be processed at future times.\n> Message有一个long类型的变量Message.when，指的是这条消息最早可以被执行的时间，这个时间是基于SystemClock.uptimeMills()的。所以如果消息队列中没有一条message到达自己的可执行时间, 这个next()方法就会一直block。值得注意的是SystemClock.uptimeMills是基于CPU活动时间的，如果cpu处于sleep状态，这个sleep时间是不算的。所以如果你postDelayed了10s，假设cpu5s后开始休眠，10s后醒来，睡眠的这段时间是不算的。所以真正执行的时间可能还会往后延迟。\n\n### 2. Handler\nHandler基本上就做两件事\n1. add message to the messageQueue of the Looper it's associated with\n- post()  //把一条消息添加到所有可以被执行的消息的最后面，但在还没到时间的消息的前面\n- postDelayed()/postAtTime() //一个相对时间，一个绝对时间\n- postAtFrontOfQueue() // @piwai 插队行为，不要用\n2. Handle message when this message doesn't have callback\n   Handler的构造方法有7个,初始化时需要获得一个Looper\n   常用的Handler handler = new Handler() 会创建一个基于当前线程的Looper的Handler,如果当前线程没有调用Looper.Prepare，会抛出一个异常，这些在源代码里都能看到。\n   一些好用的构造函数\n> Handler (Looper.getMainLooper()) //往主线程的Looper的消息队列里发消息\n> Hanlder(Looper.myLooper()) //往当前线程Looper的消息队列里添加消息\n\n### Choreographer\n使用Android studio时，经常会在Logcat里看到这样的 info:\n> Skipped 60 frames! The application may be doing too much work on its main thread\n\n这段log出自Chreographer ，大意就是主线程上做的事太多或者做了太多不该在主线程上做的事。至于为什么不要在主线程上做太多的事，来看看主线程都有哪些工作:\nSystem Events , Input Events ,Application callback ,Services, Alarm ,UI Drawing....另外，当屏幕内容发生变化，或者在Animation运行中，系统将会尝试每隔16ms来Draw a Frame。而这部分工作是由Choregrapher来完成的，而其内部是通过一个Handler来进行Frame更新的。\n\n```java\nFrameHandler mHandler = new FrameHandler(Looper.myLooper());\nMessage msg = mHandler.obtainMessage(MSG_DO_FRAME);\nmsg.setAsynchronous(true);\nmHandler.sendMessageAtTime(msg,nextFrameTime)\n\n private final class FrameHandler extends Handler {\n        public FrameHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_DO_FRAME:\n                    doFrame(System.nanoTime(), 0);\n                    break;\n                case MSG_DO_SCHEDULE_VSYNC:\n                    doScheduleVsync();\n                    break;\n                case MSG_DO_SCHEDULE_CALLBACK:\n                    doScheduleCallback(msg.arg1);\n                    break;\n            }\n        }\n    }\n```\n假设你在onMeasure,onLayout,onDraw这些方法中耽误主线程太多时间，Choregrapher将不能及时的更新Frame，哪怕你只耽误了1ms，系统也只能在16ms(大约)之后才能更新下一Frame。\n\n### 3. 为了在开发中发现不应该在主线程中进行的操作(IO，网络)，可以使用StrictMode：\n```java\nif (BuildConfig.DEBUG) {\n            StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()\n                    .detectDiskReads()\n                    .detectDiskWrites()\n                    .detectNetwork()   // or .detectAll() for all detectable problems\n                    .penaltyLog()\n                    .build());\n            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()\n                    .detectLeakedSqlLiteObjects()\n                    .detectLeakedClosableObjects()\n                    .penaltyLog()\n                    .penaltyDeath()\n                    .build());\n        }\n```\n### 4 .Activity LifeCycle Events\n- Activity LifeCycle Events(startActivity(), finishi()) go out of your process through Binder IPC to the ActivityManager //有时候startActivity启动的Activity不是自己Process的,比如调用系统相机这种\n- Then back on to your main queue in the form of lifeCycle callbacks(onCreate(),onDestory() et_al) // 异步，异步！\n\n\n\n最后回到文章开头的那个问题：Handler.postDelay会阻塞线程吗？\n答案在[这里](http://www.dss886.com/android/2016/08/17/17-18)找到了\npostDelayed本身就是把一条消息推迟到相对时间多久之后。关键在Looper取出这条消息时，用的是\n> Message msg = queue.next();  // might block\n\n注释已经暗示了可能会阻塞，看下next方法做了什么:\n```java\n    Message next() {\n    .....省略\n        for (;;) {\n            if (nextPollTimeoutMillis != 0) {\n                Binder.flushPendingCommands();\n            }\n\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n\n            synchronized (this) {\n                // Try to retrieve the next message.  Return if found.\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\t....省略部分\n```\n首先进来 调用了nativePollOnce(ptr,nextPollTimeoutMillis);\n这是个native方法，类似于线程的wait方法，不过使用了Native的方法会更加精准。可以认为是用native方法让这个queue.next的方法耗时延长了，所以return时返回的Message也就满足合适的时间。\n往下看\n>  // Next message is not ready.  Set a timeout to wake up when it is ready.       \n>  nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n\n所以确实是blocked了。但这并不意味着从postDelayed(r,10)开始，接下来的10ms就真的完全堵塞了(queue.next阻塞)\nPostDelayed最终会调用到enqueMessage方法，看一下:\n```java\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n```\n注意nativeWake方法，在满足一定情况下会唤醒线程\n总结一下就是postDelayed确实调用了阻塞线程的方法，但一旦消息队列前面插入了可执行的message，会调用唤醒线程的方法。这些大部分在MessageQueue这个class中，看一下基本都能明白。\n\n### 回顾一下整个过程:\n\n主线程作为一个Thread，持有一个Looper对象，Looper持有一个MessageQueue的消息队列，并一个一个地从中取出满足执行时间条件的Message，执行Messgae的callback或者交给Handler的handleMessage去处理。\n\n### Reference\n1. [Handler.postDelayed()是如何精确延迟指定时间的](http://www.dss886.com/android/2016/08/17/17-18)\n2. [How the Main Thread works](https://www.youtube.com/watch?v=aFGbv9Ih9qQ)\n3. [安卓中为什么主线程不会因为Looper中的死循环而卡死？](http://www.cnblogs.com/linguanh/p/6412042.html)\n","slug":"2016-10-12-How-the-mainThread-work","published":1,"updated":"2017-07-23T10:43:10.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnf20000bovr9lqjkcld","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/writing%20code%20that%20nobody%20else%20can%20read.jpg\" alt=\"\"></p>\n<p>​    今天突然找到这样一个问题: “Handler的postDelayed会阻塞线程吗？”。基于自己之前对于Handler的线程间通讯机制的理解，还是不能给出明确的答案。正好打算把一篇关于主线程的工作原理的文章写出来，顺带看下能否把这个问题从源码的角度解释清楚。<a id=\"more\"></a></p>\n<h3 id=\"1-从线程（Thread）开始\"><a href=\"#1-从线程（Thread）开始\" class=\"headerlink\" title=\"1. 从线程（Thread）开始\"></a>1. 从线程（Thread）开始</h3><p>通常，一个Process会有一个主线程, 而在Android中，UI控件相关的方法和一些系统callback都会发生在主线程上(onResume,onCreate,onStartCommand,onDraw, etc)。 如果App中使用了多个Process，则每个Process都会有一个主线程，但这不是今天的重点。<br>Android应用是如何启动的?<br>启动一个应用时，系统会从Zygote Process fork出一个新的Process，最终走到ActivityThread 的main方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//省略部分无关代码</span></div><div class=\"line\">       Looper.prepareMainLooper();</div><div class=\"line\">       ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</div><div class=\"line\">       thread.attach(<span class=\"keyword\">false</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           sMainThreadHandler = thread.getHandler();</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"comment\">// End of event ActivityThreadMain.</span></div><div class=\"line\">       Looper.loop();</div><div class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);<span class=\"comment\">//从这里可以猜到Looper.loop方法会一直执行下去</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>看一下Looper.prepareMainLooper()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Initialize the current thread as a looper, marking it as an</div><div class=\"line\"> * application's main looper. The main looper for your application</div><div class=\"line\"> * is created by the Android environment, so you should never need</div><div class=\"line\"> * to call this function yourself.  See also: &#123;<span class=\"doctag\">@link</span> #prepare()&#125;</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    prepare(<span class=\"keyword\">false</span>);</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sMainLooper = myLooper();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大致意思就是为当前Thread添加一个Looper。<br>Looper.java是一个普通的class，其大致作用就是<strong>为当前Thread维持一个message loop</strong>，默认情况下一个Thread并没有一个Looper，要想添加一个，需要在该线程中调用Looper.prepare()，然后调用Looper.loop()方法即可让消息循环一直持续下去。大部分和message Loop的交互都是通过Handler这个类来进行的。例如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">  *      <span class=\"keyword\">public</span> Handler mHandler;</div><div class=\"line\">  *</div><div class=\"line\">  *      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  *          Looper.prepare();</div><div class=\"line\">  *</div><div class=\"line\">  *          mHandler = <span class=\"keyword\">new</span> Handler() &#123;</div><div class=\"line\">  *              <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">  *                  <span class=\"comment\">// 在这里处理消息</span></div><div class=\"line\">  *              &#125;</div><div class=\"line\">  *          &#125;;</div><div class=\"line\">  *</div><div class=\"line\">  *          Looper.loop();</div><div class=\"line\">    \t\t<span class=\"comment\">//这里面发送消息</span></div><div class=\"line\">  *      &#125;</div><div class=\"line\">  *  &#125;</div></pre></td></tr></table></figure></p>\n<p>Looper持有一个MessageQueue(消息队列)成员变量，消息循环时，Looper就不断地从消息队列中拿出消息进行处理。<br>下面来看Looper.loop()方法里所做的事：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 删除了部分不相关的代码</div><div class=\"line\">   * Run the message queue in this thread. Be sure to call</div><div class=\"line\">   * &#123;<span class=\"doctag\">@link</span> #quit()&#125; to end the loop.</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">final</span> Looper me = myLooper();<span class=\"comment\">//返回当前线程中对应的Looper，看看下面的Exception就知道了</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\">      <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">          Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              <span class=\"comment\">// No message indicates that the message queue is quitting.</span></div><div class=\"line\">              <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">              msg.target.dispatchMessage(msg);</div><div class=\"line\">          &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">             ....省略</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>简单解释一下，也就是从消息队列中取出新的消息(msg)。交给msg.target.dispatchMessage(msg)<br>这个trarget是个Handler<br>来看下Handler里面的dispatchMessage方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">    * Handle system messages here.</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           handleCallback(msg);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           handleMessage(msg);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>很明显是一个either or 的过程：<br>Message这个类里面有个Runnable callback，如果这个message有callback的话，就执行这个runnable，否则执行handler.callBack.handleMessage。也就是我们经常用的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler handler = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>这种内部类的形式了<br>需要注意的是，Message最好不要用new，使用obtain方法获得，使用release方法释放，这里面有一个消息池的概念，我也不太理解。<br>MessageQueue中没有太多的公共方法，其中next()方法会返回</p>\n<blockquote>\n<p>message that should be processed. Will not return message that will be processed at future times.<br>Message有一个long类型的变量Message.when，指的是这条消息最早可以被执行的时间，这个时间是基于SystemClock.uptimeMills()的。所以如果消息队列中没有一条message到达自己的可执行时间, 这个next()方法就会一直block。值得注意的是SystemClock.uptimeMills是基于CPU活动时间的，如果cpu处于sleep状态，这个sleep时间是不算的。所以如果你postDelayed了10s，假设cpu5s后开始休眠，10s后醒来，睡眠的这段时间是不算的。所以真正执行的时间可能还会往后延迟。</p>\n</blockquote>\n<h3 id=\"2-Handler\"><a href=\"#2-Handler\" class=\"headerlink\" title=\"2. Handler\"></a>2. Handler</h3><p>Handler基本上就做两件事</p>\n<ol>\n<li>add message to the messageQueue of the Looper it’s associated with</li>\n</ol>\n<ul>\n<li>post()  //把一条消息添加到所有可以被执行的消息的最后面，但在还没到时间的消息的前面</li>\n<li>postDelayed()/postAtTime() //一个相对时间，一个绝对时间</li>\n<li>postAtFrontOfQueue() // @piwai 插队行为，不要用</li>\n</ul>\n<ol>\n<li>Handle message when this message doesn’t have callback<br>Handler的构造方法有7个,初始化时需要获得一个Looper<br>常用的Handler handler = new Handler() 会创建一个基于当前线程的Looper的Handler,如果当前线程没有调用Looper.Prepare，会抛出一个异常，这些在源代码里都能看到。<br>一些好用的构造函数<blockquote>\n<p>Handler (Looper.getMainLooper()) //往主线程的Looper的消息队列里发消息<br>Hanlder(Looper.myLooper()) //往当前线程Looper的消息队列里添加消息</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h3><p>使用Android studio时，经常会在Logcat里看到这样的 info:</p>\n<blockquote>\n<p>Skipped 60 frames! The application may be doing too much work on its main thread</p>\n</blockquote>\n<p>这段log出自Chreographer ，大意就是主线程上做的事太多或者做了太多不该在主线程上做的事。至于为什么不要在主线程上做太多的事，来看看主线程都有哪些工作:<br>System Events , Input Events ,Application callback ,Services, Alarm ,UI Drawing….另外，当屏幕内容发生变化，或者在Animation运行中，系统将会尝试每隔16ms来Draw a Frame。而这部分工作是由Choregrapher来完成的，而其内部是通过一个Handler来进行Frame更新的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">FrameHandler mHandler = <span class=\"keyword\">new</span> FrameHandler(Looper.myLooper());</div><div class=\"line\">Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</div><div class=\"line\">msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">mHandler.sendMessageAtTime(msg,nextFrameTime)</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FrameHandler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(looper);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> MSG_DO_FRAME:</div><div class=\"line\">                    doFrame(System.nanoTime(), <span class=\"number\">0</span>);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</div><div class=\"line\">                    doScheduleVsync();</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</div><div class=\"line\">                    doScheduleCallback(msg.arg1);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>假设你在onMeasure,onLayout,onDraw这些方法中耽误主线程太多时间，Choregrapher将不能及时的更新Frame，哪怕你只耽误了1ms，系统也只能在16ms(大约)之后才能更新下一Frame。</p>\n<h3 id=\"3-为了在开发中发现不应该在主线程中进行的操作-IO，网络-，可以使用StrictMode：\"><a href=\"#3-为了在开发中发现不应该在主线程中进行的操作-IO，网络-，可以使用StrictMode：\" class=\"headerlink\" title=\"3. 为了在开发中发现不应该在主线程中进行的操作(IO，网络)，可以使用StrictMode：\"></a>3. 为了在开发中发现不应该在主线程中进行的操作(IO，网络)，可以使用StrictMode：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (BuildConfig.DEBUG) &#123;</div><div class=\"line\">            StrictMode.setThreadPolicy(<span class=\"keyword\">new</span> StrictMode.ThreadPolicy.Builder()</div><div class=\"line\">                    .detectDiskReads()</div><div class=\"line\">                    .detectDiskWrites()</div><div class=\"line\">                    .detectNetwork()   <span class=\"comment\">// or .detectAll() for all detectable problems</span></div><div class=\"line\">                    .penaltyLog()</div><div class=\"line\">                    .build());</div><div class=\"line\">            StrictMode.setVmPolicy(<span class=\"keyword\">new</span> StrictMode.VmPolicy.Builder()</div><div class=\"line\">                    .detectLeakedSqlLiteObjects()</div><div class=\"line\">                    .detectLeakedClosableObjects()</div><div class=\"line\">                    .penaltyLog()</div><div class=\"line\">                    .penaltyDeath()</div><div class=\"line\">                    .build());</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-Activity-LifeCycle-Events\"><a href=\"#4-Activity-LifeCycle-Events\" class=\"headerlink\" title=\"4 .Activity LifeCycle Events\"></a>4 .Activity LifeCycle Events</h3><ul>\n<li>Activity LifeCycle Events(startActivity(), finishi()) go out of your process through Binder IPC to the ActivityManager //有时候startActivity启动的Activity不是自己Process的,比如调用系统相机这种</li>\n<li>Then back on to your main queue in the form of lifeCycle callbacks(onCreate(),onDestory() et_al) // 异步，异步！</li>\n</ul>\n<p>最后回到文章开头的那个问题：Handler.postDelay会阻塞线程吗？<br>答案在<a href=\"http://www.dss886.com/android/2016/08/17/17-18\">这里</a>找到了<br>postDelayed本身就是把一条消息推迟到相对时间多久之后。关键在Looper取出这条消息时，用的是</p>\n<blockquote>\n<p>Message msg = queue.next();  // might block</p>\n</blockquote>\n<p>注释已经暗示了可能会阻塞，看下next方法做了什么:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   .....省略</div><div class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">               Binder.flushPendingCommands();</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">               <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</div><div class=\"line\">               Message prevMsg = <span class=\"keyword\">null</span>;</div><div class=\"line\">               Message msg = mMessages;</div><div class=\"line\">               <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class=\"line\">                   do &#123;</div><div class=\"line\">                       prevMsg = msg;</div><div class=\"line\">                       msg = msg.next;</div><div class=\"line\">                   &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</div><div class=\"line\">                       <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class=\"line\">                       nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                       <span class=\"comment\">// Got a message.</span></div><div class=\"line\">                       mBlocked = <span class=\"keyword\">false</span>;</div><div class=\"line\">                       <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                           prevMsg.next = msg.next;</div><div class=\"line\">                       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                           mMessages = msg.next;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       msg.next = <span class=\"keyword\">null</span>;</div><div class=\"line\">                       msg.markInUse();</div><div class=\"line\">                       <span class=\"keyword\">return</span> msg;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   <span class=\"comment\">// No more messages.</span></div><div class=\"line\">                   nextPollTimeoutMillis = -<span class=\"number\">1</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">....省略部分</div></pre></td></tr></table></figure></p>\n<p>首先进来 调用了nativePollOnce(ptr,nextPollTimeoutMillis);<br>这是个native方法，类似于线程的wait方法，不过使用了Native的方法会更加精准。可以认为是用native方法让这个queue.next的方法耗时延长了，所以return时返回的Message也就满足合适的时间。<br>往下看</p>\n<blockquote>\n<p> // Next message is not ready.  Set a timeout to wake up when it is ready.<br> nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</p>\n</blockquote>\n<p>所以确实是blocked了。但这并不意味着从postDelayed(r,10)开始，接下来的10ms就真的完全堵塞了(queue.next阻塞)<br>PostDelayed最终会调用到enqueMessage方法，看一下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mQuitting) &#123;</div><div class=\"line\">        IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</div><div class=\"line\">        Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">        msg.recycle();</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    msg.markInUse();</div><div class=\"line\">    msg.when = when;</div><div class=\"line\">    Message p = mMessages;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> needWake;</div><div class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</div><div class=\"line\">        <span class=\"comment\">// New head, wake up the event queue if blocked.</span></div><div class=\"line\">        msg.next = p;</div><div class=\"line\">        mMessages = msg;</div><div class=\"line\">        needWake = mBlocked;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class=\"line\">        <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></div><div class=\"line\">        <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></div><div class=\"line\">        needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">        Message prev;</div><div class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">            prev = p;</div><div class=\"line\">            p = p.next;</div><div class=\"line\">            <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                needWake = <span class=\"keyword\">false</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></div><div class=\"line\">        prev.next = msg;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (needWake) &#123;</div><div class=\"line\">        nativeWake(mPtr);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意nativeWake方法，在满足一定情况下会唤醒线程<br>总结一下就是postDelayed确实调用了阻塞线程的方法，但一旦消息队列前面插入了可执行的message，会调用唤醒线程的方法。这些大部分在MessageQueue这个class中，看一下基本都能明白。</p>\n<h3 id=\"回顾一下整个过程\"><a href=\"#回顾一下整个过程\" class=\"headerlink\" title=\"回顾一下整个过程:\"></a>回顾一下整个过程:</h3><p>主线程作为一个Thread，持有一个Looper对象，Looper持有一个MessageQueue的消息队列，并一个一个地从中取出满足执行时间条件的Message，执行Messgae的callback或者交给Handler的handleMessage去处理。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://www.dss886.com/android/2016/08/17/17-18\">Handler.postDelayed()是如何精确延迟指定时间的</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=aFGbv9Ih9qQ\">How the Main Thread works</a></li>\n<li><a href=\"http://www.cnblogs.com/linguanh/p/6412042.html\">安卓中为什么主线程不会因为Looper中的死循环而卡死？</a></li>\n</ol>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/writing%20code%20that%20nobody%20else%20can%20read.jpg\" alt=\"\"></p>\n<p>​    今天突然找到这样一个问题: “Handler的postDelayed会阻塞线程吗？”。基于自己之前对于Handler的线程间通讯机制的理解，还是不能给出明确的答案。正好打算把一篇关于主线程的工作原理的文章写出来，顺带看下能否把这个问题从源码的角度解释清楚。","more":"</p>\n<h3 id=\"1-从线程（Thread）开始\"><a href=\"#1-从线程（Thread）开始\" class=\"headerlink\" title=\"1. 从线程（Thread）开始\"></a>1. 从线程（Thread）开始</h3><p>通常，一个Process会有一个主线程, 而在Android中，UI控件相关的方法和一些系统callback都会发生在主线程上(onResume,onCreate,onStartCommand,onDraw, etc)。 如果App中使用了多个Process，则每个Process都会有一个主线程，但这不是今天的重点。<br>Android应用是如何启动的?<br>启动一个应用时，系统会从Zygote Process fork出一个新的Process，最终走到ActivityThread 的main方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//省略部分无关代码</span></div><div class=\"line\">       Looper.prepareMainLooper();</div><div class=\"line\">       ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</div><div class=\"line\">       thread.attach(<span class=\"keyword\">false</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           sMainThreadHandler = thread.getHandler();</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"comment\">// End of event ActivityThreadMain.</span></div><div class=\"line\">       Looper.loop();</div><div class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);<span class=\"comment\">//从这里可以猜到Looper.loop方法会一直执行下去</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>看一下Looper.prepareMainLooper()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Initialize the current thread as a looper, marking it as an</div><div class=\"line\"> * application's main looper. The main looper for your application</div><div class=\"line\"> * is created by the Android environment, so you should never need</div><div class=\"line\"> * to call this function yourself.  See also: &#123;<span class=\"doctag\">@link</span> #prepare()&#125;</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    prepare(<span class=\"keyword\">false</span>);</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sMainLooper = myLooper();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大致意思就是为当前Thread添加一个Looper。<br>Looper.java是一个普通的class，其大致作用就是<strong>为当前Thread维持一个message loop</strong>，默认情况下一个Thread并没有一个Looper，要想添加一个，需要在该线程中调用Looper.prepare()，然后调用Looper.loop()方法即可让消息循环一直持续下去。大部分和message Loop的交互都是通过Handler这个类来进行的。例如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">  *      <span class=\"keyword\">public</span> Handler mHandler;</div><div class=\"line\">  *</div><div class=\"line\">  *      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  *          Looper.prepare();</div><div class=\"line\">  *</div><div class=\"line\">  *          mHandler = <span class=\"keyword\">new</span> Handler() &#123;</div><div class=\"line\">  *              <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">  *                  <span class=\"comment\">// 在这里处理消息</span></div><div class=\"line\">  *              &#125;</div><div class=\"line\">  *          &#125;;</div><div class=\"line\">  *</div><div class=\"line\">  *          Looper.loop();</div><div class=\"line\">    \t\t<span class=\"comment\">//这里面发送消息</span></div><div class=\"line\">  *      &#125;</div><div class=\"line\">  *  &#125;</div></pre></td></tr></table></figure></p>\n<p>Looper持有一个MessageQueue(消息队列)成员变量，消息循环时，Looper就不断地从消息队列中拿出消息进行处理。<br>下面来看Looper.loop()方法里所做的事：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** 删除了部分不相关的代码</div><div class=\"line\">   * Run the message queue in this thread. Be sure to call</div><div class=\"line\">   * &#123;<span class=\"doctag\">@link</span> #quit()&#125; to end the loop.</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">final</span> Looper me = myLooper();<span class=\"comment\">//返回当前线程中对应的Looper，看看下面的Exception就知道了</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\">      <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">          Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              <span class=\"comment\">// No message indicates that the message queue is quitting.</span></div><div class=\"line\">              <span class=\"keyword\">return</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">              msg.target.dispatchMessage(msg);</div><div class=\"line\">          &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">             ....省略</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>简单解释一下，也就是从消息队列中取出新的消息(msg)。交给msg.target.dispatchMessage(msg)<br>这个trarget是个Handler<br>来看下Handler里面的dispatchMessage方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">    * Handle system messages here.</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           handleCallback(msg);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           handleMessage(msg);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>很明显是一个either or 的过程：<br>Message这个类里面有个Runnable callback，如果这个message有callback的话，就执行这个runnable，否则执行handler.callBack.handleMessage。也就是我们经常用的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler handler = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>这种内部类的形式了<br>需要注意的是，Message最好不要用new，使用obtain方法获得，使用release方法释放，这里面有一个消息池的概念，我也不太理解。<br>MessageQueue中没有太多的公共方法，其中next()方法会返回</p>\n<blockquote>\n<p>message that should be processed. Will not return message that will be processed at future times.<br>Message有一个long类型的变量Message.when，指的是这条消息最早可以被执行的时间，这个时间是基于SystemClock.uptimeMills()的。所以如果消息队列中没有一条message到达自己的可执行时间, 这个next()方法就会一直block。值得注意的是SystemClock.uptimeMills是基于CPU活动时间的，如果cpu处于sleep状态，这个sleep时间是不算的。所以如果你postDelayed了10s，假设cpu5s后开始休眠，10s后醒来，睡眠的这段时间是不算的。所以真正执行的时间可能还会往后延迟。</p>\n</blockquote>\n<h3 id=\"2-Handler\"><a href=\"#2-Handler\" class=\"headerlink\" title=\"2. Handler\"></a>2. Handler</h3><p>Handler基本上就做两件事</p>\n<ol>\n<li>add message to the messageQueue of the Looper it’s associated with</li>\n</ol>\n<ul>\n<li>post()  //把一条消息添加到所有可以被执行的消息的最后面，但在还没到时间的消息的前面</li>\n<li>postDelayed()/postAtTime() //一个相对时间，一个绝对时间</li>\n<li>postAtFrontOfQueue() // @piwai 插队行为，不要用</li>\n</ul>\n<ol>\n<li>Handle message when this message doesn’t have callback<br>Handler的构造方法有7个,初始化时需要获得一个Looper<br>常用的Handler handler = new Handler() 会创建一个基于当前线程的Looper的Handler,如果当前线程没有调用Looper.Prepare，会抛出一个异常，这些在源代码里都能看到。<br>一些好用的构造函数<blockquote>\n<p>Handler (Looper.getMainLooper()) //往主线程的Looper的消息队列里发消息<br>Hanlder(Looper.myLooper()) //往当前线程Looper的消息队列里添加消息</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h3><p>使用Android studio时，经常会在Logcat里看到这样的 info:</p>\n<blockquote>\n<p>Skipped 60 frames! The application may be doing too much work on its main thread</p>\n</blockquote>\n<p>这段log出自Chreographer ，大意就是主线程上做的事太多或者做了太多不该在主线程上做的事。至于为什么不要在主线程上做太多的事，来看看主线程都有哪些工作:<br>System Events , Input Events ,Application callback ,Services, Alarm ,UI Drawing….另外，当屏幕内容发生变化，或者在Animation运行中，系统将会尝试每隔16ms来Draw a Frame。而这部分工作是由Choregrapher来完成的，而其内部是通过一个Handler来进行Frame更新的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">FrameHandler mHandler = <span class=\"keyword\">new</span> FrameHandler(Looper.myLooper());</div><div class=\"line\">Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</div><div class=\"line\">msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">mHandler.sendMessageAtTime(msg,nextFrameTime)</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FrameHandler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(looper);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> MSG_DO_FRAME:</div><div class=\"line\">                    doFrame(System.nanoTime(), <span class=\"number\">0</span>);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</div><div class=\"line\">                    doScheduleVsync();</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</div><div class=\"line\">                    doScheduleCallback(msg.arg1);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>假设你在onMeasure,onLayout,onDraw这些方法中耽误主线程太多时间，Choregrapher将不能及时的更新Frame，哪怕你只耽误了1ms，系统也只能在16ms(大约)之后才能更新下一Frame。</p>\n<h3 id=\"3-为了在开发中发现不应该在主线程中进行的操作-IO，网络-，可以使用StrictMode：\"><a href=\"#3-为了在开发中发现不应该在主线程中进行的操作-IO，网络-，可以使用StrictMode：\" class=\"headerlink\" title=\"3. 为了在开发中发现不应该在主线程中进行的操作(IO，网络)，可以使用StrictMode：\"></a>3. 为了在开发中发现不应该在主线程中进行的操作(IO，网络)，可以使用StrictMode：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (BuildConfig.DEBUG) &#123;</div><div class=\"line\">            StrictMode.setThreadPolicy(<span class=\"keyword\">new</span> StrictMode.ThreadPolicy.Builder()</div><div class=\"line\">                    .detectDiskReads()</div><div class=\"line\">                    .detectDiskWrites()</div><div class=\"line\">                    .detectNetwork()   <span class=\"comment\">// or .detectAll() for all detectable problems</span></div><div class=\"line\">                    .penaltyLog()</div><div class=\"line\">                    .build());</div><div class=\"line\">            StrictMode.setVmPolicy(<span class=\"keyword\">new</span> StrictMode.VmPolicy.Builder()</div><div class=\"line\">                    .detectLeakedSqlLiteObjects()</div><div class=\"line\">                    .detectLeakedClosableObjects()</div><div class=\"line\">                    .penaltyLog()</div><div class=\"line\">                    .penaltyDeath()</div><div class=\"line\">                    .build());</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-Activity-LifeCycle-Events\"><a href=\"#4-Activity-LifeCycle-Events\" class=\"headerlink\" title=\"4 .Activity LifeCycle Events\"></a>4 .Activity LifeCycle Events</h3><ul>\n<li>Activity LifeCycle Events(startActivity(), finishi()) go out of your process through Binder IPC to the ActivityManager //有时候startActivity启动的Activity不是自己Process的,比如调用系统相机这种</li>\n<li>Then back on to your main queue in the form of lifeCycle callbacks(onCreate(),onDestory() et_al) // 异步，异步！</li>\n</ul>\n<p>最后回到文章开头的那个问题：Handler.postDelay会阻塞线程吗？<br>答案在<a href=\"http://www.dss886.com/android/2016/08/17/17-18\">这里</a>找到了<br>postDelayed本身就是把一条消息推迟到相对时间多久之后。关键在Looper取出这条消息时，用的是</p>\n<blockquote>\n<p>Message msg = queue.next();  // might block</p>\n</blockquote>\n<p>注释已经暗示了可能会阻塞，看下next方法做了什么:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   .....省略</div><div class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">               Binder.flushPendingCommands();</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">               <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</div><div class=\"line\">               Message prevMsg = <span class=\"keyword\">null</span>;</div><div class=\"line\">               Message msg = mMessages;</div><div class=\"line\">               <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class=\"line\">                   do &#123;</div><div class=\"line\">                       prevMsg = msg;</div><div class=\"line\">                       msg = msg.next;</div><div class=\"line\">                   &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</div><div class=\"line\">                       <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class=\"line\">                       nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                       <span class=\"comment\">// Got a message.</span></div><div class=\"line\">                       mBlocked = <span class=\"keyword\">false</span>;</div><div class=\"line\">                       <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                           prevMsg.next = msg.next;</div><div class=\"line\">                       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                           mMessages = msg.next;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       msg.next = <span class=\"keyword\">null</span>;</div><div class=\"line\">                       msg.markInUse();</div><div class=\"line\">                       <span class=\"keyword\">return</span> msg;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   <span class=\"comment\">// No more messages.</span></div><div class=\"line\">                   nextPollTimeoutMillis = -<span class=\"number\">1</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">....省略部分</div></pre></td></tr></table></figure></p>\n<p>首先进来 调用了nativePollOnce(ptr,nextPollTimeoutMillis);<br>这是个native方法，类似于线程的wait方法，不过使用了Native的方法会更加精准。可以认为是用native方法让这个queue.next的方法耗时延长了，所以return时返回的Message也就满足合适的时间。<br>往下看</p>\n<blockquote>\n<p> // Next message is not ready.  Set a timeout to wake up when it is ready.<br> nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</p>\n</blockquote>\n<p>所以确实是blocked了。但这并不意味着从postDelayed(r,10)开始，接下来的10ms就真的完全堵塞了(queue.next阻塞)<br>PostDelayed最终会调用到enqueMessage方法，看一下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mQuitting) &#123;</div><div class=\"line\">        IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</div><div class=\"line\">        Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">        msg.recycle();</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    msg.markInUse();</div><div class=\"line\">    msg.when = when;</div><div class=\"line\">    Message p = mMessages;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> needWake;</div><div class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</div><div class=\"line\">        <span class=\"comment\">// New head, wake up the event queue if blocked.</span></div><div class=\"line\">        msg.next = p;</div><div class=\"line\">        mMessages = msg;</div><div class=\"line\">        needWake = mBlocked;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class=\"line\">        <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></div><div class=\"line\">        <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></div><div class=\"line\">        needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">        Message prev;</div><div class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">            prev = p;</div><div class=\"line\">            p = p.next;</div><div class=\"line\">            <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                needWake = <span class=\"keyword\">false</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></div><div class=\"line\">        prev.next = msg;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (needWake) &#123;</div><div class=\"line\">        nativeWake(mPtr);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意nativeWake方法，在满足一定情况下会唤醒线程<br>总结一下就是postDelayed确实调用了阻塞线程的方法，但一旦消息队列前面插入了可执行的message，会调用唤醒线程的方法。这些大部分在MessageQueue这个class中，看一下基本都能明白。</p>\n<h3 id=\"回顾一下整个过程\"><a href=\"#回顾一下整个过程\" class=\"headerlink\" title=\"回顾一下整个过程:\"></a>回顾一下整个过程:</h3><p>主线程作为一个Thread，持有一个Looper对象，Looper持有一个MessageQueue的消息队列，并一个一个地从中取出满足执行时间条件的Message，执行Messgae的callback或者交给Handler的handleMessage去处理。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://www.dss886.com/android/2016/08/17/17-18\">Handler.postDelayed()是如何精确延迟指定时间的</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=aFGbv9Ih9qQ\">How the Main Thread works</a></li>\n<li><a href=\"http://www.cnblogs.com/linguanh/p/6412042.html\">安卓中为什么主线程不会因为Looper中的死循环而卡死？</a></li>\n</ol>"},{"title":"安卓坐标系常用方法","date":"2016-10-13T10:17:02.000Z","_content":"记录一些Android系统坐标系的常用方法，因为日常开发中难免会碰到需要单独计算View系统坐标的情况。\n\n![](http://odzl05jxx.bkt.clouddn.com/minion.jpg?imageView2/2/w/400)\n<!--more-->\n\nScrollTo，ScrollBy，getVisibleRect这些方法平时想要用的时候总要去网上查找，这里记录下来，方便今后直接参考\n首先是一张很多人都见过的图\n![](http://odzl05jxx.bkt.clouddn.com/android_screen_coordinate_system.png?imageView2/2/w/500)\n中间的蓝色的点是TouchEvent发生时，获得的MotionEvent.getX()、getY()。\n### 1. 坐标原点和坐标轴方向\n坐标原点有两种，屏幕左上角（statusBar也包含其中）和父控件左上角\n坐标轴方向：X轴向右，Y轴向下，Z轴(5.0增加)向上。\n\n\n### 2. Left,Top,Right,Bottom\n而Top，left，bottom,down分别对应着其其相对于父控件的距离，由此可以计算得到View的宽度width = getRight()-getLeft() ,View的高度 height = getBottom()-getTop()\n而实际上view.getHeight()方法的实现也就是mBottom-mTop.\n\n\n### 3. X , Y\nX代表的是当前View的左上角那个点的横坐标，Y代表的是纵坐标。\nX = left + getTranslationX  \nY = Top + getTranslationY\n通常在动画中使用setTranslationX来实现偏移效果，注意，这是不会改变left的。在滑动过程中，x, y会随着改变。\n\n### 4. 几个跟Rect相关的\n获得的是当前View左上角距离屏幕左上角的位置，为此我专门测试了一下\n>  W/ViewAnimationActivity.java: [32 | onWindowFocusChanged]statusBarHeight = 75\n>  W/ViewAnimationActivity.java: [35 | onWindowFocusChanged]getLocationInWindow  x = 0 y = 75 \n>  W/ViewAnimationActivity.java: [38 | onWindowFocusChanged]getLocationOnScreen x = 0 y = 75\n可以看到返回的就是View左上角的坐标，一般情况下两者区别不重要，stackoverFlow上有[讨论](http://stackoverflow.com/questions/17672891/getlocationonscreen-vs-getlocationinwindow)\n\n```java\nView.getLocationInWindow(pos); //获取在当前window内的绝对坐标\nView.getLocationOnScreen(pos); //包括statusBar，以屏幕左上角为坐标原点\nView.getLocalVisibleRect()  \n//以view自身的左上角为坐标原点，这个很有用，\n//返回的坐标一定是(0,0,xxx,xxx)这样的，可以判断当前View是否完全可见\nView.getGlobalVisibleRect()  // 以屏幕左上角为坐标原点\n```\n以上四个方法在onCreate里面返回的值都是0，需要在Activity的onWindowFocusChanged(true)中去获得\n这里需要扯一点关于window的问题，根据大部分博客的介绍：DecorView是FrameLayout的子类，是View视图层级树的根节点。\n一般会有一个LinearLayout的child\n\n为此，我在setContentView里面放了一个CoordinateLayout,使用Hierarchy View截图的到这样的结果。\n图片有点大\n![](http://odzl05jxx.bkt.clouddn.com/view_hirearchy_1013.png)\n\n在ViewHirearchy中可以看到，Activity中View视图层级从上到下依次为：\n\n> PhoneWindow$DecorView（有三个child,分别是LinearLayout，View(id/statusBarBackground)和View(id/navigationBarBackground)）\n> LinearLayout\n> FrameLayout\n> FitWindowsLinearLayout\n> ContentFrameLayout(id/android.R.id.content) //这在开发过程中有时会用到\n> setContentView设置的view\n\n关于window，DecorWindow的文章网上有很多，仔细研究下会对理解View的测量机制有一定好处，这对于View的工作原理也能够更彻底的理解。\n[参考文章](http://blog.csdn.net/qibin0506/article/details/49245601)\n日常开发中，setContentView这个方法只是将我们自己写的activiy_main.xml布局文件inflate出来的view添加到\nandroid.R.id.content这个ViewGroup中，实践下来发现这是一个ContentFrameLayout的实例，它的child只有一个，就是我们通过setContentView添加的View\n\n### 5. 让View滑动起来\n> offsetLeftAndRight(int offset) //给left和right加上一个值，改变的是View的位置\n> offsetTopAndBottom(int offset) \n\n> scrollTo(int x,int y)  // 将View中的内容移动，坐标原点为parentView左上角，注意，参数为正，效果为反\n例如scrollTo(-100,0) 在手机上看效果是往右移动了\n\n> scrollBy(int x, int y)\n\nscrollBy的源码如下:\n```java\n  public void scrollBy(int x, int y) {\n        scrollTo(mScrollX + x, mScrollY + y);\n    }\n```\n还有一些不常用的：\n```java\npublic void setScrollX(int value) {\n        scrollTo(value, mScrollY);\n    }\n```\n\n### 6. 改变LayoutParams的margin让View移动\n这是一种很生硬的方式，不常用\n```java\nMarginLayoutParams params = (MarginLayoutParams)mTextView.getLayoutParams(); //可能为null\nparams.leftMargin + = 100;\nmTextView.setLayoutParams();// 这里面调用了requestLayout\n```\n\n\n### 7.使用Animation让View动起来\n根据官方文档的[定义](https://developer.android.com/guide/topics/graphics/overview.html)Android中一共两种Animation: \n> Property Animation\n> View Animation(包括Tween animation, Frame animation)\n\n首先从package的位置来看\n属性动画都位于android.animation这个package下面，常见的如ObjectAnimator继承自ValueAnimator\nView动画则位于android.view.animation这个package下，常见的如TranslateA,AlphaAnimation等\n\nView Animation可以代码创建，也可以写在R.anim文件夹下,用法很简单\n```java\nImageView image = (ImageView) findViewById(R.id.image);\nAnimation hyperspaceJump = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);\nimage.startAnimation(hyperspaceJump);\n```\n属性动画可以代码创建，也可以写在R.animator文件夹下,用法:\n```java\nAnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n    R.anim.property_animator);\nset.setTarget(myObject);\nset.start();\n```\n推荐使用ViewPropertyAnimator，这是一个位于android.view下面的class，感觉更像是一个Util,大部分的方法都是在API 12 ,API 14引入的，\n实际开发中推荐使用ViewCompat.animate() 返回一个ViewPropertyAnimator对象，省去了开发者版本判断的麻烦\n语法更为简单：\n```java\nViewCompat.animate(view).x(500).y(500).setDuration(5000).setInterpolator(new DecelaratorInterpolator());  //不需要调用start()\n```\n据说这种方式性能最好，Google官方强烈推荐,参考DevByte。\n另外，据说大部分Google的App使用的都是DecelaratorInterpolator，当然这跟设计有关。\n\n### 8.使用Scroller实现smoothScroll\nView有一个方法computeScroll(),复写，像这样就可以了\n```java\nScroller scroller = new Scroller(mContext);\n \n private void smoothScrollTo(int dstX, int dstY) {\n      int scrollX = getScrollX();\n      int delta = dstX - scrollX;\n      scroller.startScroll(scrollX, 0, delta, 0, 1000);\n      invalidate();\n }\n  \n @Override\n public void computeScroll() {\n     if (scroller.computeScrollOffset()) {\n         scrollTo(scroller.getCurrX(), scroller.getCurY());\n         postInvalidate();\n     }\n }\n```\n\n### 9. 补充几个好玩的函数\nView.canScrollVertically(int)\n```java\n public static boolean canChildScrollUp(View view) {\n        if (android.os.Build.VERSION.SDK_INT < 14) {\n            if (view instanceof AbsListView) {\n                final AbsListView absListView = (AbsListView) view;\n                return absListView.getChildCount() > 0\n                        && (absListView.getFirstVisiblePosition() > 0 || absListView.getChildAt(0)\n                        .getTop() < absListView.getPaddingTop());\n            } else {\n                return view.getScrollY() > 0;\n            }\n        } else {\n            return view.canScrollVertically(-1);\n        }\n    }\n```\n这段是我在秋百万的android-ultra-pulltorefresh里面找到的，想当初为了自己写下拉刷新，一遍一遍的打Log，最后甚至用上getVisibleRect才算搞定。\n其实很多东西前人已经帮我们整理好了。\n对了这东西在v4包里有ViewCompat.canScrollVertically，v4包除了方法数有点多(10k+好像)这点不好以外，一直都很好用\n附上supportLibrary各个包的方法数，如果对65536这个数字熟悉的话，还是会注意点的。\n![pic](http://odzl05jxx.bkt.clouddn.com/support_lib_methods_summary.jpg)\n\n\n\n### 总结\n- 使用getLocalVisibleRect可以判断一个view是否完全可见\n- scrollBy,setScrollX等内部都是调用了scrollTo方法，ScrollTo方法传参数与实际效果是相反的\n\n\n\n\n### Reference\n1. [Android应用坐标系统全面详解](http://blog.csdn.net/yanbober/article/details/50419117)\n2. ​[如何取得View的位置之View.getLocationInWindow()的小秘密](http://blog.csdn.net/imyfriend/article/details/8564781\n3. [详解实现Android中实现View滑动的几种方式](http://www.cnblogs.com/absfree/p/5352258.html)","source":"_posts/2016-10-13-Android-coordinate-System.md","raw":"---\ntitle: 安卓坐标系常用方法\ndate: 2016-10-13 18:17:02\ncategories: blog\ntags: [android,TouchEvent]\n---\n记录一些Android系统坐标系的常用方法，因为日常开发中难免会碰到需要单独计算View系统坐标的情况。\n\n![](http://odzl05jxx.bkt.clouddn.com/minion.jpg?imageView2/2/w/400)\n<!--more-->\n\nScrollTo，ScrollBy，getVisibleRect这些方法平时想要用的时候总要去网上查找，这里记录下来，方便今后直接参考\n首先是一张很多人都见过的图\n![](http://odzl05jxx.bkt.clouddn.com/android_screen_coordinate_system.png?imageView2/2/w/500)\n中间的蓝色的点是TouchEvent发生时，获得的MotionEvent.getX()、getY()。\n### 1. 坐标原点和坐标轴方向\n坐标原点有两种，屏幕左上角（statusBar也包含其中）和父控件左上角\n坐标轴方向：X轴向右，Y轴向下，Z轴(5.0增加)向上。\n\n\n### 2. Left,Top,Right,Bottom\n而Top，left，bottom,down分别对应着其其相对于父控件的距离，由此可以计算得到View的宽度width = getRight()-getLeft() ,View的高度 height = getBottom()-getTop()\n而实际上view.getHeight()方法的实现也就是mBottom-mTop.\n\n\n### 3. X , Y\nX代表的是当前View的左上角那个点的横坐标，Y代表的是纵坐标。\nX = left + getTranslationX  \nY = Top + getTranslationY\n通常在动画中使用setTranslationX来实现偏移效果，注意，这是不会改变left的。在滑动过程中，x, y会随着改变。\n\n### 4. 几个跟Rect相关的\n获得的是当前View左上角距离屏幕左上角的位置，为此我专门测试了一下\n>  W/ViewAnimationActivity.java: [32 | onWindowFocusChanged]statusBarHeight = 75\n>  W/ViewAnimationActivity.java: [35 | onWindowFocusChanged]getLocationInWindow  x = 0 y = 75 \n>  W/ViewAnimationActivity.java: [38 | onWindowFocusChanged]getLocationOnScreen x = 0 y = 75\n可以看到返回的就是View左上角的坐标，一般情况下两者区别不重要，stackoverFlow上有[讨论](http://stackoverflow.com/questions/17672891/getlocationonscreen-vs-getlocationinwindow)\n\n```java\nView.getLocationInWindow(pos); //获取在当前window内的绝对坐标\nView.getLocationOnScreen(pos); //包括statusBar，以屏幕左上角为坐标原点\nView.getLocalVisibleRect()  \n//以view自身的左上角为坐标原点，这个很有用，\n//返回的坐标一定是(0,0,xxx,xxx)这样的，可以判断当前View是否完全可见\nView.getGlobalVisibleRect()  // 以屏幕左上角为坐标原点\n```\n以上四个方法在onCreate里面返回的值都是0，需要在Activity的onWindowFocusChanged(true)中去获得\n这里需要扯一点关于window的问题，根据大部分博客的介绍：DecorView是FrameLayout的子类，是View视图层级树的根节点。\n一般会有一个LinearLayout的child\n\n为此，我在setContentView里面放了一个CoordinateLayout,使用Hierarchy View截图的到这样的结果。\n图片有点大\n![](http://odzl05jxx.bkt.clouddn.com/view_hirearchy_1013.png)\n\n在ViewHirearchy中可以看到，Activity中View视图层级从上到下依次为：\n\n> PhoneWindow$DecorView（有三个child,分别是LinearLayout，View(id/statusBarBackground)和View(id/navigationBarBackground)）\n> LinearLayout\n> FrameLayout\n> FitWindowsLinearLayout\n> ContentFrameLayout(id/android.R.id.content) //这在开发过程中有时会用到\n> setContentView设置的view\n\n关于window，DecorWindow的文章网上有很多，仔细研究下会对理解View的测量机制有一定好处，这对于View的工作原理也能够更彻底的理解。\n[参考文章](http://blog.csdn.net/qibin0506/article/details/49245601)\n日常开发中，setContentView这个方法只是将我们自己写的activiy_main.xml布局文件inflate出来的view添加到\nandroid.R.id.content这个ViewGroup中，实践下来发现这是一个ContentFrameLayout的实例，它的child只有一个，就是我们通过setContentView添加的View\n\n### 5. 让View滑动起来\n> offsetLeftAndRight(int offset) //给left和right加上一个值，改变的是View的位置\n> offsetTopAndBottom(int offset) \n\n> scrollTo(int x,int y)  // 将View中的内容移动，坐标原点为parentView左上角，注意，参数为正，效果为反\n例如scrollTo(-100,0) 在手机上看效果是往右移动了\n\n> scrollBy(int x, int y)\n\nscrollBy的源码如下:\n```java\n  public void scrollBy(int x, int y) {\n        scrollTo(mScrollX + x, mScrollY + y);\n    }\n```\n还有一些不常用的：\n```java\npublic void setScrollX(int value) {\n        scrollTo(value, mScrollY);\n    }\n```\n\n### 6. 改变LayoutParams的margin让View移动\n这是一种很生硬的方式，不常用\n```java\nMarginLayoutParams params = (MarginLayoutParams)mTextView.getLayoutParams(); //可能为null\nparams.leftMargin + = 100;\nmTextView.setLayoutParams();// 这里面调用了requestLayout\n```\n\n\n### 7.使用Animation让View动起来\n根据官方文档的[定义](https://developer.android.com/guide/topics/graphics/overview.html)Android中一共两种Animation: \n> Property Animation\n> View Animation(包括Tween animation, Frame animation)\n\n首先从package的位置来看\n属性动画都位于android.animation这个package下面，常见的如ObjectAnimator继承自ValueAnimator\nView动画则位于android.view.animation这个package下，常见的如TranslateA,AlphaAnimation等\n\nView Animation可以代码创建，也可以写在R.anim文件夹下,用法很简单\n```java\nImageView image = (ImageView) findViewById(R.id.image);\nAnimation hyperspaceJump = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);\nimage.startAnimation(hyperspaceJump);\n```\n属性动画可以代码创建，也可以写在R.animator文件夹下,用法:\n```java\nAnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n    R.anim.property_animator);\nset.setTarget(myObject);\nset.start();\n```\n推荐使用ViewPropertyAnimator，这是一个位于android.view下面的class，感觉更像是一个Util,大部分的方法都是在API 12 ,API 14引入的，\n实际开发中推荐使用ViewCompat.animate() 返回一个ViewPropertyAnimator对象，省去了开发者版本判断的麻烦\n语法更为简单：\n```java\nViewCompat.animate(view).x(500).y(500).setDuration(5000).setInterpolator(new DecelaratorInterpolator());  //不需要调用start()\n```\n据说这种方式性能最好，Google官方强烈推荐,参考DevByte。\n另外，据说大部分Google的App使用的都是DecelaratorInterpolator，当然这跟设计有关。\n\n### 8.使用Scroller实现smoothScroll\nView有一个方法computeScroll(),复写，像这样就可以了\n```java\nScroller scroller = new Scroller(mContext);\n \n private void smoothScrollTo(int dstX, int dstY) {\n      int scrollX = getScrollX();\n      int delta = dstX - scrollX;\n      scroller.startScroll(scrollX, 0, delta, 0, 1000);\n      invalidate();\n }\n  \n @Override\n public void computeScroll() {\n     if (scroller.computeScrollOffset()) {\n         scrollTo(scroller.getCurrX(), scroller.getCurY());\n         postInvalidate();\n     }\n }\n```\n\n### 9. 补充几个好玩的函数\nView.canScrollVertically(int)\n```java\n public static boolean canChildScrollUp(View view) {\n        if (android.os.Build.VERSION.SDK_INT < 14) {\n            if (view instanceof AbsListView) {\n                final AbsListView absListView = (AbsListView) view;\n                return absListView.getChildCount() > 0\n                        && (absListView.getFirstVisiblePosition() > 0 || absListView.getChildAt(0)\n                        .getTop() < absListView.getPaddingTop());\n            } else {\n                return view.getScrollY() > 0;\n            }\n        } else {\n            return view.canScrollVertically(-1);\n        }\n    }\n```\n这段是我在秋百万的android-ultra-pulltorefresh里面找到的，想当初为了自己写下拉刷新，一遍一遍的打Log，最后甚至用上getVisibleRect才算搞定。\n其实很多东西前人已经帮我们整理好了。\n对了这东西在v4包里有ViewCompat.canScrollVertically，v4包除了方法数有点多(10k+好像)这点不好以外，一直都很好用\n附上supportLibrary各个包的方法数，如果对65536这个数字熟悉的话，还是会注意点的。\n![pic](http://odzl05jxx.bkt.clouddn.com/support_lib_methods_summary.jpg)\n\n\n\n### 总结\n- 使用getLocalVisibleRect可以判断一个view是否完全可见\n- scrollBy,setScrollX等内部都是调用了scrollTo方法，ScrollTo方法传参数与实际效果是相反的\n\n\n\n\n### Reference\n1. [Android应用坐标系统全面详解](http://blog.csdn.net/yanbober/article/details/50419117)\n2. ​[如何取得View的位置之View.getLocationInWindow()的小秘密](http://blog.csdn.net/imyfriend/article/details/8564781\n3. [详解实现Android中实现View滑动的几种方式](http://www.cnblogs.com/absfree/p/5352258.html)","slug":"2016-10-13-Android-coordinate-System","published":1,"updated":"2017-04-23T10:50:09.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnfb0001bovr110mk9q8","content":"<p>记录一些Android系统坐标系的常用方法，因为日常开发中难免会碰到需要单独计算View系统坐标的情况。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/minion.jpg?imageView2/2/w/400\" alt=\"\"><br><a id=\"more\"></a></p>\n<p>ScrollTo，ScrollBy，getVisibleRect这些方法平时想要用的时候总要去网上查找，这里记录下来，方便今后直接参考<br>首先是一张很多人都见过的图<br><img src=\"http://odzl05jxx.bkt.clouddn.com/android_screen_coordinate_system.png?imageView2/2/w/500\" alt=\"\"><br>中间的蓝色的点是TouchEvent发生时，获得的MotionEvent.getX()、getY()。</p>\n<h3 id=\"1-坐标原点和坐标轴方向\"><a href=\"#1-坐标原点和坐标轴方向\" class=\"headerlink\" title=\"1. 坐标原点和坐标轴方向\"></a>1. 坐标原点和坐标轴方向</h3><p>坐标原点有两种，屏幕左上角（statusBar也包含其中）和父控件左上角<br>坐标轴方向：X轴向右，Y轴向下，Z轴(5.0增加)向上。</p>\n<h3 id=\"2-Left-Top-Right-Bottom\"><a href=\"#2-Left-Top-Right-Bottom\" class=\"headerlink\" title=\"2. Left,Top,Right,Bottom\"></a>2. Left,Top,Right,Bottom</h3><p>而Top，left，bottom,down分别对应着其其相对于父控件的距离，由此可以计算得到View的宽度width = getRight()-getLeft() ,View的高度 height = getBottom()-getTop()<br>而实际上view.getHeight()方法的实现也就是mBottom-mTop.</p>\n<h3 id=\"3-X-Y\"><a href=\"#3-X-Y\" class=\"headerlink\" title=\"3. X , Y\"></a>3. X , Y</h3><p>X代表的是当前View的左上角那个点的横坐标，Y代表的是纵坐标。<br>X = left + getTranslationX<br>Y = Top + getTranslationY<br>通常在动画中使用setTranslationX来实现偏移效果，注意，这是不会改变left的。在滑动过程中，x, y会随着改变。</p>\n<h3 id=\"4-几个跟Rect相关的\"><a href=\"#4-几个跟Rect相关的\" class=\"headerlink\" title=\"4. 几个跟Rect相关的\"></a>4. 几个跟Rect相关的</h3><p>获得的是当前View左上角距离屏幕左上角的位置，为此我专门测试了一下</p>\n<blockquote>\n<p> W/ViewAnimationActivity.java: [32 | onWindowFocusChanged]statusBarHeight = 75<br> W/ViewAnimationActivity.java: [35 | onWindowFocusChanged]getLocationInWindow  x = 0 y = 75<br> W/ViewAnimationActivity.java: [38 | onWindowFocusChanged]getLocationOnScreen x = 0 y = 75<br>可以看到返回的就是View左上角的坐标，一般情况下两者区别不重要，stackoverFlow上有<a href=\"http://stackoverflow.com/questions/17672891/getlocationonscreen-vs-getlocationinwindow\">讨论</a></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">View.getLocationInWindow(pos); <span class=\"comment\">//获取在当前window内的绝对坐标</span></div><div class=\"line\">View.getLocationOnScreen(pos); <span class=\"comment\">//包括statusBar，以屏幕左上角为坐标原点</span></div><div class=\"line\">View.getLocalVisibleRect()  </div><div class=\"line\"><span class=\"comment\">//以view自身的左上角为坐标原点，这个很有用，</span></div><div class=\"line\"><span class=\"comment\">//返回的坐标一定是(0,0,xxx,xxx)这样的，可以判断当前View是否完全可见</span></div><div class=\"line\">View.getGlobalVisibleRect()  <span class=\"comment\">// 以屏幕左上角为坐标原点</span></div></pre></td></tr></table></figure>\n<p>以上四个方法在onCreate里面返回的值都是0，需要在Activity的onWindowFocusChanged(true)中去获得<br>这里需要扯一点关于window的问题，根据大部分博客的介绍：DecorView是FrameLayout的子类，是View视图层级树的根节点。<br>一般会有一个LinearLayout的child</p>\n<p>为此，我在setContentView里面放了一个CoordinateLayout,使用Hierarchy View截图的到这样的结果。<br>图片有点大<br><img src=\"http://odzl05jxx.bkt.clouddn.com/view_hirearchy_1013.png\" alt=\"\"></p>\n<p>在ViewHirearchy中可以看到，Activity中View视图层级从上到下依次为：</p>\n<blockquote>\n<p>PhoneWindow$DecorView（有三个child,分别是LinearLayout，View(id/statusBarBackground)和View(id/navigationBarBackground)）<br>LinearLayout<br>FrameLayout<br>FitWindowsLinearLayout<br>ContentFrameLayout(id/android.R.id.content) //这在开发过程中有时会用到<br>setContentView设置的view</p>\n</blockquote>\n<p>关于window，DecorWindow的文章网上有很多，仔细研究下会对理解View的测量机制有一定好处，这对于View的工作原理也能够更彻底的理解。<br><a href=\"http://blog.csdn.net/qibin0506/article/details/49245601\">参考文章</a><br>日常开发中，setContentView这个方法只是将我们自己写的activiy_main.xml布局文件inflate出来的view添加到<br>android.R.id.content这个ViewGroup中，实践下来发现这是一个ContentFrameLayout的实例，它的child只有一个，就是我们通过setContentView添加的View</p>\n<h3 id=\"5-让View滑动起来\"><a href=\"#5-让View滑动起来\" class=\"headerlink\" title=\"5. 让View滑动起来\"></a>5. 让View滑动起来</h3><blockquote>\n<p>offsetLeftAndRight(int offset) //给left和right加上一个值，改变的是View的位置<br>offsetTopAndBottom(int offset) </p>\n<p>scrollTo(int x,int y)  // 将View中的内容移动，坐标原点为parentView左上角，注意，参数为正，效果为反<br>例如scrollTo(-100,0) 在手机上看效果是往右移动了</p>\n<p>scrollBy(int x, int y)</p>\n</blockquote>\n<p>scrollBy的源码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scrollBy</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">      scrollTo(mScrollX + x, mScrollY + y);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>还有一些不常用的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScrollX</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">        scrollTo(value, mScrollY);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"6-改变LayoutParams的margin让View移动\"><a href=\"#6-改变LayoutParams的margin让View移动\" class=\"headerlink\" title=\"6. 改变LayoutParams的margin让View移动\"></a>6. 改变LayoutParams的margin让View移动</h3><p>这是一种很生硬的方式，不常用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MarginLayoutParams params = (MarginLayoutParams)mTextView.getLayoutParams(); <span class=\"comment\">//可能为null</span></div><div class=\"line\">params.leftMargin + = <span class=\"number\">100</span>;</div><div class=\"line\">mTextView.setLayoutParams();<span class=\"comment\">// 这里面调用了requestLayout</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"7-使用Animation让View动起来\"><a href=\"#7-使用Animation让View动起来\" class=\"headerlink\" title=\"7.使用Animation让View动起来\"></a>7.使用Animation让View动起来</h3><p>根据官方文档的<a href=\"https://developer.android.com/guide/topics/graphics/overview.html\">定义</a>Android中一共两种Animation: </p>\n<blockquote>\n<p>Property Animation<br>View Animation(包括Tween animation, Frame animation)</p>\n</blockquote>\n<p>首先从package的位置来看<br>属性动画都位于android.animation这个package下面，常见的如ObjectAnimator继承自ValueAnimator<br>View动画则位于android.view.animation这个package下，常见的如TranslateA,AlphaAnimation等</p>\n<p>View Animation可以代码创建，也可以写在R.anim文件夹下,用法很简单<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageView image = (ImageView) findViewById(R.id.image);</div><div class=\"line\">Animation hyperspaceJump = AnimationUtils.loadAnimation(<span class=\"keyword\">this</span>, R.anim.hyperspace_jump);</div><div class=\"line\">image.startAnimation(hyperspaceJump);</div></pre></td></tr></table></figure></p>\n<p>属性动画可以代码创建，也可以写在R.animator文件夹下,用法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,</div><div class=\"line\">    R.anim.property_animator);</div><div class=\"line\">set.setTarget(myObject);</div><div class=\"line\">set.start();</div></pre></td></tr></table></figure></p>\n<p>推荐使用ViewPropertyAnimator，这是一个位于android.view下面的class，感觉更像是一个Util,大部分的方法都是在API 12 ,API 14引入的，<br>实际开发中推荐使用ViewCompat.animate() 返回一个ViewPropertyAnimator对象，省去了开发者版本判断的麻烦<br>语法更为简单：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ViewCompat.animate(view).x(<span class=\"number\">500</span>).y(<span class=\"number\">500</span>).setDuration(<span class=\"number\">5000</span>).setInterpolator(<span class=\"keyword\">new</span> DecelaratorInterpolator());  <span class=\"comment\">//不需要调用start()</span></div></pre></td></tr></table></figure></p>\n<p>据说这种方式性能最好，Google官方强烈推荐,参考DevByte。<br>另外，据说大部分Google的App使用的都是DecelaratorInterpolator，当然这跟设计有关。</p>\n<h3 id=\"8-使用Scroller实现smoothScroll\"><a href=\"#8-使用Scroller实现smoothScroll\" class=\"headerlink\" title=\"8.使用Scroller实现smoothScroll\"></a>8.使用Scroller实现smoothScroll</h3><p>View有一个方法computeScroll(),复写，像这样就可以了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scroller scroller = <span class=\"keyword\">new</span> Scroller(mContext);</div><div class=\"line\"> </div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">smoothScrollTo</span><span class=\"params\">(<span class=\"keyword\">int</span> dstX, <span class=\"keyword\">int</span> dstY)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> scrollX = getScrollX();</div><div class=\"line\">      <span class=\"keyword\">int</span> delta = dstX - scrollX;</div><div class=\"line\">      scroller.startScroll(scrollX, <span class=\"number\">0</span>, delta, <span class=\"number\">0</span>, <span class=\"number\">1000</span>);</div><div class=\"line\">      invalidate();</div><div class=\"line\"> &#125;</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (scroller.computeScrollOffset()) &#123;</div><div class=\"line\">         scrollTo(scroller.getCurrX(), scroller.getCurY());</div><div class=\"line\">         postInvalidate();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"9-补充几个好玩的函数\"><a href=\"#9-补充几个好玩的函数\" class=\"headerlink\" title=\"9. 补充几个好玩的函数\"></a>9. 补充几个好玩的函数</h3><p>View.canScrollVertically(int)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canChildScrollUp</span><span class=\"params\">(View view)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class=\"number\">14</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> AbsListView) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> AbsListView absListView = (AbsListView) view;</div><div class=\"line\">               <span class=\"keyword\">return</span> absListView.getChildCount() &gt; <span class=\"number\">0</span></div><div class=\"line\">                       &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class=\"number\">0</span> || absListView.getChildAt(<span class=\"number\">0</span>)</div><div class=\"line\">                       .getTop() &lt; absListView.getPaddingTop());</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               <span class=\"keyword\">return</span> view.getScrollY() &gt; <span class=\"number\">0</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> view.canScrollVertically(-<span class=\"number\">1</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这段是我在秋百万的android-ultra-pulltorefresh里面找到的，想当初为了自己写下拉刷新，一遍一遍的打Log，最后甚至用上getVisibleRect才算搞定。<br>其实很多东西前人已经帮我们整理好了。<br>对了这东西在v4包里有ViewCompat.canScrollVertically，v4包除了方法数有点多(10k+好像)这点不好以外，一直都很好用<br>附上supportLibrary各个包的方法数，如果对65536这个数字熟悉的话，还是会注意点的。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/support_lib_methods_summary.jpg\" alt=\"pic\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>使用getLocalVisibleRect可以判断一个view是否完全可见</li>\n<li>scrollBy,setScrollX等内部都是调用了scrollTo方法，ScrollTo方法传参数与实际效果是相反的</li>\n</ul>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://blog.csdn.net/yanbober/article/details/50419117\">Android应用坐标系统全面详解</a></li>\n<li>​[如何取得View的位置之View.getLocationInWindow()的小秘密](<a href=\"http://blog.csdn.net/imyfriend/article/details/8564781\">http://blog.csdn.net/imyfriend/article/details/8564781</a></li>\n<li><a href=\"http://www.cnblogs.com/absfree/p/5352258.html\">详解实现Android中实现View滑动的几种方式</a></li>\n</ol>\n","excerpt":"<p>记录一些Android系统坐标系的常用方法，因为日常开发中难免会碰到需要单独计算View系统坐标的情况。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/minion.jpg?imageView2/2/w/400\" alt=\"\"><br>","more":"</p>\n<p>ScrollTo，ScrollBy，getVisibleRect这些方法平时想要用的时候总要去网上查找，这里记录下来，方便今后直接参考<br>首先是一张很多人都见过的图<br><img src=\"http://odzl05jxx.bkt.clouddn.com/android_screen_coordinate_system.png?imageView2/2/w/500\" alt=\"\"><br>中间的蓝色的点是TouchEvent发生时，获得的MotionEvent.getX()、getY()。</p>\n<h3 id=\"1-坐标原点和坐标轴方向\"><a href=\"#1-坐标原点和坐标轴方向\" class=\"headerlink\" title=\"1. 坐标原点和坐标轴方向\"></a>1. 坐标原点和坐标轴方向</h3><p>坐标原点有两种，屏幕左上角（statusBar也包含其中）和父控件左上角<br>坐标轴方向：X轴向右，Y轴向下，Z轴(5.0增加)向上。</p>\n<h3 id=\"2-Left-Top-Right-Bottom\"><a href=\"#2-Left-Top-Right-Bottom\" class=\"headerlink\" title=\"2. Left,Top,Right,Bottom\"></a>2. Left,Top,Right,Bottom</h3><p>而Top，left，bottom,down分别对应着其其相对于父控件的距离，由此可以计算得到View的宽度width = getRight()-getLeft() ,View的高度 height = getBottom()-getTop()<br>而实际上view.getHeight()方法的实现也就是mBottom-mTop.</p>\n<h3 id=\"3-X-Y\"><a href=\"#3-X-Y\" class=\"headerlink\" title=\"3. X , Y\"></a>3. X , Y</h3><p>X代表的是当前View的左上角那个点的横坐标，Y代表的是纵坐标。<br>X = left + getTranslationX<br>Y = Top + getTranslationY<br>通常在动画中使用setTranslationX来实现偏移效果，注意，这是不会改变left的。在滑动过程中，x, y会随着改变。</p>\n<h3 id=\"4-几个跟Rect相关的\"><a href=\"#4-几个跟Rect相关的\" class=\"headerlink\" title=\"4. 几个跟Rect相关的\"></a>4. 几个跟Rect相关的</h3><p>获得的是当前View左上角距离屏幕左上角的位置，为此我专门测试了一下</p>\n<blockquote>\n<p> W/ViewAnimationActivity.java: [32 | onWindowFocusChanged]statusBarHeight = 75<br> W/ViewAnimationActivity.java: [35 | onWindowFocusChanged]getLocationInWindow  x = 0 y = 75<br> W/ViewAnimationActivity.java: [38 | onWindowFocusChanged]getLocationOnScreen x = 0 y = 75<br>可以看到返回的就是View左上角的坐标，一般情况下两者区别不重要，stackoverFlow上有<a href=\"http://stackoverflow.com/questions/17672891/getlocationonscreen-vs-getlocationinwindow\">讨论</a></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">View.getLocationInWindow(pos); <span class=\"comment\">//获取在当前window内的绝对坐标</span></div><div class=\"line\">View.getLocationOnScreen(pos); <span class=\"comment\">//包括statusBar，以屏幕左上角为坐标原点</span></div><div class=\"line\">View.getLocalVisibleRect()  </div><div class=\"line\"><span class=\"comment\">//以view自身的左上角为坐标原点，这个很有用，</span></div><div class=\"line\"><span class=\"comment\">//返回的坐标一定是(0,0,xxx,xxx)这样的，可以判断当前View是否完全可见</span></div><div class=\"line\">View.getGlobalVisibleRect()  <span class=\"comment\">// 以屏幕左上角为坐标原点</span></div></pre></td></tr></table></figure>\n<p>以上四个方法在onCreate里面返回的值都是0，需要在Activity的onWindowFocusChanged(true)中去获得<br>这里需要扯一点关于window的问题，根据大部分博客的介绍：DecorView是FrameLayout的子类，是View视图层级树的根节点。<br>一般会有一个LinearLayout的child</p>\n<p>为此，我在setContentView里面放了一个CoordinateLayout,使用Hierarchy View截图的到这样的结果。<br>图片有点大<br><img src=\"http://odzl05jxx.bkt.clouddn.com/view_hirearchy_1013.png\" alt=\"\"></p>\n<p>在ViewHirearchy中可以看到，Activity中View视图层级从上到下依次为：</p>\n<blockquote>\n<p>PhoneWindow$DecorView（有三个child,分别是LinearLayout，View(id/statusBarBackground)和View(id/navigationBarBackground)）<br>LinearLayout<br>FrameLayout<br>FitWindowsLinearLayout<br>ContentFrameLayout(id/android.R.id.content) //这在开发过程中有时会用到<br>setContentView设置的view</p>\n</blockquote>\n<p>关于window，DecorWindow的文章网上有很多，仔细研究下会对理解View的测量机制有一定好处，这对于View的工作原理也能够更彻底的理解。<br><a href=\"http://blog.csdn.net/qibin0506/article/details/49245601\">参考文章</a><br>日常开发中，setContentView这个方法只是将我们自己写的activiy_main.xml布局文件inflate出来的view添加到<br>android.R.id.content这个ViewGroup中，实践下来发现这是一个ContentFrameLayout的实例，它的child只有一个，就是我们通过setContentView添加的View</p>\n<h3 id=\"5-让View滑动起来\"><a href=\"#5-让View滑动起来\" class=\"headerlink\" title=\"5. 让View滑动起来\"></a>5. 让View滑动起来</h3><blockquote>\n<p>offsetLeftAndRight(int offset) //给left和right加上一个值，改变的是View的位置<br>offsetTopAndBottom(int offset) </p>\n<p>scrollTo(int x,int y)  // 将View中的内容移动，坐标原点为parentView左上角，注意，参数为正，效果为反<br>例如scrollTo(-100,0) 在手机上看效果是往右移动了</p>\n<p>scrollBy(int x, int y)</p>\n</blockquote>\n<p>scrollBy的源码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scrollBy</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">      scrollTo(mScrollX + x, mScrollY + y);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>还有一些不常用的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScrollX</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">        scrollTo(value, mScrollY);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"6-改变LayoutParams的margin让View移动\"><a href=\"#6-改变LayoutParams的margin让View移动\" class=\"headerlink\" title=\"6. 改变LayoutParams的margin让View移动\"></a>6. 改变LayoutParams的margin让View移动</h3><p>这是一种很生硬的方式，不常用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MarginLayoutParams params = (MarginLayoutParams)mTextView.getLayoutParams(); <span class=\"comment\">//可能为null</span></div><div class=\"line\">params.leftMargin + = <span class=\"number\">100</span>;</div><div class=\"line\">mTextView.setLayoutParams();<span class=\"comment\">// 这里面调用了requestLayout</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"7-使用Animation让View动起来\"><a href=\"#7-使用Animation让View动起来\" class=\"headerlink\" title=\"7.使用Animation让View动起来\"></a>7.使用Animation让View动起来</h3><p>根据官方文档的<a href=\"https://developer.android.com/guide/topics/graphics/overview.html\">定义</a>Android中一共两种Animation: </p>\n<blockquote>\n<p>Property Animation<br>View Animation(包括Tween animation, Frame animation)</p>\n</blockquote>\n<p>首先从package的位置来看<br>属性动画都位于android.animation这个package下面，常见的如ObjectAnimator继承自ValueAnimator<br>View动画则位于android.view.animation这个package下，常见的如TranslateA,AlphaAnimation等</p>\n<p>View Animation可以代码创建，也可以写在R.anim文件夹下,用法很简单<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageView image = (ImageView) findViewById(R.id.image);</div><div class=\"line\">Animation hyperspaceJump = AnimationUtils.loadAnimation(<span class=\"keyword\">this</span>, R.anim.hyperspace_jump);</div><div class=\"line\">image.startAnimation(hyperspaceJump);</div></pre></td></tr></table></figure></p>\n<p>属性动画可以代码创建，也可以写在R.animator文件夹下,用法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,</div><div class=\"line\">    R.anim.property_animator);</div><div class=\"line\">set.setTarget(myObject);</div><div class=\"line\">set.start();</div></pre></td></tr></table></figure></p>\n<p>推荐使用ViewPropertyAnimator，这是一个位于android.view下面的class，感觉更像是一个Util,大部分的方法都是在API 12 ,API 14引入的，<br>实际开发中推荐使用ViewCompat.animate() 返回一个ViewPropertyAnimator对象，省去了开发者版本判断的麻烦<br>语法更为简单：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ViewCompat.animate(view).x(<span class=\"number\">500</span>).y(<span class=\"number\">500</span>).setDuration(<span class=\"number\">5000</span>).setInterpolator(<span class=\"keyword\">new</span> DecelaratorInterpolator());  <span class=\"comment\">//不需要调用start()</span></div></pre></td></tr></table></figure></p>\n<p>据说这种方式性能最好，Google官方强烈推荐,参考DevByte。<br>另外，据说大部分Google的App使用的都是DecelaratorInterpolator，当然这跟设计有关。</p>\n<h3 id=\"8-使用Scroller实现smoothScroll\"><a href=\"#8-使用Scroller实现smoothScroll\" class=\"headerlink\" title=\"8.使用Scroller实现smoothScroll\"></a>8.使用Scroller实现smoothScroll</h3><p>View有一个方法computeScroll(),复写，像这样就可以了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scroller scroller = <span class=\"keyword\">new</span> Scroller(mContext);</div><div class=\"line\"> </div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">smoothScrollTo</span><span class=\"params\">(<span class=\"keyword\">int</span> dstX, <span class=\"keyword\">int</span> dstY)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> scrollX = getScrollX();</div><div class=\"line\">      <span class=\"keyword\">int</span> delta = dstX - scrollX;</div><div class=\"line\">      scroller.startScroll(scrollX, <span class=\"number\">0</span>, delta, <span class=\"number\">0</span>, <span class=\"number\">1000</span>);</div><div class=\"line\">      invalidate();</div><div class=\"line\"> &#125;</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (scroller.computeScrollOffset()) &#123;</div><div class=\"line\">         scrollTo(scroller.getCurrX(), scroller.getCurY());</div><div class=\"line\">         postInvalidate();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"9-补充几个好玩的函数\"><a href=\"#9-补充几个好玩的函数\" class=\"headerlink\" title=\"9. 补充几个好玩的函数\"></a>9. 补充几个好玩的函数</h3><p>View.canScrollVertically(int)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canChildScrollUp</span><span class=\"params\">(View view)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class=\"number\">14</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (view <span class=\"keyword\">instanceof</span> AbsListView) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> AbsListView absListView = (AbsListView) view;</div><div class=\"line\">               <span class=\"keyword\">return</span> absListView.getChildCount() &gt; <span class=\"number\">0</span></div><div class=\"line\">                       &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class=\"number\">0</span> || absListView.getChildAt(<span class=\"number\">0</span>)</div><div class=\"line\">                       .getTop() &lt; absListView.getPaddingTop());</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               <span class=\"keyword\">return</span> view.getScrollY() &gt; <span class=\"number\">0</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> view.canScrollVertically(-<span class=\"number\">1</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这段是我在秋百万的android-ultra-pulltorefresh里面找到的，想当初为了自己写下拉刷新，一遍一遍的打Log，最后甚至用上getVisibleRect才算搞定。<br>其实很多东西前人已经帮我们整理好了。<br>对了这东西在v4包里有ViewCompat.canScrollVertically，v4包除了方法数有点多(10k+好像)这点不好以外，一直都很好用<br>附上supportLibrary各个包的方法数，如果对65536这个数字熟悉的话，还是会注意点的。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/support_lib_methods_summary.jpg\" alt=\"pic\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>使用getLocalVisibleRect可以判断一个view是否完全可见</li>\n<li>scrollBy,setScrollX等内部都是调用了scrollTo方法，ScrollTo方法传参数与实际效果是相反的</li>\n</ul>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://blog.csdn.net/yanbober/article/details/50419117\">Android应用坐标系统全面详解</a></li>\n<li>​[如何取得View的位置之View.getLocationInWindow()的小秘密](<a href=\"http://blog.csdn.net/imyfriend/article/details/8564781\">http://blog.csdn.net/imyfriend/article/details/8564781</a></li>\n<li><a href=\"http://www.cnblogs.com/absfree/p/5352258.html\">详解实现Android中实现View滑动的几种方式</a></li>\n</ol>"},{"title":"fitSystemWindow和沉浸式状态栏的一些总结","date":"2016-10-14T09:15:47.000Z","_content":"沉浸式状态栏是api 19之后引入的，KitKat应该算是一次比较大的更新了，像是Transition，art runtime,storage access FrameWork(这个有空研究下)，另外就是这个被官方称为Full-screen immersive mode的特性了。具体来说，App可以将展示的区域拓展到statusBar的位置了。我觉得直接叫statusBar就好了，大部分人应该也能理解这就是手机上显示\"中国移动\"还有显示手机电量那一块的长条，宽度是match_parent。高度的话，据说是25dp，然后6.0上给改成了24dp。不过这不是重点<!--more-->\n\n### 1.最初的做法\n看到有人推荐使用[SystemBarTint](https://github.com/jgilfelt/SystemBarTint)这个class,刚上来觉得也挺好用的，就是一个java class，直接复制粘贴到项目里，改一下package name，无脑使用即可。原理的话，看过源码后，大致明白是在statusBar的位置添加一个new View，然后持有这个view的引用，接下来就可以做常规的setBackground或者setBackgroundColor了。初始化时的关键代码如下\n```java\nprivate void setupStatusBarView(Context context, ViewGroup decorViewGroup) {//这个decorViewGroup指的是activity.getWindow()\n        mStatusBarTintView = new View(context);\n        LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, mConfig.getStatusBarHeight());\n        params.gravity = Gravity.TOP;\n        if (mNavBarAvailable && !mConfig.isNavigationAtBottom()) {\n            params.rightMargin = mConfig.getNavigationBarWidth();\n        }\n        mStatusBarTintView.setLayoutParams(params);\n        mStatusBarTintView.setBackgroundColor(DEFAULT_TINT_COLOR);\n        mStatusBarTintView.setVisibility(View.GONE);\n        decorViewGroup.addView(mStatusBarTintView);\n    }\n```\n一切看起来都很美好\n\n### 2. 直到碰到了fitSystemWindow = ture\n几个月前曾经在项目里写过一个普通的Coordinatelayout内部CollapingToolbarLayout的沉浸式状态栏实现，当时为了赶进度一直试到夜里2点才尝试出在4.4和5.0以上手机都能满意的效果。现在想想有些事还是能够事先搞清楚的好，被动学习的代价实在太大。当时的方法是给Toolbar添加了一个顶部的padding，具体原理也不大清楚。\n但实际上并不总能一直</br>  \n  ![trying stuff utill it work](http://odzl05jxx.bkt.clouddn.com/Trying%20stuff%20Untill%20it%20work.jpg?imageView2/2/w/600)\n\n### 3. 使用CollapsingToolbarLayout时的问题\n1. 5.0以上的手机似乎很简单\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <android.support.design.widget.CoordinatorLayout\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        android:id=\"@+id/coordinateLayout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:background=\"@android:color/background_light\"\n        android:fitsSystemWindows=\"true\"\n        >\n\n        <android.support.design.widget.AppBarLayout\n            android:id=\"@+id/appbarLayout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"300dp\"\n            android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"\n            android:fitsSystemWindows=\"true\"\n            >\n\n            <android.support.design.widget.CollapsingToolbarLayout\n                android:id=\"@+id/collapsingToolbarLayout\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                app:contentScrim=\"?attr/colorPrimary\"\n                app:expandedTitleMarginEnd=\"64dp\"\n                app:expandedTitleMarginStart=\"48dp\"\n                app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"\n                >\n\n                <ImageView\n                    android:id=\"@+id/backdrop\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:scaleType=\"centerCrop\"\n                    android:src=\"@drawable/image_19\"\n                    app:layout_collapseMode=\"parallax\"\n                    android:fitsSystemWindows=\"true\"\n                    />\n\n                <android.support.v7.widget.Toolbar\n                    android:id=\"@+id/toolbar\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"?attr/actionBarSize\"\n                    app:layout_collapseMode=\"pin\"\n                    app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"\n                    />\n            </android.support.design.widget.CollapsingToolbarLayout>\n        </android.support.design.widget.AppBarLayout>\n\n        <android.support.v4.widget.NestedScrollView\n            android:id=\"@+id/nestedScrollView\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"\n            >\n\n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:lineSpacingExtra=\"8dp\"\n                android:padding=\"@dimen/activity_horizontal_margin\"\n                android:text=\"@string/newsBody\"\n                android:textSize=\"20sp\"\n                />\n        </android.support.v4.widget.NestedScrollView>\n\n        <android.support.design.widget.FloatingActionButton\n            android:id=\"@+id/fab\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_margin=\"@dimen/activity_horizontal_margin\"\n            android:src=\"@android:drawable/ic_menu_slideshow\"\n            app:layout_anchor=\"@id/appbarLayout\"\n            app:layout_anchorGravity=\"bottom|right|end\"\n            />\n    </android.support.design.widget.CoordinatorLayout>\n```\n只要分别在CoordinateLayout，AppBarLayout和CollapsingToolbarLayout的xml属性中加上android:fitSystemWindow = \"true\"\njava代码里添加一句\n> getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); //注意下版本判断\n\n或者在当前Activity的values-v19 styles中添加 <item name=\"android:windowTranslucentStatus\">true</item>\n就行了。实际效果就是图片完全展开时可以扩展到statusBar下面，图片收缩起来后可以让Toolbar停在statusBar下面。但同样的代码在4.4的手机上会使得实际绘图区域落到statusBar以下，statusBar位置变成带灰色遮罩的白色背景。\n\n### 4. fitSystemWindow是什么意思\nfitSystemWindows属性： \n官方描述: \nBoolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity. \n简单来说就是如果设置为true,机会根据statusbar来添加一个padding.\n假定:\n布局文件只是一个普通的LinearLayout(fitSystemWindow = false（默认情况）),顶部include一个toolbar(fitSystemWindow = true )\n就已经可以实现4.4以下，4.4-5.0，5.0以上的各种场景了,(前提，使用Appcompat 的Theme，因为它会使用colorPrimaryDark为statusBar着色)\n\n但我的问题在于布局文件是\nCoordinateLayout>  AppBarLyout>  CollapsingToolbarLayout>  Toolbar & ImageView\n这种情况下，照理说Toolbar应该顶部留有25dp的padding，也就是fitSystemWindow = true（假设就只是这么简单）[然而事实是，fitSystemWindow会让你设置的padding失效](https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec#.vx75v2c9p),而ImageView需要侵入到statusBar下面，也就是fitSystemWindow = false。\n那就只要在toolbar的xml中添加fitSystemWindow这个属性好了。编译，运行，5.1手机，Toolbar的小箭头一部分跑到statusBar下面了，感觉就像Toolbar往上移动了25dp(这个目测的哈)，不可取。\n\n### 5. 查找到的一些解决方案\n 主要介绍原理了:\n\n 1. 类似于SystemBarTint，在android.R.id.content的View中添加一个 View\n ```java\n ViewGroup.LayoutParams statusViewLp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                    getStatusBarHeight());\ncontentView.addView(statusBarView,layoutParams)\n ```\n Activity持有一个PhoneWindow，PhoneWindow持有一个根View，叫DecorView（是一个FrameLayout），DecorView持有一个LinearLayout，在LinearLayout下分配两个FrameLayout，一个给ActionBar（当设置主题为NoActionBar是为ViewStub），一个给ContentView。不管如何，只要我们在LinearLayout的第一个位置插入一个View就可以让ContentView下移了。[简书作者](http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&utm_medium=referral)\n 这种方式其实已经无所谓是否需要在xml中fitSystemWindow了，因为都会通过添加最后一个View的方式把状态栏那块给遮住了。用来着色其实挺好的。\n\n\n2. 往android.R.id.content这个View里面添加一个假View,xml中fitSystemWindows\n\n3. 往android.R.id.content这个View的parent里面添加一个假View,xml中fitSystemWindows\n\n\n### 6.我最后实现的解决方案（4.4,5.1均通过）\n**其实整个问题的关键就是你是否想要在statusBar那一块长条的位置画画。。。。**\n一整张imageView的话，当然希望能够把图片延伸到statusBar以下\n而Toolbar则不需要延伸到statusBar以下。\n我尝试了给toolbar加上padding  >>失败\n我尝试了给toolbar加上margin   >>>> 问题终于解决\n\n所以最后，我的xml文件中删除了所有的fitSystemWindow，在style-v19中添加了该加的东西\n最后只在onCreate里面添加几段话\n```java\nsetSupportActionBar(binding.toolbar);\ngetSupportActionBar().setDisplayHomeAsUpEnabled(true);  //这个用于显示返回的小箭头，还得指明parentActivity\ngetSupportActionBar().setTitle(\"\");\nCollapsingToolbarLayout.LayoutParams params = (CollapsingToolbarLayout.LayoutParams) binding.toolbar.getLayoutParams();\nparams.setMargins(0, Utils.getStatusBarHeight(), 0, 0); //顶部加个margin就好了\nbinding.toolbar.setLayoutParams(params);\n```\n实际操作可能还要判断非空什么的，但大致意思如此\n看起来像这样\n5.1图片展开:  \n  ![5.1模拟器，图片展开](http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_expanded.png?imageView2/2/w/300)  \n\n5.1图片收起:  \n  ![5.1模拟器，图片收起](http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_collapsed.png?imageView2/2/w/300)  \n\n4.4图片展开:  \n  ![4.4模拟器，图片展开](http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_expanded.png?imageView2/2/w/300)  \n\n4.4图片收起:\n  ![4.4模拟器，图片收起](http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_collapsed.png?imageView2/2/w/300)  \n\n\n原理就是让整个布局占据statusBar的位置，但把Toolbar往下挪一点（其实也就是[这篇文章](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html)中所推荐的给contentView的给第一个childView添加marginTop的方法）\n\n\n### 7.在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪.\n自己测试了一下，在根布局里添加fitSystemWindows = true之后，在Activity的onCreate里面是可以使用ViewCompat.setfitSystems(rootView,false)设置起作用的。但也只限于onCreate的时候。例如添加一个点击事件，在onClick里面setFitSystemWindows，是不会把RootView往下挪的。这种情况就需要一开始就确保fitSystem = false，然后需要往下挪的时候，给设置一个FrameLayout.LayoutParams的TopMargin就可以了。注意来回切换(全屏模式和着色模式之间切换)的时候要看下rootView的getTop,因为MarginTop设置了之后会导致Top!=0。\n其实fitSystemWindows是在FitSystemWindowLinearLayout中添加Padding起效的，后期操作的Margin只是对其Child ContentFrameLayout进行操作。\n所以，这种情况下我觉得直接全部弄成fitSystemWindows = false，先把statusBar后面的空间占据了再说，后面再通过手动设置Margin上下挪动。\n\n\n\n\n### 8. 一些不要犯的小错误\n- 在Theme中添加\n```xml\n<item name=\"android:fitsSystemWindows\">true</item>\n```\n这会导致Toast的文字往上偏移，所以，如果需要使用fitSystemWinow = true的话，请老老实实去xml中写\n\n- 状态栏那一块如果你不去占据的话，而你又声明了windowTranslucentStatus，v21上默认的颜色应该是colorPrimaryDark(是的，AppCompat帮你照顾好了)v19上就是一片带阴影的白色(AppCompat不会在这个版本上帮你着色statusBar)。\n\n- 6.0以上可以设置statusBar字体的颜色了，这个随便找找就有了\n\n- Ian Lake在medium上给出了对于fitSystemWindow的权威解释，非常有价值。\n\n\n### 9. 下面这段话可能对于理解window有一定帮助\nfitsSystemWindows, 该属性可以设置是否为系统 View 预留出空间, 当设置为 true 时,会预留出状态栏的空间.\nContentView, 实质为 ContentFrameLayout, 但是重写了 dispatchFitSystemWindows 方法, 所以对其设置 fitsSystemWindows 无效.\nContentParent, 实质为 FitWindowsLinearLayout, 里面第一个 View 是 ViewStubCompat, 如果主题没有设置 title ,它就不会 inflate .第二个 View 就是 ContentView.\n另外，如果使用AppCompat，在api21以上，会自动将状态栏颜色设置为colorPrimaryDark。\n最后感谢网上各位博主不辞辛苦写出来的干货，让我能够比较简单的复制粘贴他们的代码来检验，写博客真的很累。\n\n### Reference\n1. [Android-transulcent-status-bar总结](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html)\n2. [由沉浸式状态栏引发的血案](http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&utm_medium=referral)\n3. [Android开发：Translucent System Bar 的最佳实践](http://www.jianshu.com/p/0acc12c29c1b)\n4. [Why would I want to fitsSystemWindows](https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec)","source":"_posts/2016-10-14-Android-translucent-status-bar.md","raw":"---\ntitle: fitSystemWindow和沉浸式状态栏的一些总结\ndate: 2016-10-14 17:15:47\ncategories: blog\ntags: [android,Window,statusBar]\n---\n沉浸式状态栏是api 19之后引入的，KitKat应该算是一次比较大的更新了，像是Transition，art runtime,storage access FrameWork(这个有空研究下)，另外就是这个被官方称为Full-screen immersive mode的特性了。具体来说，App可以将展示的区域拓展到statusBar的位置了。我觉得直接叫statusBar就好了，大部分人应该也能理解这就是手机上显示\"中国移动\"还有显示手机电量那一块的长条，宽度是match_parent。高度的话，据说是25dp，然后6.0上给改成了24dp。不过这不是重点<!--more-->\n\n### 1.最初的做法\n看到有人推荐使用[SystemBarTint](https://github.com/jgilfelt/SystemBarTint)这个class,刚上来觉得也挺好用的，就是一个java class，直接复制粘贴到项目里，改一下package name，无脑使用即可。原理的话，看过源码后，大致明白是在statusBar的位置添加一个new View，然后持有这个view的引用，接下来就可以做常规的setBackground或者setBackgroundColor了。初始化时的关键代码如下\n```java\nprivate void setupStatusBarView(Context context, ViewGroup decorViewGroup) {//这个decorViewGroup指的是activity.getWindow()\n        mStatusBarTintView = new View(context);\n        LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, mConfig.getStatusBarHeight());\n        params.gravity = Gravity.TOP;\n        if (mNavBarAvailable && !mConfig.isNavigationAtBottom()) {\n            params.rightMargin = mConfig.getNavigationBarWidth();\n        }\n        mStatusBarTintView.setLayoutParams(params);\n        mStatusBarTintView.setBackgroundColor(DEFAULT_TINT_COLOR);\n        mStatusBarTintView.setVisibility(View.GONE);\n        decorViewGroup.addView(mStatusBarTintView);\n    }\n```\n一切看起来都很美好\n\n### 2. 直到碰到了fitSystemWindow = ture\n几个月前曾经在项目里写过一个普通的Coordinatelayout内部CollapingToolbarLayout的沉浸式状态栏实现，当时为了赶进度一直试到夜里2点才尝试出在4.4和5.0以上手机都能满意的效果。现在想想有些事还是能够事先搞清楚的好，被动学习的代价实在太大。当时的方法是给Toolbar添加了一个顶部的padding，具体原理也不大清楚。\n但实际上并不总能一直</br>  \n  ![trying stuff utill it work](http://odzl05jxx.bkt.clouddn.com/Trying%20stuff%20Untill%20it%20work.jpg?imageView2/2/w/600)\n\n### 3. 使用CollapsingToolbarLayout时的问题\n1. 5.0以上的手机似乎很简单\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <android.support.design.widget.CoordinatorLayout\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        android:id=\"@+id/coordinateLayout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:background=\"@android:color/background_light\"\n        android:fitsSystemWindows=\"true\"\n        >\n\n        <android.support.design.widget.AppBarLayout\n            android:id=\"@+id/appbarLayout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"300dp\"\n            android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"\n            android:fitsSystemWindows=\"true\"\n            >\n\n            <android.support.design.widget.CollapsingToolbarLayout\n                android:id=\"@+id/collapsingToolbarLayout\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                app:contentScrim=\"?attr/colorPrimary\"\n                app:expandedTitleMarginEnd=\"64dp\"\n                app:expandedTitleMarginStart=\"48dp\"\n                app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"\n                >\n\n                <ImageView\n                    android:id=\"@+id/backdrop\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:scaleType=\"centerCrop\"\n                    android:src=\"@drawable/image_19\"\n                    app:layout_collapseMode=\"parallax\"\n                    android:fitsSystemWindows=\"true\"\n                    />\n\n                <android.support.v7.widget.Toolbar\n                    android:id=\"@+id/toolbar\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"?attr/actionBarSize\"\n                    app:layout_collapseMode=\"pin\"\n                    app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"\n                    />\n            </android.support.design.widget.CollapsingToolbarLayout>\n        </android.support.design.widget.AppBarLayout>\n\n        <android.support.v4.widget.NestedScrollView\n            android:id=\"@+id/nestedScrollView\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"\n            >\n\n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:lineSpacingExtra=\"8dp\"\n                android:padding=\"@dimen/activity_horizontal_margin\"\n                android:text=\"@string/newsBody\"\n                android:textSize=\"20sp\"\n                />\n        </android.support.v4.widget.NestedScrollView>\n\n        <android.support.design.widget.FloatingActionButton\n            android:id=\"@+id/fab\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_margin=\"@dimen/activity_horizontal_margin\"\n            android:src=\"@android:drawable/ic_menu_slideshow\"\n            app:layout_anchor=\"@id/appbarLayout\"\n            app:layout_anchorGravity=\"bottom|right|end\"\n            />\n    </android.support.design.widget.CoordinatorLayout>\n```\n只要分别在CoordinateLayout，AppBarLayout和CollapsingToolbarLayout的xml属性中加上android:fitSystemWindow = \"true\"\njava代码里添加一句\n> getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); //注意下版本判断\n\n或者在当前Activity的values-v19 styles中添加 <item name=\"android:windowTranslucentStatus\">true</item>\n就行了。实际效果就是图片完全展开时可以扩展到statusBar下面，图片收缩起来后可以让Toolbar停在statusBar下面。但同样的代码在4.4的手机上会使得实际绘图区域落到statusBar以下，statusBar位置变成带灰色遮罩的白色背景。\n\n### 4. fitSystemWindow是什么意思\nfitSystemWindows属性： \n官方描述: \nBoolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity. \n简单来说就是如果设置为true,机会根据statusbar来添加一个padding.\n假定:\n布局文件只是一个普通的LinearLayout(fitSystemWindow = false（默认情况）),顶部include一个toolbar(fitSystemWindow = true )\n就已经可以实现4.4以下，4.4-5.0，5.0以上的各种场景了,(前提，使用Appcompat 的Theme，因为它会使用colorPrimaryDark为statusBar着色)\n\n但我的问题在于布局文件是\nCoordinateLayout>  AppBarLyout>  CollapsingToolbarLayout>  Toolbar & ImageView\n这种情况下，照理说Toolbar应该顶部留有25dp的padding，也就是fitSystemWindow = true（假设就只是这么简单）[然而事实是，fitSystemWindow会让你设置的padding失效](https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec#.vx75v2c9p),而ImageView需要侵入到statusBar下面，也就是fitSystemWindow = false。\n那就只要在toolbar的xml中添加fitSystemWindow这个属性好了。编译，运行，5.1手机，Toolbar的小箭头一部分跑到statusBar下面了，感觉就像Toolbar往上移动了25dp(这个目测的哈)，不可取。\n\n### 5. 查找到的一些解决方案\n 主要介绍原理了:\n\n 1. 类似于SystemBarTint，在android.R.id.content的View中添加一个 View\n ```java\n ViewGroup.LayoutParams statusViewLp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                    getStatusBarHeight());\ncontentView.addView(statusBarView,layoutParams)\n ```\n Activity持有一个PhoneWindow，PhoneWindow持有一个根View，叫DecorView（是一个FrameLayout），DecorView持有一个LinearLayout，在LinearLayout下分配两个FrameLayout，一个给ActionBar（当设置主题为NoActionBar是为ViewStub），一个给ContentView。不管如何，只要我们在LinearLayout的第一个位置插入一个View就可以让ContentView下移了。[简书作者](http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&utm_medium=referral)\n 这种方式其实已经无所谓是否需要在xml中fitSystemWindow了，因为都会通过添加最后一个View的方式把状态栏那块给遮住了。用来着色其实挺好的。\n\n\n2. 往android.R.id.content这个View里面添加一个假View,xml中fitSystemWindows\n\n3. 往android.R.id.content这个View的parent里面添加一个假View,xml中fitSystemWindows\n\n\n### 6.我最后实现的解决方案（4.4,5.1均通过）\n**其实整个问题的关键就是你是否想要在statusBar那一块长条的位置画画。。。。**\n一整张imageView的话，当然希望能够把图片延伸到statusBar以下\n而Toolbar则不需要延伸到statusBar以下。\n我尝试了给toolbar加上padding  >>失败\n我尝试了给toolbar加上margin   >>>> 问题终于解决\n\n所以最后，我的xml文件中删除了所有的fitSystemWindow，在style-v19中添加了该加的东西\n最后只在onCreate里面添加几段话\n```java\nsetSupportActionBar(binding.toolbar);\ngetSupportActionBar().setDisplayHomeAsUpEnabled(true);  //这个用于显示返回的小箭头，还得指明parentActivity\ngetSupportActionBar().setTitle(\"\");\nCollapsingToolbarLayout.LayoutParams params = (CollapsingToolbarLayout.LayoutParams) binding.toolbar.getLayoutParams();\nparams.setMargins(0, Utils.getStatusBarHeight(), 0, 0); //顶部加个margin就好了\nbinding.toolbar.setLayoutParams(params);\n```\n实际操作可能还要判断非空什么的，但大致意思如此\n看起来像这样\n5.1图片展开:  \n  ![5.1模拟器，图片展开](http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_expanded.png?imageView2/2/w/300)  \n\n5.1图片收起:  \n  ![5.1模拟器，图片收起](http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_collapsed.png?imageView2/2/w/300)  \n\n4.4图片展开:  \n  ![4.4模拟器，图片展开](http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_expanded.png?imageView2/2/w/300)  \n\n4.4图片收起:\n  ![4.4模拟器，图片收起](http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_collapsed.png?imageView2/2/w/300)  \n\n\n原理就是让整个布局占据statusBar的位置，但把Toolbar往下挪一点（其实也就是[这篇文章](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html)中所推荐的给contentView的给第一个childView添加marginTop的方法）\n\n\n### 7.在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪.\n自己测试了一下，在根布局里添加fitSystemWindows = true之后，在Activity的onCreate里面是可以使用ViewCompat.setfitSystems(rootView,false)设置起作用的。但也只限于onCreate的时候。例如添加一个点击事件，在onClick里面setFitSystemWindows，是不会把RootView往下挪的。这种情况就需要一开始就确保fitSystem = false，然后需要往下挪的时候，给设置一个FrameLayout.LayoutParams的TopMargin就可以了。注意来回切换(全屏模式和着色模式之间切换)的时候要看下rootView的getTop,因为MarginTop设置了之后会导致Top!=0。\n其实fitSystemWindows是在FitSystemWindowLinearLayout中添加Padding起效的，后期操作的Margin只是对其Child ContentFrameLayout进行操作。\n所以，这种情况下我觉得直接全部弄成fitSystemWindows = false，先把statusBar后面的空间占据了再说，后面再通过手动设置Margin上下挪动。\n\n\n\n\n### 8. 一些不要犯的小错误\n- 在Theme中添加\n```xml\n<item name=\"android:fitsSystemWindows\">true</item>\n```\n这会导致Toast的文字往上偏移，所以，如果需要使用fitSystemWinow = true的话，请老老实实去xml中写\n\n- 状态栏那一块如果你不去占据的话，而你又声明了windowTranslucentStatus，v21上默认的颜色应该是colorPrimaryDark(是的，AppCompat帮你照顾好了)v19上就是一片带阴影的白色(AppCompat不会在这个版本上帮你着色statusBar)。\n\n- 6.0以上可以设置statusBar字体的颜色了，这个随便找找就有了\n\n- Ian Lake在medium上给出了对于fitSystemWindow的权威解释，非常有价值。\n\n\n### 9. 下面这段话可能对于理解window有一定帮助\nfitsSystemWindows, 该属性可以设置是否为系统 View 预留出空间, 当设置为 true 时,会预留出状态栏的空间.\nContentView, 实质为 ContentFrameLayout, 但是重写了 dispatchFitSystemWindows 方法, 所以对其设置 fitsSystemWindows 无效.\nContentParent, 实质为 FitWindowsLinearLayout, 里面第一个 View 是 ViewStubCompat, 如果主题没有设置 title ,它就不会 inflate .第二个 View 就是 ContentView.\n另外，如果使用AppCompat，在api21以上，会自动将状态栏颜色设置为colorPrimaryDark。\n最后感谢网上各位博主不辞辛苦写出来的干货，让我能够比较简单的复制粘贴他们的代码来检验，写博客真的很累。\n\n### Reference\n1. [Android-transulcent-status-bar总结](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html)\n2. [由沉浸式状态栏引发的血案](http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&utm_medium=referral)\n3. [Android开发：Translucent System Bar 的最佳实践](http://www.jianshu.com/p/0acc12c29c1b)\n4. [Why would I want to fitsSystemWindows](https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec)","slug":"2016-10-14-Android-translucent-status-bar","published":1,"updated":"2017-07-15T08:56:34.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnfq0004bovrzfeyiz2t","content":"<p>沉浸式状态栏是api 19之后引入的，KitKat应该算是一次比较大的更新了，像是Transition，art runtime,storage access FrameWork(这个有空研究下)，另外就是这个被官方称为Full-screen immersive mode的特性了。具体来说，App可以将展示的区域拓展到statusBar的位置了。我觉得直接叫statusBar就好了，大部分人应该也能理解这就是手机上显示”中国移动”还有显示手机电量那一块的长条，宽度是match_parent。高度的话，据说是25dp，然后6.0上给改成了24dp。不过这不是重点<a id=\"more\"></a></p>\n<h3 id=\"1-最初的做法\"><a href=\"#1-最初的做法\" class=\"headerlink\" title=\"1.最初的做法\"></a>1.最初的做法</h3><p>看到有人推荐使用<a href=\"https://github.com/jgilfelt/SystemBarTint\">SystemBarTint</a>这个class,刚上来觉得也挺好用的，就是一个java class，直接复制粘贴到项目里，改一下package name，无脑使用即可。原理的话，看过源码后，大致明白是在statusBar的位置添加一个new View，然后持有这个view的引用，接下来就可以做常规的setBackground或者setBackgroundColor了。初始化时的关键代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setupStatusBarView</span><span class=\"params\">(Context context, ViewGroup decorViewGroup)</span> </span>&#123;<span class=\"comment\">//这个decorViewGroup指的是activity.getWindow()</span></div><div class=\"line\">        mStatusBarTintView = <span class=\"keyword\">new</span> View(context);</div><div class=\"line\">        LayoutParams params = <span class=\"keyword\">new</span> LayoutParams(LayoutParams.MATCH_PARENT, mConfig.getStatusBarHeight());</div><div class=\"line\">        params.gravity = Gravity.TOP;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mNavBarAvailable &amp;&amp; !mConfig.isNavigationAtBottom()) &#123;</div><div class=\"line\">            params.rightMargin = mConfig.getNavigationBarWidth();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mStatusBarTintView.setLayoutParams(params);</div><div class=\"line\">        mStatusBarTintView.setBackgroundColor(DEFAULT_TINT_COLOR);</div><div class=\"line\">        mStatusBarTintView.setVisibility(View.GONE);</div><div class=\"line\">        decorViewGroup.addView(mStatusBarTintView);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>一切看起来都很美好</p>\n<h3 id=\"2-直到碰到了fitSystemWindow-ture\"><a href=\"#2-直到碰到了fitSystemWindow-ture\" class=\"headerlink\" title=\"2. 直到碰到了fitSystemWindow = ture\"></a>2. 直到碰到了fitSystemWindow = ture</h3><p>几个月前曾经在项目里写过一个普通的Coordinatelayout内部CollapingToolbarLayout的沉浸式状态栏实现，当时为了赶进度一直试到夜里2点才尝试出在4.4和5.0以上手机都能满意的效果。现在想想有些事还是能够事先搞清楚的好，被动学习的代价实在太大。当时的方法是给Toolbar添加了一个顶部的padding，具体原理也不大清楚。<br>但实际上并不总能一直</br><br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/Trying%20stuff%20Untill%20it%20work.jpg?imageView2/2/w/600\" alt=\"trying stuff utill it work\"></p>\n<h3 id=\"3-使用CollapsingToolbarLayout时的问题\"><a href=\"#3-使用CollapsingToolbarLayout时的问题\" class=\"headerlink\" title=\"3. 使用CollapsingToolbarLayout时的问题\"></a>3. 使用CollapsingToolbarLayout时的问题</h3><ol>\n<li>5.0以上的手机似乎很简单<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.CoordinatorLayout</span></div><div class=\"line\">        <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></div><div class=\"line\">        <span class=\"attr\">xmlns:app</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/coordinateLayout\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:background</span>=<span class=\"string\">\"@android:color/background_light\"</span></div><div class=\"line\">        <span class=\"attr\">android:fitsSystemWindows</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">        &gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.AppBarLayout</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/appbarLayout\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"300dp\"</span></div><div class=\"line\">            <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"</span></div><div class=\"line\">            <span class=\"attr\">android:fitsSystemWindows</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">            &gt;</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.CollapsingToolbarLayout</span></div><div class=\"line\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/collapsingToolbarLayout\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">app:contentScrim</span>=<span class=\"string\">\"?attr/colorPrimary\"</span></div><div class=\"line\">                <span class=\"attr\">app:expandedTitleMarginEnd</span>=<span class=\"string\">\"64dp\"</span></div><div class=\"line\">                <span class=\"attr\">app:expandedTitleMarginStart</span>=<span class=\"string\">\"48dp\"</span></div><div class=\"line\">                <span class=\"attr\">app:layout_scrollFlags</span>=<span class=\"string\">\"scroll|exitUntilCollapsed\"</span></div><div class=\"line\">                &gt;</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></div><div class=\"line\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/backdrop\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                    <span class=\"attr\">android:scaleType</span>=<span class=\"string\">\"centerCrop\"</span></div><div class=\"line\">                    <span class=\"attr\">android:src</span>=<span class=\"string\">\"@drawable/image_19\"</span></div><div class=\"line\">                    <span class=\"attr\">app:layout_collapseMode</span>=<span class=\"string\">\"parallax\"</span></div><div class=\"line\">                    <span class=\"attr\">android:fitsSystemWindows</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">                    /&gt;</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">android.support.v7.widget.Toolbar</span></div><div class=\"line\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/toolbar\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"?attr/actionBarSize\"</span></div><div class=\"line\">                    <span class=\"attr\">app:layout_collapseMode</span>=<span class=\"string\">\"pin\"</span></div><div class=\"line\">                    <span class=\"attr\">app:popupTheme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompat.Light\"</span></div><div class=\"line\">                    /&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">android.support.design.widget.AppBarLayout</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">android.support.v4.widget.NestedScrollView</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/nestedScrollView\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">app:layout_behavior</span>=<span class=\"string\">\"@string/appbar_scrolling_view_behavior\"</span></div><div class=\"line\">            &gt;</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">TextView</span></div><div class=\"line\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">                <span class=\"attr\">android:lineSpacingExtra</span>=<span class=\"string\">\"8dp\"</span></div><div class=\"line\">                <span class=\"attr\">android:padding</span>=<span class=\"string\">\"@dimen/activity_horizontal_margin\"</span></div><div class=\"line\">                <span class=\"attr\">android:text</span>=<span class=\"string\">\"@string/newsBody\"</span></div><div class=\"line\">                <span class=\"attr\">android:textSize</span>=<span class=\"string\">\"20sp\"</span></div><div class=\"line\">                /&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">android.support.v4.widget.NestedScrollView</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.FloatingActionButton</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fab\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_margin</span>=<span class=\"string\">\"@dimen/activity_horizontal_margin\"</span></div><div class=\"line\">            <span class=\"attr\">android:src</span>=<span class=\"string\">\"@android:drawable/ic_menu_slideshow\"</span></div><div class=\"line\">            <span class=\"attr\">app:layout_anchor</span>=<span class=\"string\">\"@id/appbarLayout\"</span></div><div class=\"line\">            <span class=\"attr\">app:layout_anchorGravity</span>=<span class=\"string\">\"bottom|right|end\"</span></div><div class=\"line\">            /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">android.support.design.widget.CoordinatorLayout</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>只要分别在CoordinateLayout，AppBarLayout和CollapsingToolbarLayout的xml属性中加上android:fitSystemWindow = “true”<br>java代码里添加一句</p>\n<blockquote>\n<p>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); //注意下版本判断</p>\n</blockquote>\n<p>或者在当前Activity的values-v19 styles中添加 <item name=\"android:windowTranslucentStatus\">true</item><br>就行了。实际效果就是图片完全展开时可以扩展到statusBar下面，图片收缩起来后可以让Toolbar停在statusBar下面。但同样的代码在4.4的手机上会使得实际绘图区域落到statusBar以下，statusBar位置变成带灰色遮罩的白色背景。</p>\n<h3 id=\"4-fitSystemWindow是什么意思\"><a href=\"#4-fitSystemWindow是什么意思\" class=\"headerlink\" title=\"4. fitSystemWindow是什么意思\"></a>4. fitSystemWindow是什么意思</h3><p>fitSystemWindows属性：<br>官方描述:<br>Boolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity.<br>简单来说就是如果设置为true,机会根据statusbar来添加一个padding.<br>假定:<br>布局文件只是一个普通的LinearLayout(fitSystemWindow = false（默认情况）),顶部include一个toolbar(fitSystemWindow = true )<br>就已经可以实现4.4以下，4.4-5.0，5.0以上的各种场景了,(前提，使用Appcompat 的Theme，因为它会使用colorPrimaryDark为statusBar着色)</p>\n<p>但我的问题在于布局文件是<br>CoordinateLayout&gt;  AppBarLyout&gt;  CollapsingToolbarLayout&gt;  Toolbar &amp; ImageView<br>这种情况下，照理说Toolbar应该顶部留有25dp的padding，也就是fitSystemWindow = true（假设就只是这么简单）<a href=\"https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec#.vx75v2c9p\">然而事实是，fitSystemWindow会让你设置的padding失效</a>,而ImageView需要侵入到statusBar下面，也就是fitSystemWindow = false。<br>那就只要在toolbar的xml中添加fitSystemWindow这个属性好了。编译，运行，5.1手机，Toolbar的小箭头一部分跑到statusBar下面了，感觉就像Toolbar往上移动了25dp(这个目测的哈)，不可取。</p>\n<h3 id=\"5-查找到的一些解决方案\"><a href=\"#5-查找到的一些解决方案\" class=\"headerlink\" title=\"5. 查找到的一些解决方案\"></a>5. 查找到的一些解决方案</h3><p> 主要介绍原理了:</p>\n<ol>\n<li><p>类似于SystemBarTint，在android.R.id.content的View中添加一个 View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ViewGroup.LayoutParams statusViewLp = <span class=\"keyword\">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</div><div class=\"line\">                    getStatusBarHeight());</div><div class=\"line\">contentView.addView(statusBarView,layoutParams)</div></pre></td></tr></table></figure>\n<p>Activity持有一个PhoneWindow，PhoneWindow持有一个根View，叫DecorView（是一个FrameLayout），DecorView持有一个LinearLayout，在LinearLayout下分配两个FrameLayout，一个给ActionBar（当设置主题为NoActionBar是为ViewStub），一个给ContentView。不管如何，只要我们在LinearLayout的第一个位置插入一个View就可以让ContentView下移了。<a href=\"http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&amp;utm_medium=referral\">简书作者</a><br>这种方式其实已经无所谓是否需要在xml中fitSystemWindow了，因为都会通过添加最后一个View的方式把状态栏那块给遮住了。用来着色其实挺好的。</p>\n</li>\n</ol>\n<ol>\n<li><p>往android.R.id.content这个View里面添加一个假View,xml中fitSystemWindows</p>\n</li>\n<li><p>往android.R.id.content这个View的parent里面添加一个假View,xml中fitSystemWindows</p>\n</li>\n</ol>\n<h3 id=\"6-我最后实现的解决方案（4-4-5-1均通过）\"><a href=\"#6-我最后实现的解决方案（4-4-5-1均通过）\" class=\"headerlink\" title=\"6.我最后实现的解决方案（4.4,5.1均通过）\"></a>6.我最后实现的解决方案（4.4,5.1均通过）</h3><p><strong>其实整个问题的关键就是你是否想要在statusBar那一块长条的位置画画。。。。</strong><br>一整张imageView的话，当然希望能够把图片延伸到statusBar以下<br>而Toolbar则不需要延伸到statusBar以下。<br>我尝试了给toolbar加上padding  &gt;&gt;失败<br>我尝试了给toolbar加上margin   &gt;&gt;&gt;&gt; 问题终于解决</p>\n<p>所以最后，我的xml文件中删除了所有的fitSystemWindow，在style-v19中添加了该加的东西<br>最后只在onCreate里面添加几段话<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">setSupportActionBar(binding.toolbar);</div><div class=\"line\">getSupportActionBar().setDisplayHomeAsUpEnabled(<span class=\"keyword\">true</span>);  <span class=\"comment\">//这个用于显示返回的小箭头，还得指明parentActivity</span></div><div class=\"line\">getSupportActionBar().setTitle(<span class=\"string\">\"\"</span>);</div><div class=\"line\">CollapsingToolbarLayout.LayoutParams params = (CollapsingToolbarLayout.LayoutParams) binding.toolbar.getLayoutParams();</div><div class=\"line\">params.setMargins(<span class=\"number\">0</span>, Utils.getStatusBarHeight(), <span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">//顶部加个margin就好了</span></div><div class=\"line\">binding.toolbar.setLayoutParams(params);</div></pre></td></tr></table></figure></p>\n<p>实际操作可能还要判断非空什么的，但大致意思如此<br>看起来像这样<br>5.1图片展开:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_expanded.png?imageView2/2/w/300\" alt=\"5.1模拟器，图片展开\">  </p>\n<p>5.1图片收起:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_collapsed.png?imageView2/2/w/300\" alt=\"5.1模拟器，图片收起\">  </p>\n<p>4.4图片展开:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_expanded.png?imageView2/2/w/300\" alt=\"4.4模拟器，图片展开\">  </p>\n<p>4.4图片收起:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_collapsed.png?imageView2/2/w/300\" alt=\"4.4模拟器，图片收起\">  </p>\n<p>原理就是让整个布局占据statusBar的位置，但把Toolbar往下挪一点（其实也就是<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html\">这篇文章</a>中所推荐的给contentView的给第一个childView添加marginTop的方法）</p>\n<h3 id=\"7-在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪\"><a href=\"#7-在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪\" class=\"headerlink\" title=\"7.在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪.\"></a>7.在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪.</h3><p>自己测试了一下，在根布局里添加fitSystemWindows = true之后，在Activity的onCreate里面是可以使用ViewCompat.setfitSystems(rootView,false)设置起作用的。但也只限于onCreate的时候。例如添加一个点击事件，在onClick里面setFitSystemWindows，是不会把RootView往下挪的。这种情况就需要一开始就确保fitSystem = false，然后需要往下挪的时候，给设置一个FrameLayout.LayoutParams的TopMargin就可以了。注意来回切换(全屏模式和着色模式之间切换)的时候要看下rootView的getTop,因为MarginTop设置了之后会导致Top!=0。<br>其实fitSystemWindows是在FitSystemWindowLinearLayout中添加Padding起效的，后期操作的Margin只是对其Child ContentFrameLayout进行操作。<br>所以，这种情况下我觉得直接全部弄成fitSystemWindows = false，先把statusBar后面的空间占据了再说，后面再通过手动设置Margin上下挪动。</p>\n<h3 id=\"8-一些不要犯的小错误\"><a href=\"#8-一些不要犯的小错误\" class=\"headerlink\" title=\"8. 一些不要犯的小错误\"></a>8. 一些不要犯的小错误</h3><ul>\n<li>在Theme中添加<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:fitsSystemWindows\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这会导致Toast的文字往上偏移，所以，如果需要使用fitSystemWinow = true的话，请老老实实去xml中写</p>\n<ul>\n<li><p>状态栏那一块如果你不去占据的话，而你又声明了windowTranslucentStatus，v21上默认的颜色应该是colorPrimaryDark(是的，AppCompat帮你照顾好了)v19上就是一片带阴影的白色(AppCompat不会在这个版本上帮你着色statusBar)。</p>\n</li>\n<li><p>6.0以上可以设置statusBar字体的颜色了，这个随便找找就有了</p>\n</li>\n<li><p>Ian Lake在medium上给出了对于fitSystemWindow的权威解释，非常有价值。</p>\n</li>\n</ul>\n<h3 id=\"9-下面这段话可能对于理解window有一定帮助\"><a href=\"#9-下面这段话可能对于理解window有一定帮助\" class=\"headerlink\" title=\"9. 下面这段话可能对于理解window有一定帮助\"></a>9. 下面这段话可能对于理解window有一定帮助</h3><p>fitsSystemWindows, 该属性可以设置是否为系统 View 预留出空间, 当设置为 true 时,会预留出状态栏的空间.<br>ContentView, 实质为 ContentFrameLayout, 但是重写了 dispatchFitSystemWindows 方法, 所以对其设置 fitsSystemWindows 无效.<br>ContentParent, 实质为 FitWindowsLinearLayout, 里面第一个 View 是 ViewStubCompat, 如果主题没有设置 title ,它就不会 inflate .第二个 View 就是 ContentView.<br>另外，如果使用AppCompat，在api21以上，会自动将状态栏颜色设置为colorPrimaryDark。<br>最后感谢网上各位博主不辞辛苦写出来的干货，让我能够比较简单的复制粘贴他们的代码来检验，写博客真的很累。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html\">Android-transulcent-status-bar总结</a></li>\n<li><a href=\"http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&amp;utm_medium=referral\">由沉浸式状态栏引发的血案</a></li>\n<li><a href=\"http://www.jianshu.com/p/0acc12c29c1b\">Android开发：Translucent System Bar 的最佳实践</a></li>\n<li><a href=\"https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec\">Why would I want to fitsSystemWindows</a></li>\n</ol>\n","excerpt":"<p>沉浸式状态栏是api 19之后引入的，KitKat应该算是一次比较大的更新了，像是Transition，art runtime,storage access FrameWork(这个有空研究下)，另外就是这个被官方称为Full-screen immersive mode的特性了。具体来说，App可以将展示的区域拓展到statusBar的位置了。我觉得直接叫statusBar就好了，大部分人应该也能理解这就是手机上显示”中国移动”还有显示手机电量那一块的长条，宽度是match_parent。高度的话，据说是25dp，然后6.0上给改成了24dp。不过这不是重点","more":"</p>\n<h3 id=\"1-最初的做法\"><a href=\"#1-最初的做法\" class=\"headerlink\" title=\"1.最初的做法\"></a>1.最初的做法</h3><p>看到有人推荐使用<a href=\"https://github.com/jgilfelt/SystemBarTint\">SystemBarTint</a>这个class,刚上来觉得也挺好用的，就是一个java class，直接复制粘贴到项目里，改一下package name，无脑使用即可。原理的话，看过源码后，大致明白是在statusBar的位置添加一个new View，然后持有这个view的引用，接下来就可以做常规的setBackground或者setBackgroundColor了。初始化时的关键代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setupStatusBarView</span><span class=\"params\">(Context context, ViewGroup decorViewGroup)</span> </span>&#123;<span class=\"comment\">//这个decorViewGroup指的是activity.getWindow()</span></div><div class=\"line\">        mStatusBarTintView = <span class=\"keyword\">new</span> View(context);</div><div class=\"line\">        LayoutParams params = <span class=\"keyword\">new</span> LayoutParams(LayoutParams.MATCH_PARENT, mConfig.getStatusBarHeight());</div><div class=\"line\">        params.gravity = Gravity.TOP;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mNavBarAvailable &amp;&amp; !mConfig.isNavigationAtBottom()) &#123;</div><div class=\"line\">            params.rightMargin = mConfig.getNavigationBarWidth();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mStatusBarTintView.setLayoutParams(params);</div><div class=\"line\">        mStatusBarTintView.setBackgroundColor(DEFAULT_TINT_COLOR);</div><div class=\"line\">        mStatusBarTintView.setVisibility(View.GONE);</div><div class=\"line\">        decorViewGroup.addView(mStatusBarTintView);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>一切看起来都很美好</p>\n<h3 id=\"2-直到碰到了fitSystemWindow-ture\"><a href=\"#2-直到碰到了fitSystemWindow-ture\" class=\"headerlink\" title=\"2. 直到碰到了fitSystemWindow = ture\"></a>2. 直到碰到了fitSystemWindow = ture</h3><p>几个月前曾经在项目里写过一个普通的Coordinatelayout内部CollapingToolbarLayout的沉浸式状态栏实现，当时为了赶进度一直试到夜里2点才尝试出在4.4和5.0以上手机都能满意的效果。现在想想有些事还是能够事先搞清楚的好，被动学习的代价实在太大。当时的方法是给Toolbar添加了一个顶部的padding，具体原理也不大清楚。<br>但实际上并不总能一直</br><br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/Trying%20stuff%20Untill%20it%20work.jpg?imageView2/2/w/600\" alt=\"trying stuff utill it work\"></p>\n<h3 id=\"3-使用CollapsingToolbarLayout时的问题\"><a href=\"#3-使用CollapsingToolbarLayout时的问题\" class=\"headerlink\" title=\"3. 使用CollapsingToolbarLayout时的问题\"></a>3. 使用CollapsingToolbarLayout时的问题</h3><ol>\n<li>5.0以上的手机似乎很简单<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.CoordinatorLayout</span></div><div class=\"line\">        <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></div><div class=\"line\">        <span class=\"attr\">xmlns:app</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/coordinateLayout\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:background</span>=<span class=\"string\">\"@android:color/background_light\"</span></div><div class=\"line\">        <span class=\"attr\">android:fitsSystemWindows</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">        &gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.AppBarLayout</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/appbarLayout\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"300dp\"</span></div><div class=\"line\">            <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"</span></div><div class=\"line\">            <span class=\"attr\">android:fitsSystemWindows</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">            &gt;</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.CollapsingToolbarLayout</span></div><div class=\"line\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/collapsingToolbarLayout\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">app:contentScrim</span>=<span class=\"string\">\"?attr/colorPrimary\"</span></div><div class=\"line\">                <span class=\"attr\">app:expandedTitleMarginEnd</span>=<span class=\"string\">\"64dp\"</span></div><div class=\"line\">                <span class=\"attr\">app:expandedTitleMarginStart</span>=<span class=\"string\">\"48dp\"</span></div><div class=\"line\">                <span class=\"attr\">app:layout_scrollFlags</span>=<span class=\"string\">\"scroll|exitUntilCollapsed\"</span></div><div class=\"line\">                &gt;</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></div><div class=\"line\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/backdrop\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                    <span class=\"attr\">android:scaleType</span>=<span class=\"string\">\"centerCrop\"</span></div><div class=\"line\">                    <span class=\"attr\">android:src</span>=<span class=\"string\">\"@drawable/image_19\"</span></div><div class=\"line\">                    <span class=\"attr\">app:layout_collapseMode</span>=<span class=\"string\">\"parallax\"</span></div><div class=\"line\">                    <span class=\"attr\">android:fitsSystemWindows</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">                    /&gt;</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">android.support.v7.widget.Toolbar</span></div><div class=\"line\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/toolbar\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"?attr/actionBarSize\"</span></div><div class=\"line\">                    <span class=\"attr\">app:layout_collapseMode</span>=<span class=\"string\">\"pin\"</span></div><div class=\"line\">                    <span class=\"attr\">app:popupTheme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompat.Light\"</span></div><div class=\"line\">                    /&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">android.support.design.widget.AppBarLayout</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">android.support.v4.widget.NestedScrollView</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/nestedScrollView\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">app:layout_behavior</span>=<span class=\"string\">\"@string/appbar_scrolling_view_behavior\"</span></div><div class=\"line\">            &gt;</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">TextView</span></div><div class=\"line\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">                <span class=\"attr\">android:lineSpacingExtra</span>=<span class=\"string\">\"8dp\"</span></div><div class=\"line\">                <span class=\"attr\">android:padding</span>=<span class=\"string\">\"@dimen/activity_horizontal_margin\"</span></div><div class=\"line\">                <span class=\"attr\">android:text</span>=<span class=\"string\">\"@string/newsBody\"</span></div><div class=\"line\">                <span class=\"attr\">android:textSize</span>=<span class=\"string\">\"20sp\"</span></div><div class=\"line\">                /&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">android.support.v4.widget.NestedScrollView</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">android.support.design.widget.FloatingActionButton</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fab\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_margin</span>=<span class=\"string\">\"@dimen/activity_horizontal_margin\"</span></div><div class=\"line\">            <span class=\"attr\">android:src</span>=<span class=\"string\">\"@android:drawable/ic_menu_slideshow\"</span></div><div class=\"line\">            <span class=\"attr\">app:layout_anchor</span>=<span class=\"string\">\"@id/appbarLayout\"</span></div><div class=\"line\">            <span class=\"attr\">app:layout_anchorGravity</span>=<span class=\"string\">\"bottom|right|end\"</span></div><div class=\"line\">            /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">android.support.design.widget.CoordinatorLayout</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>只要分别在CoordinateLayout，AppBarLayout和CollapsingToolbarLayout的xml属性中加上android:fitSystemWindow = “true”<br>java代码里添加一句</p>\n<blockquote>\n<p>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); //注意下版本判断</p>\n</blockquote>\n<p>或者在当前Activity的values-v19 styles中添加 <item name=\"android:windowTranslucentStatus\">true</item><br>就行了。实际效果就是图片完全展开时可以扩展到statusBar下面，图片收缩起来后可以让Toolbar停在statusBar下面。但同样的代码在4.4的手机上会使得实际绘图区域落到statusBar以下，statusBar位置变成带灰色遮罩的白色背景。</p>\n<h3 id=\"4-fitSystemWindow是什么意思\"><a href=\"#4-fitSystemWindow是什么意思\" class=\"headerlink\" title=\"4. fitSystemWindow是什么意思\"></a>4. fitSystemWindow是什么意思</h3><p>fitSystemWindows属性：<br>官方描述:<br>Boolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity.<br>简单来说就是如果设置为true,机会根据statusbar来添加一个padding.<br>假定:<br>布局文件只是一个普通的LinearLayout(fitSystemWindow = false（默认情况）),顶部include一个toolbar(fitSystemWindow = true )<br>就已经可以实现4.4以下，4.4-5.0，5.0以上的各种场景了,(前提，使用Appcompat 的Theme，因为它会使用colorPrimaryDark为statusBar着色)</p>\n<p>但我的问题在于布局文件是<br>CoordinateLayout&gt;  AppBarLyout&gt;  CollapsingToolbarLayout&gt;  Toolbar &amp; ImageView<br>这种情况下，照理说Toolbar应该顶部留有25dp的padding，也就是fitSystemWindow = true（假设就只是这么简单）<a href=\"https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec#.vx75v2c9p\">然而事实是，fitSystemWindow会让你设置的padding失效</a>,而ImageView需要侵入到statusBar下面，也就是fitSystemWindow = false。<br>那就只要在toolbar的xml中添加fitSystemWindow这个属性好了。编译，运行，5.1手机，Toolbar的小箭头一部分跑到statusBar下面了，感觉就像Toolbar往上移动了25dp(这个目测的哈)，不可取。</p>\n<h3 id=\"5-查找到的一些解决方案\"><a href=\"#5-查找到的一些解决方案\" class=\"headerlink\" title=\"5. 查找到的一些解决方案\"></a>5. 查找到的一些解决方案</h3><p> 主要介绍原理了:</p>\n<ol>\n<li><p>类似于SystemBarTint，在android.R.id.content的View中添加一个 View</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ViewGroup.LayoutParams statusViewLp = <span class=\"keyword\">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</div><div class=\"line\">                    getStatusBarHeight());</div><div class=\"line\">contentView.addView(statusBarView,layoutParams)</div></pre></td></tr></table></figure>\n<p>Activity持有一个PhoneWindow，PhoneWindow持有一个根View，叫DecorView（是一个FrameLayout），DecorView持有一个LinearLayout，在LinearLayout下分配两个FrameLayout，一个给ActionBar（当设置主题为NoActionBar是为ViewStub），一个给ContentView。不管如何，只要我们在LinearLayout的第一个位置插入一个View就可以让ContentView下移了。<a href=\"http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&amp;utm_medium=referral\">简书作者</a><br>这种方式其实已经无所谓是否需要在xml中fitSystemWindow了，因为都会通过添加最后一个View的方式把状态栏那块给遮住了。用来着色其实挺好的。</p>\n</li>\n</ol>\n<ol>\n<li><p>往android.R.id.content这个View里面添加一个假View,xml中fitSystemWindows</p>\n</li>\n<li><p>往android.R.id.content这个View的parent里面添加一个假View,xml中fitSystemWindows</p>\n</li>\n</ol>\n<h3 id=\"6-我最后实现的解决方案（4-4-5-1均通过）\"><a href=\"#6-我最后实现的解决方案（4-4-5-1均通过）\" class=\"headerlink\" title=\"6.我最后实现的解决方案（4.4,5.1均通过）\"></a>6.我最后实现的解决方案（4.4,5.1均通过）</h3><p><strong>其实整个问题的关键就是你是否想要在statusBar那一块长条的位置画画。。。。</strong><br>一整张imageView的话，当然希望能够把图片延伸到statusBar以下<br>而Toolbar则不需要延伸到statusBar以下。<br>我尝试了给toolbar加上padding  &gt;&gt;失败<br>我尝试了给toolbar加上margin   &gt;&gt;&gt;&gt; 问题终于解决</p>\n<p>所以最后，我的xml文件中删除了所有的fitSystemWindow，在style-v19中添加了该加的东西<br>最后只在onCreate里面添加几段话<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">setSupportActionBar(binding.toolbar);</div><div class=\"line\">getSupportActionBar().setDisplayHomeAsUpEnabled(<span class=\"keyword\">true</span>);  <span class=\"comment\">//这个用于显示返回的小箭头，还得指明parentActivity</span></div><div class=\"line\">getSupportActionBar().setTitle(<span class=\"string\">\"\"</span>);</div><div class=\"line\">CollapsingToolbarLayout.LayoutParams params = (CollapsingToolbarLayout.LayoutParams) binding.toolbar.getLayoutParams();</div><div class=\"line\">params.setMargins(<span class=\"number\">0</span>, Utils.getStatusBarHeight(), <span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">//顶部加个margin就好了</span></div><div class=\"line\">binding.toolbar.setLayoutParams(params);</div></pre></td></tr></table></figure></p>\n<p>实际操作可能还要判断非空什么的，但大致意思如此<br>看起来像这样<br>5.1图片展开:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_expanded.png?imageView2/2/w/300\" alt=\"5.1模拟器，图片展开\">  </p>\n<p>5.1图片收起:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_5.0_collapsed.png?imageView2/2/w/300\" alt=\"5.1模拟器，图片收起\">  </p>\n<p>4.4图片展开:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_expanded.png?imageView2/2/w/300\" alt=\"4.4模拟器，图片展开\">  </p>\n<p>4.4图片收起:<br>  <img src=\"http://odzl05jxx.bkt.clouddn.com/statusbar_4.4_collapsed.png?imageView2/2/w/300\" alt=\"4.4模拟器，图片收起\">  </p>\n<p>原理就是让整个布局占据statusBar的位置，但把Toolbar往下挪一点（其实也就是<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html\">这篇文章</a>中所推荐的给contentView的给第一个childView添加marginTop的方法）</p>\n<h3 id=\"7-在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪\"><a href=\"#7-在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪\" class=\"headerlink\" title=\"7.在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪.\"></a>7.在onCreate之后设置fitSystemWindows并不会把ContentView往上挪或往下挪.</h3><p>自己测试了一下，在根布局里添加fitSystemWindows = true之后，在Activity的onCreate里面是可以使用ViewCompat.setfitSystems(rootView,false)设置起作用的。但也只限于onCreate的时候。例如添加一个点击事件，在onClick里面setFitSystemWindows，是不会把RootView往下挪的。这种情况就需要一开始就确保fitSystem = false，然后需要往下挪的时候，给设置一个FrameLayout.LayoutParams的TopMargin就可以了。注意来回切换(全屏模式和着色模式之间切换)的时候要看下rootView的getTop,因为MarginTop设置了之后会导致Top!=0。<br>其实fitSystemWindows是在FitSystemWindowLinearLayout中添加Padding起效的，后期操作的Margin只是对其Child ContentFrameLayout进行操作。<br>所以，这种情况下我觉得直接全部弄成fitSystemWindows = false，先把statusBar后面的空间占据了再说，后面再通过手动设置Margin上下挪动。</p>\n<h3 id=\"8-一些不要犯的小错误\"><a href=\"#8-一些不要犯的小错误\" class=\"headerlink\" title=\"8. 一些不要犯的小错误\"></a>8. 一些不要犯的小错误</h3><ul>\n<li>在Theme中添加<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:fitsSystemWindows\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这会导致Toast的文字往上偏移，所以，如果需要使用fitSystemWinow = true的话，请老老实实去xml中写</p>\n<ul>\n<li><p>状态栏那一块如果你不去占据的话，而你又声明了windowTranslucentStatus，v21上默认的颜色应该是colorPrimaryDark(是的，AppCompat帮你照顾好了)v19上就是一片带阴影的白色(AppCompat不会在这个版本上帮你着色statusBar)。</p>\n</li>\n<li><p>6.0以上可以设置statusBar字体的颜色了，这个随便找找就有了</p>\n</li>\n<li><p>Ian Lake在medium上给出了对于fitSystemWindow的权威解释，非常有价值。</p>\n</li>\n</ul>\n<h3 id=\"9-下面这段话可能对于理解window有一定帮助\"><a href=\"#9-下面这段话可能对于理解window有一定帮助\" class=\"headerlink\" title=\"9. 下面这段话可能对于理解window有一定帮助\"></a>9. 下面这段话可能对于理解window有一定帮助</h3><p>fitsSystemWindows, 该属性可以设置是否为系统 View 预留出空间, 当设置为 true 时,会预留出状态栏的空间.<br>ContentView, 实质为 ContentFrameLayout, 但是重写了 dispatchFitSystemWindows 方法, 所以对其设置 fitsSystemWindows 无效.<br>ContentParent, 实质为 FitWindowsLinearLayout, 里面第一个 View 是 ViewStubCompat, 如果主题没有设置 title ,它就不会 inflate .第二个 View 就是 ContentView.<br>另外，如果使用AppCompat，在api21以上，会自动将状态栏颜色设置为colorPrimaryDark。<br>最后感谢网上各位博主不辞辛苦写出来的干货，让我能够比较简单的复制粘贴他们的代码来检验，写博客真的很累。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0330/4104.html\">Android-transulcent-status-bar总结</a></li>\n<li><a href=\"http://www.jianshu.com/p/140be70b84cd?utm_source=tuicool&amp;utm_medium=referral\">由沉浸式状态栏引发的血案</a></li>\n<li><a href=\"http://www.jianshu.com/p/0acc12c29c1b\">Android开发：Translucent System Bar 的最佳实践</a></li>\n<li><a href=\"https://medium.com/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec\">Why would I want to fitsSystemWindows</a></li>\n</ol>"},{"title":"使用Loader进行异步数据操作","date":"2016-10-15T11:12:22.000Z","_content":"App中经常有这样的需求:\n进入一个页面，首先查询数据库，如果数据库数据有效，直接使用数据库数据。否则去网络查询数据，网络数据返回后重新加载数据。\n很显然，这里的查询数据库和网络请求都需要放到子线程去操作，异步了。android推荐使用Loader进行数据查询，最大的好处就是Laoder会处理好与生命周期相关的事情，Android Developers推出过关于Loaders的[介绍视频](https://www.youtube.com/watch?v=s4eAtMHU5gI&index=8&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)，Loader就是为了解决这种问题而推出的，Loader具有几点好处\n1. 如果Activity挂掉了，Activity中启动了的线程怎么办，如果不处理好有可能导致leak。\n2. activity挂了，而子线程中持有View的强引用，此时再去更新View已经没有意义，View已经不可见了\n3. 这条线程所做的工作，加载的资源都白白浪费了，下次还需要重新加载一遍。\n<!--more-->\n\n### 1. 自定义一个Loader(加载数据类型，Cache处理等)\nLoader的使用就像一个AsyncTask一样，可以提前指定需要在异步线程中做的事情、数据类型以及完成加载后将数据推送到主线程。谷歌给出了一个使用Loader来查询手机上安装的App并显示在一个ListView中的DemoApp，虽然是好几年前的东西了，并且使用的是V4包里的Loader,但还是值得学习。\n首先来看自定义的AppListLoader\n\n```java\npublic class AppListLoader extends AsyncTaskLoader<List<AppEntry>> { //AsynTaskLoader支持泛型，AppEntry是已安装App信息的包装类。\n    private List<AppEntry> mApps;\n    //查询的App列表保存为成员变量\n    final PackageManager mPm;\n    private boolean DEBUG = true;\n    public static final String TAG = AppListLoader.class.getSimpleName();\n\n    //构造函数\n    public AppListLoader(Context ctx) {\n        // Loaders may be used across multiple Activitys (assuming they aren't\n        // bound to the LoaderManager), so NEVER hold a reference to the context\n        // directly. Doing so will cause you to leak an entire Activity's context.\n        // The superclass constructor will store a reference to the Application\n        // Context instead, and can be retrieved with a call to getContext().\n        super(ctx);\n        //第一，这里运行在主线程上；\n        //第二，传进来的context(一般是Activity只是为了获取ApplicationContext)\n        mPm = getContext().getPackageManager();//getContext()返回的是Application的Context。\n    }\n\n    @Override\n    public List<AppEntry> loadInBackground() {\n        if (DEBUG) Log.i(TAG, \"+++ loadInBackground() called! +++\");\n        LogUtil.p(\"\");// 子线程,耗时的工作放到这里\n        // Retrieve all installed applications.\n        List<ApplicationInfo> apps = mPm.getInstalledApplications(0);//PackageManager的方法\n        if (apps == null) {\n            apps = new ArrayList<ApplicationInfo>();\n        }\n        // Create corresponding array of entries and load their labels.\n        List<AppEntry> entries = new ArrayList<AppEntry>(apps.size());\n        for (int i = 0; i < apps.size(); i++) {\n            AppEntry entry = new AppEntry(this, apps.get(i));\n            entry.loadLabel(getContext());\n            entries.add(entry);\n        }\n        // Sort the list.\n        Collections.sort(entries, ALPHA_COMPARATOR);\n        return entries;\n    }\n\n    @Override\n    public void deliverResult(List<AppEntry> apps) {\n        //运行在主线程上\n        if (isReset()) {//这里就类似于AsyncTask的onPostExecute了，把子线程处理好的数据推送到主线程\n            if (DEBUG)\n                Log.w(TAG, \"+++ Warning! An async query came in while the Loader was reset! +++\");\n            // The Loader has been reset; ignore the result and invalidate the data.\n            // This can happen when the Loader is reset while an asynchronous query\n            // is working in the background. That is, when the background thread\n            // finishes its work and attempts to deliver the results to the client,\n            // it will see here that the Loader has been reset and discard any\n            // resources associated with the new data as necessary.\n            if (apps != null) {\n                releaseResources(apps);\n                return;\n            }\n        }//如果调用了reset()方法，说明子线程加载的数据是无效的，释放资源，处理无效数据\n        // Hold a reference to the old data so it doesn't get garbage collected.\n        // We must protect it until the new data has been delivered.\n        List<AppEntry> oldApps = mApps;\n        mApps = apps;\n        if (isStarted()) {// 如果一切正常，即调用了startLoading且stopLoading和reset均为被调用\n            if (DEBUG) Log.i(TAG, \"+++ Delivering results to the LoaderManager for\" +\n                    \" the ListFragment to display! +++\");\n            // If the Loader is in a started state, have the superclass deliver the\n            // results to the client.\n            super.deliverResult(apps);\n        }\n        // Invalidate the old data as we don't need it any more.\n        if (oldApps != null && oldApps != apps) {\n            if (DEBUG) Log.i(TAG, \"+++ Releasing any old data associated with this Loader. +++\");\n            releaseResources(oldApps);\n        }\n    }\n}\n```\n到此，数据加载的Server端算是完成，这里注意调用到了isReset()、isStarted()等方法，这些就是Server端在在处理Client端生命周期是需要注意的，这个后面再说。\n\n### 2. 使用LoaderManager管理Loader\n我们使用LoaderManager在Activity或Fragment中与Loader交互。通常在onCreate或者onActivityCreated中:\n> getSupportedLoaderManager.initLoader()//Activity中\n> getLoaderManager() //Fragment中\n\n这里介绍在Fragment中的使用，因为Loader处理好了与Activity,Fragment甚至Child Fragment的生命周期。\n推荐使用v4包里的Loader，Loader是在Android3.0引入FrameWork中的，但v4包让Loadder在更早的版本上也有相应的API。更重要的是，v4 包中的Loader是伴随着v4包新的release step，也就是说v4包会与时俱进修复其中的bug。\n这一点在medium上有[介绍](https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.wrh1ciyts) 。\n再看一下这个方法\n>  public abstract <D> Loader<D> initLoader(int id, Bundle args,\n            LoaderManager.LoaderCallbacks<D> callback);\n\t\t\t\n\nDemo中使用的是Fragment：\n>  // Initialize a Loader with id '1'. If the Loader with this id already\n            // exists, then the LoaderManager will reuse the existing Loader.\n            getLoaderManager().initLoader(LOADER_ID, null, this);\t\t\t\n\t\t\t\n相对应的Fragment需要implements  LoaderManager.LoaderCallbacks<List<AppEntry>> //注意泛型\n这个接口有三个方法\n```java\n public interface LoaderCallbacks<D> {\n       \n        public Loader<D> onCreateLoader(int id, Bundle args);\n\n       \n        public void onLoadFinished(Loader<D> loader, D data);\n\n       \n        public void onLoaderReset(Loader<D> loader);\n    }\n```\t\t\t\n看一下Demo中是如何实现的\n```java\n   @Override\n        public android.support.v4.content.Loader<List<AppEntry>> onCreateLoader(int id, Bundle args) {\n            if (DEBUG) Log.i(TAG, \"+++ onCreateLoader() called! +++\");\n            return new AppListLoader(getActivity());\n        }\n\n        @Override\n        public void onLoadFinished(android.support.v4.content.Loader<List<AppEntry>> loader, List<AppEntry> data) {\n            if (DEBUG) Log.i(TAG, \"+++ onLoadFinished() called! +++\");\n            mAdapter.setData(data);//加载数据到UI\n\n            if (isResumed()) {\n                setListShown(true);\n            } else {\n                setListShownNoAnimation(true);\n            } \n        }\n\n        @Override\n        public void onLoaderReset(android.support.v4.content.Loader<List<AppEntry>> loader) {\n            if (DEBUG) Log.i(TAG, \"+++ onLoadReset() called! +++\");\n            mAdapter.setData(null);//loader被reset，UI这边需要清除所有与Loader数据相关的引用，但清除数据的任务会由Loader处理好\n        }\n```\n在三个明显的回调中处理好数据绑定到UI及过期数据的清理即可。\n\n### 3. 处理Activity生命周期的问题\n回到server端(Loader),AsyncTaskLoader是一个abstract class，loadInBackground方法已经实现了，但还有几个方法强调必须要复写或者与生命周期相关\n```java\n @Override\n    protected void onStartLoading() {\n        /* Subclasses must implement this to take care of loading their data,\n          as per {@link #startLoading()}.  This is not called by clients directly,\n          but as a result of a call to {@link #startLoading()}.*/\n        //在这里检查一下成员变量中的数据是否不为空，有数据的话，deliverResults\n    }\n\n    @Override\n    protected void onStopLoading() {\n          /*Subclasses must implement this to take care of stopping their loader,\n          as per {@link #stopLoading()}.  This is not called by clients directly,\n          but as a result of a call to {@link #stopLoading()}.\n          This will always be called from the process's main thread.*/\n    }\n\n    @Override\n    protected void onReset() {\n        /* Subclasses must implement this to take care of resetting their loader,\n         as per {@link #reset()}.  This is not called by clients directly,\n         but as a result of a call to {@link #reset()}.\n         This will always be called from the process's main thread.\n         如果调用了destoryLoader或者Loader相关联的Activity/Fragment被destory了\n         所以在Demo中可以看到onReset里面调用了onStopLoading去取消当前任务，同时释放资源，取消广播注册*/\n    }\n\n    @Override\n    public void onCanceled(List<AppEntry> apps) {\n         /* Called if the task was canceled before it was completed.  Gives the class a chance\n          to clean up post-cancellation and to properly dispose of the result.\n         \n          @param data The value that was returned by {@link #loadInBackground}, or null\n          if the task threw {@link OperationCanceledException}.*/\n        //在这里释放资源\n    }\n\n    @Override\n    public void forceLoad() {\n        /*Force an asynchronous load. Unlike {@link #startLoading()} this will ignore a previously\n        loaded data set and load a new one.  This simply calls through to the\n        implementation's {@link #onForceLoad()}.  You generally should only call this\n        when the loader is started -- that is, {@link #isStarted()} returns true.\n        Must be called from the process's main thread.*/\n        //startLoading会直接使用onConfigurationchange之前的Activity中Loader加载的数据，但这里则放弃旧的数据，重新加载，所以isStarted会在这时返回true\n    }\n```\n考虑一下，如果在加载数据过程中数据源发生了变化，比如在扫描已安装App过程中又安装了新的App怎么办？所以这里又注册了两个广播，在onReceive的时候调用\n>     mLoader.onContentChanged();\n//这会直接调用forceLoad（Loader已经started）或者设置一个标志位，让takeContentChanged（）返回true\n> 在onStartLoading中发现这个为true，直接forceLoad\n//接下来进入loadInBackground,完成后进入deliverResult\ndeliverResult首先检查Activity是否destoryed(挂了直接释放资源),没挂的话判断下isStarted(是否一切正常，未调用过stopLoading或reset)，符合条件的话通过super.deliverResult把数据传递出去。接下来判断下之前的旧数据和新数据是否一致，否则释放掉旧数据\n\n整个过程考虑到了数据的有效性，资源的释放，在Loader这一端，通过isReset,isStarted等方法确保了不确定的数据加载过程能够和不确定的生命周期和谐共处。\n网上看到的关于Loader的文章大部分是关于CursorLoader的，也就是和数据库打交道的那一块，这里不细说。主要是目前没有看到太多App中使用这种加载模式，可能确实有点麻烦。在Medium上看到这篇文章，觉得还是有必要做一些记录的。\n\n### 4. 关于性能\n最后我想说的是，AsyncTaskLoader内部使用的还是AsyncTask那一套，关于AsyncTask的串行和并行的讨论网上有很多。于是我看了下AsyncTaskLoader中最终调用AsyncTask的execute方法:\n>  mTask.executeOnExecutor(mExecutor, (Void[]) null);\n\n至于这个mExecutor的本质:\n\n> public static final Executor THREAD_POOL_EXECUTOR\n            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,\n                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); \nCORE_POOL_SIZE = 5\n嗯，并行的线程池，性能应该还不错。\n学过rxjava，是否rxjava会是一种比loader更好的加载数据的方式呢\n\n### Reference\n\n1. [rxLoader](http://huxian99.github.io/2015/10/28/RxJava%E7%9A%84Android%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF-RxJava%E5%AE%9E%E6%88%98-%E4%BA%8C/)\n2. [making loading data on android lifecycle aware](https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.btjs9ady6)\n3. [AppListLoader](https://github.com/alexjlockwood/adp-applistloader)","source":"_posts/2016-10-15-using-loader-in-android-app.md","raw":"---\ntitle: 使用Loader进行异步数据操作\ndate: 2016-10-15 19:12:22\ncategories: blog  \ntags: [android]\n---\nApp中经常有这样的需求:\n进入一个页面，首先查询数据库，如果数据库数据有效，直接使用数据库数据。否则去网络查询数据，网络数据返回后重新加载数据。\n很显然，这里的查询数据库和网络请求都需要放到子线程去操作，异步了。android推荐使用Loader进行数据查询，最大的好处就是Laoder会处理好与生命周期相关的事情，Android Developers推出过关于Loaders的[介绍视频](https://www.youtube.com/watch?v=s4eAtMHU5gI&index=8&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)，Loader就是为了解决这种问题而推出的，Loader具有几点好处\n1. 如果Activity挂掉了，Activity中启动了的线程怎么办，如果不处理好有可能导致leak。\n2. activity挂了，而子线程中持有View的强引用，此时再去更新View已经没有意义，View已经不可见了\n3. 这条线程所做的工作，加载的资源都白白浪费了，下次还需要重新加载一遍。\n<!--more-->\n\n### 1. 自定义一个Loader(加载数据类型，Cache处理等)\nLoader的使用就像一个AsyncTask一样，可以提前指定需要在异步线程中做的事情、数据类型以及完成加载后将数据推送到主线程。谷歌给出了一个使用Loader来查询手机上安装的App并显示在一个ListView中的DemoApp，虽然是好几年前的东西了，并且使用的是V4包里的Loader,但还是值得学习。\n首先来看自定义的AppListLoader\n\n```java\npublic class AppListLoader extends AsyncTaskLoader<List<AppEntry>> { //AsynTaskLoader支持泛型，AppEntry是已安装App信息的包装类。\n    private List<AppEntry> mApps;\n    //查询的App列表保存为成员变量\n    final PackageManager mPm;\n    private boolean DEBUG = true;\n    public static final String TAG = AppListLoader.class.getSimpleName();\n\n    //构造函数\n    public AppListLoader(Context ctx) {\n        // Loaders may be used across multiple Activitys (assuming they aren't\n        // bound to the LoaderManager), so NEVER hold a reference to the context\n        // directly. Doing so will cause you to leak an entire Activity's context.\n        // The superclass constructor will store a reference to the Application\n        // Context instead, and can be retrieved with a call to getContext().\n        super(ctx);\n        //第一，这里运行在主线程上；\n        //第二，传进来的context(一般是Activity只是为了获取ApplicationContext)\n        mPm = getContext().getPackageManager();//getContext()返回的是Application的Context。\n    }\n\n    @Override\n    public List<AppEntry> loadInBackground() {\n        if (DEBUG) Log.i(TAG, \"+++ loadInBackground() called! +++\");\n        LogUtil.p(\"\");// 子线程,耗时的工作放到这里\n        // Retrieve all installed applications.\n        List<ApplicationInfo> apps = mPm.getInstalledApplications(0);//PackageManager的方法\n        if (apps == null) {\n            apps = new ArrayList<ApplicationInfo>();\n        }\n        // Create corresponding array of entries and load their labels.\n        List<AppEntry> entries = new ArrayList<AppEntry>(apps.size());\n        for (int i = 0; i < apps.size(); i++) {\n            AppEntry entry = new AppEntry(this, apps.get(i));\n            entry.loadLabel(getContext());\n            entries.add(entry);\n        }\n        // Sort the list.\n        Collections.sort(entries, ALPHA_COMPARATOR);\n        return entries;\n    }\n\n    @Override\n    public void deliverResult(List<AppEntry> apps) {\n        //运行在主线程上\n        if (isReset()) {//这里就类似于AsyncTask的onPostExecute了，把子线程处理好的数据推送到主线程\n            if (DEBUG)\n                Log.w(TAG, \"+++ Warning! An async query came in while the Loader was reset! +++\");\n            // The Loader has been reset; ignore the result and invalidate the data.\n            // This can happen when the Loader is reset while an asynchronous query\n            // is working in the background. That is, when the background thread\n            // finishes its work and attempts to deliver the results to the client,\n            // it will see here that the Loader has been reset and discard any\n            // resources associated with the new data as necessary.\n            if (apps != null) {\n                releaseResources(apps);\n                return;\n            }\n        }//如果调用了reset()方法，说明子线程加载的数据是无效的，释放资源，处理无效数据\n        // Hold a reference to the old data so it doesn't get garbage collected.\n        // We must protect it until the new data has been delivered.\n        List<AppEntry> oldApps = mApps;\n        mApps = apps;\n        if (isStarted()) {// 如果一切正常，即调用了startLoading且stopLoading和reset均为被调用\n            if (DEBUG) Log.i(TAG, \"+++ Delivering results to the LoaderManager for\" +\n                    \" the ListFragment to display! +++\");\n            // If the Loader is in a started state, have the superclass deliver the\n            // results to the client.\n            super.deliverResult(apps);\n        }\n        // Invalidate the old data as we don't need it any more.\n        if (oldApps != null && oldApps != apps) {\n            if (DEBUG) Log.i(TAG, \"+++ Releasing any old data associated with this Loader. +++\");\n            releaseResources(oldApps);\n        }\n    }\n}\n```\n到此，数据加载的Server端算是完成，这里注意调用到了isReset()、isStarted()等方法，这些就是Server端在在处理Client端生命周期是需要注意的，这个后面再说。\n\n### 2. 使用LoaderManager管理Loader\n我们使用LoaderManager在Activity或Fragment中与Loader交互。通常在onCreate或者onActivityCreated中:\n> getSupportedLoaderManager.initLoader()//Activity中\n> getLoaderManager() //Fragment中\n\n这里介绍在Fragment中的使用，因为Loader处理好了与Activity,Fragment甚至Child Fragment的生命周期。\n推荐使用v4包里的Loader，Loader是在Android3.0引入FrameWork中的，但v4包让Loadder在更早的版本上也有相应的API。更重要的是，v4 包中的Loader是伴随着v4包新的release step，也就是说v4包会与时俱进修复其中的bug。\n这一点在medium上有[介绍](https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.wrh1ciyts) 。\n再看一下这个方法\n>  public abstract <D> Loader<D> initLoader(int id, Bundle args,\n            LoaderManager.LoaderCallbacks<D> callback);\n\t\t\t\n\nDemo中使用的是Fragment：\n>  // Initialize a Loader with id '1'. If the Loader with this id already\n            // exists, then the LoaderManager will reuse the existing Loader.\n            getLoaderManager().initLoader(LOADER_ID, null, this);\t\t\t\n\t\t\t\n相对应的Fragment需要implements  LoaderManager.LoaderCallbacks<List<AppEntry>> //注意泛型\n这个接口有三个方法\n```java\n public interface LoaderCallbacks<D> {\n       \n        public Loader<D> onCreateLoader(int id, Bundle args);\n\n       \n        public void onLoadFinished(Loader<D> loader, D data);\n\n       \n        public void onLoaderReset(Loader<D> loader);\n    }\n```\t\t\t\n看一下Demo中是如何实现的\n```java\n   @Override\n        public android.support.v4.content.Loader<List<AppEntry>> onCreateLoader(int id, Bundle args) {\n            if (DEBUG) Log.i(TAG, \"+++ onCreateLoader() called! +++\");\n            return new AppListLoader(getActivity());\n        }\n\n        @Override\n        public void onLoadFinished(android.support.v4.content.Loader<List<AppEntry>> loader, List<AppEntry> data) {\n            if (DEBUG) Log.i(TAG, \"+++ onLoadFinished() called! +++\");\n            mAdapter.setData(data);//加载数据到UI\n\n            if (isResumed()) {\n                setListShown(true);\n            } else {\n                setListShownNoAnimation(true);\n            } \n        }\n\n        @Override\n        public void onLoaderReset(android.support.v4.content.Loader<List<AppEntry>> loader) {\n            if (DEBUG) Log.i(TAG, \"+++ onLoadReset() called! +++\");\n            mAdapter.setData(null);//loader被reset，UI这边需要清除所有与Loader数据相关的引用，但清除数据的任务会由Loader处理好\n        }\n```\n在三个明显的回调中处理好数据绑定到UI及过期数据的清理即可。\n\n### 3. 处理Activity生命周期的问题\n回到server端(Loader),AsyncTaskLoader是一个abstract class，loadInBackground方法已经实现了，但还有几个方法强调必须要复写或者与生命周期相关\n```java\n @Override\n    protected void onStartLoading() {\n        /* Subclasses must implement this to take care of loading their data,\n          as per {@link #startLoading()}.  This is not called by clients directly,\n          but as a result of a call to {@link #startLoading()}.*/\n        //在这里检查一下成员变量中的数据是否不为空，有数据的话，deliverResults\n    }\n\n    @Override\n    protected void onStopLoading() {\n          /*Subclasses must implement this to take care of stopping their loader,\n          as per {@link #stopLoading()}.  This is not called by clients directly,\n          but as a result of a call to {@link #stopLoading()}.\n          This will always be called from the process's main thread.*/\n    }\n\n    @Override\n    protected void onReset() {\n        /* Subclasses must implement this to take care of resetting their loader,\n         as per {@link #reset()}.  This is not called by clients directly,\n         but as a result of a call to {@link #reset()}.\n         This will always be called from the process's main thread.\n         如果调用了destoryLoader或者Loader相关联的Activity/Fragment被destory了\n         所以在Demo中可以看到onReset里面调用了onStopLoading去取消当前任务，同时释放资源，取消广播注册*/\n    }\n\n    @Override\n    public void onCanceled(List<AppEntry> apps) {\n         /* Called if the task was canceled before it was completed.  Gives the class a chance\n          to clean up post-cancellation and to properly dispose of the result.\n         \n          @param data The value that was returned by {@link #loadInBackground}, or null\n          if the task threw {@link OperationCanceledException}.*/\n        //在这里释放资源\n    }\n\n    @Override\n    public void forceLoad() {\n        /*Force an asynchronous load. Unlike {@link #startLoading()} this will ignore a previously\n        loaded data set and load a new one.  This simply calls through to the\n        implementation's {@link #onForceLoad()}.  You generally should only call this\n        when the loader is started -- that is, {@link #isStarted()} returns true.\n        Must be called from the process's main thread.*/\n        //startLoading会直接使用onConfigurationchange之前的Activity中Loader加载的数据，但这里则放弃旧的数据，重新加载，所以isStarted会在这时返回true\n    }\n```\n考虑一下，如果在加载数据过程中数据源发生了变化，比如在扫描已安装App过程中又安装了新的App怎么办？所以这里又注册了两个广播，在onReceive的时候调用\n>     mLoader.onContentChanged();\n//这会直接调用forceLoad（Loader已经started）或者设置一个标志位，让takeContentChanged（）返回true\n> 在onStartLoading中发现这个为true，直接forceLoad\n//接下来进入loadInBackground,完成后进入deliverResult\ndeliverResult首先检查Activity是否destoryed(挂了直接释放资源),没挂的话判断下isStarted(是否一切正常，未调用过stopLoading或reset)，符合条件的话通过super.deliverResult把数据传递出去。接下来判断下之前的旧数据和新数据是否一致，否则释放掉旧数据\n\n整个过程考虑到了数据的有效性，资源的释放，在Loader这一端，通过isReset,isStarted等方法确保了不确定的数据加载过程能够和不确定的生命周期和谐共处。\n网上看到的关于Loader的文章大部分是关于CursorLoader的，也就是和数据库打交道的那一块，这里不细说。主要是目前没有看到太多App中使用这种加载模式，可能确实有点麻烦。在Medium上看到这篇文章，觉得还是有必要做一些记录的。\n\n### 4. 关于性能\n最后我想说的是，AsyncTaskLoader内部使用的还是AsyncTask那一套，关于AsyncTask的串行和并行的讨论网上有很多。于是我看了下AsyncTaskLoader中最终调用AsyncTask的execute方法:\n>  mTask.executeOnExecutor(mExecutor, (Void[]) null);\n\n至于这个mExecutor的本质:\n\n> public static final Executor THREAD_POOL_EXECUTOR\n            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,\n                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); \nCORE_POOL_SIZE = 5\n嗯，并行的线程池，性能应该还不错。\n学过rxjava，是否rxjava会是一种比loader更好的加载数据的方式呢\n\n### Reference\n\n1. [rxLoader](http://huxian99.github.io/2015/10/28/RxJava%E7%9A%84Android%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF-RxJava%E5%AE%9E%E6%88%98-%E4%BA%8C/)\n2. [making loading data on android lifecycle aware](https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.btjs9ady6)\n3. [AppListLoader](https://github.com/alexjlockwood/adp-applistloader)","slug":"2016-10-15-using-loader-in-android-app","published":1,"updated":"2017-04-23T10:50:17.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnft0005bovrncyjp95g","content":"<p>App中经常有这样的需求:<br>进入一个页面，首先查询数据库，如果数据库数据有效，直接使用数据库数据。否则去网络查询数据，网络数据返回后重新加载数据。<br>很显然，这里的查询数据库和网络请求都需要放到子线程去操作，异步了。android推荐使用Loader进行数据查询，最大的好处就是Laoder会处理好与生命周期相关的事情，Android Developers推出过关于Loaders的<a href=\"https://www.youtube.com/watch?v=s4eAtMHU5gI&amp;index=8&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE\">介绍视频</a>，Loader就是为了解决这种问题而推出的，Loader具有几点好处</p>\n<ol>\n<li>如果Activity挂掉了，Activity中启动了的线程怎么办，如果不处理好有可能导致leak。</li>\n<li>activity挂了，而子线程中持有View的强引用，此时再去更新View已经没有意义，View已经不可见了</li>\n<li>这条线程所做的工作，加载的资源都白白浪费了，下次还需要重新加载一遍。<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"1-自定义一个Loader-加载数据类型，Cache处理等\"><a href=\"#1-自定义一个Loader-加载数据类型，Cache处理等\" class=\"headerlink\" title=\"1. 自定义一个Loader(加载数据类型，Cache处理等)\"></a>1. 自定义一个Loader(加载数据类型，Cache处理等)</h3><p>Loader的使用就像一个AsyncTask一样，可以提前指定需要在异步线程中做的事情、数据类型以及完成加载后将数据推送到主线程。谷歌给出了一个使用Loader来查询手机上安装的App并显示在一个ListView中的DemoApp，虽然是好几年前的东西了，并且使用的是V4包里的Loader,但还是值得学习。<br>首先来看自定义的AppListLoader</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppListLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTaskLoader</span>&lt;<span class=\"title\">List</span>&lt;<span class=\"title\">AppEntry</span>&gt;&gt; </span>&#123; <span class=\"comment\">//AsynTaskLoader支持泛型，AppEntry是已安装App信息的包装类。</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;AppEntry&gt; mApps;</div><div class=\"line\">    <span class=\"comment\">//查询的App列表保存为成员变量</span></div><div class=\"line\">    <span class=\"keyword\">final</span> PackageManager mPm;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> DEBUG = <span class=\"keyword\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = AppListLoader.class.getSimpleName();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppListLoader</span><span class=\"params\">(Context ctx)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Loaders may be used across multiple Activitys (assuming they aren't</span></div><div class=\"line\">        <span class=\"comment\">// bound to the LoaderManager), so NEVER hold a reference to the context</span></div><div class=\"line\">        <span class=\"comment\">// directly. Doing so will cause you to leak an entire Activity's context.</span></div><div class=\"line\">        <span class=\"comment\">// The superclass constructor will store a reference to the Application</span></div><div class=\"line\">        <span class=\"comment\">// Context instead, and can be retrieved with a call to getContext().</span></div><div class=\"line\">        <span class=\"keyword\">super</span>(ctx);</div><div class=\"line\">        <span class=\"comment\">//第一，这里运行在主线程上；</span></div><div class=\"line\">        <span class=\"comment\">//第二，传进来的context(一般是Activity只是为了获取ApplicationContext)</span></div><div class=\"line\">        mPm = getContext().getPackageManager();<span class=\"comment\">//getContext()返回的是Application的Context。</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;AppEntry&gt; <span class=\"title\">loadInBackground</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ loadInBackground() called! +++\"</span>);</div><div class=\"line\">        LogUtil.p(<span class=\"string\">\"\"</span>);<span class=\"comment\">// 子线程,耗时的工作放到这里</span></div><div class=\"line\">        <span class=\"comment\">// Retrieve all installed applications.</span></div><div class=\"line\">        List&lt;ApplicationInfo&gt; apps = mPm.getInstalledApplications(<span class=\"number\">0</span>);<span class=\"comment\">//PackageManager的方法</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (apps == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            apps = <span class=\"keyword\">new</span> ArrayList&lt;ApplicationInfo&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Create corresponding array of entries and load their labels.</span></div><div class=\"line\">        List&lt;AppEntry&gt; entries = <span class=\"keyword\">new</span> ArrayList&lt;AppEntry&gt;(apps.size());</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; apps.size(); i++) &#123;</div><div class=\"line\">            AppEntry entry = <span class=\"keyword\">new</span> AppEntry(<span class=\"keyword\">this</span>, apps.get(i));</div><div class=\"line\">            entry.loadLabel(getContext());</div><div class=\"line\">            entries.add(entry);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Sort the list.</span></div><div class=\"line\">        Collections.sort(entries, ALPHA_COMPARATOR);</div><div class=\"line\">        <span class=\"keyword\">return</span> entries;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResult</span><span class=\"params\">(List&lt;AppEntry&gt; apps)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//运行在主线程上</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (isReset()) &#123;<span class=\"comment\">//这里就类似于AsyncTask的onPostExecute了，把子线程处理好的数据推送到主线程</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG)</div><div class=\"line\">                Log.w(TAG, <span class=\"string\">\"+++ Warning! An async query came in while the Loader was reset! +++\"</span>);</div><div class=\"line\">            <span class=\"comment\">// The Loader has been reset; ignore the result and invalidate the data.</span></div><div class=\"line\">            <span class=\"comment\">// This can happen when the Loader is reset while an asynchronous query</span></div><div class=\"line\">            <span class=\"comment\">// is working in the background. That is, when the background thread</span></div><div class=\"line\">            <span class=\"comment\">// finishes its work and attempts to deliver the results to the client,</span></div><div class=\"line\">            <span class=\"comment\">// it will see here that the Loader has been reset and discard any</span></div><div class=\"line\">            <span class=\"comment\">// resources associated with the new data as necessary.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (apps != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                releaseResources(apps);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;<span class=\"comment\">//如果调用了reset()方法，说明子线程加载的数据是无效的，释放资源，处理无效数据</span></div><div class=\"line\">        <span class=\"comment\">// Hold a reference to the old data so it doesn't get garbage collected.</span></div><div class=\"line\">        <span class=\"comment\">// We must protect it until the new data has been delivered.</span></div><div class=\"line\">        List&lt;AppEntry&gt; oldApps = mApps;</div><div class=\"line\">        mApps = apps;</div><div class=\"line\">        <span class=\"keyword\">if</span> (isStarted()) &#123;<span class=\"comment\">// 如果一切正常，即调用了startLoading且stopLoading和reset均为被调用</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ Delivering results to the LoaderManager for\"</span> +</div><div class=\"line\">                    <span class=\"string\">\" the ListFragment to display! +++\"</span>);</div><div class=\"line\">            <span class=\"comment\">// If the Loader is in a started state, have the superclass deliver the</span></div><div class=\"line\">            <span class=\"comment\">// results to the client.</span></div><div class=\"line\">            <span class=\"keyword\">super</span>.deliverResult(apps);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Invalidate the old data as we don't need it any more.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (oldApps != <span class=\"keyword\">null</span> &amp;&amp; oldApps != apps) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ Releasing any old data associated with this Loader. +++\"</span>);</div><div class=\"line\">            releaseResources(oldApps);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到此，数据加载的Server端算是完成，这里注意调用到了isReset()、isStarted()等方法，这些就是Server端在在处理Client端生命周期是需要注意的，这个后面再说。</p>\n<h3 id=\"2-使用LoaderManager管理Loader\"><a href=\"#2-使用LoaderManager管理Loader\" class=\"headerlink\" title=\"2. 使用LoaderManager管理Loader\"></a>2. 使用LoaderManager管理Loader</h3><p>我们使用LoaderManager在Activity或Fragment中与Loader交互。通常在onCreate或者onActivityCreated中:</p>\n<blockquote>\n<p>getSupportedLoaderManager.initLoader()//Activity中<br>getLoaderManager() //Fragment中</p>\n</blockquote>\n<p>这里介绍在Fragment中的使用，因为Loader处理好了与Activity,Fragment甚至Child Fragment的生命周期。<br>推荐使用v4包里的Loader，Loader是在Android3.0引入FrameWork中的，但v4包让Loadder在更早的版本上也有相应的API。更重要的是，v4 包中的Loader是伴随着v4包新的release step，也就是说v4包会与时俱进修复其中的bug。<br>这一点在medium上有<a href=\"https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.wrh1ciyts\">介绍</a> 。<br>再看一下这个方法</p>\n<blockquote>\n<p> public abstract <D> Loader<D> initLoader(int id, Bundle args,<br>            LoaderManager.LoaderCallbacks<D> callback);</p>\n</blockquote>\n<p>Demo中使用的是Fragment：</p>\n<blockquote>\n<p> // Initialize a Loader with id ‘1’. If the Loader with this id already<br>            // exists, then the LoaderManager will reuse the existing Loader.<br>            getLoaderManager().initLoader(LOADER_ID, null, this);            </p>\n</blockquote>\n<p>相对应的Fragment需要implements  LoaderManager.LoaderCallbacks<List<AppEntry>&gt; //注意泛型<br>这个接口有三个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LoaderCallbacks</span>&lt;<span class=\"title\">D</span>&gt; </span>&#123;</div><div class=\"line\">       </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Loader&lt;D&gt; <span class=\"title\">onCreateLoader</span><span class=\"params\">(<span class=\"keyword\">int</span> id, Bundle args)</span></span>;</div><div class=\"line\"></div><div class=\"line\">       </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadFinished</span><span class=\"params\">(Loader&lt;D&gt; loader, D data)</span></span>;</div><div class=\"line\"></div><div class=\"line\">       </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoaderReset</span><span class=\"params\">(Loader&lt;D&gt; loader)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">```\t\t\t</div><div class=\"line\">看一下Demo中是如何实现的</div><div class=\"line\">```java</div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"keyword\">public</span> android.support.v4.content.Loader&lt;List&lt;AppEntry&gt;&gt; onCreateLoader(<span class=\"keyword\">int</span> id, Bundle args) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ onCreateLoader() called! +++\"</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppListLoader(getActivity());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadFinished</span><span class=\"params\">(android.support.v4.content.Loader&lt;List&lt;AppEntry&gt;&gt; loader, List&lt;AppEntry&gt; data)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ onLoadFinished() called! +++\"</span>);</div><div class=\"line\">            mAdapter.setData(data);<span class=\"comment\">//加载数据到UI</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (isResumed()) &#123;</div><div class=\"line\">                setListShown(<span class=\"keyword\">true</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                setListShownNoAnimation(<span class=\"keyword\">true</span>);</div><div class=\"line\">            &#125; </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoaderReset</span><span class=\"params\">(android.support.v4.content.Loader&lt;List&lt;AppEntry&gt;&gt; loader)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ onLoadReset() called! +++\"</span>);</div><div class=\"line\">            mAdapter.setData(<span class=\"keyword\">null</span>);<span class=\"comment\">//loader被reset，UI这边需要清除所有与Loader数据相关的引用，但清除数据的任务会由Loader处理好</span></div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>在三个明显的回调中处理好数据绑定到UI及过期数据的清理即可。</p>\n<h3 id=\"3-处理Activity生命周期的问题\"><a href=\"#3-处理Activity生命周期的问题\" class=\"headerlink\" title=\"3. 处理Activity生命周期的问题\"></a>3. 处理Activity生命周期的问题</h3><p>回到server端(Loader),AsyncTaskLoader是一个abstract class，loadInBackground方法已经实现了，但还有几个方法强调必须要复写或者与生命周期相关<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartLoading</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">/* Subclasses must implement this to take care of loading their data,</div><div class=\"line\">         as per &#123;@link #startLoading()&#125;.  This is not called by clients directly,</div><div class=\"line\">         but as a result of a call to &#123;@link #startLoading()&#125;.*/</span></div><div class=\"line\">       <span class=\"comment\">//在这里检查一下成员变量中的数据是否不为空，有数据的话，deliverResults</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStopLoading</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">/*Subclasses must implement this to take care of stopping their loader,</div><div class=\"line\">         as per &#123;@link #stopLoading()&#125;.  This is not called by clients directly,</div><div class=\"line\">         but as a result of a call to &#123;@link #stopLoading()&#125;.</div><div class=\"line\">         This will always be called from the process's main thread.*/</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onReset</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">/* Subclasses must implement this to take care of resetting their loader,</div><div class=\"line\">        as per &#123;@link #reset()&#125;.  This is not called by clients directly,</div><div class=\"line\">        but as a result of a call to &#123;@link #reset()&#125;.</div><div class=\"line\">        This will always be called from the process's main thread.</div><div class=\"line\">        如果调用了destoryLoader或者Loader相关联的Activity/Fragment被destory了</div><div class=\"line\">        所以在Demo中可以看到onReset里面调用了onStopLoading去取消当前任务，同时释放资源，取消广播注册*/</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCanceled</span><span class=\"params\">(List&lt;AppEntry&gt; apps)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">/* Called if the task was canceled before it was completed.  Gives the class a chance</div><div class=\"line\">         to clean up post-cancellation and to properly dispose of the result.</div><div class=\"line\">        </div><div class=\"line\">         @param data The value that was returned by &#123;@link #loadInBackground&#125;, or null</div><div class=\"line\">         if the task threw &#123;@link OperationCanceledException&#125;.*/</span></div><div class=\"line\">       <span class=\"comment\">//在这里释放资源</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forceLoad</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">/*Force an asynchronous load. Unlike &#123;@link #startLoading()&#125; this will ignore a previously</div><div class=\"line\">       loaded data set and load a new one.  This simply calls through to the</div><div class=\"line\">       implementation's &#123;@link #onForceLoad()&#125;.  You generally should only call this</div><div class=\"line\">       when the loader is started -- that is, &#123;@link #isStarted()&#125; returns true.</div><div class=\"line\">       Must be called from the process's main thread.*/</span></div><div class=\"line\">       <span class=\"comment\">//startLoading会直接使用onConfigurationchange之前的Activity中Loader加载的数据，但这里则放弃旧的数据，重新加载，所以isStarted会在这时返回true</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>考虑一下，如果在加载数据过程中数据源发生了变化，比如在扫描已安装App过程中又安装了新的App怎么办？所以这里又注册了两个广播，在onReceive的时候调用</p>\n<blockquote>\n<pre><code>mLoader.onContentChanged();\n</code></pre><p>//这会直接调用forceLoad（Loader已经started）或者设置一个标志位，让takeContentChanged（）返回true<br>在onStartLoading中发现这个为true，直接forceLoad<br>//接下来进入loadInBackground,完成后进入deliverResult<br>deliverResult首先检查Activity是否destoryed(挂了直接释放资源),没挂的话判断下isStarted(是否一切正常，未调用过stopLoading或reset)，符合条件的话通过super.deliverResult把数据传递出去。接下来判断下之前的旧数据和新数据是否一致，否则释放掉旧数据</p>\n</blockquote>\n<p>整个过程考虑到了数据的有效性，资源的释放，在Loader这一端，通过isReset,isStarted等方法确保了不确定的数据加载过程能够和不确定的生命周期和谐共处。<br>网上看到的关于Loader的文章大部分是关于CursorLoader的，也就是和数据库打交道的那一块，这里不细说。主要是目前没有看到太多App中使用这种加载模式，可能确实有点麻烦。在Medium上看到这篇文章，觉得还是有必要做一些记录的。</p>\n<h3 id=\"4-关于性能\"><a href=\"#4-关于性能\" class=\"headerlink\" title=\"4. 关于性能\"></a>4. 关于性能</h3><p>最后我想说的是，AsyncTaskLoader内部使用的还是AsyncTask那一套，关于AsyncTask的串行和并行的讨论网上有很多。于是我看了下AsyncTaskLoader中最终调用AsyncTask的execute方法:</p>\n<blockquote>\n<p> mTask.executeOnExecutor(mExecutor, (Void[]) null);</p>\n</blockquote>\n<p>至于这个mExecutor的本质:</p>\n<blockquote>\n<p>public static final Executor THREAD_POOL_EXECUTOR<br>            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,<br>                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);<br>CORE_POOL_SIZE = 5<br>嗯，并行的线程池，性能应该还不错。<br>学过rxjava，是否rxjava会是一种比loader更好的加载数据的方式呢</p>\n</blockquote>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://huxian99.github.io/2015/10/28/RxJava%E7%9A%84Android%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF-RxJava%E5%AE%9E%E6%88%98-%E4%BA%8C/\">rxLoader</a></li>\n<li><a href=\"https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.btjs9ady6\">making loading data on android lifecycle aware</a></li>\n<li><a href=\"https://github.com/alexjlockwood/adp-applistloader\">AppListLoader</a></li>\n</ol>\n","excerpt":"<p>App中经常有这样的需求:<br>进入一个页面，首先查询数据库，如果数据库数据有效，直接使用数据库数据。否则去网络查询数据，网络数据返回后重新加载数据。<br>很显然，这里的查询数据库和网络请求都需要放到子线程去操作，异步了。android推荐使用Loader进行数据查询，最大的好处就是Laoder会处理好与生命周期相关的事情，Android Developers推出过关于Loaders的<a href=\"https://www.youtube.com/watch?v=s4eAtMHU5gI&amp;index=8&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE\">介绍视频</a>，Loader就是为了解决这种问题而推出的，Loader具有几点好处</p>\n<ol>\n<li>如果Activity挂掉了，Activity中启动了的线程怎么办，如果不处理好有可能导致leak。</li>\n<li>activity挂了，而子线程中持有View的强引用，此时再去更新View已经没有意义，View已经不可见了</li>\n<li>这条线程所做的工作，加载的资源都白白浪费了，下次还需要重新加载一遍。","more":"</li>\n</ol>\n<h3 id=\"1-自定义一个Loader-加载数据类型，Cache处理等\"><a href=\"#1-自定义一个Loader-加载数据类型，Cache处理等\" class=\"headerlink\" title=\"1. 自定义一个Loader(加载数据类型，Cache处理等)\"></a>1. 自定义一个Loader(加载数据类型，Cache处理等)</h3><p>Loader的使用就像一个AsyncTask一样，可以提前指定需要在异步线程中做的事情、数据类型以及完成加载后将数据推送到主线程。谷歌给出了一个使用Loader来查询手机上安装的App并显示在一个ListView中的DemoApp，虽然是好几年前的东西了，并且使用的是V4包里的Loader,但还是值得学习。<br>首先来看自定义的AppListLoader</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppListLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTaskLoader</span>&lt;<span class=\"title\">List</span>&lt;<span class=\"title\">AppEntry</span>&gt;&gt; </span>&#123; <span class=\"comment\">//AsynTaskLoader支持泛型，AppEntry是已安装App信息的包装类。</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;AppEntry&gt; mApps;</div><div class=\"line\">    <span class=\"comment\">//查询的App列表保存为成员变量</span></div><div class=\"line\">    <span class=\"keyword\">final</span> PackageManager mPm;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> DEBUG = <span class=\"keyword\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = AppListLoader.class.getSimpleName();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppListLoader</span><span class=\"params\">(Context ctx)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Loaders may be used across multiple Activitys (assuming they aren't</span></div><div class=\"line\">        <span class=\"comment\">// bound to the LoaderManager), so NEVER hold a reference to the context</span></div><div class=\"line\">        <span class=\"comment\">// directly. Doing so will cause you to leak an entire Activity's context.</span></div><div class=\"line\">        <span class=\"comment\">// The superclass constructor will store a reference to the Application</span></div><div class=\"line\">        <span class=\"comment\">// Context instead, and can be retrieved with a call to getContext().</span></div><div class=\"line\">        <span class=\"keyword\">super</span>(ctx);</div><div class=\"line\">        <span class=\"comment\">//第一，这里运行在主线程上；</span></div><div class=\"line\">        <span class=\"comment\">//第二，传进来的context(一般是Activity只是为了获取ApplicationContext)</span></div><div class=\"line\">        mPm = getContext().getPackageManager();<span class=\"comment\">//getContext()返回的是Application的Context。</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;AppEntry&gt; <span class=\"title\">loadInBackground</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ loadInBackground() called! +++\"</span>);</div><div class=\"line\">        LogUtil.p(<span class=\"string\">\"\"</span>);<span class=\"comment\">// 子线程,耗时的工作放到这里</span></div><div class=\"line\">        <span class=\"comment\">// Retrieve all installed applications.</span></div><div class=\"line\">        List&lt;ApplicationInfo&gt; apps = mPm.getInstalledApplications(<span class=\"number\">0</span>);<span class=\"comment\">//PackageManager的方法</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (apps == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            apps = <span class=\"keyword\">new</span> ArrayList&lt;ApplicationInfo&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Create corresponding array of entries and load their labels.</span></div><div class=\"line\">        List&lt;AppEntry&gt; entries = <span class=\"keyword\">new</span> ArrayList&lt;AppEntry&gt;(apps.size());</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; apps.size(); i++) &#123;</div><div class=\"line\">            AppEntry entry = <span class=\"keyword\">new</span> AppEntry(<span class=\"keyword\">this</span>, apps.get(i));</div><div class=\"line\">            entry.loadLabel(getContext());</div><div class=\"line\">            entries.add(entry);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Sort the list.</span></div><div class=\"line\">        Collections.sort(entries, ALPHA_COMPARATOR);</div><div class=\"line\">        <span class=\"keyword\">return</span> entries;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResult</span><span class=\"params\">(List&lt;AppEntry&gt; apps)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//运行在主线程上</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (isReset()) &#123;<span class=\"comment\">//这里就类似于AsyncTask的onPostExecute了，把子线程处理好的数据推送到主线程</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG)</div><div class=\"line\">                Log.w(TAG, <span class=\"string\">\"+++ Warning! An async query came in while the Loader was reset! +++\"</span>);</div><div class=\"line\">            <span class=\"comment\">// The Loader has been reset; ignore the result and invalidate the data.</span></div><div class=\"line\">            <span class=\"comment\">// This can happen when the Loader is reset while an asynchronous query</span></div><div class=\"line\">            <span class=\"comment\">// is working in the background. That is, when the background thread</span></div><div class=\"line\">            <span class=\"comment\">// finishes its work and attempts to deliver the results to the client,</span></div><div class=\"line\">            <span class=\"comment\">// it will see here that the Loader has been reset and discard any</span></div><div class=\"line\">            <span class=\"comment\">// resources associated with the new data as necessary.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (apps != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                releaseResources(apps);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;<span class=\"comment\">//如果调用了reset()方法，说明子线程加载的数据是无效的，释放资源，处理无效数据</span></div><div class=\"line\">        <span class=\"comment\">// Hold a reference to the old data so it doesn't get garbage collected.</span></div><div class=\"line\">        <span class=\"comment\">// We must protect it until the new data has been delivered.</span></div><div class=\"line\">        List&lt;AppEntry&gt; oldApps = mApps;</div><div class=\"line\">        mApps = apps;</div><div class=\"line\">        <span class=\"keyword\">if</span> (isStarted()) &#123;<span class=\"comment\">// 如果一切正常，即调用了startLoading且stopLoading和reset均为被调用</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ Delivering results to the LoaderManager for\"</span> +</div><div class=\"line\">                    <span class=\"string\">\" the ListFragment to display! +++\"</span>);</div><div class=\"line\">            <span class=\"comment\">// If the Loader is in a started state, have the superclass deliver the</span></div><div class=\"line\">            <span class=\"comment\">// results to the client.</span></div><div class=\"line\">            <span class=\"keyword\">super</span>.deliverResult(apps);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Invalidate the old data as we don't need it any more.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (oldApps != <span class=\"keyword\">null</span> &amp;&amp; oldApps != apps) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ Releasing any old data associated with this Loader. +++\"</span>);</div><div class=\"line\">            releaseResources(oldApps);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到此，数据加载的Server端算是完成，这里注意调用到了isReset()、isStarted()等方法，这些就是Server端在在处理Client端生命周期是需要注意的，这个后面再说。</p>\n<h3 id=\"2-使用LoaderManager管理Loader\"><a href=\"#2-使用LoaderManager管理Loader\" class=\"headerlink\" title=\"2. 使用LoaderManager管理Loader\"></a>2. 使用LoaderManager管理Loader</h3><p>我们使用LoaderManager在Activity或Fragment中与Loader交互。通常在onCreate或者onActivityCreated中:</p>\n<blockquote>\n<p>getSupportedLoaderManager.initLoader()//Activity中<br>getLoaderManager() //Fragment中</p>\n</blockquote>\n<p>这里介绍在Fragment中的使用，因为Loader处理好了与Activity,Fragment甚至Child Fragment的生命周期。<br>推荐使用v4包里的Loader，Loader是在Android3.0引入FrameWork中的，但v4包让Loadder在更早的版本上也有相应的API。更重要的是，v4 包中的Loader是伴随着v4包新的release step，也就是说v4包会与时俱进修复其中的bug。<br>这一点在medium上有<a href=\"https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.wrh1ciyts\">介绍</a> 。<br>再看一下这个方法</p>\n<blockquote>\n<p> public abstract <D> Loader<D> initLoader(int id, Bundle args,<br>            LoaderManager.LoaderCallbacks<D> callback);</p>\n</blockquote>\n<p>Demo中使用的是Fragment：</p>\n<blockquote>\n<p> // Initialize a Loader with id ‘1’. If the Loader with this id already<br>            // exists, then the LoaderManager will reuse the existing Loader.<br>            getLoaderManager().initLoader(LOADER_ID, null, this);            </p>\n</blockquote>\n<p>相对应的Fragment需要implements  LoaderManager.LoaderCallbacks<List<AppEntry>&gt; //注意泛型<br>这个接口有三个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LoaderCallbacks</span>&lt;<span class=\"title\">D</span>&gt; </span>&#123;</div><div class=\"line\">       </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Loader&lt;D&gt; <span class=\"title\">onCreateLoader</span><span class=\"params\">(<span class=\"keyword\">int</span> id, Bundle args)</span></span>;</div><div class=\"line\"></div><div class=\"line\">       </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadFinished</span><span class=\"params\">(Loader&lt;D&gt; loader, D data)</span></span>;</div><div class=\"line\"></div><div class=\"line\">       </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoaderReset</span><span class=\"params\">(Loader&lt;D&gt; loader)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">```\t\t\t</div><div class=\"line\">看一下Demo中是如何实现的</div><div class=\"line\">```java</div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"keyword\">public</span> android.support.v4.content.Loader&lt;List&lt;AppEntry&gt;&gt; onCreateLoader(<span class=\"keyword\">int</span> id, Bundle args) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ onCreateLoader() called! +++\"</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppListLoader(getActivity());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadFinished</span><span class=\"params\">(android.support.v4.content.Loader&lt;List&lt;AppEntry&gt;&gt; loader, List&lt;AppEntry&gt; data)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ onLoadFinished() called! +++\"</span>);</div><div class=\"line\">            mAdapter.setData(data);<span class=\"comment\">//加载数据到UI</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (isResumed()) &#123;</div><div class=\"line\">                setListShown(<span class=\"keyword\">true</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                setListShownNoAnimation(<span class=\"keyword\">true</span>);</div><div class=\"line\">            &#125; </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoaderReset</span><span class=\"params\">(android.support.v4.content.Loader&lt;List&lt;AppEntry&gt;&gt; loader)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.i(TAG, <span class=\"string\">\"+++ onLoadReset() called! +++\"</span>);</div><div class=\"line\">            mAdapter.setData(<span class=\"keyword\">null</span>);<span class=\"comment\">//loader被reset，UI这边需要清除所有与Loader数据相关的引用，但清除数据的任务会由Loader处理好</span></div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>在三个明显的回调中处理好数据绑定到UI及过期数据的清理即可。</p>\n<h3 id=\"3-处理Activity生命周期的问题\"><a href=\"#3-处理Activity生命周期的问题\" class=\"headerlink\" title=\"3. 处理Activity生命周期的问题\"></a>3. 处理Activity生命周期的问题</h3><p>回到server端(Loader),AsyncTaskLoader是一个abstract class，loadInBackground方法已经实现了，但还有几个方法强调必须要复写或者与生命周期相关<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartLoading</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">/* Subclasses must implement this to take care of loading their data,</div><div class=\"line\">         as per &#123;@link #startLoading()&#125;.  This is not called by clients directly,</div><div class=\"line\">         but as a result of a call to &#123;@link #startLoading()&#125;.*/</span></div><div class=\"line\">       <span class=\"comment\">//在这里检查一下成员变量中的数据是否不为空，有数据的话，deliverResults</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStopLoading</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">/*Subclasses must implement this to take care of stopping their loader,</div><div class=\"line\">         as per &#123;@link #stopLoading()&#125;.  This is not called by clients directly,</div><div class=\"line\">         but as a result of a call to &#123;@link #stopLoading()&#125;.</div><div class=\"line\">         This will always be called from the process's main thread.*/</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onReset</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">/* Subclasses must implement this to take care of resetting their loader,</div><div class=\"line\">        as per &#123;@link #reset()&#125;.  This is not called by clients directly,</div><div class=\"line\">        but as a result of a call to &#123;@link #reset()&#125;.</div><div class=\"line\">        This will always be called from the process's main thread.</div><div class=\"line\">        如果调用了destoryLoader或者Loader相关联的Activity/Fragment被destory了</div><div class=\"line\">        所以在Demo中可以看到onReset里面调用了onStopLoading去取消当前任务，同时释放资源，取消广播注册*/</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCanceled</span><span class=\"params\">(List&lt;AppEntry&gt; apps)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">/* Called if the task was canceled before it was completed.  Gives the class a chance</div><div class=\"line\">         to clean up post-cancellation and to properly dispose of the result.</div><div class=\"line\">        </div><div class=\"line\">         @param data The value that was returned by &#123;@link #loadInBackground&#125;, or null</div><div class=\"line\">         if the task threw &#123;@link OperationCanceledException&#125;.*/</span></div><div class=\"line\">       <span class=\"comment\">//在这里释放资源</span></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forceLoad</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">/*Force an asynchronous load. Unlike &#123;@link #startLoading()&#125; this will ignore a previously</div><div class=\"line\">       loaded data set and load a new one.  This simply calls through to the</div><div class=\"line\">       implementation's &#123;@link #onForceLoad()&#125;.  You generally should only call this</div><div class=\"line\">       when the loader is started -- that is, &#123;@link #isStarted()&#125; returns true.</div><div class=\"line\">       Must be called from the process's main thread.*/</span></div><div class=\"line\">       <span class=\"comment\">//startLoading会直接使用onConfigurationchange之前的Activity中Loader加载的数据，但这里则放弃旧的数据，重新加载，所以isStarted会在这时返回true</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>考虑一下，如果在加载数据过程中数据源发生了变化，比如在扫描已安装App过程中又安装了新的App怎么办？所以这里又注册了两个广播，在onReceive的时候调用</p>\n<blockquote>\n<pre><code>mLoader.onContentChanged();\n</code></pre><p>//这会直接调用forceLoad（Loader已经started）或者设置一个标志位，让takeContentChanged（）返回true<br>在onStartLoading中发现这个为true，直接forceLoad<br>//接下来进入loadInBackground,完成后进入deliverResult<br>deliverResult首先检查Activity是否destoryed(挂了直接释放资源),没挂的话判断下isStarted(是否一切正常，未调用过stopLoading或reset)，符合条件的话通过super.deliverResult把数据传递出去。接下来判断下之前的旧数据和新数据是否一致，否则释放掉旧数据</p>\n</blockquote>\n<p>整个过程考虑到了数据的有效性，资源的释放，在Loader这一端，通过isReset,isStarted等方法确保了不确定的数据加载过程能够和不确定的生命周期和谐共处。<br>网上看到的关于Loader的文章大部分是关于CursorLoader的，也就是和数据库打交道的那一块，这里不细说。主要是目前没有看到太多App中使用这种加载模式，可能确实有点麻烦。在Medium上看到这篇文章，觉得还是有必要做一些记录的。</p>\n<h3 id=\"4-关于性能\"><a href=\"#4-关于性能\" class=\"headerlink\" title=\"4. 关于性能\"></a>4. 关于性能</h3><p>最后我想说的是，AsyncTaskLoader内部使用的还是AsyncTask那一套，关于AsyncTask的串行和并行的讨论网上有很多。于是我看了下AsyncTaskLoader中最终调用AsyncTask的execute方法:</p>\n<blockquote>\n<p> mTask.executeOnExecutor(mExecutor, (Void[]) null);</p>\n</blockquote>\n<p>至于这个mExecutor的本质:</p>\n<blockquote>\n<p>public static final Executor THREAD_POOL_EXECUTOR<br>            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,<br>                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);<br>CORE_POOL_SIZE = 5<br>嗯，并行的线程池，性能应该还不错。<br>学过rxjava，是否rxjava会是一种比loader更好的加载数据的方式呢</p>\n</blockquote>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"http://huxian99.github.io/2015/10/28/RxJava%E7%9A%84Android%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF-RxJava%E5%AE%9E%E6%88%98-%E4%BA%8C/\">rxLoader</a></li>\n<li><a href=\"https://medium.com/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#.btjs9ady6\">making loading data on android lifecycle aware</a></li>\n<li><a href=\"https://github.com/alexjlockwood/adp-applistloader\">AppListLoader</a></li>\n</ol>"},{"title":"使用RecyclerView的Animation","date":"2016-10-20T08:16:49.000Z","_content":"\nFrom the talk \nRecyclerView Animations and Behind the Scenes\nYigit Biyar & Chet Haase\non Anroid Dev Summit 2015\n\n### 1. RecyclerView架构\n\nRecyclerView is Flexible , Pluggable and Customizeable\n内部很多功能都交给了各个组件去完成\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020135353.jpg?imageView2/2/w/600)\nChildHelper 、AdapterHelper 、Recycler对于开发者来说并不常用，但它们在内部负责了许多针对Child View的管理。<!--more-->\n\n\n- ViewHolder的创建\n![](http://odzl05jxx.bkt.clouddn.com/viewHolder_step_1.jpg?imageView2/2/w/600)\n1 .LayoutManager首先检查getViewForPosition，RecyclerView查找Cache(getViewForPosition)，如果找到了。直接交给LayoutManager,这一过程甚至不需要与Adapter接触。\n2. 如果Cache中未找到，RecyclerView调用Adpter的getViewType，并去Recycled Pool中getViewHolderByType。\n3. 如果在Pool中未找到，RecyclerView将调用Adapter的createViewHolder。\n4. 如果在Pool中这种Type的ViewHolder已经有了，或者步骤3中创建了一个新的viewHolder，bindViewHolder并交给LayoutManager。\n![](http://odzl05jxx.bkt.clouddn.com/viewHolder_step_2.jpg?imageView2/2/w/600)\n5. 最终LayoutManager将把这个View添加到UI，这时会调用RecyclerView的onViewAttachedToWindow回调（生命周期）。\n\n\n- ViewHolder的回收(Reserves)\n![](http://odzl05jxx.bkt.clouddn.com/viewHolder_step_3.jpg?imageView2/2/w/600)\n1. LayoutManager调用removeAndRecycleView，RecyclerView会在这里收到回调onViewDetachedFromWindow\n2. 检查这个View.isValid。这一点很重要，在scroll过程中，如果一个View是Valid的话，可以将View添加到Cache中，随后可以简单将其复用。Cache将会invalidate oldest one，并告诉Adapter(onViewRecycled)。\n3. 如果不是Valid的View，将会被添加到Pool中，Adapter会收到onViewRecycled回调。\n\n- ViewHolder的另一种更好的回收方式(Fancy Reserves!)\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020124442.jpg?imageView2/2/w/600)\n1. LayoutManager调用onLayoutChildren\n2. Layout完成后，RecyclerView检查那些之前已经被layout了的但不再存在于屏幕上了。RecyclerView将这些View重新添加到ViewGroup中，这些View此时对LayoutManager不可见。重新添加的目的在于动画。\n3. RecyclerView这时候把这些本不该add的View交给ItemAnimator，后者调用动画效果，300ms(安卓中大部分默认动画时间是300ms)之后，调用onAnimationFinished，告诉RecyclerView.\n4. 接着RecyclerView通知Adapter(onViewDetachedFromWindow)\n5. 最后将这些View添加到Cache或者Recycled Pool。\n\n- ViewHolder的销毁\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020124836.jpg?imageView2/2/w/600)\n1. LayoutManager调用removeAndRecycleView，RecyclerView检查View是否valid\n2. 如果不是Valid，添加到RecycledPool中，但在这之前先检查是否 hasTransientState（例如正在运行动画）\n3. 如果这个View正好处在Animation中，一些属性被Animating， Pool会调用Adapter的onFailedToRecycle(Adapter中应该复写这个方法，取消动画)\n4. onFailedToRecycle(ViewHolder)返回true的话，Pool将无视View的TransientState并回收这个View(可能处在动画中)\n\n- 另一种可能导致ViewHolder被销毁的方式\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020143554.jpg?imageView2/2/w/600)\nRecyclerView将View添加到Pool中(实际调用的是addViewHolderToRecycledViewPool(ViewHolder))，Pool会检查这种type的ViewHolder是否还放得下（例如type x的ViewHolder已经有5个了，实在太多了），这种情况下就会Kill这种View,这种情况是我们希望避免的。开发者可以调用pool.setMaxRecycledViews(type,count)来让Pool放更多的Holder per type。\n\n一些需要注意的，Pool是基于一个Activity Context的。\n\n### 2. 使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\n\nperdictiveItemAnimation的关键在于RecyclerView的list并不局限于屏幕。\n在LayoutManager中复写\n> supportPredictiveItemAnimations()，返回true。\n\nLinearLayoutManger的实现\n\n```java\n @Override\n    public boolean supportsPredictiveItemAnimations() {\n        return mPendingSavedState == null && mLastStackFromEnd == mStackFromEnd;\n    }\n```\n可以认为返回值就是true\n\nonLayoutChildern在这种情况下会被调用两次，(之前提到本该被移除的View需要重新添加到ViewGroup中，实现就在这里)\n参考LinearLayoutManager的实现，源代码实在太长，只复制一些注释\n```java\n @Override\n    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n        // layout algorithm:\n        // 1) by checking children and other variables, find an anchor coordinate and an anchor\n        //  item position.\n        // 2) fill towards start, stacking from bottom\n        // 3) fill towards end, stacking from top\n        // 4) scroll to fulfill requirements like stack from bottom.\n        // create layout state\n        //omitted....\n        }\n```\n简单来说一共三步:\n\n1. detach and Scrap Views\n2. layout那些需要出现在list中的View(包括将要消失的View)\n3. 接下来进入第二步layout，在这里确定那些将出现在屏幕外的View的实际位置。\n\n这样LayoutManager就能将必要的信息传递给ItemAnimator\n\n- 进入ItemAnimator\n大部分的需要实现的函数在SimpleItemAnimator或者DefaultItemAnimator里面都已经实现好了，所以大部分人的选择就是：\n1. 使用DefaultItemAnimator(默认已经设置好了)\n2. Implement SimpleItemAnimator(或者DeafaultItemAnimator)，复写一些必要的方法\n\nAnimator需要做的一些事\n```java\nrecord[Pre|Post]LayoutInformation//记录动画开始和结束的layout信息\nanimate[Appearance|Disappearance]\nanimatePersistence()//不会改变位置\nanimateChange()//实际的动画添加位置\n```\n这些在DefaultItemAnimator中都有默认的实现\n动画完成后一定要调用\n> DispatchAnimationFinished(ViewHolder)\n\n记录动画开始前和结束后的信息，实例代码:\n```java\n  @NonNull\n        @Override\n        public ItemHolderInfo recordPreLayoutInformation(RecyclerView.State state,\n                RecyclerView.ViewHolder viewHolder, int changeFlags, List<Object> payloads) {\n            ColorTextInfo info = (ColorTextInfo) super.recordPreLayoutInformation(state, viewHolder,\n                    changeFlags, payloads);\n            return getItemHolderInfo((MyViewHolder) viewHolder, info);\n        }\n\n        @NonNull\n        @Override\n        public ItemHolderInfo recordPostLayoutInformation(@NonNull RecyclerView.State state,\n                @NonNull RecyclerView.ViewHolder viewHolder) {\n            ColorTextInfo info = (ColorTextInfo) super.recordPostLayoutInformation(state, viewHolder);\n            return getItemHolderInfo((MyViewHolder) viewHolder, info);\n        }\n\n        @Override\n        public ItemHolderInfo obtainHolderInfo() {\n            return new ColorTextInfo();\n        }\n\n```\n\n\n- canReuseViewHolder的作用:\n例如notifyItemChanged(position)后，只是某个位置的viewHolder发生了信息改变，那就没有必要创建一个新的ViewHolder，直接提供原有的ViewHolder，提升性能。\n\n### 3. 常见错误\n1. mAdapter.notifyItemMoved(1,5)\n不会调用onBindViewHolder，不会invalidate \n\n2. 不要在onBindViewHolder中添加onClickListener(以匿名内部类的方式,这会使得position变成final),想象一下，mAdapter.notifyItemMoved(1,5)调用后不会调用onBindViewHolder，这使得点击pos 1时实际传递给listener的是pos 5。\n\n3. 检查RecyclerView.NO_POSITION\n这个Int值为-1，其实就是itemView被removed，但用户手够快，在View被移除前点击了这个View，那这个onClickListener还是会被调用。\n\n4. mAdapter.notifyItemChanged(position,payload)\n如果某个ViewHolder中只是一部分信息改变，将更新内容丢到payload中，最终会调用到onBindViewHolder(ViewHolder,position,List Payloads)，在这里只需要把ViewHolder中的一小部分改变就可以了，这有助于优化新能。\n\n5. onCreateViewHolder*必须*返回一个new ViewHolder，不能在本地作为成员变量返回。\n\n6. RecyclerView.setRecycledViewPool(pool)\n一个pool只能为为同一个context(Activity)中的RecyclerView使用，因为这些View是与Context相关的，而不同的Activity可能有不同的Theme，Style。\n\n7. Pro RecyclerView\n最近看到yigit在relam作的关于recyclerView的演讲，记录下来一些比较重要的点\n\n- view:: requestLayout的效果，requestLayout会一直地向上请求直到根视图，next Frame开始时，所有的子View都将调用自身的measure(onMeasure)和layout(onLayout)方法\n如果子View不曾requestLayout,之前的measure结果会被cache下来，节省measure和layout的时间。\n\n- 在RecyclerView中，在itemView的onBIndView方法中调用ImageLoader的加载图片方法，由于图片加载是异步操作，最终会调用ImageView的setImageBitmap方法。而在ImageView的实现中，setImageBitmap方法最终会调用requestLayout方法，最终会一层层向上传递到recyclerView中，就像这样\n```java\nimageView setImageBitmap\n\nimageView requestLayout\n\nitemView requestLayout\n\nrecyclerView requestLayout \n```\n而recyclerView的requestLayout方法会在next Frame重新position所有的child(very expensive!)为此，recyclerView提供了一个setHasFixedSize方法，设置为true表明recyclerView自身不会因为childView的变化而resize，这样recyclerVeiw就不会调用requestLayout方法(如果去看RecyclerView的源码，可以看到mEatRequestLayout这个变量，也就是避免重复调用requestLayout造成性能损耗。)，不会造成所有的childView都被重新测量一遍。在ImageView(2011年之后的版本)中，setImageDrawable方法大致长这样：\n```java\nvoid setImageDrawable(Drawable drawable){\n    if(mDrawable != drawable){\n    int oldWidth = mDrawableWidth;\n    int oldHeight = mDrawableHeight;\n    updateDrawable(drawable)\n        if(oldWidth!=mDrawableWidth||oldHeight!=mDrawableHeight){\n            requestLayout();\n        }\n        invalidate();\n    }\n}\n\n```\n简单来说就是判断下前后图像的宽度或高度是否发生了变化，如果无变化则不需调用requestLayout方法，只需要reDraw。也就避免了这种性能的损耗。但是，TextView的implementation则复杂的多，并没有这种优化。实际操作中，API应该能够告诉客户端图片的width和Height,使用AspectRationImageView加载图片。在图片加载完成之前优先使用PlaceHolder，并设定好加载完成应有的尺寸，这样就避免了后期图片加载完成后的requestLayout。\n\n- 使用SortedList用于进行List变更\n```java\nSortedList<Item> mSortedList = new SortedList<Item>(Item.class,\n    new SortedListAdapterCallback<Item>(mAdapter)){\n    //override三个方法，懒得抄了\n\n}\n使用方式十分简单，后面的数据更新操作包括notifyDataChange都被处理好了。\nonNetwokCallback(List<News> news){\n    mSortedList.addAll(news);\n} \n```\n对于未发生变化的Item，将直接跳过，实现了最优化的列表数据更新。\n\n- DiffUtil(added in 24.2.0)用于对比数据变更前后的两个List\n```java\nDiffResult result = DiffUtil.calculateDiff(\n    new MyCallback(oldList,newList));\nmAdapter.setItems(newList);\nresult.dispatchTo(mAdapter);\n```\n只需调用上述方法即可实现列表Item更新及Adapter的notify。DiffUtil的callback有四个方法需要复写，另外有一个方法用于单个Item的部分payload更新。在[medium](https://medium.com/@iammert/using-diffutil-in-android-recyclerview-bdca8e4fbb00#.rbtzmmtbg)上找到一个现成的，直接借用了。\n```java\npublic class MyDiffCallback extends DiffUtil.Callback{\n\n    List<Person> oldPersons;\n    List<Person> newPersons;\n\n    public MyDiffCallback(List<Person> newPersons, List<Person> oldPersons) {\n        this.newPersons = newPersons;\n        this.oldPersons = oldPersons;\n    }\n\n    @Override\n    public int getOldListSize() {\n        return oldPersons.size();\n    }\n\n    @Override\n    public int getNewListSize() {\n        return newPersons.size();\n    }\n\n    @Override\n    public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {\n        return oldPersons.get(oldItemPosition).id == newPersons.get(newItemPosition).id;\n    }\n\n    @Override\n    public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {\n        return oldPersons.get(oldItemPosition).equals(newPersons.get(newItemPosition));\n    }\n\n    @Nullable\n    @Override\n    public Object getChangePayload(int oldItemPosition, int newItemPosition) {\n        //you can return particular field for changed item.//这里的object会被带到onBindViewHolder中\n        return super.getChangePayload(oldItemPosition, newItemPosition);\n    }\n}\n```\n这些方法会帮助完成remove和add等方法。\n\n- viewHolder的生命周期\n```java\nonCreate\nonBindViewHolder(获取video资源)\nonViewAttachedToWindow(可以在这里开始播放视频)\nonViewDetachedFromWindow(可以在这里停止播放视频，随时有可能重新被直接attach，这过程中不会调用onBind方法)\nonRecycled(可以在这里释放Video资源或者释放Bitmap引用，这之后再使用该ViewHolder需要调用onBind方法)\n```\n\n- recyclerView的一些defer操作对于日常开发的帮助\nrecyclerView会将一些pending操作defer到next frame。eg:\n```java\nrecyclerView.scrollToPosition(15);\nint x = layoutManager.getFirstVisiblePosition()//此时x并不等于15，因为下一帧并未开始。真正的执行scroll操作需要等到nextFrame执行后才能生效，具体一点的话，就是下一个执行layout的message的callback还未被执行。\n又例如，在onCreate中调用\n```java\nrecyclerView.scrollToPosition(15)\n//在netWorkCallback中调用setAdapter，这时recyclerView会利用pending的15 position。原因在于recyclerView会判断如果layoutManager和adapter是否为null，如果都为null。skip layout。\n\n- 在getItemViewType中返回R.layout.itemLayout的好处。\n在onCreateViewHolder(ViewGroup viewParent,int ViewType){\n    View itemView = inflate.inflate(ViewType,parent,false);\n    return XXXHolder(itemView);//aapt可以确保R.layout.xxxx是unique的。\n}\n```\n\n- ClickListener的实现\n在onCreateViewHolder中传一个callback，不要在onBindViewHolder中传，不要把onBindViewHolder中的position变为final的。getAdapterPositon可能为NO_POSITION(-1)，因为RecyclerView的UI更新会被defer到next Frame，在下一帧更新被执行前，用户可能已经点击了item，这时的position就有可能是-1(这种情况发生在点击后删除了所有的item数据，这时获得的position就类似于list的indexAt，当然是-1。).\n\n- LayoutManager只知道LayoutPosition，并不知道AdapterPosition\nItems在Adapter的数据集中的顺序可能会随时变更，但recyclerView可能并不会调用onBindViewHolder方法，这也就是onBindViewHolder中的position并不可靠的原因。因为viewHolder本身是backed by Item的，而viewHolder的getAdapterPosition能够正确地反应Item在数据集中的顺序。\n\n\n\n\n\n### 4 . 一些参考资料\n- [RecyclerView Animations and Behind the Scenes (Android Dev Summit 2015)](https://www.youtube.com/watch?v=imsr8NrIAMs)\n- [ItemAnimator模板](https://github.com/wasabeef/recyclerview-animators)\n- [UI ToolKit Demo](https://github.com/google/android-ui-toolkit-demos)\n- [Yigit Boyar: Pro RecyclerView](https://www.youtube.com/watch?v=KhLVD6iiZQs)","source":"_posts/2016-10-20-RecyclerViewAnimationStuff.md","raw":"---\ntitle: 使用RecyclerView的Animation\ndate: 2016-10-20 16:16:49\ncategories: blog  \ntags: [android,RecyclerView]\n---\n\nFrom the talk \nRecyclerView Animations and Behind the Scenes\nYigit Biyar & Chet Haase\non Anroid Dev Summit 2015\n\n### 1. RecyclerView架构\n\nRecyclerView is Flexible , Pluggable and Customizeable\n内部很多功能都交给了各个组件去完成\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020135353.jpg?imageView2/2/w/600)\nChildHelper 、AdapterHelper 、Recycler对于开发者来说并不常用，但它们在内部负责了许多针对Child View的管理。<!--more-->\n\n\n- ViewHolder的创建\n![](http://odzl05jxx.bkt.clouddn.com/viewHolder_step_1.jpg?imageView2/2/w/600)\n1 .LayoutManager首先检查getViewForPosition，RecyclerView查找Cache(getViewForPosition)，如果找到了。直接交给LayoutManager,这一过程甚至不需要与Adapter接触。\n2. 如果Cache中未找到，RecyclerView调用Adpter的getViewType，并去Recycled Pool中getViewHolderByType。\n3. 如果在Pool中未找到，RecyclerView将调用Adapter的createViewHolder。\n4. 如果在Pool中这种Type的ViewHolder已经有了，或者步骤3中创建了一个新的viewHolder，bindViewHolder并交给LayoutManager。\n![](http://odzl05jxx.bkt.clouddn.com/viewHolder_step_2.jpg?imageView2/2/w/600)\n5. 最终LayoutManager将把这个View添加到UI，这时会调用RecyclerView的onViewAttachedToWindow回调（生命周期）。\n\n\n- ViewHolder的回收(Reserves)\n![](http://odzl05jxx.bkt.clouddn.com/viewHolder_step_3.jpg?imageView2/2/w/600)\n1. LayoutManager调用removeAndRecycleView，RecyclerView会在这里收到回调onViewDetachedFromWindow\n2. 检查这个View.isValid。这一点很重要，在scroll过程中，如果一个View是Valid的话，可以将View添加到Cache中，随后可以简单将其复用。Cache将会invalidate oldest one，并告诉Adapter(onViewRecycled)。\n3. 如果不是Valid的View，将会被添加到Pool中，Adapter会收到onViewRecycled回调。\n\n- ViewHolder的另一种更好的回收方式(Fancy Reserves!)\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020124442.jpg?imageView2/2/w/600)\n1. LayoutManager调用onLayoutChildren\n2. Layout完成后，RecyclerView检查那些之前已经被layout了的但不再存在于屏幕上了。RecyclerView将这些View重新添加到ViewGroup中，这些View此时对LayoutManager不可见。重新添加的目的在于动画。\n3. RecyclerView这时候把这些本不该add的View交给ItemAnimator，后者调用动画效果，300ms(安卓中大部分默认动画时间是300ms)之后，调用onAnimationFinished，告诉RecyclerView.\n4. 接着RecyclerView通知Adapter(onViewDetachedFromWindow)\n5. 最后将这些View添加到Cache或者Recycled Pool。\n\n- ViewHolder的销毁\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020124836.jpg?imageView2/2/w/600)\n1. LayoutManager调用removeAndRecycleView，RecyclerView检查View是否valid\n2. 如果不是Valid，添加到RecycledPool中，但在这之前先检查是否 hasTransientState（例如正在运行动画）\n3. 如果这个View正好处在Animation中，一些属性被Animating， Pool会调用Adapter的onFailedToRecycle(Adapter中应该复写这个方法，取消动画)\n4. onFailedToRecycle(ViewHolder)返回true的话，Pool将无视View的TransientState并回收这个View(可能处在动画中)\n\n- 另一种可能导致ViewHolder被销毁的方式\n![](http://odzl05jxx.bkt.clouddn.com/snapshot20161020143554.jpg?imageView2/2/w/600)\nRecyclerView将View添加到Pool中(实际调用的是addViewHolderToRecycledViewPool(ViewHolder))，Pool会检查这种type的ViewHolder是否还放得下（例如type x的ViewHolder已经有5个了，实在太多了），这种情况下就会Kill这种View,这种情况是我们希望避免的。开发者可以调用pool.setMaxRecycledViews(type,count)来让Pool放更多的Holder per type。\n\n一些需要注意的，Pool是基于一个Activity Context的。\n\n### 2. 使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\n\nperdictiveItemAnimation的关键在于RecyclerView的list并不局限于屏幕。\n在LayoutManager中复写\n> supportPredictiveItemAnimations()，返回true。\n\nLinearLayoutManger的实现\n\n```java\n @Override\n    public boolean supportsPredictiveItemAnimations() {\n        return mPendingSavedState == null && mLastStackFromEnd == mStackFromEnd;\n    }\n```\n可以认为返回值就是true\n\nonLayoutChildern在这种情况下会被调用两次，(之前提到本该被移除的View需要重新添加到ViewGroup中，实现就在这里)\n参考LinearLayoutManager的实现，源代码实在太长，只复制一些注释\n```java\n @Override\n    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n        // layout algorithm:\n        // 1) by checking children and other variables, find an anchor coordinate and an anchor\n        //  item position.\n        // 2) fill towards start, stacking from bottom\n        // 3) fill towards end, stacking from top\n        // 4) scroll to fulfill requirements like stack from bottom.\n        // create layout state\n        //omitted....\n        }\n```\n简单来说一共三步:\n\n1. detach and Scrap Views\n2. layout那些需要出现在list中的View(包括将要消失的View)\n3. 接下来进入第二步layout，在这里确定那些将出现在屏幕外的View的实际位置。\n\n这样LayoutManager就能将必要的信息传递给ItemAnimator\n\n- 进入ItemAnimator\n大部分的需要实现的函数在SimpleItemAnimator或者DefaultItemAnimator里面都已经实现好了，所以大部分人的选择就是：\n1. 使用DefaultItemAnimator(默认已经设置好了)\n2. Implement SimpleItemAnimator(或者DeafaultItemAnimator)，复写一些必要的方法\n\nAnimator需要做的一些事\n```java\nrecord[Pre|Post]LayoutInformation//记录动画开始和结束的layout信息\nanimate[Appearance|Disappearance]\nanimatePersistence()//不会改变位置\nanimateChange()//实际的动画添加位置\n```\n这些在DefaultItemAnimator中都有默认的实现\n动画完成后一定要调用\n> DispatchAnimationFinished(ViewHolder)\n\n记录动画开始前和结束后的信息，实例代码:\n```java\n  @NonNull\n        @Override\n        public ItemHolderInfo recordPreLayoutInformation(RecyclerView.State state,\n                RecyclerView.ViewHolder viewHolder, int changeFlags, List<Object> payloads) {\n            ColorTextInfo info = (ColorTextInfo) super.recordPreLayoutInformation(state, viewHolder,\n                    changeFlags, payloads);\n            return getItemHolderInfo((MyViewHolder) viewHolder, info);\n        }\n\n        @NonNull\n        @Override\n        public ItemHolderInfo recordPostLayoutInformation(@NonNull RecyclerView.State state,\n                @NonNull RecyclerView.ViewHolder viewHolder) {\n            ColorTextInfo info = (ColorTextInfo) super.recordPostLayoutInformation(state, viewHolder);\n            return getItemHolderInfo((MyViewHolder) viewHolder, info);\n        }\n\n        @Override\n        public ItemHolderInfo obtainHolderInfo() {\n            return new ColorTextInfo();\n        }\n\n```\n\n\n- canReuseViewHolder的作用:\n例如notifyItemChanged(position)后，只是某个位置的viewHolder发生了信息改变，那就没有必要创建一个新的ViewHolder，直接提供原有的ViewHolder，提升性能。\n\n### 3. 常见错误\n1. mAdapter.notifyItemMoved(1,5)\n不会调用onBindViewHolder，不会invalidate \n\n2. 不要在onBindViewHolder中添加onClickListener(以匿名内部类的方式,这会使得position变成final),想象一下，mAdapter.notifyItemMoved(1,5)调用后不会调用onBindViewHolder，这使得点击pos 1时实际传递给listener的是pos 5。\n\n3. 检查RecyclerView.NO_POSITION\n这个Int值为-1，其实就是itemView被removed，但用户手够快，在View被移除前点击了这个View，那这个onClickListener还是会被调用。\n\n4. mAdapter.notifyItemChanged(position,payload)\n如果某个ViewHolder中只是一部分信息改变，将更新内容丢到payload中，最终会调用到onBindViewHolder(ViewHolder,position,List Payloads)，在这里只需要把ViewHolder中的一小部分改变就可以了，这有助于优化新能。\n\n5. onCreateViewHolder*必须*返回一个new ViewHolder，不能在本地作为成员变量返回。\n\n6. RecyclerView.setRecycledViewPool(pool)\n一个pool只能为为同一个context(Activity)中的RecyclerView使用，因为这些View是与Context相关的，而不同的Activity可能有不同的Theme，Style。\n\n7. Pro RecyclerView\n最近看到yigit在relam作的关于recyclerView的演讲，记录下来一些比较重要的点\n\n- view:: requestLayout的效果，requestLayout会一直地向上请求直到根视图，next Frame开始时，所有的子View都将调用自身的measure(onMeasure)和layout(onLayout)方法\n如果子View不曾requestLayout,之前的measure结果会被cache下来，节省measure和layout的时间。\n\n- 在RecyclerView中，在itemView的onBIndView方法中调用ImageLoader的加载图片方法，由于图片加载是异步操作，最终会调用ImageView的setImageBitmap方法。而在ImageView的实现中，setImageBitmap方法最终会调用requestLayout方法，最终会一层层向上传递到recyclerView中，就像这样\n```java\nimageView setImageBitmap\n\nimageView requestLayout\n\nitemView requestLayout\n\nrecyclerView requestLayout \n```\n而recyclerView的requestLayout方法会在next Frame重新position所有的child(very expensive!)为此，recyclerView提供了一个setHasFixedSize方法，设置为true表明recyclerView自身不会因为childView的变化而resize，这样recyclerVeiw就不会调用requestLayout方法(如果去看RecyclerView的源码，可以看到mEatRequestLayout这个变量，也就是避免重复调用requestLayout造成性能损耗。)，不会造成所有的childView都被重新测量一遍。在ImageView(2011年之后的版本)中，setImageDrawable方法大致长这样：\n```java\nvoid setImageDrawable(Drawable drawable){\n    if(mDrawable != drawable){\n    int oldWidth = mDrawableWidth;\n    int oldHeight = mDrawableHeight;\n    updateDrawable(drawable)\n        if(oldWidth!=mDrawableWidth||oldHeight!=mDrawableHeight){\n            requestLayout();\n        }\n        invalidate();\n    }\n}\n\n```\n简单来说就是判断下前后图像的宽度或高度是否发生了变化，如果无变化则不需调用requestLayout方法，只需要reDraw。也就避免了这种性能的损耗。但是，TextView的implementation则复杂的多，并没有这种优化。实际操作中，API应该能够告诉客户端图片的width和Height,使用AspectRationImageView加载图片。在图片加载完成之前优先使用PlaceHolder，并设定好加载完成应有的尺寸，这样就避免了后期图片加载完成后的requestLayout。\n\n- 使用SortedList用于进行List变更\n```java\nSortedList<Item> mSortedList = new SortedList<Item>(Item.class,\n    new SortedListAdapterCallback<Item>(mAdapter)){\n    //override三个方法，懒得抄了\n\n}\n使用方式十分简单，后面的数据更新操作包括notifyDataChange都被处理好了。\nonNetwokCallback(List<News> news){\n    mSortedList.addAll(news);\n} \n```\n对于未发生变化的Item，将直接跳过，实现了最优化的列表数据更新。\n\n- DiffUtil(added in 24.2.0)用于对比数据变更前后的两个List\n```java\nDiffResult result = DiffUtil.calculateDiff(\n    new MyCallback(oldList,newList));\nmAdapter.setItems(newList);\nresult.dispatchTo(mAdapter);\n```\n只需调用上述方法即可实现列表Item更新及Adapter的notify。DiffUtil的callback有四个方法需要复写，另外有一个方法用于单个Item的部分payload更新。在[medium](https://medium.com/@iammert/using-diffutil-in-android-recyclerview-bdca8e4fbb00#.rbtzmmtbg)上找到一个现成的，直接借用了。\n```java\npublic class MyDiffCallback extends DiffUtil.Callback{\n\n    List<Person> oldPersons;\n    List<Person> newPersons;\n\n    public MyDiffCallback(List<Person> newPersons, List<Person> oldPersons) {\n        this.newPersons = newPersons;\n        this.oldPersons = oldPersons;\n    }\n\n    @Override\n    public int getOldListSize() {\n        return oldPersons.size();\n    }\n\n    @Override\n    public int getNewListSize() {\n        return newPersons.size();\n    }\n\n    @Override\n    public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {\n        return oldPersons.get(oldItemPosition).id == newPersons.get(newItemPosition).id;\n    }\n\n    @Override\n    public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {\n        return oldPersons.get(oldItemPosition).equals(newPersons.get(newItemPosition));\n    }\n\n    @Nullable\n    @Override\n    public Object getChangePayload(int oldItemPosition, int newItemPosition) {\n        //you can return particular field for changed item.//这里的object会被带到onBindViewHolder中\n        return super.getChangePayload(oldItemPosition, newItemPosition);\n    }\n}\n```\n这些方法会帮助完成remove和add等方法。\n\n- viewHolder的生命周期\n```java\nonCreate\nonBindViewHolder(获取video资源)\nonViewAttachedToWindow(可以在这里开始播放视频)\nonViewDetachedFromWindow(可以在这里停止播放视频，随时有可能重新被直接attach，这过程中不会调用onBind方法)\nonRecycled(可以在这里释放Video资源或者释放Bitmap引用，这之后再使用该ViewHolder需要调用onBind方法)\n```\n\n- recyclerView的一些defer操作对于日常开发的帮助\nrecyclerView会将一些pending操作defer到next frame。eg:\n```java\nrecyclerView.scrollToPosition(15);\nint x = layoutManager.getFirstVisiblePosition()//此时x并不等于15，因为下一帧并未开始。真正的执行scroll操作需要等到nextFrame执行后才能生效，具体一点的话，就是下一个执行layout的message的callback还未被执行。\n又例如，在onCreate中调用\n```java\nrecyclerView.scrollToPosition(15)\n//在netWorkCallback中调用setAdapter，这时recyclerView会利用pending的15 position。原因在于recyclerView会判断如果layoutManager和adapter是否为null，如果都为null。skip layout。\n\n- 在getItemViewType中返回R.layout.itemLayout的好处。\n在onCreateViewHolder(ViewGroup viewParent,int ViewType){\n    View itemView = inflate.inflate(ViewType,parent,false);\n    return XXXHolder(itemView);//aapt可以确保R.layout.xxxx是unique的。\n}\n```\n\n- ClickListener的实现\n在onCreateViewHolder中传一个callback，不要在onBindViewHolder中传，不要把onBindViewHolder中的position变为final的。getAdapterPositon可能为NO_POSITION(-1)，因为RecyclerView的UI更新会被defer到next Frame，在下一帧更新被执行前，用户可能已经点击了item，这时的position就有可能是-1(这种情况发生在点击后删除了所有的item数据，这时获得的position就类似于list的indexAt，当然是-1。).\n\n- LayoutManager只知道LayoutPosition，并不知道AdapterPosition\nItems在Adapter的数据集中的顺序可能会随时变更，但recyclerView可能并不会调用onBindViewHolder方法，这也就是onBindViewHolder中的position并不可靠的原因。因为viewHolder本身是backed by Item的，而viewHolder的getAdapterPosition能够正确地反应Item在数据集中的顺序。\n\n\n\n\n\n### 4 . 一些参考资料\n- [RecyclerView Animations and Behind the Scenes (Android Dev Summit 2015)](https://www.youtube.com/watch?v=imsr8NrIAMs)\n- [ItemAnimator模板](https://github.com/wasabeef/recyclerview-animators)\n- [UI ToolKit Demo](https://github.com/google/android-ui-toolkit-demos)\n- [Yigit Boyar: Pro RecyclerView](https://www.youtube.com/watch?v=KhLVD6iiZQs)","slug":"2016-10-20-RecyclerViewAnimationStuff","published":1,"updated":"2017-04-23T10:50:29.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnfz0006bovrsy7njntt","content":"<p>From the talk<br>RecyclerView Animations and Behind the Scenes<br>Yigit Biyar &amp; Chet Haase<br>on Anroid Dev Summit 2015</p>\n<h3 id=\"1-RecyclerView架构\"><a href=\"#1-RecyclerView架构\" class=\"headerlink\" title=\"1. RecyclerView架构\"></a>1. RecyclerView架构</h3><p>RecyclerView is Flexible , Pluggable and Customizeable<br>内部很多功能都交给了各个组件去完成<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020135353.jpg?imageView2/2/w/600\" alt=\"\"><br>ChildHelper 、AdapterHelper 、Recycler对于开发者来说并不常用，但它们在内部负责了许多针对Child View的管理。<a id=\"more\"></a></p>\n<ul>\n<li>ViewHolder的创建<br><img src=\"http://odzl05jxx.bkt.clouddn.com/viewHolder_step_1.jpg?imageView2/2/w/600\" alt=\"\"><br>1 .LayoutManager首先检查getViewForPosition，RecyclerView查找Cache(getViewForPosition)，如果找到了。直接交给LayoutManager,这一过程甚至不需要与Adapter接触。</li>\n</ul>\n<ol>\n<li>如果Cache中未找到，RecyclerView调用Adpter的getViewType，并去Recycled Pool中getViewHolderByType。</li>\n<li>如果在Pool中未找到，RecyclerView将调用Adapter的createViewHolder。</li>\n<li>如果在Pool中这种Type的ViewHolder已经有了，或者步骤3中创建了一个新的viewHolder，bindViewHolder并交给LayoutManager。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/viewHolder_step_2.jpg?imageView2/2/w/600\" alt=\"\"></li>\n<li>最终LayoutManager将把这个View添加到UI，这时会调用RecyclerView的onViewAttachedToWindow回调（生命周期）。</li>\n</ol>\n<ul>\n<li>ViewHolder的回收(Reserves)<br><img src=\"http://odzl05jxx.bkt.clouddn.com/viewHolder_step_3.jpg?imageView2/2/w/600\" alt=\"\"></li>\n</ul>\n<ol>\n<li>LayoutManager调用removeAndRecycleView，RecyclerView会在这里收到回调onViewDetachedFromWindow</li>\n<li>检查这个View.isValid。这一点很重要，在scroll过程中，如果一个View是Valid的话，可以将View添加到Cache中，随后可以简单将其复用。Cache将会invalidate oldest one，并告诉Adapter(onViewRecycled)。</li>\n<li>如果不是Valid的View，将会被添加到Pool中，Adapter会收到onViewRecycled回调。</li>\n</ol>\n<ul>\n<li>ViewHolder的另一种更好的回收方式(Fancy Reserves!)<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020124442.jpg?imageView2/2/w/600\" alt=\"\"></li>\n</ul>\n<ol>\n<li>LayoutManager调用onLayoutChildren</li>\n<li>Layout完成后，RecyclerView检查那些之前已经被layout了的但不再存在于屏幕上了。RecyclerView将这些View重新添加到ViewGroup中，这些View此时对LayoutManager不可见。重新添加的目的在于动画。</li>\n<li>RecyclerView这时候把这些本不该add的View交给ItemAnimator，后者调用动画效果，300ms(安卓中大部分默认动画时间是300ms)之后，调用onAnimationFinished，告诉RecyclerView.</li>\n<li>接着RecyclerView通知Adapter(onViewDetachedFromWindow)</li>\n<li>最后将这些View添加到Cache或者Recycled Pool。</li>\n</ol>\n<ul>\n<li>ViewHolder的销毁<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020124836.jpg?imageView2/2/w/600\" alt=\"\"></li>\n</ul>\n<ol>\n<li>LayoutManager调用removeAndRecycleView，RecyclerView检查View是否valid</li>\n<li>如果不是Valid，添加到RecycledPool中，但在这之前先检查是否 hasTransientState（例如正在运行动画）</li>\n<li>如果这个View正好处在Animation中，一些属性被Animating， Pool会调用Adapter的onFailedToRecycle(Adapter中应该复写这个方法，取消动画)</li>\n<li>onFailedToRecycle(ViewHolder)返回true的话，Pool将无视View的TransientState并回收这个View(可能处在动画中)</li>\n</ol>\n<ul>\n<li>另一种可能导致ViewHolder被销毁的方式<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020143554.jpg?imageView2/2/w/600\" alt=\"\"><br>RecyclerView将View添加到Pool中(实际调用的是addViewHolderToRecycledViewPool(ViewHolder))，Pool会检查这种type的ViewHolder是否还放得下（例如type x的ViewHolder已经有5个了，实在太多了），这种情况下就会Kill这种View,这种情况是我们希望避免的。开发者可以调用pool.setMaxRecycledViews(type,count)来让Pool放更多的Holder per type。</li>\n</ul>\n<p>一些需要注意的，Pool是基于一个Activity Context的。</p>\n<h3 id=\"2-使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\"><a href=\"#2-使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\" class=\"headerlink\" title=\"2. 使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\"></a>2. 使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤</h3><p>perdictiveItemAnimation的关键在于RecyclerView的list并不局限于屏幕。<br>在LayoutManager中复写</p>\n<blockquote>\n<p>supportPredictiveItemAnimations()，返回true。</p>\n</blockquote>\n<p>LinearLayoutManger的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsPredictiveItemAnimations</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> mPendingSavedState == <span class=\"keyword\">null</span> &amp;&amp; mLastStackFromEnd == mStackFromEnd;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>可以认为返回值就是true</p>\n<p>onLayoutChildern在这种情况下会被调用两次，(之前提到本该被移除的View需要重新添加到ViewGroup中，实现就在这里)<br>参考LinearLayoutManager的实现，源代码实在太长，只复制一些注释<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// layout algorithm:</span></div><div class=\"line\">       <span class=\"comment\">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></div><div class=\"line\">       <span class=\"comment\">//  item position.</span></div><div class=\"line\">       <span class=\"comment\">// 2) fill towards start, stacking from bottom</span></div><div class=\"line\">       <span class=\"comment\">// 3) fill towards end, stacking from top</span></div><div class=\"line\">       <span class=\"comment\">// 4) scroll to fulfill requirements like stack from bottom.</span></div><div class=\"line\">       <span class=\"comment\">// create layout state</span></div><div class=\"line\">       <span class=\"comment\">//omitted....</span></div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<p>简单来说一共三步:</p>\n<ol>\n<li>detach and Scrap Views</li>\n<li>layout那些需要出现在list中的View(包括将要消失的View)</li>\n<li>接下来进入第二步layout，在这里确定那些将出现在屏幕外的View的实际位置。</li>\n</ol>\n<p>这样LayoutManager就能将必要的信息传递给ItemAnimator</p>\n<ul>\n<li>进入ItemAnimator<br>大部分的需要实现的函数在SimpleItemAnimator或者DefaultItemAnimator里面都已经实现好了，所以大部分人的选择就是：</li>\n</ul>\n<ol>\n<li>使用DefaultItemAnimator(默认已经设置好了)</li>\n<li>Implement SimpleItemAnimator(或者DeafaultItemAnimator)，复写一些必要的方法</li>\n</ol>\n<p>Animator需要做的一些事<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">record[Pre|Post]LayoutInformation<span class=\"comment\">//记录动画开始和结束的layout信息</span></div><div class=\"line\">animate[Appearance|Disappearance]</div><div class=\"line\">animatePersistence()<span class=\"comment\">//不会改变位置</span></div><div class=\"line\">animateChange()<span class=\"comment\">//实际的动画添加位置</span></div></pre></td></tr></table></figure></p>\n<p>这些在DefaultItemAnimator中都有默认的实现<br>动画完成后一定要调用</p>\n<blockquote>\n<p>DispatchAnimationFinished(ViewHolder)</p>\n</blockquote>\n<p>记录动画开始前和结束后的信息，实例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NonNull</span></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> ItemHolderInfo <span class=\"title\">recordPreLayoutInformation</span><span class=\"params\">(RecyclerView.State state,</div><div class=\"line\">              RecyclerView.ViewHolder viewHolder, <span class=\"keyword\">int</span> changeFlags, List&lt;Object&gt; payloads)</span> </span>&#123;</div><div class=\"line\">          ColorTextInfo info = (ColorTextInfo) <span class=\"keyword\">super</span>.recordPreLayoutInformation(state, viewHolder,</div><div class=\"line\">                  changeFlags, payloads);</div><div class=\"line\">          <span class=\"keyword\">return</span> getItemHolderInfo((MyViewHolder) viewHolder, info);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@NonNull</span></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> ItemHolderInfo <span class=\"title\">recordPostLayoutInformation</span><span class=\"params\">(@NonNull RecyclerView.State state,</div><div class=\"line\">              @NonNull RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</div><div class=\"line\">          ColorTextInfo info = (ColorTextInfo) <span class=\"keyword\">super</span>.recordPostLayoutInformation(state, viewHolder);</div><div class=\"line\">          <span class=\"keyword\">return</span> getItemHolderInfo((MyViewHolder) viewHolder, info);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> ItemHolderInfo <span class=\"title\">obtainHolderInfo</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorTextInfo();</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>canReuseViewHolder的作用:<br>例如notifyItemChanged(position)后，只是某个位置的viewHolder发生了信息改变，那就没有必要创建一个新的ViewHolder，直接提供原有的ViewHolder，提升性能。</li>\n</ul>\n<h3 id=\"3-常见错误\"><a href=\"#3-常见错误\" class=\"headerlink\" title=\"3. 常见错误\"></a>3. 常见错误</h3><ol>\n<li><p>mAdapter.notifyItemMoved(1,5)<br>不会调用onBindViewHolder，不会invalidate </p>\n</li>\n<li><p>不要在onBindViewHolder中添加onClickListener(以匿名内部类的方式,这会使得position变成final),想象一下，mAdapter.notifyItemMoved(1,5)调用后不会调用onBindViewHolder，这使得点击pos 1时实际传递给listener的是pos 5。</p>\n</li>\n<li><p>检查RecyclerView.NO_POSITION<br>这个Int值为-1，其实就是itemView被removed，但用户手够快，在View被移除前点击了这个View，那这个onClickListener还是会被调用。</p>\n</li>\n<li><p>mAdapter.notifyItemChanged(position,payload)<br>如果某个ViewHolder中只是一部分信息改变，将更新内容丢到payload中，最终会调用到onBindViewHolder(ViewHolder,position,List Payloads)，在这里只需要把ViewHolder中的一小部分改变就可以了，这有助于优化新能。</p>\n</li>\n<li><p>onCreateViewHolder<em>必须</em>返回一个new ViewHolder，不能在本地作为成员变量返回。</p>\n</li>\n<li><p>RecyclerView.setRecycledViewPool(pool)<br>一个pool只能为为同一个context(Activity)中的RecyclerView使用，因为这些View是与Context相关的，而不同的Activity可能有不同的Theme，Style。</p>\n</li>\n<li><p>Pro RecyclerView<br>最近看到yigit在relam作的关于recyclerView的演讲，记录下来一些比较重要的点</p>\n</li>\n</ol>\n<ul>\n<li><p>view:: requestLayout的效果，requestLayout会一直地向上请求直到根视图，next Frame开始时，所有的子View都将调用自身的measure(onMeasure)和layout(onLayout)方法<br>如果子View不曾requestLayout,之前的measure结果会被cache下来，节省measure和layout的时间。</p>\n</li>\n<li><p>在RecyclerView中，在itemView的onBIndView方法中调用ImageLoader的加载图片方法，由于图片加载是异步操作，最终会调用ImageView的setImageBitmap方法。而在ImageView的实现中，setImageBitmap方法最终会调用requestLayout方法，最终会一层层向上传递到recyclerView中，就像这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageView setImageBitmap</div><div class=\"line\"></div><div class=\"line\">imageView requestLayout</div><div class=\"line\"></div><div class=\"line\">itemView requestLayout</div><div class=\"line\"></div><div class=\"line\">recyclerView requestLayout</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>而recyclerView的requestLayout方法会在next Frame重新position所有的child(very expensive!)为此，recyclerView提供了一个setHasFixedSize方法，设置为true表明recyclerView自身不会因为childView的变化而resize，这样recyclerVeiw就不会调用requestLayout方法(如果去看RecyclerView的源码，可以看到mEatRequestLayout这个变量，也就是避免重复调用requestLayout造成性能损耗。)，不会造成所有的childView都被重新测量一遍。在ImageView(2011年之后的版本)中，setImageDrawable方法大致长这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setImageDrawable</span><span class=\"params\">(Drawable drawable)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(mDrawable != drawable)&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</div><div class=\"line\">    <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</div><div class=\"line\">    updateDrawable(drawable)</div><div class=\"line\">        <span class=\"keyword\">if</span>(oldWidth!=mDrawableWidth||oldHeight!=mDrawableHeight)&#123;</div><div class=\"line\">            requestLayout();</div><div class=\"line\">        &#125;</div><div class=\"line\">        invalidate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>简单来说就是判断下前后图像的宽度或高度是否发生了变化，如果无变化则不需调用requestLayout方法，只需要reDraw。也就避免了这种性能的损耗。但是，TextView的implementation则复杂的多，并没有这种优化。实际操作中，API应该能够告诉客户端图片的width和Height,使用AspectRationImageView加载图片。在图片加载完成之前优先使用PlaceHolder，并设定好加载完成应有的尺寸，这样就避免了后期图片加载完成后的requestLayout。</p>\n<ul>\n<li>使用SortedList用于进行List变更<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SortedList&lt;Item&gt; mSortedList = <span class=\"keyword\">new</span> SortedList&lt;Item&gt;(Item.class,</div><div class=\"line\">    <span class=\"keyword\">new</span> SortedListAdapterCallback&lt;Item&gt;(mAdapter))&#123;</div><div class=\"line\">    <span class=\"comment\">//override三个方法，懒得抄了</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">使用方式十分简单，后面的数据更新操作包括notifyDataChange都被处理好了。</div><div class=\"line\">onNetwokCallback(List&lt;News&gt; news)&#123;</div><div class=\"line\">    mSortedList.addAll(news);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于未发生变化的Item，将直接跳过，实现了最优化的列表数据更新。</p>\n<ul>\n<li>DiffUtil(added in 24.2.0)用于对比数据变更前后的两个List<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">DiffResult result = DiffUtil.calculateDiff(</div><div class=\"line\">    <span class=\"keyword\">new</span> MyCallback(oldList,newList));</div><div class=\"line\">mAdapter.setItems(newList);</div><div class=\"line\">result.dispatchTo(mAdapter);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>只需调用上述方法即可实现列表Item更新及Adapter的notify。DiffUtil的callback有四个方法需要复写，另外有一个方法用于单个Item的部分payload更新。在<a href=\"https://medium.com/@iammert/using-diffutil-in-android-recyclerview-bdca8e4fbb00#.rbtzmmtbg\">medium</a>上找到一个现成的，直接借用了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDiffCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">DiffUtil</span>.<span class=\"title\">Callback</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    List&lt;Person&gt; oldPersons;</div><div class=\"line\">    List&lt;Person&gt; newPersons;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyDiffCallback</span><span class=\"params\">(List&lt;Person&gt; newPersons, List&lt;Person&gt; oldPersons)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.newPersons = newPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.oldPersons = oldPersons;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getOldListSize</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> oldPersons.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNewListSize</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> newPersons.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">areItemsTheSame</span><span class=\"params\">(<span class=\"keyword\">int</span> oldItemPosition, <span class=\"keyword\">int</span> newItemPosition)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> oldPersons.get(oldItemPosition).id == newPersons.get(newItemPosition).id;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">areContentsTheSame</span><span class=\"params\">(<span class=\"keyword\">int</span> oldItemPosition, <span class=\"keyword\">int</span> newItemPosition)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> oldPersons.get(oldItemPosition).equals(newPersons.get(newItemPosition));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Nullable</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getChangePayload</span><span class=\"params\">(<span class=\"keyword\">int</span> oldItemPosition, <span class=\"keyword\">int</span> newItemPosition)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//you can return particular field for changed item.//这里的object会被带到onBindViewHolder中</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getChangePayload(oldItemPosition, newItemPosition);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这些方法会帮助完成remove和add等方法。</p>\n<ul>\n<li><p>viewHolder的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">onCreate</div><div class=\"line\"><span class=\"title\">onBindViewHolder</span><span class=\"params\">(获取video资源)</span></div><div class=\"line\"><span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(可以在这里开始播放视频)</span></div><div class=\"line\"><span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(可以在这里停止播放视频，随时有可能重新被直接attach，这过程中不会调用onBind方法)</span></div><div class=\"line\"><span class=\"title\">onRecycled</span><span class=\"params\">(可以在这里释放Video资源或者释放Bitmap引用，这之后再使用该ViewHolder需要调用onBind方法)</span></span></div></pre></td></tr></table></figure>\n</li>\n<li><p>recyclerView的一些defer操作对于日常开发的帮助<br>recyclerView会将一些pending操作defer到next frame。eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerView.scrollToPosition(<span class=\"number\">15</span>);</div><div class=\"line\"><span class=\"keyword\">int</span> x = layoutManager.getFirstVisiblePosition()<span class=\"comment\">//此时x并不等于15，因为下一帧并未开始。真正的执行scroll操作需要等到nextFrame执行后才能生效，具体一点的话，就是下一个执行layout的message的callback还未被执行。</span></div><div class=\"line\">又例如，在onCreate中调用</div><div class=\"line\">```java</div><div class=\"line\">recyclerView.scrollToPosition(<span class=\"number\">15</span>)</div><div class=\"line\"><span class=\"comment\">//在netWorkCallback中调用setAdapter，这时recyclerView会利用pending的15 position。原因在于recyclerView会判断如果layoutManager和adapter是否为null，如果都为null。skip layout。</span></div><div class=\"line\"></div><div class=\"line\">- 在getItemViewType中返回R.layout.itemLayout的好处。</div><div class=\"line\">在onCreateViewHolder(ViewGroup viewParent,<span class=\"keyword\">int</span> ViewType)&#123;</div><div class=\"line\">    View itemView = inflate.inflate(ViewType,parent,<span class=\"keyword\">false</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> XXXHolder(itemView);<span class=\"comment\">//aapt可以确保R.layout.xxxx是unique的。</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ClickListener的实现<br>在onCreateViewHolder中传一个callback，不要在onBindViewHolder中传，不要把onBindViewHolder中的position变为final的。getAdapterPositon可能为NO_POSITION(-1)，因为RecyclerView的UI更新会被defer到next Frame，在下一帧更新被执行前，用户可能已经点击了item，这时的position就有可能是-1(这种情况发生在点击后删除了所有的item数据，这时获得的position就类似于list的indexAt，当然是-1。).</p>\n</li>\n<li><p>LayoutManager只知道LayoutPosition，并不知道AdapterPosition<br>Items在Adapter的数据集中的顺序可能会随时变更，但recyclerView可能并不会调用onBindViewHolder方法，这也就是onBindViewHolder中的position并不可靠的原因。因为viewHolder本身是backed by Item的，而viewHolder的getAdapterPosition能够正确地反应Item在数据集中的顺序。</p>\n</li>\n</ul>\n<h3 id=\"4-一些参考资料\"><a href=\"#4-一些参考资料\" class=\"headerlink\" title=\"4 . 一些参考资料\"></a>4 . 一些参考资料</h3><ul>\n<li><a href=\"https://www.youtube.com/watch?v=imsr8NrIAMs\">RecyclerView Animations and Behind the Scenes (Android Dev Summit 2015)</a></li>\n<li><a href=\"https://github.com/wasabeef/recyclerview-animators\">ItemAnimator模板</a></li>\n<li><a href=\"https://github.com/google/android-ui-toolkit-demos\">UI ToolKit Demo</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=KhLVD6iiZQs\">Yigit Boyar: Pro RecyclerView</a></li>\n</ul>\n","excerpt":"<p>From the talk<br>RecyclerView Animations and Behind the Scenes<br>Yigit Biyar &amp; Chet Haase<br>on Anroid Dev Summit 2015</p>\n<h3 id=\"1-RecyclerView架构\"><a href=\"#1-RecyclerView架构\" class=\"headerlink\" title=\"1. RecyclerView架构\"></a>1. RecyclerView架构</h3><p>RecyclerView is Flexible , Pluggable and Customizeable<br>内部很多功能都交给了各个组件去完成<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020135353.jpg?imageView2/2/w/600\" alt=\"\"><br>ChildHelper 、AdapterHelper 、Recycler对于开发者来说并不常用，但它们在内部负责了许多针对Child View的管理。","more":"</p>\n<ul>\n<li>ViewHolder的创建<br><img src=\"http://odzl05jxx.bkt.clouddn.com/viewHolder_step_1.jpg?imageView2/2/w/600\" alt=\"\"><br>1 .LayoutManager首先检查getViewForPosition，RecyclerView查找Cache(getViewForPosition)，如果找到了。直接交给LayoutManager,这一过程甚至不需要与Adapter接触。</li>\n</ul>\n<ol>\n<li>如果Cache中未找到，RecyclerView调用Adpter的getViewType，并去Recycled Pool中getViewHolderByType。</li>\n<li>如果在Pool中未找到，RecyclerView将调用Adapter的createViewHolder。</li>\n<li>如果在Pool中这种Type的ViewHolder已经有了，或者步骤3中创建了一个新的viewHolder，bindViewHolder并交给LayoutManager。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/viewHolder_step_2.jpg?imageView2/2/w/600\" alt=\"\"></li>\n<li>最终LayoutManager将把这个View添加到UI，这时会调用RecyclerView的onViewAttachedToWindow回调（生命周期）。</li>\n</ol>\n<ul>\n<li>ViewHolder的回收(Reserves)<br><img src=\"http://odzl05jxx.bkt.clouddn.com/viewHolder_step_3.jpg?imageView2/2/w/600\" alt=\"\"></li>\n</ul>\n<ol>\n<li>LayoutManager调用removeAndRecycleView，RecyclerView会在这里收到回调onViewDetachedFromWindow</li>\n<li>检查这个View.isValid。这一点很重要，在scroll过程中，如果一个View是Valid的话，可以将View添加到Cache中，随后可以简单将其复用。Cache将会invalidate oldest one，并告诉Adapter(onViewRecycled)。</li>\n<li>如果不是Valid的View，将会被添加到Pool中，Adapter会收到onViewRecycled回调。</li>\n</ol>\n<ul>\n<li>ViewHolder的另一种更好的回收方式(Fancy Reserves!)<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020124442.jpg?imageView2/2/w/600\" alt=\"\"></li>\n</ul>\n<ol>\n<li>LayoutManager调用onLayoutChildren</li>\n<li>Layout完成后，RecyclerView检查那些之前已经被layout了的但不再存在于屏幕上了。RecyclerView将这些View重新添加到ViewGroup中，这些View此时对LayoutManager不可见。重新添加的目的在于动画。</li>\n<li>RecyclerView这时候把这些本不该add的View交给ItemAnimator，后者调用动画效果，300ms(安卓中大部分默认动画时间是300ms)之后，调用onAnimationFinished，告诉RecyclerView.</li>\n<li>接着RecyclerView通知Adapter(onViewDetachedFromWindow)</li>\n<li>最后将这些View添加到Cache或者Recycled Pool。</li>\n</ol>\n<ul>\n<li>ViewHolder的销毁<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020124836.jpg?imageView2/2/w/600\" alt=\"\"></li>\n</ul>\n<ol>\n<li>LayoutManager调用removeAndRecycleView，RecyclerView检查View是否valid</li>\n<li>如果不是Valid，添加到RecycledPool中，但在这之前先检查是否 hasTransientState（例如正在运行动画）</li>\n<li>如果这个View正好处在Animation中，一些属性被Animating， Pool会调用Adapter的onFailedToRecycle(Adapter中应该复写这个方法，取消动画)</li>\n<li>onFailedToRecycle(ViewHolder)返回true的话，Pool将无视View的TransientState并回收这个View(可能处在动画中)</li>\n</ol>\n<ul>\n<li>另一种可能导致ViewHolder被销毁的方式<br><img src=\"http://odzl05jxx.bkt.clouddn.com/snapshot20161020143554.jpg?imageView2/2/w/600\" alt=\"\"><br>RecyclerView将View添加到Pool中(实际调用的是addViewHolderToRecycledViewPool(ViewHolder))，Pool会检查这种type的ViewHolder是否还放得下（例如type x的ViewHolder已经有5个了，实在太多了），这种情况下就会Kill这种View,这种情况是我们希望避免的。开发者可以调用pool.setMaxRecycledViews(type,count)来让Pool放更多的Holder per type。</li>\n</ul>\n<p>一些需要注意的，Pool是基于一个Activity Context的。</p>\n<h3 id=\"2-使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\"><a href=\"#2-使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\" class=\"headerlink\" title=\"2. 使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤\"></a>2. 使用LayoutManager配合ItemAnimator自定义ItemView的动画的步骤</h3><p>perdictiveItemAnimation的关键在于RecyclerView的list并不局限于屏幕。<br>在LayoutManager中复写</p>\n<blockquote>\n<p>supportPredictiveItemAnimations()，返回true。</p>\n</blockquote>\n<p>LinearLayoutManger的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsPredictiveItemAnimations</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> mPendingSavedState == <span class=\"keyword\">null</span> &amp;&amp; mLastStackFromEnd == mStackFromEnd;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>可以认为返回值就是true</p>\n<p>onLayoutChildern在这种情况下会被调用两次，(之前提到本该被移除的View需要重新添加到ViewGroup中，实现就在这里)<br>参考LinearLayoutManager的实现，源代码实在太长，只复制一些注释<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// layout algorithm:</span></div><div class=\"line\">       <span class=\"comment\">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></div><div class=\"line\">       <span class=\"comment\">//  item position.</span></div><div class=\"line\">       <span class=\"comment\">// 2) fill towards start, stacking from bottom</span></div><div class=\"line\">       <span class=\"comment\">// 3) fill towards end, stacking from top</span></div><div class=\"line\">       <span class=\"comment\">// 4) scroll to fulfill requirements like stack from bottom.</span></div><div class=\"line\">       <span class=\"comment\">// create layout state</span></div><div class=\"line\">       <span class=\"comment\">//omitted....</span></div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<p>简单来说一共三步:</p>\n<ol>\n<li>detach and Scrap Views</li>\n<li>layout那些需要出现在list中的View(包括将要消失的View)</li>\n<li>接下来进入第二步layout，在这里确定那些将出现在屏幕外的View的实际位置。</li>\n</ol>\n<p>这样LayoutManager就能将必要的信息传递给ItemAnimator</p>\n<ul>\n<li>进入ItemAnimator<br>大部分的需要实现的函数在SimpleItemAnimator或者DefaultItemAnimator里面都已经实现好了，所以大部分人的选择就是：</li>\n</ul>\n<ol>\n<li>使用DefaultItemAnimator(默认已经设置好了)</li>\n<li>Implement SimpleItemAnimator(或者DeafaultItemAnimator)，复写一些必要的方法</li>\n</ol>\n<p>Animator需要做的一些事<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">record[Pre|Post]LayoutInformation<span class=\"comment\">//记录动画开始和结束的layout信息</span></div><div class=\"line\">animate[Appearance|Disappearance]</div><div class=\"line\">animatePersistence()<span class=\"comment\">//不会改变位置</span></div><div class=\"line\">animateChange()<span class=\"comment\">//实际的动画添加位置</span></div></pre></td></tr></table></figure></p>\n<p>这些在DefaultItemAnimator中都有默认的实现<br>动画完成后一定要调用</p>\n<blockquote>\n<p>DispatchAnimationFinished(ViewHolder)</p>\n</blockquote>\n<p>记录动画开始前和结束后的信息，实例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NonNull</span></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> ItemHolderInfo <span class=\"title\">recordPreLayoutInformation</span><span class=\"params\">(RecyclerView.State state,</div><div class=\"line\">              RecyclerView.ViewHolder viewHolder, <span class=\"keyword\">int</span> changeFlags, List&lt;Object&gt; payloads)</span> </span>&#123;</div><div class=\"line\">          ColorTextInfo info = (ColorTextInfo) <span class=\"keyword\">super</span>.recordPreLayoutInformation(state, viewHolder,</div><div class=\"line\">                  changeFlags, payloads);</div><div class=\"line\">          <span class=\"keyword\">return</span> getItemHolderInfo((MyViewHolder) viewHolder, info);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@NonNull</span></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> ItemHolderInfo <span class=\"title\">recordPostLayoutInformation</span><span class=\"params\">(@NonNull RecyclerView.State state,</div><div class=\"line\">              @NonNull RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</div><div class=\"line\">          ColorTextInfo info = (ColorTextInfo) <span class=\"keyword\">super</span>.recordPostLayoutInformation(state, viewHolder);</div><div class=\"line\">          <span class=\"keyword\">return</span> getItemHolderInfo((MyViewHolder) viewHolder, info);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> ItemHolderInfo <span class=\"title\">obtainHolderInfo</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorTextInfo();</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>canReuseViewHolder的作用:<br>例如notifyItemChanged(position)后，只是某个位置的viewHolder发生了信息改变，那就没有必要创建一个新的ViewHolder，直接提供原有的ViewHolder，提升性能。</li>\n</ul>\n<h3 id=\"3-常见错误\"><a href=\"#3-常见错误\" class=\"headerlink\" title=\"3. 常见错误\"></a>3. 常见错误</h3><ol>\n<li><p>mAdapter.notifyItemMoved(1,5)<br>不会调用onBindViewHolder，不会invalidate </p>\n</li>\n<li><p>不要在onBindViewHolder中添加onClickListener(以匿名内部类的方式,这会使得position变成final),想象一下，mAdapter.notifyItemMoved(1,5)调用后不会调用onBindViewHolder，这使得点击pos 1时实际传递给listener的是pos 5。</p>\n</li>\n<li><p>检查RecyclerView.NO_POSITION<br>这个Int值为-1，其实就是itemView被removed，但用户手够快，在View被移除前点击了这个View，那这个onClickListener还是会被调用。</p>\n</li>\n<li><p>mAdapter.notifyItemChanged(position,payload)<br>如果某个ViewHolder中只是一部分信息改变，将更新内容丢到payload中，最终会调用到onBindViewHolder(ViewHolder,position,List Payloads)，在这里只需要把ViewHolder中的一小部分改变就可以了，这有助于优化新能。</p>\n</li>\n<li><p>onCreateViewHolder<em>必须</em>返回一个new ViewHolder，不能在本地作为成员变量返回。</p>\n</li>\n<li><p>RecyclerView.setRecycledViewPool(pool)<br>一个pool只能为为同一个context(Activity)中的RecyclerView使用，因为这些View是与Context相关的，而不同的Activity可能有不同的Theme，Style。</p>\n</li>\n<li><p>Pro RecyclerView<br>最近看到yigit在relam作的关于recyclerView的演讲，记录下来一些比较重要的点</p>\n</li>\n</ol>\n<ul>\n<li><p>view:: requestLayout的效果，requestLayout会一直地向上请求直到根视图，next Frame开始时，所有的子View都将调用自身的measure(onMeasure)和layout(onLayout)方法<br>如果子View不曾requestLayout,之前的measure结果会被cache下来，节省measure和layout的时间。</p>\n</li>\n<li><p>在RecyclerView中，在itemView的onBIndView方法中调用ImageLoader的加载图片方法，由于图片加载是异步操作，最终会调用ImageView的setImageBitmap方法。而在ImageView的实现中，setImageBitmap方法最终会调用requestLayout方法，最终会一层层向上传递到recyclerView中，就像这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageView setImageBitmap</div><div class=\"line\"></div><div class=\"line\">imageView requestLayout</div><div class=\"line\"></div><div class=\"line\">itemView requestLayout</div><div class=\"line\"></div><div class=\"line\">recyclerView requestLayout</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>而recyclerView的requestLayout方法会在next Frame重新position所有的child(very expensive!)为此，recyclerView提供了一个setHasFixedSize方法，设置为true表明recyclerView自身不会因为childView的变化而resize，这样recyclerVeiw就不会调用requestLayout方法(如果去看RecyclerView的源码，可以看到mEatRequestLayout这个变量，也就是避免重复调用requestLayout造成性能损耗。)，不会造成所有的childView都被重新测量一遍。在ImageView(2011年之后的版本)中，setImageDrawable方法大致长这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setImageDrawable</span><span class=\"params\">(Drawable drawable)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(mDrawable != drawable)&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> oldWidth = mDrawableWidth;</div><div class=\"line\">    <span class=\"keyword\">int</span> oldHeight = mDrawableHeight;</div><div class=\"line\">    updateDrawable(drawable)</div><div class=\"line\">        <span class=\"keyword\">if</span>(oldWidth!=mDrawableWidth||oldHeight!=mDrawableHeight)&#123;</div><div class=\"line\">            requestLayout();</div><div class=\"line\">        &#125;</div><div class=\"line\">        invalidate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>简单来说就是判断下前后图像的宽度或高度是否发生了变化，如果无变化则不需调用requestLayout方法，只需要reDraw。也就避免了这种性能的损耗。但是，TextView的implementation则复杂的多，并没有这种优化。实际操作中，API应该能够告诉客户端图片的width和Height,使用AspectRationImageView加载图片。在图片加载完成之前优先使用PlaceHolder，并设定好加载完成应有的尺寸，这样就避免了后期图片加载完成后的requestLayout。</p>\n<ul>\n<li>使用SortedList用于进行List变更<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SortedList&lt;Item&gt; mSortedList = <span class=\"keyword\">new</span> SortedList&lt;Item&gt;(Item.class,</div><div class=\"line\">    <span class=\"keyword\">new</span> SortedListAdapterCallback&lt;Item&gt;(mAdapter))&#123;</div><div class=\"line\">    <span class=\"comment\">//override三个方法，懒得抄了</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">使用方式十分简单，后面的数据更新操作包括notifyDataChange都被处理好了。</div><div class=\"line\">onNetwokCallback(List&lt;News&gt; news)&#123;</div><div class=\"line\">    mSortedList.addAll(news);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于未发生变化的Item，将直接跳过，实现了最优化的列表数据更新。</p>\n<ul>\n<li>DiffUtil(added in 24.2.0)用于对比数据变更前后的两个List<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">DiffResult result = DiffUtil.calculateDiff(</div><div class=\"line\">    <span class=\"keyword\">new</span> MyCallback(oldList,newList));</div><div class=\"line\">mAdapter.setItems(newList);</div><div class=\"line\">result.dispatchTo(mAdapter);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>只需调用上述方法即可实现列表Item更新及Adapter的notify。DiffUtil的callback有四个方法需要复写，另外有一个方法用于单个Item的部分payload更新。在<a href=\"https://medium.com/@iammert/using-diffutil-in-android-recyclerview-bdca8e4fbb00#.rbtzmmtbg\">medium</a>上找到一个现成的，直接借用了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDiffCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">DiffUtil</span>.<span class=\"title\">Callback</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    List&lt;Person&gt; oldPersons;</div><div class=\"line\">    List&lt;Person&gt; newPersons;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyDiffCallback</span><span class=\"params\">(List&lt;Person&gt; newPersons, List&lt;Person&gt; oldPersons)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.newPersons = newPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.oldPersons = oldPersons;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getOldListSize</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> oldPersons.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNewListSize</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> newPersons.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">areItemsTheSame</span><span class=\"params\">(<span class=\"keyword\">int</span> oldItemPosition, <span class=\"keyword\">int</span> newItemPosition)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> oldPersons.get(oldItemPosition).id == newPersons.get(newItemPosition).id;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">areContentsTheSame</span><span class=\"params\">(<span class=\"keyword\">int</span> oldItemPosition, <span class=\"keyword\">int</span> newItemPosition)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> oldPersons.get(oldItemPosition).equals(newPersons.get(newItemPosition));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Nullable</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getChangePayload</span><span class=\"params\">(<span class=\"keyword\">int</span> oldItemPosition, <span class=\"keyword\">int</span> newItemPosition)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//you can return particular field for changed item.//这里的object会被带到onBindViewHolder中</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getChangePayload(oldItemPosition, newItemPosition);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这些方法会帮助完成remove和add等方法。</p>\n<ul>\n<li><p>viewHolder的生命周期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">onCreate</div><div class=\"line\"><span class=\"title\">onBindViewHolder</span><span class=\"params\">(获取video资源)</span></div><div class=\"line\"><span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(可以在这里开始播放视频)</span></div><div class=\"line\"><span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(可以在这里停止播放视频，随时有可能重新被直接attach，这过程中不会调用onBind方法)</span></div><div class=\"line\"><span class=\"title\">onRecycled</span><span class=\"params\">(可以在这里释放Video资源或者释放Bitmap引用，这之后再使用该ViewHolder需要调用onBind方法)</span></span></div></pre></td></tr></table></figure>\n</li>\n<li><p>recyclerView的一些defer操作对于日常开发的帮助<br>recyclerView会将一些pending操作defer到next frame。eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerView.scrollToPosition(<span class=\"number\">15</span>);</div><div class=\"line\"><span class=\"keyword\">int</span> x = layoutManager.getFirstVisiblePosition()<span class=\"comment\">//此时x并不等于15，因为下一帧并未开始。真正的执行scroll操作需要等到nextFrame执行后才能生效，具体一点的话，就是下一个执行layout的message的callback还未被执行。</span></div><div class=\"line\">又例如，在onCreate中调用</div><div class=\"line\">```java</div><div class=\"line\">recyclerView.scrollToPosition(<span class=\"number\">15</span>)</div><div class=\"line\"><span class=\"comment\">//在netWorkCallback中调用setAdapter，这时recyclerView会利用pending的15 position。原因在于recyclerView会判断如果layoutManager和adapter是否为null，如果都为null。skip layout。</span></div><div class=\"line\"></div><div class=\"line\">- 在getItemViewType中返回R.layout.itemLayout的好处。</div><div class=\"line\">在onCreateViewHolder(ViewGroup viewParent,<span class=\"keyword\">int</span> ViewType)&#123;</div><div class=\"line\">    View itemView = inflate.inflate(ViewType,parent,<span class=\"keyword\">false</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> XXXHolder(itemView);<span class=\"comment\">//aapt可以确保R.layout.xxxx是unique的。</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>ClickListener的实现<br>在onCreateViewHolder中传一个callback，不要在onBindViewHolder中传，不要把onBindViewHolder中的position变为final的。getAdapterPositon可能为NO_POSITION(-1)，因为RecyclerView的UI更新会被defer到next Frame，在下一帧更新被执行前，用户可能已经点击了item，这时的position就有可能是-1(这种情况发生在点击后删除了所有的item数据，这时获得的position就类似于list的indexAt，当然是-1。).</p>\n</li>\n<li><p>LayoutManager只知道LayoutPosition，并不知道AdapterPosition<br>Items在Adapter的数据集中的顺序可能会随时变更，但recyclerView可能并不会调用onBindViewHolder方法，这也就是onBindViewHolder中的position并不可靠的原因。因为viewHolder本身是backed by Item的，而viewHolder的getAdapterPosition能够正确地反应Item在数据集中的顺序。</p>\n</li>\n</ul>\n<h3 id=\"4-一些参考资料\"><a href=\"#4-一些参考资料\" class=\"headerlink\" title=\"4 . 一些参考资料\"></a>4 . 一些参考资料</h3><ul>\n<li><a href=\"https://www.youtube.com/watch?v=imsr8NrIAMs\">RecyclerView Animations and Behind the Scenes (Android Dev Summit 2015)</a></li>\n<li><a href=\"https://github.com/wasabeef/recyclerview-animators\">ItemAnimator模板</a></li>\n<li><a href=\"https://github.com/google/android-ui-toolkit-demos\">UI ToolKit Demo</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=KhLVD6iiZQs\">Yigit Boyar: Pro RecyclerView</a></li>\n</ul>"},{"title":"自定义LayoutManager","date":"2016-10-20T08:37:42.000Z","_content":"\n### 1. 系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\n基本用法都很简单，这里记录一些重要的用法\n\n![](http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/600)\n<!--more-->\n\n- GridLayoutManager可以设置某个Item在某一行占据的Column num（VERTICAL的情况下）\n代码如下:\n```java\nGridLayoutManager manager = new GridLayoutManager(\n   this,2 ,GridLayoutManager.VERTICAL,false)\n\nmanager.setSpanSizeLookup(){\n        new GridLayoutManager.SpanSizeLookup(){\n        @override\n        public int getSpanSize(int position){\n                return (position % 3 == 0 ? 2 : 1)\n            }\n        }\n    }   \n```\n所以，一开始可以把这个2设置大一点，后面可以动态设置，看上去就会造成一种多种格子的错觉。\n\n- GridLayoutManger的同一行的ItemView的itemHeight必须一致，否则同一行的ItemView底部会出现空隙。这种情况请使用StaggeredGridLayoutManager\n\n### 2. LayoutManager <-------> Recycler <--------> Adapter\nLayoutManager永远永远永远不要碰Adapter!!!\n\n### 3.Recycler构造\nRecycler内部有两个集合:\n1. Scrap Heap ： detachAndScrapView() 暂时不用的View丢到这里，随时取回使用\n2. Recycle Pool: removeAndRecycleView() 确定不需要的View丢到这里，拿回来时position或者data变了\n\n### 4.FillGaps,最重要的方法\n1. Discover firstVisible position/location\n2. 找到layout Gaps\n```java\nfindFirstVisiblePosition\n```\n\n3. Scrap everything(丢到ScrapHeap)\n```java\n /**\n         * Temporarily detach and scrap all currently attached child views. Views will be scrapped\n         * into the given Recycler. The Recycler may prefer to reuse scrap views before\n         * other views that were previously recycled.\n         *\n         * @param recycler Recycler to scrap views into\n         */\n        public void detachAndScrapAttachedViews(Recycler recycler) {\n            final int childCount = getChildCount();\n            for (int i = childCount - 1; i >= 0; i--) {\n                final View v = getChildAt(i);\n                scrapOrRecycleView(recycler, i, v);\n            }\n        }\n```\n4. Lay out all visible positions\n\n```java\nfor(...){\n    int nextPosition = ...;\n    View view = recycler.getViewForPosition(nextPosition);\n    addView(view);\n\n    //注意这里的Measure和Layout不是平时使用的measureChild和layout方法，原因是ItemDecoration\n    measureChildWithMargin(view,...)\n    layoutDecorated(view,....)\n    }\n```\n5. Recycle remaining views\n```java\nfinal List<RecyclerView.ViewHolder> scrapList =\n    recycler.getScrapList();\nfor(int i=0;i<scrapList.size;i++){\n    final View removingView = scrapList.get(i);\n    recycler.recycleView(removingView);\n    }    \n```\n\n注意: 丢到RecyclerPool的View的viewHolder、LayoutParams都被清除掉\n\n\n### 4. Scroll事件\n```java\n   public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) {\n\n   //dx 表示系统根据传入的TouchEvent告诉你应该滑动多少\n   dx <0 内容向右滑动\n   dx > 0内容向左滑动\n   //这个正负号和ScrollBy那个是一样的邪门\n   //返回值是你告诉系统你实际滑动了多少\n   offsetChildrenHorizontal(delta);//调用该方法会帮助你移动所有的ChildView，比一个个Iterate方便多了\n   }\n```\n### 5.notifyDataSetChanged()调用了什么函数\n最终会走到onLayoutChildren这里面，就跟重新走一遍layout就可以了\n\n### 6.ScrollToPosition()和SmoothScrollToPosition()\n两者的实现的不同:\nscrollToPosition:Track Requested Position、Trigger requestLayout\nSmoothscrollToPosition: Create a SmoothScroller instance、Set the Target Position、invoke startSmoothScroll\nSmoothScroller是一个接口，在里面实现computeScrollVectorForPosition返回需要到达的位置\n\n### 7. supportPredictiveItemAnimation主要用于ItemChange Animation\n主要在发生变化时展示动画。如果想要在滑动过程中展示动画的话，可以考虑在onViewAttachedToWindow或者onBindViewHolder里面给View添加TranslationX（从左边出来），Alpha(透明度从0变成1)，或者ScaleX等等\n\n\n\n### Reference\n1. [Dave Smith](https://github.com/devunwired/recyclerview-playground)\n2. [500px](https://github.com/500px/greedo-layout-for-android.git)\n","source":"_posts/2016-10-20-write-your-own-layoutmanager.md","raw":"---\ntitle: 自定义LayoutManager\ndate: 2016-10-20 16:37:42\ncategories: blog  \ntags: [android]\n---\n\n### 1. 系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\n基本用法都很简单，这里记录一些重要的用法\n\n![](http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/600)\n<!--more-->\n\n- GridLayoutManager可以设置某个Item在某一行占据的Column num（VERTICAL的情况下）\n代码如下:\n```java\nGridLayoutManager manager = new GridLayoutManager(\n   this,2 ,GridLayoutManager.VERTICAL,false)\n\nmanager.setSpanSizeLookup(){\n        new GridLayoutManager.SpanSizeLookup(){\n        @override\n        public int getSpanSize(int position){\n                return (position % 3 == 0 ? 2 : 1)\n            }\n        }\n    }   \n```\n所以，一开始可以把这个2设置大一点，后面可以动态设置，看上去就会造成一种多种格子的错觉。\n\n- GridLayoutManger的同一行的ItemView的itemHeight必须一致，否则同一行的ItemView底部会出现空隙。这种情况请使用StaggeredGridLayoutManager\n\n### 2. LayoutManager <-------> Recycler <--------> Adapter\nLayoutManager永远永远永远不要碰Adapter!!!\n\n### 3.Recycler构造\nRecycler内部有两个集合:\n1. Scrap Heap ： detachAndScrapView() 暂时不用的View丢到这里，随时取回使用\n2. Recycle Pool: removeAndRecycleView() 确定不需要的View丢到这里，拿回来时position或者data变了\n\n### 4.FillGaps,最重要的方法\n1. Discover firstVisible position/location\n2. 找到layout Gaps\n```java\nfindFirstVisiblePosition\n```\n\n3. Scrap everything(丢到ScrapHeap)\n```java\n /**\n         * Temporarily detach and scrap all currently attached child views. Views will be scrapped\n         * into the given Recycler. The Recycler may prefer to reuse scrap views before\n         * other views that were previously recycled.\n         *\n         * @param recycler Recycler to scrap views into\n         */\n        public void detachAndScrapAttachedViews(Recycler recycler) {\n            final int childCount = getChildCount();\n            for (int i = childCount - 1; i >= 0; i--) {\n                final View v = getChildAt(i);\n                scrapOrRecycleView(recycler, i, v);\n            }\n        }\n```\n4. Lay out all visible positions\n\n```java\nfor(...){\n    int nextPosition = ...;\n    View view = recycler.getViewForPosition(nextPosition);\n    addView(view);\n\n    //注意这里的Measure和Layout不是平时使用的measureChild和layout方法，原因是ItemDecoration\n    measureChildWithMargin(view,...)\n    layoutDecorated(view,....)\n    }\n```\n5. Recycle remaining views\n```java\nfinal List<RecyclerView.ViewHolder> scrapList =\n    recycler.getScrapList();\nfor(int i=0;i<scrapList.size;i++){\n    final View removingView = scrapList.get(i);\n    recycler.recycleView(removingView);\n    }    \n```\n\n注意: 丢到RecyclerPool的View的viewHolder、LayoutParams都被清除掉\n\n\n### 4. Scroll事件\n```java\n   public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) {\n\n   //dx 表示系统根据传入的TouchEvent告诉你应该滑动多少\n   dx <0 内容向右滑动\n   dx > 0内容向左滑动\n   //这个正负号和ScrollBy那个是一样的邪门\n   //返回值是你告诉系统你实际滑动了多少\n   offsetChildrenHorizontal(delta);//调用该方法会帮助你移动所有的ChildView，比一个个Iterate方便多了\n   }\n```\n### 5.notifyDataSetChanged()调用了什么函数\n最终会走到onLayoutChildren这里面，就跟重新走一遍layout就可以了\n\n### 6.ScrollToPosition()和SmoothScrollToPosition()\n两者的实现的不同:\nscrollToPosition:Track Requested Position、Trigger requestLayout\nSmoothscrollToPosition: Create a SmoothScroller instance、Set the Target Position、invoke startSmoothScroll\nSmoothScroller是一个接口，在里面实现computeScrollVectorForPosition返回需要到达的位置\n\n### 7. supportPredictiveItemAnimation主要用于ItemChange Animation\n主要在发生变化时展示动画。如果想要在滑动过程中展示动画的话，可以考虑在onViewAttachedToWindow或者onBindViewHolder里面给View添加TranslationX（从左边出来），Alpha(透明度从0变成1)，或者ScaleX等等\n\n\n\n### Reference\n1. [Dave Smith](https://github.com/devunwired/recyclerview-playground)\n2. [500px](https://github.com/500px/greedo-layout-for-android.git)\n","slug":"2016-10-20-write-your-own-layoutmanager","published":1,"updated":"2017-07-23T10:43:10.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdng5000abovricu47aor","content":"<h3 id=\"1-系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\"><a href=\"#1-系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\" class=\"headerlink\" title=\"1. 系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\"></a>1. 系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。</h3><p>基本用法都很简单，这里记录一些重要的用法</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<ul>\n<li>GridLayoutManager可以设置某个Item在某一行占据的Column num（VERTICAL的情况下）<br>代码如下:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">GridLayoutManager manager = <span class=\"keyword\">new</span> GridLayoutManager(</div><div class=\"line\">   <span class=\"keyword\">this</span>,<span class=\"number\">2</span> ,GridLayoutManager.VERTICAL,<span class=\"keyword\">false</span>)</div><div class=\"line\"></div><div class=\"line\">manager.setSpanSizeLookup()&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> GridLayoutManager.SpanSizeLookup()&#123;</div><div class=\"line\">        <span class=\"meta\">@override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSpanSize</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span></span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> (position % <span class=\"number\">3</span> == <span class=\"number\">0</span> ? <span class=\"number\">2</span> : <span class=\"number\">1</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以，一开始可以把这个2设置大一点，后面可以动态设置，看上去就会造成一种多种格子的错觉。</p>\n<ul>\n<li>GridLayoutManger的同一行的ItemView的itemHeight必须一致，否则同一行的ItemView底部会出现空隙。这种情况请使用StaggeredGridLayoutManager</li>\n</ul>\n<h3 id=\"2-LayoutManager-lt-——-gt-Recycler-lt-——–-gt-Adapter\"><a href=\"#2-LayoutManager-lt-——-gt-Recycler-lt-——–-gt-Adapter\" class=\"headerlink\" title=\"2. LayoutManager &lt;——-&gt; Recycler &lt;——–&gt; Adapter\"></a>2. LayoutManager &lt;——-&gt; Recycler &lt;——–&gt; Adapter</h3><p>LayoutManager永远永远永远不要碰Adapter!!!</p>\n<h3 id=\"3-Recycler构造\"><a href=\"#3-Recycler构造\" class=\"headerlink\" title=\"3.Recycler构造\"></a>3.Recycler构造</h3><p>Recycler内部有两个集合:</p>\n<ol>\n<li>Scrap Heap ： detachAndScrapView() 暂时不用的View丢到这里，随时取回使用</li>\n<li>Recycle Pool: removeAndRecycleView() 确定不需要的View丢到这里，拿回来时position或者data变了</li>\n</ol>\n<h3 id=\"4-FillGaps-最重要的方法\"><a href=\"#4-FillGaps-最重要的方法\" class=\"headerlink\" title=\"4.FillGaps,最重要的方法\"></a>4.FillGaps,最重要的方法</h3><ol>\n<li>Discover firstVisible position/location</li>\n<li><p>找到layout Gaps</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findFirstVisiblePosition</div></pre></td></tr></table></figure>\n</li>\n<li><p>Scrap everything(丢到ScrapHeap)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">        * Temporarily detach and scrap all currently attached child views. Views will be scrapped</div><div class=\"line\">        * into the given Recycler. The Recycler may prefer to reuse scrap views before</div><div class=\"line\">        * other views that were previously recycled.</div><div class=\"line\">        *</div><div class=\"line\">        * <span class=\"doctag\">@param</span> recycler Recycler to scrap views into</div><div class=\"line\">        */</span></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">detachAndScrapAttachedViews</span><span class=\"params\">(Recycler recycler)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childCount = getChildCount();</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> View v = getChildAt(i);</div><div class=\"line\">               scrapOrRecycleView(recycler, i, v);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Lay out all visible positions</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(...)&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nextPosition = ...;</div><div class=\"line\">    View view = recycler.getViewForPosition(nextPosition);</div><div class=\"line\">    addView(view);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意这里的Measure和Layout不是平时使用的measureChild和layout方法，原因是ItemDecoration</span></div><div class=\"line\">    measureChildWithMargin(view,...)</div><div class=\"line\">    layoutDecorated(view,....)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>Recycle remaining views<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> List&lt;RecyclerView.ViewHolder&gt; scrapList =</div><div class=\"line\">    recycler.getScrapList();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;scrapList.size;i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> View removingView = scrapList.get(i);</div><div class=\"line\">    recycler.recycleView(removingView);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意: 丢到RecyclerPool的View的viewHolder、LayoutParams都被清除掉</p>\n<h3 id=\"4-Scroll事件\"><a href=\"#4-Scroll事件\" class=\"headerlink\" title=\"4. Scroll事件\"></a>4. Scroll事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">scrollHorizontallyBy</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//dx 表示系统根据传入的TouchEvent告诉你应该滑动多少</span></div><div class=\"line\">dx &lt;<span class=\"number\">0</span> 内容向右滑动</div><div class=\"line\">dx &gt; <span class=\"number\">0</span>内容向左滑动</div><div class=\"line\"><span class=\"comment\">//这个正负号和ScrollBy那个是一样的邪门</span></div><div class=\"line\"><span class=\"comment\">//返回值是你告诉系统你实际滑动了多少</span></div><div class=\"line\">offsetChildrenHorizontal(delta);<span class=\"comment\">//调用该方法会帮助你移动所有的ChildView，比一个个Iterate方便多了</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-notifyDataSetChanged-调用了什么函数\"><a href=\"#5-notifyDataSetChanged-调用了什么函数\" class=\"headerlink\" title=\"5.notifyDataSetChanged()调用了什么函数\"></a>5.notifyDataSetChanged()调用了什么函数</h3><p>最终会走到onLayoutChildren这里面，就跟重新走一遍layout就可以了</p>\n<h3 id=\"6-ScrollToPosition-和SmoothScrollToPosition\"><a href=\"#6-ScrollToPosition-和SmoothScrollToPosition\" class=\"headerlink\" title=\"6.ScrollToPosition()和SmoothScrollToPosition()\"></a>6.ScrollToPosition()和SmoothScrollToPosition()</h3><p>两者的实现的不同:<br>scrollToPosition:Track Requested Position、Trigger requestLayout<br>SmoothscrollToPosition: Create a SmoothScroller instance、Set the Target Position、invoke startSmoothScroll<br>SmoothScroller是一个接口，在里面实现computeScrollVectorForPosition返回需要到达的位置</p>\n<h3 id=\"7-supportPredictiveItemAnimation主要用于ItemChange-Animation\"><a href=\"#7-supportPredictiveItemAnimation主要用于ItemChange-Animation\" class=\"headerlink\" title=\"7. supportPredictiveItemAnimation主要用于ItemChange Animation\"></a>7. supportPredictiveItemAnimation主要用于ItemChange Animation</h3><p>主要在发生变化时展示动画。如果想要在滑动过程中展示动画的话，可以考虑在onViewAttachedToWindow或者onBindViewHolder里面给View添加TranslationX（从左边出来），Alpha(透明度从0变成1)，或者ScaleX等等</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"https://github.com/devunwired/recyclerview-playground\">Dave Smith</a></li>\n<li><a href=\"https://github.com/500px/greedo-layout-for-android.git\">500px</a></li>\n</ol>\n","excerpt":"<h3 id=\"1-系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\"><a href=\"#1-系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\" class=\"headerlink\" title=\"1. 系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。\"></a>1. 系统为我们提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。</h3><p>基本用法都很简单，这里记录一些重要的用法</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<ul>\n<li>GridLayoutManager可以设置某个Item在某一行占据的Column num（VERTICAL的情况下）<br>代码如下:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">GridLayoutManager manager = <span class=\"keyword\">new</span> GridLayoutManager(</div><div class=\"line\">   <span class=\"keyword\">this</span>,<span class=\"number\">2</span> ,GridLayoutManager.VERTICAL,<span class=\"keyword\">false</span>)</div><div class=\"line\"></div><div class=\"line\">manager.setSpanSizeLookup()&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> GridLayoutManager.SpanSizeLookup()&#123;</div><div class=\"line\">        <span class=\"meta\">@override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSpanSize</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span></span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> (position % <span class=\"number\">3</span> == <span class=\"number\">0</span> ? <span class=\"number\">2</span> : <span class=\"number\">1</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以，一开始可以把这个2设置大一点，后面可以动态设置，看上去就会造成一种多种格子的错觉。</p>\n<ul>\n<li>GridLayoutManger的同一行的ItemView的itemHeight必须一致，否则同一行的ItemView底部会出现空隙。这种情况请使用StaggeredGridLayoutManager</li>\n</ul>\n<h3 id=\"2-LayoutManager-lt-——-gt-Recycler-lt-——–-gt-Adapter\"><a href=\"#2-LayoutManager-lt-——-gt-Recycler-lt-——–-gt-Adapter\" class=\"headerlink\" title=\"2. LayoutManager &lt;——-&gt; Recycler &lt;——–&gt; Adapter\"></a>2. LayoutManager &lt;——-&gt; Recycler &lt;——–&gt; Adapter</h3><p>LayoutManager永远永远永远不要碰Adapter!!!</p>\n<h3 id=\"3-Recycler构造\"><a href=\"#3-Recycler构造\" class=\"headerlink\" title=\"3.Recycler构造\"></a>3.Recycler构造</h3><p>Recycler内部有两个集合:</p>\n<ol>\n<li>Scrap Heap ： detachAndScrapView() 暂时不用的View丢到这里，随时取回使用</li>\n<li>Recycle Pool: removeAndRecycleView() 确定不需要的View丢到这里，拿回来时position或者data变了</li>\n</ol>\n<h3 id=\"4-FillGaps-最重要的方法\"><a href=\"#4-FillGaps-最重要的方法\" class=\"headerlink\" title=\"4.FillGaps,最重要的方法\"></a>4.FillGaps,最重要的方法</h3><ol>\n<li>Discover firstVisible position/location</li>\n<li><p>找到layout Gaps</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findFirstVisiblePosition</div></pre></td></tr></table></figure>\n</li>\n<li><p>Scrap everything(丢到ScrapHeap)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">        * Temporarily detach and scrap all currently attached child views. Views will be scrapped</div><div class=\"line\">        * into the given Recycler. The Recycler may prefer to reuse scrap views before</div><div class=\"line\">        * other views that were previously recycled.</div><div class=\"line\">        *</div><div class=\"line\">        * <span class=\"doctag\">@param</span> recycler Recycler to scrap views into</div><div class=\"line\">        */</span></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">detachAndScrapAttachedViews</span><span class=\"params\">(Recycler recycler)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childCount = getChildCount();</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> View v = getChildAt(i);</div><div class=\"line\">               scrapOrRecycleView(recycler, i, v);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Lay out all visible positions</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(...)&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nextPosition = ...;</div><div class=\"line\">    View view = recycler.getViewForPosition(nextPosition);</div><div class=\"line\">    addView(view);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意这里的Measure和Layout不是平时使用的measureChild和layout方法，原因是ItemDecoration</span></div><div class=\"line\">    measureChildWithMargin(view,...)</div><div class=\"line\">    layoutDecorated(view,....)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>Recycle remaining views<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> List&lt;RecyclerView.ViewHolder&gt; scrapList =</div><div class=\"line\">    recycler.getScrapList();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;scrapList.size;i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> View removingView = scrapList.get(i);</div><div class=\"line\">    recycler.recycleView(removingView);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意: 丢到RecyclerPool的View的viewHolder、LayoutParams都被清除掉</p>\n<h3 id=\"4-Scroll事件\"><a href=\"#4-Scroll事件\" class=\"headerlink\" title=\"4. Scroll事件\"></a>4. Scroll事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">scrollHorizontallyBy</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//dx 表示系统根据传入的TouchEvent告诉你应该滑动多少</span></div><div class=\"line\">dx &lt;<span class=\"number\">0</span> 内容向右滑动</div><div class=\"line\">dx &gt; <span class=\"number\">0</span>内容向左滑动</div><div class=\"line\"><span class=\"comment\">//这个正负号和ScrollBy那个是一样的邪门</span></div><div class=\"line\"><span class=\"comment\">//返回值是你告诉系统你实际滑动了多少</span></div><div class=\"line\">offsetChildrenHorizontal(delta);<span class=\"comment\">//调用该方法会帮助你移动所有的ChildView，比一个个Iterate方便多了</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-notifyDataSetChanged-调用了什么函数\"><a href=\"#5-notifyDataSetChanged-调用了什么函数\" class=\"headerlink\" title=\"5.notifyDataSetChanged()调用了什么函数\"></a>5.notifyDataSetChanged()调用了什么函数</h3><p>最终会走到onLayoutChildren这里面，就跟重新走一遍layout就可以了</p>\n<h3 id=\"6-ScrollToPosition-和SmoothScrollToPosition\"><a href=\"#6-ScrollToPosition-和SmoothScrollToPosition\" class=\"headerlink\" title=\"6.ScrollToPosition()和SmoothScrollToPosition()\"></a>6.ScrollToPosition()和SmoothScrollToPosition()</h3><p>两者的实现的不同:<br>scrollToPosition:Track Requested Position、Trigger requestLayout<br>SmoothscrollToPosition: Create a SmoothScroller instance、Set the Target Position、invoke startSmoothScroll<br>SmoothScroller是一个接口，在里面实现computeScrollVectorForPosition返回需要到达的位置</p>\n<h3 id=\"7-supportPredictiveItemAnimation主要用于ItemChange-Animation\"><a href=\"#7-supportPredictiveItemAnimation主要用于ItemChange-Animation\" class=\"headerlink\" title=\"7. supportPredictiveItemAnimation主要用于ItemChange Animation\"></a>7. supportPredictiveItemAnimation主要用于ItemChange Animation</h3><p>主要在发生变化时展示动画。如果想要在滑动过程中展示动画的话，可以考虑在onViewAttachedToWindow或者onBindViewHolder里面给View添加TranslationX（从左边出来），Alpha(透明度从0变成1)，或者ScaleX等等</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"https://github.com/devunwired/recyclerview-playground\">Dave Smith</a></li>\n<li><a href=\"https://github.com/500px/greedo-layout-for-android.git\">500px</a></li>\n</ol>"},{"title":"让service常驻后台的方法","date":"2016-10-20T13:35:10.000Z","_content":"\n今天在V2EX上看到有人提到Notification有漏洞，好奇也就查了一下，结果发现有人专门针对这个问题进行了[分析](http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/)。本身的技术分析并不多，写在这里只是为了作为今后的一个参考。<!--more-->\n\n### 1. 问题的由来\nAndroid对后台应用是有一个权重区分的，最直观的就是查看最近使用的应用，这里每一个应用可能有一个或者多个Process，而系统在资源紧张时会干掉一些Process，而决定后台应用生死的是一个Lru List，也就是least recently used 会被干掉。显然大家都不希望自己被干掉，DAU对于很多应用来说是优先于系统资源和用户体验的。\n根据[官方文档](https://developer.android.com/guide/components/processes-and-threads.html),Android Process有五种，根据优先级从高到低为:\n- 前台进程\n- 可见进程\n- 服务进程\n- 后台进程\n- 空进程\n\n越靠前的进程就越不容易被系统干掉，所以大家都希望能够成为前台进程。成为前台进程的条件:\n```\n用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：\n托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）\n托管某个 Service，后者绑定到用户正在交互的 Activity\n托管正在“前台”运行的 Service（服务已调用 startForeground()）\n托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）\n托管正执行其 onReceive() 方法的 BroadcastReceiver\n通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。\n```\n以上条件只有startForeground满足条件了，但大家都知道startForeground会在通知栏常驻一个Notification，且用户取消不了。对于我这种强迫症来说实在是太丑。\n\n\n### 2. startForeground一定会在系统状态栏显示一个通知，真的吗?\n```java\nvoid startForeground (int id, \n                Notification notification)\n```\n我找到了G+上的Chris Banes的一篇[post](https://plus.google.com/+AndroidDevelopers/posts/NEPWzPwSruR)，这其中明确指出\n```\nUnfortunately there are a number of applications on Google Play which are using the startForeground() API without passing a valid notification. While this worked in previous versions of Android, it is a loophole which has been fixed in Android 4.3. The system now displays a notifications for you automatically if you do not provide a valid one.\n```\n也就是说，API 18以前，只需要提供一个无效的Notification就可以让Notification不显示了。所以，判断下API<18的时候，直接new Notification()就可以得到一个不完整的Notification.\n文章也指出了这是一个Loophole（已经是个贬义词了）。\nApi 18之后的修复措施，看[ServiceRecord的源码](https://android.googlesource.com/platform/frameworks/base.git/+/android-4.3_r2.1/services/java/com/android/server/am/ServiceRecord.java):\n\n```java\npublic void postNotification() {\n        final int appUid = appInfo.uid;\n        final int appPid = app.pid;\n        if (foregroundId != 0 && foregroundNoti != null) {\n            // Do asynchronous communication with notification manager to\n            // avoid deadlocks.\n            final String localPackageName = packageName;\n            final int localForegroundId = foregroundId;\n            final Notification localForegroundNoti = foregroundNoti;\n            ams.mHandler.post(new Runnable() {\n                public void run() {\n                    NotificationManagerService nm =\n                            (NotificationManagerService) NotificationManager.getService();\n                    if (nm == null) {\n                        return;\n                    }\n                    try {\n                        if (localForegroundNoti.icon == 0) {\n                            // It is not correct for the caller to supply a notification\n                            // icon, but this used to be able to slip through, so for\n                            // those dirty apps give it the app's icon.\n                            localForegroundNoti.icon = appInfo.icon;\n                            // Do not allow apps to present a sneaky invisible content view either.\n                            localForegroundNoti.contentView = null;\n                            localForegroundNoti.bigContentView = null;\n                            CharSequence appName = appInfo.loadLabel(\n                                    ams.mContext.getPackageManager());\n                            if (appName == null) {\n                                appName = appInfo.packageName;\n                            }\n                            Context ctx = null;\n                            try {\n                                ctx = ams.mContext.createPackageContext(\n                                        appInfo.packageName, 0);\n                                Intent runningIntent = new Intent(\n                                        Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n                                runningIntent.setData(Uri.fromParts(\"package\",\n                                        appInfo.packageName, null));\n                                PendingIntent pi = PendingIntent.getActivity(ams.mContext, 0,\n                                        runningIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n                                localForegroundNoti.setLatestEventInfo(ctx,\n                                        ams.mContext.getString(\n                                                com.android.internal.R.string\n                                                        .app_running_notification_title,\n                                                appName),\n                                        ams.mContext.getString(\n                                                com.android.internal.R.string\n                                                        .app_running_notification_text,\n                                                appName),\n                                        pi);\n                            } catch (PackageManager.NameNotFoundException e) {\n                                localForegroundNoti.icon = 0;\n                            }\n                        }\n                        if (localForegroundNoti.icon == 0) {\n                            // Notifications whose icon is 0 are defined to not show\n                            // a notification, silently ignoring it.  We don't want to\n                            // just ignore it, we want to prevent the service from\n                            // being foreground.\n                            throw new RuntimeException(\"icon must be non-zero\");\n                        }\n                        int[] outId = new int[1];\n                        nm.enqueueNotificationInternal(localPackageName, localPackageName,\n                                appUid, appPid, null, localForegroundId, localForegroundNoti,\n                                outId, userId);\n                    } catch (RuntimeException e) {\n                        Slog.w(ActivityManagerService.TAG,\n                                \"Error showing notification for service\", e);\n                        // If it gave us a garbage notification, it doesn't\n                        // get to be foreground.\n                        ams.setServiceForeground(name, ServiceRecord.this,\n                                0, null, true);\n                        ams.crashApplication(appUid, appPid, localPackageName,\n                                \"Bad notification for startForeground: \" + e);\n                    }\n                }\n            });\n        }\n    }\n```\n单单是看注释大概能看出来Android团队对于这种做法的不满。所以如果不提供有效Notification，则显示你的App的Icon。所以Api 18以上一定会显示一个Notification。\n\n然而套路还是太深。。。。又有人给出了API 18以上的解决办法:\n我在[这里](http://blog.csdn.net/wxx614817/article/details/50669420)找到了新的方法，简单来说就是起两个Service，两个Service都在一个进程里。\n先Start A Service ，onCreate里面 bind B Service，\n在onServiceConnected的时候A service startForeground(processId,notification)\nB service startForeground(processId,notification)\n随后立即调用B service stopForeGround(true)\n由于两个Notification具有相同的id，所以A service最终成为Foreground Service，Notification也被清除掉了。\n\n\n### 3.最后\n整个过程看下来，API 18以下，给一个不完整的Notification(比如new Notification())，就不会出现在通知栏；API 18以上，起两个Service，B Service负责取消Notification就可以了。\n目前看来，国内很多App为了保活，都采取了类似的方式。\n而整体技术层面的实现并不难，只是利用了一个又一个小漏洞罢了。\n所谓脏代码不过是技术上做的一些欺骗系统的手段，作为开发者，理应明白谷歌设计这一套系统是为了更好的提升用户体验（占据市场）。然而在当前国内应用开发环境下，我们真的能够为用户考虑考虑吗，或者说，我们提交的代码能吗？\n\n![](http://odzl05jxx.bkt.clouddn.com/blamingtheuser-big.png?imageView2/2/w/600)\n\n\n\n### Reference\n- [支付宝后台不死的黑科技](http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/)\n- [Android的startForeground前台Service如何去掉通知显示](http://blog.csdn.net/wxx614817/article/details/50669420)\n\n\n","source":"_posts/2016-10-20-android-dirty-code.md","raw":"---\ntitle: 让service常驻后台的方法\ndate: 2016-10-20 21:35:10\ncategories: blog\ntags: [android]\n---\n\n今天在V2EX上看到有人提到Notification有漏洞，好奇也就查了一下，结果发现有人专门针对这个问题进行了[分析](http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/)。本身的技术分析并不多，写在这里只是为了作为今后的一个参考。<!--more-->\n\n### 1. 问题的由来\nAndroid对后台应用是有一个权重区分的，最直观的就是查看最近使用的应用，这里每一个应用可能有一个或者多个Process，而系统在资源紧张时会干掉一些Process，而决定后台应用生死的是一个Lru List，也就是least recently used 会被干掉。显然大家都不希望自己被干掉，DAU对于很多应用来说是优先于系统资源和用户体验的。\n根据[官方文档](https://developer.android.com/guide/components/processes-and-threads.html),Android Process有五种，根据优先级从高到低为:\n- 前台进程\n- 可见进程\n- 服务进程\n- 后台进程\n- 空进程\n\n越靠前的进程就越不容易被系统干掉，所以大家都希望能够成为前台进程。成为前台进程的条件:\n```\n用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：\n托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）\n托管某个 Service，后者绑定到用户正在交互的 Activity\n托管正在“前台”运行的 Service（服务已调用 startForeground()）\n托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）\n托管正执行其 onReceive() 方法的 BroadcastReceiver\n通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。\n```\n以上条件只有startForeground满足条件了，但大家都知道startForeground会在通知栏常驻一个Notification，且用户取消不了。对于我这种强迫症来说实在是太丑。\n\n\n### 2. startForeground一定会在系统状态栏显示一个通知，真的吗?\n```java\nvoid startForeground (int id, \n                Notification notification)\n```\n我找到了G+上的Chris Banes的一篇[post](https://plus.google.com/+AndroidDevelopers/posts/NEPWzPwSruR)，这其中明确指出\n```\nUnfortunately there are a number of applications on Google Play which are using the startForeground() API without passing a valid notification. While this worked in previous versions of Android, it is a loophole which has been fixed in Android 4.3. The system now displays a notifications for you automatically if you do not provide a valid one.\n```\n也就是说，API 18以前，只需要提供一个无效的Notification就可以让Notification不显示了。所以，判断下API<18的时候，直接new Notification()就可以得到一个不完整的Notification.\n文章也指出了这是一个Loophole（已经是个贬义词了）。\nApi 18之后的修复措施，看[ServiceRecord的源码](https://android.googlesource.com/platform/frameworks/base.git/+/android-4.3_r2.1/services/java/com/android/server/am/ServiceRecord.java):\n\n```java\npublic void postNotification() {\n        final int appUid = appInfo.uid;\n        final int appPid = app.pid;\n        if (foregroundId != 0 && foregroundNoti != null) {\n            // Do asynchronous communication with notification manager to\n            // avoid deadlocks.\n            final String localPackageName = packageName;\n            final int localForegroundId = foregroundId;\n            final Notification localForegroundNoti = foregroundNoti;\n            ams.mHandler.post(new Runnable() {\n                public void run() {\n                    NotificationManagerService nm =\n                            (NotificationManagerService) NotificationManager.getService();\n                    if (nm == null) {\n                        return;\n                    }\n                    try {\n                        if (localForegroundNoti.icon == 0) {\n                            // It is not correct for the caller to supply a notification\n                            // icon, but this used to be able to slip through, so for\n                            // those dirty apps give it the app's icon.\n                            localForegroundNoti.icon = appInfo.icon;\n                            // Do not allow apps to present a sneaky invisible content view either.\n                            localForegroundNoti.contentView = null;\n                            localForegroundNoti.bigContentView = null;\n                            CharSequence appName = appInfo.loadLabel(\n                                    ams.mContext.getPackageManager());\n                            if (appName == null) {\n                                appName = appInfo.packageName;\n                            }\n                            Context ctx = null;\n                            try {\n                                ctx = ams.mContext.createPackageContext(\n                                        appInfo.packageName, 0);\n                                Intent runningIntent = new Intent(\n                                        Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n                                runningIntent.setData(Uri.fromParts(\"package\",\n                                        appInfo.packageName, null));\n                                PendingIntent pi = PendingIntent.getActivity(ams.mContext, 0,\n                                        runningIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n                                localForegroundNoti.setLatestEventInfo(ctx,\n                                        ams.mContext.getString(\n                                                com.android.internal.R.string\n                                                        .app_running_notification_title,\n                                                appName),\n                                        ams.mContext.getString(\n                                                com.android.internal.R.string\n                                                        .app_running_notification_text,\n                                                appName),\n                                        pi);\n                            } catch (PackageManager.NameNotFoundException e) {\n                                localForegroundNoti.icon = 0;\n                            }\n                        }\n                        if (localForegroundNoti.icon == 0) {\n                            // Notifications whose icon is 0 are defined to not show\n                            // a notification, silently ignoring it.  We don't want to\n                            // just ignore it, we want to prevent the service from\n                            // being foreground.\n                            throw new RuntimeException(\"icon must be non-zero\");\n                        }\n                        int[] outId = new int[1];\n                        nm.enqueueNotificationInternal(localPackageName, localPackageName,\n                                appUid, appPid, null, localForegroundId, localForegroundNoti,\n                                outId, userId);\n                    } catch (RuntimeException e) {\n                        Slog.w(ActivityManagerService.TAG,\n                                \"Error showing notification for service\", e);\n                        // If it gave us a garbage notification, it doesn't\n                        // get to be foreground.\n                        ams.setServiceForeground(name, ServiceRecord.this,\n                                0, null, true);\n                        ams.crashApplication(appUid, appPid, localPackageName,\n                                \"Bad notification for startForeground: \" + e);\n                    }\n                }\n            });\n        }\n    }\n```\n单单是看注释大概能看出来Android团队对于这种做法的不满。所以如果不提供有效Notification，则显示你的App的Icon。所以Api 18以上一定会显示一个Notification。\n\n然而套路还是太深。。。。又有人给出了API 18以上的解决办法:\n我在[这里](http://blog.csdn.net/wxx614817/article/details/50669420)找到了新的方法，简单来说就是起两个Service，两个Service都在一个进程里。\n先Start A Service ，onCreate里面 bind B Service，\n在onServiceConnected的时候A service startForeground(processId,notification)\nB service startForeground(processId,notification)\n随后立即调用B service stopForeGround(true)\n由于两个Notification具有相同的id，所以A service最终成为Foreground Service，Notification也被清除掉了。\n\n\n### 3.最后\n整个过程看下来，API 18以下，给一个不完整的Notification(比如new Notification())，就不会出现在通知栏；API 18以上，起两个Service，B Service负责取消Notification就可以了。\n目前看来，国内很多App为了保活，都采取了类似的方式。\n而整体技术层面的实现并不难，只是利用了一个又一个小漏洞罢了。\n所谓脏代码不过是技术上做的一些欺骗系统的手段，作为开发者，理应明白谷歌设计这一套系统是为了更好的提升用户体验（占据市场）。然而在当前国内应用开发环境下，我们真的能够为用户考虑考虑吗，或者说，我们提交的代码能吗？\n\n![](http://odzl05jxx.bkt.clouddn.com/blamingtheuser-big.png?imageView2/2/w/600)\n\n\n\n### Reference\n- [支付宝后台不死的黑科技](http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/)\n- [Android的startForeground前台Service如何去掉通知显示](http://blog.csdn.net/wxx614817/article/details/50669420)\n\n\n","slug":"2016-10-20-android-dirty-code","published":1,"updated":"2017-04-23T10:50:24.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdng9000cbovrtqnav23x","content":"<p>今天在V2EX上看到有人提到Notification有漏洞，好奇也就查了一下，结果发现有人专门针对这个问题进行了<a href=\"http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/\">分析</a>。本身的技术分析并不多，写在这里只是为了作为今后的一个参考。<a id=\"more\"></a></p>\n<h3 id=\"1-问题的由来\"><a href=\"#1-问题的由来\" class=\"headerlink\" title=\"1. 问题的由来\"></a>1. 问题的由来</h3><p>Android对后台应用是有一个权重区分的，最直观的就是查看最近使用的应用，这里每一个应用可能有一个或者多个Process，而系统在资源紧张时会干掉一些Process，而决定后台应用生死的是一个Lru List，也就是least recently used 会被干掉。显然大家都不希望自己被干掉，DAU对于很多应用来说是优先于系统资源和用户体验的。<br>根据<a href=\"https://developer.android.com/guide/components/processes-and-threads.html\">官方文档</a>,Android Process有五种，根据优先级从高到低为:</p>\n<ul>\n<li>前台进程</li>\n<li>可见进程</li>\n<li>服务进程</li>\n<li>后台进程</li>\n<li>空进程</li>\n</ul>\n<p>越靠前的进程就越不容易被系统干掉，所以大家都希望能够成为前台进程。成为前台进程的条件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</div><div class=\"line\">托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</div><div class=\"line\">托管某个 Service，后者绑定到用户正在交互的 Activity</div><div class=\"line\">托管正在“前台”运行的 Service（服务已调用 startForeground()）</div><div class=\"line\">托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</div><div class=\"line\">托管正执行其 onReceive() 方法的 BroadcastReceiver</div><div class=\"line\">通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</div></pre></td></tr></table></figure></p>\n<p>以上条件只有startForeground满足条件了，但大家都知道startForeground会在通知栏常驻一个Notification，且用户取消不了。对于我这种强迫症来说实在是太丑。</p>\n<h3 id=\"2-startForeground一定会在系统状态栏显示一个通知，真的吗\"><a href=\"#2-startForeground一定会在系统状态栏显示一个通知，真的吗\" class=\"headerlink\" title=\"2. startForeground一定会在系统状态栏显示一个通知，真的吗?\"></a>2. startForeground一定会在系统状态栏显示一个通知，真的吗?</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startForeground</span> <span class=\"params\">(<span class=\"keyword\">int</span> id, </div><div class=\"line\">                Notification notification)</span></span></div></pre></td></tr></table></figure>\n<p>我找到了G+上的Chris Banes的一篇<a href=\"https://plus.google.com/+AndroidDevelopers/posts/NEPWzPwSruR\">post</a>，这其中明确指出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Unfortunately there are a number of applications on Google Play which are using the startForeground() API without passing a valid notification. While this worked in previous versions of Android, it is a loophole which has been fixed in Android 4.3. The system now displays a notifications for you automatically if you do not provide a valid one.</div></pre></td></tr></table></figure></p>\n<p>也就是说，API 18以前，只需要提供一个无效的Notification就可以让Notification不显示了。所以，判断下API&lt;18的时候，直接new Notification()就可以得到一个不完整的Notification.<br>文章也指出了这是一个Loophole（已经是个贬义词了）。<br>Api 18之后的修复措施，看<a href=\"https://android.googlesource.com/platform/frameworks/base.git/+/android-4.3_r2.1/services/java/com/android/server/am/ServiceRecord.java\">ServiceRecord的源码</a>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postNotification</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> appUid = appInfo.uid;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> appPid = app.pid;</div><div class=\"line\">        <span class=\"keyword\">if</span> (foregroundId != <span class=\"number\">0</span> &amp;&amp; foregroundNoti != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// Do asynchronous communication with notification manager to</span></div><div class=\"line\">            <span class=\"comment\">// avoid deadlocks.</span></div><div class=\"line\">            <span class=\"keyword\">final</span> String localPackageName = packageName;</div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localForegroundId = foregroundId;</div><div class=\"line\">            <span class=\"keyword\">final</span> Notification localForegroundNoti = foregroundNoti;</div><div class=\"line\">            ams.mHandler.post(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    NotificationManagerService nm =</div><div class=\"line\">                            (NotificationManagerService) NotificationManager.getService();</div><div class=\"line\">                    <span class=\"keyword\">if</span> (nm == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (localForegroundNoti.icon == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                            <span class=\"comment\">// It is not correct for the caller to supply a notification</span></div><div class=\"line\">                            <span class=\"comment\">// icon, but this used to be able to slip through, so for</span></div><div class=\"line\">                            <span class=\"comment\">// those dirty apps give it the app's icon.</span></div><div class=\"line\">                            localForegroundNoti.icon = appInfo.icon;</div><div class=\"line\">                            <span class=\"comment\">// Do not allow apps to present a sneaky invisible content view either.</span></div><div class=\"line\">                            localForegroundNoti.contentView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            localForegroundNoti.bigContentView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            CharSequence appName = appInfo.loadLabel(</div><div class=\"line\">                                    ams.mContext.getPackageManager());</div><div class=\"line\">                            <span class=\"keyword\">if</span> (appName == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                appName = appInfo.packageName;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            Context ctx = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                                ctx = ams.mContext.createPackageContext(</div><div class=\"line\">                                        appInfo.packageName, <span class=\"number\">0</span>);</div><div class=\"line\">                                Intent runningIntent = <span class=\"keyword\">new</span> Intent(</div><div class=\"line\">                                        Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</div><div class=\"line\">                                runningIntent.setData(Uri.fromParts(<span class=\"string\">\"package\"</span>,</div><div class=\"line\">                                        appInfo.packageName, <span class=\"keyword\">null</span>));</div><div class=\"line\">                                PendingIntent pi = PendingIntent.getActivity(ams.mContext, <span class=\"number\">0</span>,</div><div class=\"line\">                                        runningIntent, PendingIntent.FLAG_UPDATE_CURRENT);</div><div class=\"line\">                                localForegroundNoti.setLatestEventInfo(ctx,</div><div class=\"line\">                                        ams.mContext.getString(</div><div class=\"line\">                                                com.android.internal.R.string</div><div class=\"line\">                                                        .app_running_notification_title,</div><div class=\"line\">                                                appName),</div><div class=\"line\">                                        ams.mContext.getString(</div><div class=\"line\">                                                com.android.internal.R.string</div><div class=\"line\">                                                        .app_running_notification_text,</div><div class=\"line\">                                                appName),</div><div class=\"line\">                                        pi);</div><div class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">                                localForegroundNoti.icon = <span class=\"number\">0</span>;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (localForegroundNoti.icon == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                            <span class=\"comment\">// Notifications whose icon is 0 are defined to not show</span></div><div class=\"line\">                            <span class=\"comment\">// a notification, silently ignoring it.  We don't want to</span></div><div class=\"line\">                            <span class=\"comment\">// just ignore it, we want to prevent the service from</span></div><div class=\"line\">                            <span class=\"comment\">// being foreground.</span></div><div class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"icon must be non-zero\"</span>);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        <span class=\"keyword\">int</span>[] outId = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</div><div class=\"line\">                        nm.enqueueNotificationInternal(localPackageName, localPackageName,</div><div class=\"line\">                                appUid, appPid, <span class=\"keyword\">null</span>, localForegroundId, localForegroundNoti,</div><div class=\"line\">                                outId, userId);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</div><div class=\"line\">                        Slog.w(ActivityManagerService.TAG,</div><div class=\"line\">                                <span class=\"string\">\"Error showing notification for service\"</span>, e);</div><div class=\"line\">                        <span class=\"comment\">// If it gave us a garbage notification, it doesn't</span></div><div class=\"line\">                        <span class=\"comment\">// get to be foreground.</span></div><div class=\"line\">                        ams.setServiceForeground(name, ServiceRecord.<span class=\"keyword\">this</span>,</div><div class=\"line\">                                <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">                        ams.crashApplication(appUid, appPid, localPackageName,</div><div class=\"line\">                                <span class=\"string\">\"Bad notification for startForeground: \"</span> + e);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>单单是看注释大概能看出来Android团队对于这种做法的不满。所以如果不提供有效Notification，则显示你的App的Icon。所以Api 18以上一定会显示一个Notification。</p>\n<p>然而套路还是太深。。。。又有人给出了API 18以上的解决办法:<br>我在<a href=\"http://blog.csdn.net/wxx614817/article/details/50669420\">这里</a>找到了新的方法，简单来说就是起两个Service，两个Service都在一个进程里。<br>先Start A Service ，onCreate里面 bind B Service，<br>在onServiceConnected的时候A service startForeground(processId,notification)<br>B service startForeground(processId,notification)<br>随后立即调用B service stopForeGround(true)<br>由于两个Notification具有相同的id，所以A service最终成为Foreground Service，Notification也被清除掉了。</p>\n<h3 id=\"3-最后\"><a href=\"#3-最后\" class=\"headerlink\" title=\"3.最后\"></a>3.最后</h3><p>整个过程看下来，API 18以下，给一个不完整的Notification(比如new Notification())，就不会出现在通知栏；API 18以上，起两个Service，B Service负责取消Notification就可以了。<br>目前看来，国内很多App为了保活，都采取了类似的方式。<br>而整体技术层面的实现并不难，只是利用了一个又一个小漏洞罢了。<br>所谓脏代码不过是技术上做的一些欺骗系统的手段，作为开发者，理应明白谷歌设计这一套系统是为了更好的提升用户体验（占据市场）。然而在当前国内应用开发环境下，我们真的能够为用户考虑考虑吗，或者说，我们提交的代码能吗？</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/blamingtheuser-big.png?imageView2/2/w/600\" alt=\"\"></p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/\">支付宝后台不死的黑科技</a></li>\n<li><a href=\"http://blog.csdn.net/wxx614817/article/details/50669420\">Android的startForeground前台Service如何去掉通知显示</a></li>\n</ul>\n","excerpt":"<p>今天在V2EX上看到有人提到Notification有漏洞，好奇也就查了一下，结果发现有人专门针对这个问题进行了<a href=\"http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/\">分析</a>。本身的技术分析并不多，写在这里只是为了作为今后的一个参考。","more":"</p>\n<h3 id=\"1-问题的由来\"><a href=\"#1-问题的由来\" class=\"headerlink\" title=\"1. 问题的由来\"></a>1. 问题的由来</h3><p>Android对后台应用是有一个权重区分的，最直观的就是查看最近使用的应用，这里每一个应用可能有一个或者多个Process，而系统在资源紧张时会干掉一些Process，而决定后台应用生死的是一个Lru List，也就是least recently used 会被干掉。显然大家都不希望自己被干掉，DAU对于很多应用来说是优先于系统资源和用户体验的。<br>根据<a href=\"https://developer.android.com/guide/components/processes-and-threads.html\">官方文档</a>,Android Process有五种，根据优先级从高到低为:</p>\n<ul>\n<li>前台进程</li>\n<li>可见进程</li>\n<li>服务进程</li>\n<li>后台进程</li>\n<li>空进程</li>\n</ul>\n<p>越靠前的进程就越不容易被系统干掉，所以大家都希望能够成为前台进程。成为前台进程的条件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</div><div class=\"line\">托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</div><div class=\"line\">托管某个 Service，后者绑定到用户正在交互的 Activity</div><div class=\"line\">托管正在“前台”运行的 Service（服务已调用 startForeground()）</div><div class=\"line\">托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</div><div class=\"line\">托管正执行其 onReceive() 方法的 BroadcastReceiver</div><div class=\"line\">通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</div></pre></td></tr></table></figure></p>\n<p>以上条件只有startForeground满足条件了，但大家都知道startForeground会在通知栏常驻一个Notification，且用户取消不了。对于我这种强迫症来说实在是太丑。</p>\n<h3 id=\"2-startForeground一定会在系统状态栏显示一个通知，真的吗\"><a href=\"#2-startForeground一定会在系统状态栏显示一个通知，真的吗\" class=\"headerlink\" title=\"2. startForeground一定会在系统状态栏显示一个通知，真的吗?\"></a>2. startForeground一定会在系统状态栏显示一个通知，真的吗?</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startForeground</span> <span class=\"params\">(<span class=\"keyword\">int</span> id, </div><div class=\"line\">                Notification notification)</span></span></div></pre></td></tr></table></figure>\n<p>我找到了G+上的Chris Banes的一篇<a href=\"https://plus.google.com/+AndroidDevelopers/posts/NEPWzPwSruR\">post</a>，这其中明确指出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Unfortunately there are a number of applications on Google Play which are using the startForeground() API without passing a valid notification. While this worked in previous versions of Android, it is a loophole which has been fixed in Android 4.3. The system now displays a notifications for you automatically if you do not provide a valid one.</div></pre></td></tr></table></figure></p>\n<p>也就是说，API 18以前，只需要提供一个无效的Notification就可以让Notification不显示了。所以，判断下API&lt;18的时候，直接new Notification()就可以得到一个不完整的Notification.<br>文章也指出了这是一个Loophole（已经是个贬义词了）。<br>Api 18之后的修复措施，看<a href=\"https://android.googlesource.com/platform/frameworks/base.git/+/android-4.3_r2.1/services/java/com/android/server/am/ServiceRecord.java\">ServiceRecord的源码</a>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postNotification</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> appUid = appInfo.uid;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> appPid = app.pid;</div><div class=\"line\">        <span class=\"keyword\">if</span> (foregroundId != <span class=\"number\">0</span> &amp;&amp; foregroundNoti != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// Do asynchronous communication with notification manager to</span></div><div class=\"line\">            <span class=\"comment\">// avoid deadlocks.</span></div><div class=\"line\">            <span class=\"keyword\">final</span> String localPackageName = packageName;</div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localForegroundId = foregroundId;</div><div class=\"line\">            <span class=\"keyword\">final</span> Notification localForegroundNoti = foregroundNoti;</div><div class=\"line\">            ams.mHandler.post(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    NotificationManagerService nm =</div><div class=\"line\">                            (NotificationManagerService) NotificationManager.getService();</div><div class=\"line\">                    <span class=\"keyword\">if</span> (nm == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (localForegroundNoti.icon == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                            <span class=\"comment\">// It is not correct for the caller to supply a notification</span></div><div class=\"line\">                            <span class=\"comment\">// icon, but this used to be able to slip through, so for</span></div><div class=\"line\">                            <span class=\"comment\">// those dirty apps give it the app's icon.</span></div><div class=\"line\">                            localForegroundNoti.icon = appInfo.icon;</div><div class=\"line\">                            <span class=\"comment\">// Do not allow apps to present a sneaky invisible content view either.</span></div><div class=\"line\">                            localForegroundNoti.contentView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            localForegroundNoti.bigContentView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            CharSequence appName = appInfo.loadLabel(</div><div class=\"line\">                                    ams.mContext.getPackageManager());</div><div class=\"line\">                            <span class=\"keyword\">if</span> (appName == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                appName = appInfo.packageName;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            Context ctx = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                                ctx = ams.mContext.createPackageContext(</div><div class=\"line\">                                        appInfo.packageName, <span class=\"number\">0</span>);</div><div class=\"line\">                                Intent runningIntent = <span class=\"keyword\">new</span> Intent(</div><div class=\"line\">                                        Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</div><div class=\"line\">                                runningIntent.setData(Uri.fromParts(<span class=\"string\">\"package\"</span>,</div><div class=\"line\">                                        appInfo.packageName, <span class=\"keyword\">null</span>));</div><div class=\"line\">                                PendingIntent pi = PendingIntent.getActivity(ams.mContext, <span class=\"number\">0</span>,</div><div class=\"line\">                                        runningIntent, PendingIntent.FLAG_UPDATE_CURRENT);</div><div class=\"line\">                                localForegroundNoti.setLatestEventInfo(ctx,</div><div class=\"line\">                                        ams.mContext.getString(</div><div class=\"line\">                                                com.android.internal.R.string</div><div class=\"line\">                                                        .app_running_notification_title,</div><div class=\"line\">                                                appName),</div><div class=\"line\">                                        ams.mContext.getString(</div><div class=\"line\">                                                com.android.internal.R.string</div><div class=\"line\">                                                        .app_running_notification_text,</div><div class=\"line\">                                                appName),</div><div class=\"line\">                                        pi);</div><div class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">                                localForegroundNoti.icon = <span class=\"number\">0</span>;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (localForegroundNoti.icon == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                            <span class=\"comment\">// Notifications whose icon is 0 are defined to not show</span></div><div class=\"line\">                            <span class=\"comment\">// a notification, silently ignoring it.  We don't want to</span></div><div class=\"line\">                            <span class=\"comment\">// just ignore it, we want to prevent the service from</span></div><div class=\"line\">                            <span class=\"comment\">// being foreground.</span></div><div class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"icon must be non-zero\"</span>);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        <span class=\"keyword\">int</span>[] outId = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</div><div class=\"line\">                        nm.enqueueNotificationInternal(localPackageName, localPackageName,</div><div class=\"line\">                                appUid, appPid, <span class=\"keyword\">null</span>, localForegroundId, localForegroundNoti,</div><div class=\"line\">                                outId, userId);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</div><div class=\"line\">                        Slog.w(ActivityManagerService.TAG,</div><div class=\"line\">                                <span class=\"string\">\"Error showing notification for service\"</span>, e);</div><div class=\"line\">                        <span class=\"comment\">// If it gave us a garbage notification, it doesn't</span></div><div class=\"line\">                        <span class=\"comment\">// get to be foreground.</span></div><div class=\"line\">                        ams.setServiceForeground(name, ServiceRecord.<span class=\"keyword\">this</span>,</div><div class=\"line\">                                <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">                        ams.crashApplication(appUid, appPid, localPackageName,</div><div class=\"line\">                                <span class=\"string\">\"Bad notification for startForeground: \"</span> + e);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>单单是看注释大概能看出来Android团队对于这种做法的不满。所以如果不提供有效Notification，则显示你的App的Icon。所以Api 18以上一定会显示一个Notification。</p>\n<p>然而套路还是太深。。。。又有人给出了API 18以上的解决办法:<br>我在<a href=\"http://blog.csdn.net/wxx614817/article/details/50669420\">这里</a>找到了新的方法，简单来说就是起两个Service，两个Service都在一个进程里。<br>先Start A Service ，onCreate里面 bind B Service，<br>在onServiceConnected的时候A service startForeground(processId,notification)<br>B service startForeground(processId,notification)<br>随后立即调用B service stopForeGround(true)<br>由于两个Notification具有相同的id，所以A service最终成为Foreground Service，Notification也被清除掉了。</p>\n<h3 id=\"3-最后\"><a href=\"#3-最后\" class=\"headerlink\" title=\"3.最后\"></a>3.最后</h3><p>整个过程看下来，API 18以下，给一个不完整的Notification(比如new Notification())，就不会出现在通知栏；API 18以上，起两个Service，B Service负责取消Notification就可以了。<br>目前看来，国内很多App为了保活，都采取了类似的方式。<br>而整体技术层面的实现并不难，只是利用了一个又一个小漏洞罢了。<br>所谓脏代码不过是技术上做的一些欺骗系统的手段，作为开发者，理应明白谷歌设计这一套系统是为了更好的提升用户体验（占据市场）。然而在当前国内应用开发环境下，我们真的能够为用户考虑考虑吗，或者说，我们提交的代码能吗？</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/blamingtheuser-big.png?imageView2/2/w/600\" alt=\"\"></p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/\">支付宝后台不死的黑科技</a></li>\n<li><a href=\"http://blog.csdn.net/wxx614817/article/details/50669420\">Android的startForeground前台Service如何去掉通知显示</a></li>\n</ul>"},{"title":"android-Ultra-pull-to-refresh分析","date":"2016-10-24T02:25:35.000Z","_content":" 最早开始接触安卓的时候就知道有Chris Banes的[Pull-To-Refresh](https://github.com/chrisbanes/Android-PullToRefresh)，当时这个库已经被标记被Deprecated了，后来出于寻找替代品的目的找到了秋百万的[android-Ultra-pull-toRefresh](https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh)，直接\n\n ![fork](http://odzl05jxx.bkt.clouddn.com/687474703a2f2f692e696d6775722e636f6d2f4766746846417a2e706e67.png)\n\n 当时甚至没有能力把一个Demo跑起来。之后的项目中，直接使用swipeRefreshLayout了。现在回头看，终于觉得可以尝试着分析一遍整个下拉刷新的过程。本文只针对[android-Ultra-pulltoRefresh](https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh)部分源码进行分析。拆一个轮子可能只需要花一天时间，但能够从无到有构思出这个框架，将项目搭建起来并且坚持长期维护真的是一件需要很强毅力的事情，向为开源社区贡献优秀代码的秋百万和众多做出贡献的开发者致敬。\n <!--more-->\n\n ### 1. 从Demo开始吧\n从github clone下来之后，改一下gradle版本，compile sdk version什么的就可以运行项目自带的Demo了.\nMainActivity 添加了一个PtrDemoHomeFragment,onCreateView里面返回的View对应的xml文件为\nfragment_ptr_home.xml\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <in.srain.cube.views.ptr.PtrFrameLayout\n        android:id=\"@+id/fragment_ptr_home_ptr_frame\"\n        xmlns:cube_ptr=\"http://schemas.android.com/apk/res-auto\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        cube_ptr:ptr_duration_to_close=\"200\"\n        cube_ptr:ptr_duration_to_close_header=\"1000\"\n        cube_ptr:ptr_keep_header_when_refresh=\"true\"\n        cube_ptr:ptr_pull_to_fresh=\"false\"\n        cube_ptr:ptr_ratio_of_header_height_to_refresh=\"1.2\"\n        cube_ptr:ptr_resistance=\"1.7\">\n        <ScrollView\n            android:id=\"@+id/fragment_block_menu_scroll_view\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:background=\"@color/cube_mints_white\">\n\n            <in.srain.cube.views.block.BlockListView\n                android:id=\"@+id/fragment_block_menu_block_list\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:padding=\"@dimen/cube_mints_content_view_padding\" />\n        </ScrollView>\n    </in.srain.cube.views.ptr.PtrFrameLayout>\n</LinearLayout>\n```\n默认主页已经可以下拉刷新了，那么主要的事件拦截操作应该就在这个ptrFrameLayout里面\n\n\n### 2. PtrFrameLayout源码\n从注释来看 \n> This layout view for \"Pull to Refresh(Ptr)\" support all of the view, you can contain everything you want.\n  support: pull to refresh / release to refresh / auto refresh / keep header view while refreshing / hide header view while refreshing\n  It defines {@link in.srain.cube.views.ptr.PtrUIHandler}, which allows you customize the UI easily.\n\n能够容纳各种View，同时支持下拉刷新，下拉释放刷新，自动刷新，刷新时保留刷新动画，刷新时隐藏刷新动画\n\n一步步来看\n\n1. **构造函数**\n\n```java\npublic class PtrFrameLayout extends ViewGroup {\n\n public PtrFrameLayout(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        //删除无关代码\n        TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.PtrFrameLayout, 0, 0);\n        if (arr != null) {\n            mHeaderId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_header, mHeaderId); // HeaderView的layout文件id\n            mContainerId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_content, mContainerId); // contentView的layout文件id\n            mDurationToClose = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close, mDurationToClose);// 维持刷新动画多久开始关闭HeaderView\n            mDurationToCloseHeader = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close_header, mDurationToCloseHeader);\n            float ratio = mPtrIndicator.getRatioOfHeaderToHeightRefresh();\n            ratio = arr.getFloat(R.styleable.PtrFrameLayout_ptr_ratio_of_header_height_to_refresh, ratio);\n            mKeepHeaderWhenRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_keep_header_when_refresh, mKeepHeaderWhenRefresh);\n            mPullToRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_pull_to_fresh, mPullToRefresh);\n            arr.recycle();\n        }\n        //ViewConfiguration很常见了，mTouchSlop用于判断用户操作手势是否有效\n        final ViewConfiguration conf = ViewConfiguration.get(getContext());\n        mPagingTouchSlop = conf.getScaledTouchSlop() * 2;\n    }\n\n}\n```\n\n构造函数里面主要就是获得在xml中设定的一些自定义属性的值并保存为成员变量，实际用途后面再看。\n\n2. **onFinishInflate**\n 这个方法在inflate xml文件结束，所有的childView都已经添加之后调用\n PtrFrameLayout复写了这个方法，\n- 首先检查ChildView数量，如果childCount >2 会报错\n- 然后检查两个child(这里主要看childCount=2的情况下)\n```java\n//省略若干\nif (child1 instanceof PtrUIHandler) {\n                    mHeaderView = child1;\n                    mContent = child2;\n                } else if (child2 instanceof PtrUIHandler) {\n                    mHeaderView = child2;\n                    mContent = child1;\n                } \n//省略若干                \n```\n来看一下这个ptrUIHandler\n```java\npublic interface PtrUIHandler {\n\n    /**\n     * When the content view has reached top and refresh has been completed, view will be reset.\n     *\n     * @param frame\n     */\n    public void onUIReset(PtrFrameLayout frame);\n\n    /**\n     * prepare for loading\n     *\n     * @param frame\n     */\n    public void onUIRefreshPrepare(PtrFrameLayout frame);\n\n    /**\n     * perform refreshing UI\n     */\n    public void onUIRefreshBegin(PtrFrameLayout frame);\n\n    /**\n     * perform UI after refresh\n     */\n    public void onUIRefreshComplete(PtrFrameLayout frame);\n\n    public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status, PtrIndicator ptrIndicator);\n}\n```\n大概可以猜到这货是用来指定下拉过程中的刷新开始，刷新结束，刷新结束后复位等过程的实现者，具体的下拉过程中的动画，位移等特效都应该由这接口的实例(View)来完成。\n\n3. **onMeasure**\n```java\n @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        //省略...\n         measureContentView(mContent, widthMeasureSpec, heightMeasureSpec);\n    }\n\n\n     private void measureContentView(View child,\n                                    int parentWidthMeasureSpec,\n                                    int parentHeightMeasureSpec) {\n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                getPaddingTop() + getPaddingBottom() + lp.topMargin, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n主要就是调用了measureContentView方法，都是很中规中矩的实现\n\n4. **onLayout**\n代码就不贴了，根据LayoutParams计算出需要的margin,最主要的Top是由\n>  int offset = mPtrIndicator.getCurrentPosY();\n\n获得的，mPterIndicator是一个单独的组件，用于保存一些实时状态。\n滑动过程中如果有动画效果，会走到这个方法里，所以及时更新最新的位置很重要，ptr将这一功能剥离出来，这大概就是我所理解的解耦吧。\n\n\n5. **dispatchTouchEvent**\n主要的手势处理逻辑都在这里，关于TouchEvent的分发处理，这里不再赘述。\n简单列出执行顺序:\n> ViewGroup.dispatchTouchEvent----ViewGroup.onInterceptTouchEvent---View.dispatchTouchEvent----- etc 、、、、\n\n简书上有作者写出了非常好的关于TouchEvent分发的[文章](http://www.jianshu.com/p/e99b5e8bd67b)，忘记了的话可以去看看。\n来看这部分的实现，有删节\n```java\n @Override\n    public boolean dispatchTouchEvent(MotionEvent e) {\n    \t//.....\n        switch (action) {\n            case MotionEvent.ACTION_UP:\n            case MotionEvent.ACTION_CANCEL:\n                if (mPtrIndicator.hasLeftStartPosition()) {\n                    onRelease(false); //手指抬起后的操作\n                    // ......\n                    return dispatchTouchEventSupper(e);\n                } else {\n                    return dispatchTouchEventSupper(e);\n                }\n\n            case MotionEvent.ACTION_DOWN:\n            \t//取消之前还在运行的Scroller等等。。\n                // The cancel event will be sent once the position is moved.\n                // So let the event pass to children.\n                // fix #93, #102\n                dispatchTouchEventSupper(e);\n                return true;//这里返回true，child将会受到ACTION_CANCEL\n\n            case MotionEvent.ACTION_MOVE:\n                mLastMoveEvent = e; //这里实时更新装填\n                mPtrIndicator.onMove(e.getX(), e.getY());\n                float offsetX = mPtrIndicator.getOffsetX();\n                float offsetY = mPtrIndicator.getOffsetY();\n               \n\n                boolean moveDown = offsetY > 0;\n                boolean moveUp = !moveDown;\n                boolean canMoveUp = mPtrIndicator.hasLeftStartPosition();\n\n                // disable move when header not reach top\n                if (moveDown && mPtrHandler != null && !mPtrHandler.checkCanDoRefresh(this, mContent, mHeaderView)) {\n                    return dispatchTouchEventSupper(e);\n                }\n\n                if ((moveUp && canMoveUp) || moveDown) {\n                    movePos(offsetY); //实现滑动操作的代码\n                    return true;// 后续事件将只会走到此方法，不会再往下传递，直到ACTION_UP，本次手势结束\n                }\n        }\n        return dispatchTouchEventSupper(e);\n    }\n\n```\n用户手指按下。。。。。手指滑动。。。。。手指抬起\n\n**ACTION_DOWN** : 手指按下后将TouchEvent交给mPtrIndicator处理，后者保留了当前ptr的位置，高度等信息。在执行ACTION_DOWN时，并没有简单地使用Event.getY，而是保留了当前position的一个备份(这是必要的，因为对于下拉刷新来说，最终需要回到的位置是0，而用户按下的位置可能在contentView比较靠下面的位置。ACTION_DOWN的getY并没有太大意义)。随后调用Scroller的 mScroller.forceFinished(true)方法停止滑动，如果定义了页面自动刷新(就是进来会下拉刷新一次)，还会调用onRelease(true)方法，onRelease方法与ACTION_UP相关。\n\n**ACTION_MOVE** : 手指开始在屏幕上滑动，首先将滑动距离的改变保留到mPtrIndicator中，这里作者将很多坐标计算的方法都拆出来放到这个mPtrIndicator中，暴露出get方法，也使得代码更清晰。在开始滑动之前，先检查下是否是横向滑动，以及是否在(mDisableWhenHorizontalMove，ViewPager需要消费横向手势，这个标志符是为了return super)。\n往下走，来看这一段\n```java\n\tboolean moveDown = offsetY > 0; 新的Event中的y值和mptrIndicator中保留的当前y的差值，所以手指往下拉的话，offset >0,也就是这里的moveDown\n\tboolean moveUp = !moveDown;\n\tboolean canMoveUp = mPtrIndicator.hasLeftStartPosition()// 检查下当前Event中的y是否大于0，即内容区域是否已经往下走了一点了\n```\n接下来，再次询问mPtrHandler能否DoRefresh,将自身和ChildView都交出去，所以可操作性很大\n大部分的情况下，直接使用一个\n>  return PtrDefaultHandler.checkContentCanBePulledDown(frame, content, header);\n\n使用了一个类似于ViewCompat.canScollVertically的方法，但判断下如果是AbstractListView的话，会调用getFirstVisiblePosition等方法，因为AdapterView能否滑动应该是由其内容能否滑动来决定的。\n如果这个方法返回true。接着往下走，开始执行View的滑动方法:\n判断下是否手指在往上拉(moveUp && canMoveUp)或者往下拉(moveDown),return true，首先事件就不会再往下走，另外后续的ACTION_MOVE_ACTION_UP都只会传递到这个dispatchTouchEvent中\n实现滑动操作的代码最后会执行这里\n```java\n  private void updatePos(int change) {\n       \n\n        boolean isUnderTouch = mPtrIndicator.isUnderTouch();\n\n        // once moved, cancel event will be sent to child\n        if (isUnderTouch && !mHasSendCancelEvent && mPtrIndicator.hasMovedAfterPressedDown()) {\n            mHasSendCancelEvent = true;\n            sendCancelEvent();\n        }\n\n        // leave initiated position or just refresh complete\n        if ((mPtrIndicator.hasJustLeftStartPosition() && mStatus == PTR_STATUS_INIT) ||\n                (mPtrIndicator.goDownCrossFinishPosition() && mStatus == PTR_STATUS_COMPLETE && isEnabledNextPtrAtOnce())) {\n\n            mStatus = PTR_STATUS_PREPARE;\n            mPtrUIHandlerHolder.onUIRefreshPrepare(this);//刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。这个Holder的结构类似于一个链表，一个Holder里面有UIHandler，以及下一个Holder(next)。作用类似于一个集合，等于作者自己实现了这样一个不断循环的消息列表(看起来挺像Message的)。这个Holder的作用在于可以动态添加UIHanlder，相对应的方法都做好了(addHandler)。\n            //再次强调，这里表示**刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。此时的状态为STATUS_PREPARED**\n        }\n\n        // back to initiated position\n        if (mPtrIndicator.hasJustBackToStartPosition()) {\n            tryToNotifyReset();\n            //**刚刚从下面回到0的位置，通知UIHandler的onUIReset()方法,此时的状态为STATUS_INIT**\n            //将整个过程划分的真详细\n            // recover event to children，虽然手指还在屏幕上，处于ACTION_MOVE，但这里由于已经复位，需要把ACTION_DOWN传递下去，这一段比较复杂。\n            if (isUnderTouch) {\n                sendDownEvent();\n            }\n        }\n\n        // Pull to Refresh\n        if (mStatus == PTR_STATUS_PREPARE) {//从上到下依次为0 ， 出现动画临界值， HeadView高度\n            // reach fresh height while moving from top to bottom\n            if (isUnderTouch && !isAutoRefresh() && mPullToRefresh  // 手指还在屏幕上，不是自动刷新且允许ptr且到达了下滑出现动画效果的临界值，条件还是比较苛刻的\n                    && mPtrIndicator.crossRefreshLineFromTopToBottom()) {\n                tryToPerformRefresh();\n            }\n            // reach header height while auto refresh\n            if (performAutoRefreshButLater() && mPtrIndicator.hasJustReachedHeaderHeightFromTopToBottom()) {//刚刚超过headerView高度一丁点\n                tryToPerformRefresh();\n            }\n        }\n        //tryToPerformRefresh()方法判断mPtrIndicator.isOverOffsetToRefresh()，满足条件的话进入STATUS_LOADING，这个时候就要开始让动画run了。所以这里调用的是 mPtrUIHandlerHolder.onUIRefreshBegin(this);和mPtrHandler.onRefreshBegin(this);前者是后来手动添加的UIHandler，后者则是在onInFlateFinish中自行判断的，这两个都会被执行。这里扯一句，这个Holder就像一个中间层，持有了UIHandler,所有方法都调用的是后者HanldleUI的方法。facade模式？\n\n\n        // 终于看到实际调用View滑动的代码了，让一个View滑动的方式有很多种，这里采用的是改变X,Y的方式(X = left+translationX;Y = top+translationY) \n        mHeaderView.offsetTopAndBottom(change);\n        if (!isPinContent()) {\n            mContent.offsetTopAndBottom(change);\n        }\n        invalidate();??我觉得这里好像没有必要这么频繁的调这一句话\n\n        //移动完成之后通知UIHandlerHolder位置改变了，没有通知mUIHandler是因为后者就是mContent和mHeaderView。\n        if (mPtrUIHandlerHolder.hasHandler()) {\n            mPtrUIHandlerHolder.onUIPositionChange(this, isUnderTouch, mStatus, mPtrIndicator);\n        }\n        onPositionChange(isUnderTouch, mStatus, mPtrIndicator);//最后还预留了一个onPositionChange的空方法，子类可能会有点用吧\n    }\n```\n到这里，ACTION_MOVE已经研究完毕，大部分的分析都在注释里面，只要分清楚滑动过程中的各种STATUS，我觉得还是比较好理解的。MOVE过程中伴随着距离的变化，ptr也进入不同的status，ptr本身其实只做了移动headrView和childView的工作，实际的动画效果等等都是由UIHanlder拿着ptr的实例去做的。关于能够滑动多少距离的问题，由于这里并没有判断，所以，这个contentView的下滑是没有下限的，不过在xml里面有一个自定义的resistance，相当于阻力系数了，设置大一点的话就不会出事。**目前手指还在屏幕上，status等于STATUS_PREPARED或者STATUS_LOADING。借用手机评测那帮人的话来说，跟手**\n\n\n**ACTION_UP**： mPtrIndicator中的mPressed设置为false，标示下当前手指已经不按在屏幕上了。如果这时候的位置>0，就是contentView还没有复位，需要想办法让它\"弹回来\"，这部分工作交给了onRelease(false)，这个false我猜肯定是后面加上去的(查了下git log果然。。。)。来看OnRelease:\n```java\n  private void onRelease(boolean stayForLoading) {\n\n        tryToPerformRefresh();//会检查下当前status!=STATUS_PREPARED的话直接return false，就是不是在刚开始或刚复位的情况下不做；否则继续执行performRefresh操作，其实这样想也符合常理，手指离开了屏幕，ptr应该能够自我判断是否还需要执行动画\n\n        if (mStatus == PTR_STATUS_LOADING) {\n            // keep header for fresh\n            if (mKeepHeaderWhenRefresh) {\n                // scroll header back\n                if (mPtrIndicator.isOverOffsetToKeepHeaderWhileLoading() && !stayForLoading) {//已经过了需要加载动画的位置，statyForLoading这里传进来的是false\n                    mScrollChecker.tryToScrollTo(mPtrIndicator.getOffsetToKeepHeaderWhileLoading(), mDurationToClose);//滑动到加载动画的位置，这里面是不断地post一个runnable，在run方法里面调用之前和ACTION_MOVE里面一样的那个movePos方法，所以重用性还好。也会通知相应的UIHandler或者UIHandlerHolder\n                } else {\n                    // do nothing\n                }\n            } else {\n                tryScrollBackToTopWhileLoading();//这里会一直滑动到0的位置，其实也是不断调用updatPos方法，会将STATUS重置为STATUS_INIT或者STATUS_PREPARED\n            }\n        } else {\n            if (mStatus == PTR_STATUS_COMPLETE) {//STATUS_COMPLETE通常由外部调用者调用refreshComplete public 方法设置，相当于SwipeRefreshLayout的setRefreshing()，否则将一直停留在加载状态。也就是说需要调用者手动设置关闭，这也符合常理，因为加载本身是需要时间的，把这个设置的时机交给开发者来手动设置几乎是唯一的选择。\n                notifyUIRefreshComplete(false);\n            } else {\n                tryScrollBackToTopAbortRefresh();\n            }\n        }\n    }\n```\n\n到此，ptr内部只剩下一些getter和setter了，不再解释，结合Demo使用就会有所体会。\n\n\n### 3. 总结\nptr的本质就是通过ViewGroup的dispatchTouchEvent将事件拦截在内部进行处理，并将事件过程分发给几个自定义的接口。而内部又添加了一些自定义的变量，并给出getter和setter，使得外部调用者使用起来十分轻松。只要掌握好事件分发处理和View的绘制流程，拆起来还算简单。当然，如果在实际项目中碰到了类似的需求，我倾向于定制一个简单一点的小工具。\n\n\n\n\n\n","source":"_posts/2016-10-24-a-peek-on-pull-to-refresh.md","raw":"---\ntitle: android-Ultra-pull-to-refresh分析\ndate: 2016-10-24 10:25:35\ncategories: blog\ntags: [置顶]\n\n\n---\n 最早开始接触安卓的时候就知道有Chris Banes的[Pull-To-Refresh](https://github.com/chrisbanes/Android-PullToRefresh)，当时这个库已经被标记被Deprecated了，后来出于寻找替代品的目的找到了秋百万的[android-Ultra-pull-toRefresh](https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh)，直接\n\n ![fork](http://odzl05jxx.bkt.clouddn.com/687474703a2f2f692e696d6775722e636f6d2f4766746846417a2e706e67.png)\n\n 当时甚至没有能力把一个Demo跑起来。之后的项目中，直接使用swipeRefreshLayout了。现在回头看，终于觉得可以尝试着分析一遍整个下拉刷新的过程。本文只针对[android-Ultra-pulltoRefresh](https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh)部分源码进行分析。拆一个轮子可能只需要花一天时间，但能够从无到有构思出这个框架，将项目搭建起来并且坚持长期维护真的是一件需要很强毅力的事情，向为开源社区贡献优秀代码的秋百万和众多做出贡献的开发者致敬。\n <!--more-->\n\n ### 1. 从Demo开始吧\n从github clone下来之后，改一下gradle版本，compile sdk version什么的就可以运行项目自带的Demo了.\nMainActivity 添加了一个PtrDemoHomeFragment,onCreateView里面返回的View对应的xml文件为\nfragment_ptr_home.xml\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <in.srain.cube.views.ptr.PtrFrameLayout\n        android:id=\"@+id/fragment_ptr_home_ptr_frame\"\n        xmlns:cube_ptr=\"http://schemas.android.com/apk/res-auto\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        cube_ptr:ptr_duration_to_close=\"200\"\n        cube_ptr:ptr_duration_to_close_header=\"1000\"\n        cube_ptr:ptr_keep_header_when_refresh=\"true\"\n        cube_ptr:ptr_pull_to_fresh=\"false\"\n        cube_ptr:ptr_ratio_of_header_height_to_refresh=\"1.2\"\n        cube_ptr:ptr_resistance=\"1.7\">\n        <ScrollView\n            android:id=\"@+id/fragment_block_menu_scroll_view\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:background=\"@color/cube_mints_white\">\n\n            <in.srain.cube.views.block.BlockListView\n                android:id=\"@+id/fragment_block_menu_block_list\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:padding=\"@dimen/cube_mints_content_view_padding\" />\n        </ScrollView>\n    </in.srain.cube.views.ptr.PtrFrameLayout>\n</LinearLayout>\n```\n默认主页已经可以下拉刷新了，那么主要的事件拦截操作应该就在这个ptrFrameLayout里面\n\n\n### 2. PtrFrameLayout源码\n从注释来看 \n> This layout view for \"Pull to Refresh(Ptr)\" support all of the view, you can contain everything you want.\n  support: pull to refresh / release to refresh / auto refresh / keep header view while refreshing / hide header view while refreshing\n  It defines {@link in.srain.cube.views.ptr.PtrUIHandler}, which allows you customize the UI easily.\n\n能够容纳各种View，同时支持下拉刷新，下拉释放刷新，自动刷新，刷新时保留刷新动画，刷新时隐藏刷新动画\n\n一步步来看\n\n1. **构造函数**\n\n```java\npublic class PtrFrameLayout extends ViewGroup {\n\n public PtrFrameLayout(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        //删除无关代码\n        TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.PtrFrameLayout, 0, 0);\n        if (arr != null) {\n            mHeaderId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_header, mHeaderId); // HeaderView的layout文件id\n            mContainerId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_content, mContainerId); // contentView的layout文件id\n            mDurationToClose = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close, mDurationToClose);// 维持刷新动画多久开始关闭HeaderView\n            mDurationToCloseHeader = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close_header, mDurationToCloseHeader);\n            float ratio = mPtrIndicator.getRatioOfHeaderToHeightRefresh();\n            ratio = arr.getFloat(R.styleable.PtrFrameLayout_ptr_ratio_of_header_height_to_refresh, ratio);\n            mKeepHeaderWhenRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_keep_header_when_refresh, mKeepHeaderWhenRefresh);\n            mPullToRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_pull_to_fresh, mPullToRefresh);\n            arr.recycle();\n        }\n        //ViewConfiguration很常见了，mTouchSlop用于判断用户操作手势是否有效\n        final ViewConfiguration conf = ViewConfiguration.get(getContext());\n        mPagingTouchSlop = conf.getScaledTouchSlop() * 2;\n    }\n\n}\n```\n\n构造函数里面主要就是获得在xml中设定的一些自定义属性的值并保存为成员变量，实际用途后面再看。\n\n2. **onFinishInflate**\n 这个方法在inflate xml文件结束，所有的childView都已经添加之后调用\n PtrFrameLayout复写了这个方法，\n- 首先检查ChildView数量，如果childCount >2 会报错\n- 然后检查两个child(这里主要看childCount=2的情况下)\n```java\n//省略若干\nif (child1 instanceof PtrUIHandler) {\n                    mHeaderView = child1;\n                    mContent = child2;\n                } else if (child2 instanceof PtrUIHandler) {\n                    mHeaderView = child2;\n                    mContent = child1;\n                } \n//省略若干                \n```\n来看一下这个ptrUIHandler\n```java\npublic interface PtrUIHandler {\n\n    /**\n     * When the content view has reached top and refresh has been completed, view will be reset.\n     *\n     * @param frame\n     */\n    public void onUIReset(PtrFrameLayout frame);\n\n    /**\n     * prepare for loading\n     *\n     * @param frame\n     */\n    public void onUIRefreshPrepare(PtrFrameLayout frame);\n\n    /**\n     * perform refreshing UI\n     */\n    public void onUIRefreshBegin(PtrFrameLayout frame);\n\n    /**\n     * perform UI after refresh\n     */\n    public void onUIRefreshComplete(PtrFrameLayout frame);\n\n    public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status, PtrIndicator ptrIndicator);\n}\n```\n大概可以猜到这货是用来指定下拉过程中的刷新开始，刷新结束，刷新结束后复位等过程的实现者，具体的下拉过程中的动画，位移等特效都应该由这接口的实例(View)来完成。\n\n3. **onMeasure**\n```java\n @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        //省略...\n         measureContentView(mContent, widthMeasureSpec, heightMeasureSpec);\n    }\n\n\n     private void measureContentView(View child,\n                                    int parentWidthMeasureSpec,\n                                    int parentHeightMeasureSpec) {\n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                getPaddingTop() + getPaddingBottom() + lp.topMargin, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n主要就是调用了measureContentView方法，都是很中规中矩的实现\n\n4. **onLayout**\n代码就不贴了，根据LayoutParams计算出需要的margin,最主要的Top是由\n>  int offset = mPtrIndicator.getCurrentPosY();\n\n获得的，mPterIndicator是一个单独的组件，用于保存一些实时状态。\n滑动过程中如果有动画效果，会走到这个方法里，所以及时更新最新的位置很重要，ptr将这一功能剥离出来，这大概就是我所理解的解耦吧。\n\n\n5. **dispatchTouchEvent**\n主要的手势处理逻辑都在这里，关于TouchEvent的分发处理，这里不再赘述。\n简单列出执行顺序:\n> ViewGroup.dispatchTouchEvent----ViewGroup.onInterceptTouchEvent---View.dispatchTouchEvent----- etc 、、、、\n\n简书上有作者写出了非常好的关于TouchEvent分发的[文章](http://www.jianshu.com/p/e99b5e8bd67b)，忘记了的话可以去看看。\n来看这部分的实现，有删节\n```java\n @Override\n    public boolean dispatchTouchEvent(MotionEvent e) {\n    \t//.....\n        switch (action) {\n            case MotionEvent.ACTION_UP:\n            case MotionEvent.ACTION_CANCEL:\n                if (mPtrIndicator.hasLeftStartPosition()) {\n                    onRelease(false); //手指抬起后的操作\n                    // ......\n                    return dispatchTouchEventSupper(e);\n                } else {\n                    return dispatchTouchEventSupper(e);\n                }\n\n            case MotionEvent.ACTION_DOWN:\n            \t//取消之前还在运行的Scroller等等。。\n                // The cancel event will be sent once the position is moved.\n                // So let the event pass to children.\n                // fix #93, #102\n                dispatchTouchEventSupper(e);\n                return true;//这里返回true，child将会受到ACTION_CANCEL\n\n            case MotionEvent.ACTION_MOVE:\n                mLastMoveEvent = e; //这里实时更新装填\n                mPtrIndicator.onMove(e.getX(), e.getY());\n                float offsetX = mPtrIndicator.getOffsetX();\n                float offsetY = mPtrIndicator.getOffsetY();\n               \n\n                boolean moveDown = offsetY > 0;\n                boolean moveUp = !moveDown;\n                boolean canMoveUp = mPtrIndicator.hasLeftStartPosition();\n\n                // disable move when header not reach top\n                if (moveDown && mPtrHandler != null && !mPtrHandler.checkCanDoRefresh(this, mContent, mHeaderView)) {\n                    return dispatchTouchEventSupper(e);\n                }\n\n                if ((moveUp && canMoveUp) || moveDown) {\n                    movePos(offsetY); //实现滑动操作的代码\n                    return true;// 后续事件将只会走到此方法，不会再往下传递，直到ACTION_UP，本次手势结束\n                }\n        }\n        return dispatchTouchEventSupper(e);\n    }\n\n```\n用户手指按下。。。。。手指滑动。。。。。手指抬起\n\n**ACTION_DOWN** : 手指按下后将TouchEvent交给mPtrIndicator处理，后者保留了当前ptr的位置，高度等信息。在执行ACTION_DOWN时，并没有简单地使用Event.getY，而是保留了当前position的一个备份(这是必要的，因为对于下拉刷新来说，最终需要回到的位置是0，而用户按下的位置可能在contentView比较靠下面的位置。ACTION_DOWN的getY并没有太大意义)。随后调用Scroller的 mScroller.forceFinished(true)方法停止滑动，如果定义了页面自动刷新(就是进来会下拉刷新一次)，还会调用onRelease(true)方法，onRelease方法与ACTION_UP相关。\n\n**ACTION_MOVE** : 手指开始在屏幕上滑动，首先将滑动距离的改变保留到mPtrIndicator中，这里作者将很多坐标计算的方法都拆出来放到这个mPtrIndicator中，暴露出get方法，也使得代码更清晰。在开始滑动之前，先检查下是否是横向滑动，以及是否在(mDisableWhenHorizontalMove，ViewPager需要消费横向手势，这个标志符是为了return super)。\n往下走，来看这一段\n```java\n\tboolean moveDown = offsetY > 0; 新的Event中的y值和mptrIndicator中保留的当前y的差值，所以手指往下拉的话，offset >0,也就是这里的moveDown\n\tboolean moveUp = !moveDown;\n\tboolean canMoveUp = mPtrIndicator.hasLeftStartPosition()// 检查下当前Event中的y是否大于0，即内容区域是否已经往下走了一点了\n```\n接下来，再次询问mPtrHandler能否DoRefresh,将自身和ChildView都交出去，所以可操作性很大\n大部分的情况下，直接使用一个\n>  return PtrDefaultHandler.checkContentCanBePulledDown(frame, content, header);\n\n使用了一个类似于ViewCompat.canScollVertically的方法，但判断下如果是AbstractListView的话，会调用getFirstVisiblePosition等方法，因为AdapterView能否滑动应该是由其内容能否滑动来决定的。\n如果这个方法返回true。接着往下走，开始执行View的滑动方法:\n判断下是否手指在往上拉(moveUp && canMoveUp)或者往下拉(moveDown),return true，首先事件就不会再往下走，另外后续的ACTION_MOVE_ACTION_UP都只会传递到这个dispatchTouchEvent中\n实现滑动操作的代码最后会执行这里\n```java\n  private void updatePos(int change) {\n       \n\n        boolean isUnderTouch = mPtrIndicator.isUnderTouch();\n\n        // once moved, cancel event will be sent to child\n        if (isUnderTouch && !mHasSendCancelEvent && mPtrIndicator.hasMovedAfterPressedDown()) {\n            mHasSendCancelEvent = true;\n            sendCancelEvent();\n        }\n\n        // leave initiated position or just refresh complete\n        if ((mPtrIndicator.hasJustLeftStartPosition() && mStatus == PTR_STATUS_INIT) ||\n                (mPtrIndicator.goDownCrossFinishPosition() && mStatus == PTR_STATUS_COMPLETE && isEnabledNextPtrAtOnce())) {\n\n            mStatus = PTR_STATUS_PREPARE;\n            mPtrUIHandlerHolder.onUIRefreshPrepare(this);//刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。这个Holder的结构类似于一个链表，一个Holder里面有UIHandler，以及下一个Holder(next)。作用类似于一个集合，等于作者自己实现了这样一个不断循环的消息列表(看起来挺像Message的)。这个Holder的作用在于可以动态添加UIHanlder，相对应的方法都做好了(addHandler)。\n            //再次强调，这里表示**刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。此时的状态为STATUS_PREPARED**\n        }\n\n        // back to initiated position\n        if (mPtrIndicator.hasJustBackToStartPosition()) {\n            tryToNotifyReset();\n            //**刚刚从下面回到0的位置，通知UIHandler的onUIReset()方法,此时的状态为STATUS_INIT**\n            //将整个过程划分的真详细\n            // recover event to children，虽然手指还在屏幕上，处于ACTION_MOVE，但这里由于已经复位，需要把ACTION_DOWN传递下去，这一段比较复杂。\n            if (isUnderTouch) {\n                sendDownEvent();\n            }\n        }\n\n        // Pull to Refresh\n        if (mStatus == PTR_STATUS_PREPARE) {//从上到下依次为0 ， 出现动画临界值， HeadView高度\n            // reach fresh height while moving from top to bottom\n            if (isUnderTouch && !isAutoRefresh() && mPullToRefresh  // 手指还在屏幕上，不是自动刷新且允许ptr且到达了下滑出现动画效果的临界值，条件还是比较苛刻的\n                    && mPtrIndicator.crossRefreshLineFromTopToBottom()) {\n                tryToPerformRefresh();\n            }\n            // reach header height while auto refresh\n            if (performAutoRefreshButLater() && mPtrIndicator.hasJustReachedHeaderHeightFromTopToBottom()) {//刚刚超过headerView高度一丁点\n                tryToPerformRefresh();\n            }\n        }\n        //tryToPerformRefresh()方法判断mPtrIndicator.isOverOffsetToRefresh()，满足条件的话进入STATUS_LOADING，这个时候就要开始让动画run了。所以这里调用的是 mPtrUIHandlerHolder.onUIRefreshBegin(this);和mPtrHandler.onRefreshBegin(this);前者是后来手动添加的UIHandler，后者则是在onInFlateFinish中自行判断的，这两个都会被执行。这里扯一句，这个Holder就像一个中间层，持有了UIHandler,所有方法都调用的是后者HanldleUI的方法。facade模式？\n\n\n        // 终于看到实际调用View滑动的代码了，让一个View滑动的方式有很多种，这里采用的是改变X,Y的方式(X = left+translationX;Y = top+translationY) \n        mHeaderView.offsetTopAndBottom(change);\n        if (!isPinContent()) {\n            mContent.offsetTopAndBottom(change);\n        }\n        invalidate();??我觉得这里好像没有必要这么频繁的调这一句话\n\n        //移动完成之后通知UIHandlerHolder位置改变了，没有通知mUIHandler是因为后者就是mContent和mHeaderView。\n        if (mPtrUIHandlerHolder.hasHandler()) {\n            mPtrUIHandlerHolder.onUIPositionChange(this, isUnderTouch, mStatus, mPtrIndicator);\n        }\n        onPositionChange(isUnderTouch, mStatus, mPtrIndicator);//最后还预留了一个onPositionChange的空方法，子类可能会有点用吧\n    }\n```\n到这里，ACTION_MOVE已经研究完毕，大部分的分析都在注释里面，只要分清楚滑动过程中的各种STATUS，我觉得还是比较好理解的。MOVE过程中伴随着距离的变化，ptr也进入不同的status，ptr本身其实只做了移动headrView和childView的工作，实际的动画效果等等都是由UIHanlder拿着ptr的实例去做的。关于能够滑动多少距离的问题，由于这里并没有判断，所以，这个contentView的下滑是没有下限的，不过在xml里面有一个自定义的resistance，相当于阻力系数了，设置大一点的话就不会出事。**目前手指还在屏幕上，status等于STATUS_PREPARED或者STATUS_LOADING。借用手机评测那帮人的话来说，跟手**\n\n\n**ACTION_UP**： mPtrIndicator中的mPressed设置为false，标示下当前手指已经不按在屏幕上了。如果这时候的位置>0，就是contentView还没有复位，需要想办法让它\"弹回来\"，这部分工作交给了onRelease(false)，这个false我猜肯定是后面加上去的(查了下git log果然。。。)。来看OnRelease:\n```java\n  private void onRelease(boolean stayForLoading) {\n\n        tryToPerformRefresh();//会检查下当前status!=STATUS_PREPARED的话直接return false，就是不是在刚开始或刚复位的情况下不做；否则继续执行performRefresh操作，其实这样想也符合常理，手指离开了屏幕，ptr应该能够自我判断是否还需要执行动画\n\n        if (mStatus == PTR_STATUS_LOADING) {\n            // keep header for fresh\n            if (mKeepHeaderWhenRefresh) {\n                // scroll header back\n                if (mPtrIndicator.isOverOffsetToKeepHeaderWhileLoading() && !stayForLoading) {//已经过了需要加载动画的位置，statyForLoading这里传进来的是false\n                    mScrollChecker.tryToScrollTo(mPtrIndicator.getOffsetToKeepHeaderWhileLoading(), mDurationToClose);//滑动到加载动画的位置，这里面是不断地post一个runnable，在run方法里面调用之前和ACTION_MOVE里面一样的那个movePos方法，所以重用性还好。也会通知相应的UIHandler或者UIHandlerHolder\n                } else {\n                    // do nothing\n                }\n            } else {\n                tryScrollBackToTopWhileLoading();//这里会一直滑动到0的位置，其实也是不断调用updatPos方法，会将STATUS重置为STATUS_INIT或者STATUS_PREPARED\n            }\n        } else {\n            if (mStatus == PTR_STATUS_COMPLETE) {//STATUS_COMPLETE通常由外部调用者调用refreshComplete public 方法设置，相当于SwipeRefreshLayout的setRefreshing()，否则将一直停留在加载状态。也就是说需要调用者手动设置关闭，这也符合常理，因为加载本身是需要时间的，把这个设置的时机交给开发者来手动设置几乎是唯一的选择。\n                notifyUIRefreshComplete(false);\n            } else {\n                tryScrollBackToTopAbortRefresh();\n            }\n        }\n    }\n```\n\n到此，ptr内部只剩下一些getter和setter了，不再解释，结合Demo使用就会有所体会。\n\n\n### 3. 总结\nptr的本质就是通过ViewGroup的dispatchTouchEvent将事件拦截在内部进行处理，并将事件过程分发给几个自定义的接口。而内部又添加了一些自定义的变量，并给出getter和setter，使得外部调用者使用起来十分轻松。只要掌握好事件分发处理和View的绘制流程，拆起来还算简单。当然，如果在实际项目中碰到了类似的需求，我倾向于定制一个简单一点的小工具。\n\n\n\n\n\n","slug":"2016-10-24-a-peek-on-pull-to-refresh","published":1,"updated":"2017-04-23T10:50:45.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdngg000hbovra5oyctag","content":"<p> 最早开始接触安卓的时候就知道有Chris Banes的<a href=\"https://github.com/chrisbanes/Android-PullToRefresh\">Pull-To-Refresh</a>，当时这个库已经被标记被Deprecated了，后来出于寻找替代品的目的找到了秋百万的<a href=\"https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh\">android-Ultra-pull-toRefresh</a>，直接</p>\n<p> <img src=\"http://odzl05jxx.bkt.clouddn.com/687474703a2f2f692e696d6775722e636f6d2f4766746846417a2e706e67.png\" alt=\"fork\"></p>\n<p> 当时甚至没有能力把一个Demo跑起来。之后的项目中，直接使用swipeRefreshLayout了。现在回头看，终于觉得可以尝试着分析一遍整个下拉刷新的过程。本文只针对<a href=\"https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh\">android-Ultra-pulltoRefresh</a>部分源码进行分析。拆一个轮子可能只需要花一天时间，但能够从无到有构思出这个框架，将项目搭建起来并且坚持长期维护真的是一件需要很强毅力的事情，向为开源社区贡献优秀代码的秋百万和众多做出贡献的开发者致敬。<br> <a id=\"more\"></a></p>\n<h3 id=\"1-从Demo开始吧\"><a href=\"#1-从Demo开始吧\" class=\"headerlink\" title=\"1. 从Demo开始吧\"></a>1. 从Demo开始吧</h3><p>从github clone下来之后，改一下gradle版本，compile sdk version什么的就可以运行项目自带的Demo了.<br>MainActivity 添加了一个PtrDemoHomeFragment,onCreateView里面返回的View对应的xml文件为<br>fragment_ptr_home.xml<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">in.srain.cube.views.ptr.PtrFrameLayout</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fragment_ptr_home_ptr_frame\"</span></div><div class=\"line\">        <span class=\"attr\">xmlns:cube_ptr</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_duration_to_close</span>=<span class=\"string\">\"200\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_duration_to_close_header</span>=<span class=\"string\">\"1000\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_keep_header_when_refresh</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_pull_to_fresh</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_ratio_of_header_height_to_refresh</span>=<span class=\"string\">\"1.2\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_resistance</span>=<span class=\"string\">\"1.7\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ScrollView</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fragment_block_menu_scroll_view\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:background</span>=<span class=\"string\">\"@color/cube_mints_white\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">in.srain.cube.views.block.BlockListView</span></div><div class=\"line\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fragment_block_menu_block_list\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">                <span class=\"attr\">android:padding</span>=<span class=\"string\">\"@dimen/cube_mints_content_view_padding\"</span> /&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ScrollView</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">in.srain.cube.views.ptr.PtrFrameLayout</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>默认主页已经可以下拉刷新了，那么主要的事件拦截操作应该就在这个ptrFrameLayout里面</p>\n<h3 id=\"2-PtrFrameLayout源码\"><a href=\"#2-PtrFrameLayout源码\" class=\"headerlink\" title=\"2. PtrFrameLayout源码\"></a>2. PtrFrameLayout源码</h3><p>从注释来看 </p>\n<blockquote>\n<p>This layout view for “Pull to Refresh(Ptr)” support all of the view, you can contain everything you want.<br>  support: pull to refresh / release to refresh / auto refresh / keep header view while refreshing / hide header view while refreshing<br>  It defines {@link in.srain.cube.views.ptr.PtrUIHandler}, which allows you customize the UI easily.</p>\n</blockquote>\n<p>能够容纳各种View，同时支持下拉刷新，下拉释放刷新，自动刷新，刷新时保留刷新动画，刷新时隐藏刷新动画</p>\n<p>一步步来看</p>\n<ol>\n<li><strong>构造函数</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PtrFrameLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PtrFrameLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyle)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyle);</div><div class=\"line\">        <span class=\"comment\">//删除无关代码</span></div><div class=\"line\">        TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.PtrFrameLayout, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (arr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mHeaderId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_header, mHeaderId); <span class=\"comment\">// HeaderView的layout文件id</span></div><div class=\"line\">            mContainerId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_content, mContainerId); <span class=\"comment\">// contentView的layout文件id</span></div><div class=\"line\">            mDurationToClose = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close, mDurationToClose);<span class=\"comment\">// 维持刷新动画多久开始关闭HeaderView</span></div><div class=\"line\">            mDurationToCloseHeader = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close_header, mDurationToCloseHeader);</div><div class=\"line\">            <span class=\"keyword\">float</span> ratio = mPtrIndicator.getRatioOfHeaderToHeightRefresh();</div><div class=\"line\">            ratio = arr.getFloat(R.styleable.PtrFrameLayout_ptr_ratio_of_header_height_to_refresh, ratio);</div><div class=\"line\">            mKeepHeaderWhenRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_keep_header_when_refresh, mKeepHeaderWhenRefresh);</div><div class=\"line\">            mPullToRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_pull_to_fresh, mPullToRefresh);</div><div class=\"line\">            arr.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//ViewConfiguration很常见了，mTouchSlop用于判断用户操作手势是否有效</span></div><div class=\"line\">        <span class=\"keyword\">final</span> ViewConfiguration conf = ViewConfiguration.get(getContext());</div><div class=\"line\">        mPagingTouchSlop = conf.getScaledTouchSlop() * <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造函数里面主要就是获得在xml中设定的一些自定义属性的值并保存为成员变量，实际用途后面再看。</p>\n<ol>\n<li><strong>onFinishInflate</strong><br>这个方法在inflate xml文件结束，所有的childView都已经添加之后调用<br>PtrFrameLayout复写了这个方法，</li>\n</ol>\n<ul>\n<li>首先检查ChildView数量，如果childCount &gt;2 会报错</li>\n<li>然后检查两个child(这里主要看childCount=2的情况下)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//省略若干</span></div><div class=\"line\"><span class=\"keyword\">if</span> (child1 <span class=\"keyword\">instanceof</span> PtrUIHandler) &#123;</div><div class=\"line\">                    mHeaderView = child1;</div><div class=\"line\">                    mContent = child2;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child2 <span class=\"keyword\">instanceof</span> PtrUIHandler) &#123;</div><div class=\"line\">                    mHeaderView = child2;</div><div class=\"line\">                    mContent = child1;</div><div class=\"line\">                &#125; </div><div class=\"line\"><span class=\"comment\">//省略若干</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>来看一下这个ptrUIHandler<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PtrUIHandler</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * When the content view has reached top and refresh has been completed, view will be reset.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> frame</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIReset</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * prepare for loading</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> frame</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIRefreshPrepare</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * perform refreshing UI</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIRefreshBegin</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * perform UI after refresh</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIRefreshComplete</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIPositionChange</span><span class=\"params\">(PtrFrameLayout frame, <span class=\"keyword\">boolean</span> isUnderTouch, <span class=\"keyword\">byte</span> status, PtrIndicator ptrIndicator)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大概可以猜到这货是用来指定下拉过程中的刷新开始，刷新结束，刷新结束后复位等过程的实现者，具体的下拉过程中的动画，位移等特效都应该由这接口的实例(View)来完成。</p>\n<ol>\n<li><strong>onMeasure</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">       <span class=\"comment\">//省略...</span></div><div class=\"line\">        measureContentView(mContent, widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">measureContentView</span><span class=\"params\">(View child,</div><div class=\"line\">                                   <span class=\"keyword\">int</span> parentWidthMeasureSpec,</div><div class=\"line\">                                   <span class=\"keyword\">int</span> parentHeightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class=\"line\">               getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin, lp.width);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class=\"line\">               getPaddingTop() + getPaddingBottom() + lp.topMargin, lp.height);</div><div class=\"line\"></div><div class=\"line\">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要就是调用了measureContentView方法，都是很中规中矩的实现</p>\n<ol>\n<li><strong>onLayout</strong><br>代码就不贴了，根据LayoutParams计算出需要的margin,最主要的Top是由<blockquote>\n<p> int offset = mPtrIndicator.getCurrentPosY();</p>\n</blockquote>\n</li>\n</ol>\n<p>获得的，mPterIndicator是一个单独的组件，用于保存一些实时状态。<br>滑动过程中如果有动画效果，会走到这个方法里，所以及时更新最新的位置很重要，ptr将这一功能剥离出来，这大概就是我所理解的解耦吧。</p>\n<ol>\n<li><strong>dispatchTouchEvent</strong><br>主要的手势处理逻辑都在这里，关于TouchEvent的分发处理，这里不再赘述。<br>简单列出执行顺序:<blockquote>\n<p>ViewGroup.dispatchTouchEvent—-ViewGroup.onInterceptTouchEvent—View.dispatchTouchEvent—– etc 、、、、</p>\n</blockquote>\n</li>\n</ol>\n<p>简书上有作者写出了非常好的关于TouchEvent分发的<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">文章</a>，忘记了的话可以去看看。<br>来看这部分的实现，有删节<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">   \t<span class=\"comment\">//.....</span></div><div class=\"line\">       <span class=\"keyword\">switch</span> (action) &#123;</div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</div><div class=\"line\">               <span class=\"keyword\">if</span> (mPtrIndicator.hasLeftStartPosition()) &#123;</div><div class=\"line\">                   onRelease(<span class=\"keyword\">false</span>); <span class=\"comment\">//手指抬起后的操作</span></div><div class=\"line\">                   <span class=\"comment\">// ......</span></div><div class=\"line\">                   <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">           \t<span class=\"comment\">//取消之前还在运行的Scroller等等。。</span></div><div class=\"line\">               <span class=\"comment\">// The cancel event will be sent once the position is moved.</span></div><div class=\"line\">               <span class=\"comment\">// So let the event pass to children.</span></div><div class=\"line\">               <span class=\"comment\">// fix #93, #102</span></div><div class=\"line\">               dispatchTouchEventSupper(e);</div><div class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;<span class=\"comment\">//这里返回true，child将会受到ACTION_CANCEL</span></div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">               mLastMoveEvent = e; <span class=\"comment\">//这里实时更新装填</span></div><div class=\"line\">               mPtrIndicator.onMove(e.getX(), e.getY());</div><div class=\"line\">               <span class=\"keyword\">float</span> offsetX = mPtrIndicator.getOffsetX();</div><div class=\"line\">               <span class=\"keyword\">float</span> offsetY = mPtrIndicator.getOffsetY();</div><div class=\"line\">              </div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">boolean</span> moveDown = offsetY &gt; <span class=\"number\">0</span>;</div><div class=\"line\">               <span class=\"keyword\">boolean</span> moveUp = !moveDown;</div><div class=\"line\">               <span class=\"keyword\">boolean</span> canMoveUp = mPtrIndicator.hasLeftStartPosition();</div><div class=\"line\"></div><div class=\"line\">               <span class=\"comment\">// disable move when header not reach top</span></div><div class=\"line\">               <span class=\"keyword\">if</span> (moveDown &amp;&amp; mPtrHandler != <span class=\"keyword\">null</span> &amp;&amp; !mPtrHandler.checkCanDoRefresh(<span class=\"keyword\">this</span>, mContent, mHeaderView)) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">if</span> ((moveUp &amp;&amp; canMoveUp) || moveDown) &#123;</div><div class=\"line\">                   movePos(offsetY); <span class=\"comment\">//实现滑动操作的代码</span></div><div class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;<span class=\"comment\">// 后续事件将只会走到此方法，不会再往下传递，直到ACTION_UP，本次手势结束</span></div><div class=\"line\">               &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>用户手指按下。。。。。手指滑动。。。。。手指抬起</p>\n<p><strong>ACTION_DOWN</strong> : 手指按下后将TouchEvent交给mPtrIndicator处理，后者保留了当前ptr的位置，高度等信息。在执行ACTION_DOWN时，并没有简单地使用Event.getY，而是保留了当前position的一个备份(这是必要的，因为对于下拉刷新来说，最终需要回到的位置是0，而用户按下的位置可能在contentView比较靠下面的位置。ACTION_DOWN的getY并没有太大意义)。随后调用Scroller的 mScroller.forceFinished(true)方法停止滑动，如果定义了页面自动刷新(就是进来会下拉刷新一次)，还会调用onRelease(true)方法，onRelease方法与ACTION_UP相关。</p>\n<p><strong>ACTION_MOVE</strong> : 手指开始在屏幕上滑动，首先将滑动距离的改变保留到mPtrIndicator中，这里作者将很多坐标计算的方法都拆出来放到这个mPtrIndicator中，暴露出get方法，也使得代码更清晰。在开始滑动之前，先检查下是否是横向滑动，以及是否在(mDisableWhenHorizontalMove，ViewPager需要消费横向手势，这个标志符是为了return super)。<br>往下走，来看这一段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">boolean</span> moveDown = offsetY &gt; <span class=\"number\">0</span>; 新的Event中的y值和mptrIndicator中保留的当前y的差值，所以手指往下拉的话，offset &gt;<span class=\"number\">0</span>,也就是这里的moveDown</div><div class=\"line\"><span class=\"keyword\">boolean</span> moveUp = !moveDown;</div><div class=\"line\"><span class=\"keyword\">boolean</span> canMoveUp = mPtrIndicator.hasLeftStartPosition()<span class=\"comment\">// 检查下当前Event中的y是否大于0，即内容区域是否已经往下走了一点了</span></div></pre></td></tr></table></figure></p>\n<p>接下来，再次询问mPtrHandler能否DoRefresh,将自身和ChildView都交出去，所以可操作性很大<br>大部分的情况下，直接使用一个</p>\n<blockquote>\n<p> return PtrDefaultHandler.checkContentCanBePulledDown(frame, content, header);</p>\n</blockquote>\n<p>使用了一个类似于ViewCompat.canScollVertically的方法，但判断下如果是AbstractListView的话，会调用getFirstVisiblePosition等方法，因为AdapterView能否滑动应该是由其内容能否滑动来决定的。<br>如果这个方法返回true。接着往下走，开始执行View的滑动方法:<br>判断下是否手指在往上拉(moveUp &amp;&amp; canMoveUp)或者往下拉(moveDown),return true，首先事件就不会再往下走，另外后续的ACTION_MOVE_ACTION_UP都只会传递到这个dispatchTouchEvent中<br>实现滑动操作的代码最后会执行这里<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updatePos</span><span class=\"params\">(<span class=\"keyword\">int</span> change)</span> </span>&#123;</div><div class=\"line\">     </div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">boolean</span> isUnderTouch = mPtrIndicator.isUnderTouch();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// once moved, cancel event will be sent to child</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (isUnderTouch &amp;&amp; !mHasSendCancelEvent &amp;&amp; mPtrIndicator.hasMovedAfterPressedDown()) &#123;</div><div class=\"line\">          mHasSendCancelEvent = <span class=\"keyword\">true</span>;</div><div class=\"line\">          sendCancelEvent();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// leave initiated position or just refresh complete</span></div><div class=\"line\">      <span class=\"keyword\">if</span> ((mPtrIndicator.hasJustLeftStartPosition() &amp;&amp; mStatus == PTR_STATUS_INIT) ||</div><div class=\"line\">              (mPtrIndicator.goDownCrossFinishPosition() &amp;&amp; mStatus == PTR_STATUS_COMPLETE &amp;&amp; isEnabledNextPtrAtOnce())) &#123;</div><div class=\"line\"></div><div class=\"line\">          mStatus = PTR_STATUS_PREPARE;</div><div class=\"line\">          mPtrUIHandlerHolder.onUIRefreshPrepare(<span class=\"keyword\">this</span>);<span class=\"comment\">//刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。这个Holder的结构类似于一个链表，一个Holder里面有UIHandler，以及下一个Holder(next)。作用类似于一个集合，等于作者自己实现了这样一个不断循环的消息列表(看起来挺像Message的)。这个Holder的作用在于可以动态添加UIHanlder，相对应的方法都做好了(addHandler)。</span></div><div class=\"line\">          <span class=\"comment\">//再次强调，这里表示**刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。此时的状态为STATUS_PREPARED**</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// back to initiated position</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (mPtrIndicator.hasJustBackToStartPosition()) &#123;</div><div class=\"line\">          tryToNotifyReset();</div><div class=\"line\">          <span class=\"comment\">//**刚刚从下面回到0的位置，通知UIHandler的onUIReset()方法,此时的状态为STATUS_INIT**</span></div><div class=\"line\">          <span class=\"comment\">//将整个过程划分的真详细</span></div><div class=\"line\">          <span class=\"comment\">// recover event to children，虽然手指还在屏幕上，处于ACTION_MOVE，但这里由于已经复位，需要把ACTION_DOWN传递下去，这一段比较复杂。</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (isUnderTouch) &#123;</div><div class=\"line\">              sendDownEvent();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// Pull to Refresh</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (mStatus == PTR_STATUS_PREPARE) &#123;<span class=\"comment\">//从上到下依次为0 ， 出现动画临界值， HeadView高度</span></div><div class=\"line\">          <span class=\"comment\">// reach fresh height while moving from top to bottom</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (isUnderTouch &amp;&amp; !isAutoRefresh() &amp;&amp; mPullToRefresh  <span class=\"comment\">// 手指还在屏幕上，不是自动刷新且允许ptr且到达了下滑出现动画效果的临界值，条件还是比较苛刻的</span></div><div class=\"line\">                  &amp;&amp; mPtrIndicator.crossRefreshLineFromTopToBottom()) &#123;</div><div class=\"line\">              tryToPerformRefresh();</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"comment\">// reach header height while auto refresh</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (performAutoRefreshButLater() &amp;&amp; mPtrIndicator.hasJustReachedHeaderHeightFromTopToBottom()) &#123;<span class=\"comment\">//刚刚超过headerView高度一丁点</span></div><div class=\"line\">              tryToPerformRefresh();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//tryToPerformRefresh()方法判断mPtrIndicator.isOverOffsetToRefresh()，满足条件的话进入STATUS_LOADING，这个时候就要开始让动画run了。所以这里调用的是 mPtrUIHandlerHolder.onUIRefreshBegin(this);和mPtrHandler.onRefreshBegin(this);前者是后来手动添加的UIHandler，后者则是在onInFlateFinish中自行判断的，这两个都会被执行。这里扯一句，这个Holder就像一个中间层，持有了UIHandler,所有方法都调用的是后者HanldleUI的方法。facade模式？</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 终于看到实际调用View滑动的代码了，让一个View滑动的方式有很多种，这里采用的是改变X,Y的方式(X = left+translationX;Y = top+translationY) </span></div><div class=\"line\">      mHeaderView.offsetTopAndBottom(change);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!isPinContent()) &#123;</div><div class=\"line\">          mContent.offsetTopAndBottom(change);</div><div class=\"line\">      &#125;</div><div class=\"line\">      invalidate();??我觉得这里好像没有必要这么频繁的调这一句话</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//移动完成之后通知UIHandlerHolder位置改变了，没有通知mUIHandler是因为后者就是mContent和mHeaderView。</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (mPtrUIHandlerHolder.hasHandler()) &#123;</div><div class=\"line\">          mPtrUIHandlerHolder.onUIPositionChange(<span class=\"keyword\">this</span>, isUnderTouch, mStatus, mPtrIndicator);</div><div class=\"line\">      &#125;</div><div class=\"line\">      onPositionChange(isUnderTouch, mStatus, mPtrIndicator);<span class=\"comment\">//最后还预留了一个onPositionChange的空方法，子类可能会有点用吧</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>到这里，ACTION_MOVE已经研究完毕，大部分的分析都在注释里面，只要分清楚滑动过程中的各种STATUS，我觉得还是比较好理解的。MOVE过程中伴随着距离的变化，ptr也进入不同的status，ptr本身其实只做了移动headrView和childView的工作，实际的动画效果等等都是由UIHanlder拿着ptr的实例去做的。关于能够滑动多少距离的问题，由于这里并没有判断，所以，这个contentView的下滑是没有下限的，不过在xml里面有一个自定义的resistance，相当于阻力系数了，设置大一点的话就不会出事。<strong>目前手指还在屏幕上，status等于STATUS_PREPARED或者STATUS_LOADING。借用手机评测那帮人的话来说，跟手</strong></p>\n<p><strong>ACTION_UP</strong>： mPtrIndicator中的mPressed设置为false，标示下当前手指已经不按在屏幕上了。如果这时候的位置&gt;0，就是contentView还没有复位，需要想办法让它”弹回来”，这部分工作交给了onRelease(false)，这个false我猜肯定是后面加上去的(查了下git log果然。。。)。来看OnRelease:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onRelease</span><span class=\"params\">(<span class=\"keyword\">boolean</span> stayForLoading)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      tryToPerformRefresh();<span class=\"comment\">//会检查下当前status!=STATUS_PREPARED的话直接return false，就是不是在刚开始或刚复位的情况下不做；否则继续执行performRefresh操作，其实这样想也符合常理，手指离开了屏幕，ptr应该能够自我判断是否还需要执行动画</span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (mStatus == PTR_STATUS_LOADING) &#123;</div><div class=\"line\">          <span class=\"comment\">// keep header for fresh</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (mKeepHeaderWhenRefresh) &#123;</div><div class=\"line\">              <span class=\"comment\">// scroll header back</span></div><div class=\"line\">              <span class=\"keyword\">if</span> (mPtrIndicator.isOverOffsetToKeepHeaderWhileLoading() &amp;&amp; !stayForLoading) &#123;<span class=\"comment\">//已经过了需要加载动画的位置，statyForLoading这里传进来的是false</span></div><div class=\"line\">                  mScrollChecker.tryToScrollTo(mPtrIndicator.getOffsetToKeepHeaderWhileLoading(), mDurationToClose);<span class=\"comment\">//滑动到加载动画的位置，这里面是不断地post一个runnable，在run方法里面调用之前和ACTION_MOVE里面一样的那个movePos方法，所以重用性还好。也会通知相应的UIHandler或者UIHandlerHolder</span></div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  <span class=\"comment\">// do nothing</span></div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              tryScrollBackToTopWhileLoading();<span class=\"comment\">//这里会一直滑动到0的位置，其实也是不断调用updatPos方法，会将STATUS重置为STATUS_INIT或者STATUS_PREPARED</span></div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (mStatus == PTR_STATUS_COMPLETE) &#123;<span class=\"comment\">//STATUS_COMPLETE通常由外部调用者调用refreshComplete public 方法设置，相当于SwipeRefreshLayout的setRefreshing()，否则将一直停留在加载状态。也就是说需要调用者手动设置关闭，这也符合常理，因为加载本身是需要时间的，把这个设置的时机交给开发者来手动设置几乎是唯一的选择。</span></div><div class=\"line\">              notifyUIRefreshComplete(<span class=\"keyword\">false</span>);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              tryScrollBackToTopAbortRefresh();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>到此，ptr内部只剩下一些getter和setter了，不再解释，结合Demo使用就会有所体会。</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h3><p>ptr的本质就是通过ViewGroup的dispatchTouchEvent将事件拦截在内部进行处理，并将事件过程分发给几个自定义的接口。而内部又添加了一些自定义的变量，并给出getter和setter，使得外部调用者使用起来十分轻松。只要掌握好事件分发处理和View的绘制流程，拆起来还算简单。当然，如果在实际项目中碰到了类似的需求，我倾向于定制一个简单一点的小工具。</p>\n","excerpt":"<p> 最早开始接触安卓的时候就知道有Chris Banes的<a href=\"https://github.com/chrisbanes/Android-PullToRefresh\">Pull-To-Refresh</a>，当时这个库已经被标记被Deprecated了，后来出于寻找替代品的目的找到了秋百万的<a href=\"https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh\">android-Ultra-pull-toRefresh</a>，直接</p>\n<p> <img src=\"http://odzl05jxx.bkt.clouddn.com/687474703a2f2f692e696d6775722e636f6d2f4766746846417a2e706e67.png\" alt=\"fork\"></p>\n<p> 当时甚至没有能力把一个Demo跑起来。之后的项目中，直接使用swipeRefreshLayout了。现在回头看，终于觉得可以尝试着分析一遍整个下拉刷新的过程。本文只针对<a href=\"https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh\">android-Ultra-pulltoRefresh</a>部分源码进行分析。拆一个轮子可能只需要花一天时间，但能够从无到有构思出这个框架，将项目搭建起来并且坚持长期维护真的是一件需要很强毅力的事情，向为开源社区贡献优秀代码的秋百万和众多做出贡献的开发者致敬。<br>","more":"</p>\n<h3 id=\"1-从Demo开始吧\"><a href=\"#1-从Demo开始吧\" class=\"headerlink\" title=\"1. 从Demo开始吧\"></a>1. 从Demo开始吧</h3><p>从github clone下来之后，改一下gradle版本，compile sdk version什么的就可以运行项目自带的Demo了.<br>MainActivity 添加了一个PtrDemoHomeFragment,onCreateView里面返回的View对应的xml文件为<br>fragment_ptr_home.xml<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">in.srain.cube.views.ptr.PtrFrameLayout</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fragment_ptr_home_ptr_frame\"</span></div><div class=\"line\">        <span class=\"attr\">xmlns:cube_ptr</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_duration_to_close</span>=<span class=\"string\">\"200\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_duration_to_close_header</span>=<span class=\"string\">\"1000\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_keep_header_when_refresh</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_pull_to_fresh</span>=<span class=\"string\">\"false\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_ratio_of_header_height_to_refresh</span>=<span class=\"string\">\"1.2\"</span></div><div class=\"line\">        <span class=\"attr\">cube_ptr:ptr_resistance</span>=<span class=\"string\">\"1.7\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ScrollView</span></div><div class=\"line\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fragment_block_menu_scroll_view\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">            <span class=\"attr\">android:background</span>=<span class=\"string\">\"@color/cube_mints_white\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">in.srain.cube.views.block.BlockListView</span></div><div class=\"line\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/fragment_block_menu_block_list\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">                <span class=\"attr\">android:padding</span>=<span class=\"string\">\"@dimen/cube_mints_content_view_padding\"</span> /&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ScrollView</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">in.srain.cube.views.ptr.PtrFrameLayout</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>默认主页已经可以下拉刷新了，那么主要的事件拦截操作应该就在这个ptrFrameLayout里面</p>\n<h3 id=\"2-PtrFrameLayout源码\"><a href=\"#2-PtrFrameLayout源码\" class=\"headerlink\" title=\"2. PtrFrameLayout源码\"></a>2. PtrFrameLayout源码</h3><p>从注释来看 </p>\n<blockquote>\n<p>This layout view for “Pull to Refresh(Ptr)” support all of the view, you can contain everything you want.<br>  support: pull to refresh / release to refresh / auto refresh / keep header view while refreshing / hide header view while refreshing<br>  It defines {@link in.srain.cube.views.ptr.PtrUIHandler}, which allows you customize the UI easily.</p>\n</blockquote>\n<p>能够容纳各种View，同时支持下拉刷新，下拉释放刷新，自动刷新，刷新时保留刷新动画，刷新时隐藏刷新动画</p>\n<p>一步步来看</p>\n<ol>\n<li><strong>构造函数</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PtrFrameLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PtrFrameLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyle)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyle);</div><div class=\"line\">        <span class=\"comment\">//删除无关代码</span></div><div class=\"line\">        TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.PtrFrameLayout, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (arr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mHeaderId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_header, mHeaderId); <span class=\"comment\">// HeaderView的layout文件id</span></div><div class=\"line\">            mContainerId = arr.getResourceId(R.styleable.PtrFrameLayout_ptr_content, mContainerId); <span class=\"comment\">// contentView的layout文件id</span></div><div class=\"line\">            mDurationToClose = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close, mDurationToClose);<span class=\"comment\">// 维持刷新动画多久开始关闭HeaderView</span></div><div class=\"line\">            mDurationToCloseHeader = arr.getInt(R.styleable.PtrFrameLayout_ptr_duration_to_close_header, mDurationToCloseHeader);</div><div class=\"line\">            <span class=\"keyword\">float</span> ratio = mPtrIndicator.getRatioOfHeaderToHeightRefresh();</div><div class=\"line\">            ratio = arr.getFloat(R.styleable.PtrFrameLayout_ptr_ratio_of_header_height_to_refresh, ratio);</div><div class=\"line\">            mKeepHeaderWhenRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_keep_header_when_refresh, mKeepHeaderWhenRefresh);</div><div class=\"line\">            mPullToRefresh = arr.getBoolean(R.styleable.PtrFrameLayout_ptr_pull_to_fresh, mPullToRefresh);</div><div class=\"line\">            arr.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//ViewConfiguration很常见了，mTouchSlop用于判断用户操作手势是否有效</span></div><div class=\"line\">        <span class=\"keyword\">final</span> ViewConfiguration conf = ViewConfiguration.get(getContext());</div><div class=\"line\">        mPagingTouchSlop = conf.getScaledTouchSlop() * <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造函数里面主要就是获得在xml中设定的一些自定义属性的值并保存为成员变量，实际用途后面再看。</p>\n<ol>\n<li><strong>onFinishInflate</strong><br>这个方法在inflate xml文件结束，所有的childView都已经添加之后调用<br>PtrFrameLayout复写了这个方法，</li>\n</ol>\n<ul>\n<li>首先检查ChildView数量，如果childCount &gt;2 会报错</li>\n<li>然后检查两个child(这里主要看childCount=2的情况下)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//省略若干</span></div><div class=\"line\"><span class=\"keyword\">if</span> (child1 <span class=\"keyword\">instanceof</span> PtrUIHandler) &#123;</div><div class=\"line\">                    mHeaderView = child1;</div><div class=\"line\">                    mContent = child2;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child2 <span class=\"keyword\">instanceof</span> PtrUIHandler) &#123;</div><div class=\"line\">                    mHeaderView = child2;</div><div class=\"line\">                    mContent = child1;</div><div class=\"line\">                &#125; </div><div class=\"line\"><span class=\"comment\">//省略若干</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>来看一下这个ptrUIHandler<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PtrUIHandler</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * When the content view has reached top and refresh has been completed, view will be reset.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> frame</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIReset</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * prepare for loading</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> frame</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIRefreshPrepare</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * perform refreshing UI</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIRefreshBegin</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * perform UI after refresh</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIRefreshComplete</span><span class=\"params\">(PtrFrameLayout frame)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUIPositionChange</span><span class=\"params\">(PtrFrameLayout frame, <span class=\"keyword\">boolean</span> isUnderTouch, <span class=\"keyword\">byte</span> status, PtrIndicator ptrIndicator)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大概可以猜到这货是用来指定下拉过程中的刷新开始，刷新结束，刷新结束后复位等过程的实现者，具体的下拉过程中的动画，位移等特效都应该由这接口的实例(View)来完成。</p>\n<ol>\n<li><strong>onMeasure</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">       <span class=\"comment\">//省略...</span></div><div class=\"line\">        measureContentView(mContent, widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">measureContentView</span><span class=\"params\">(View child,</div><div class=\"line\">                                   <span class=\"keyword\">int</span> parentWidthMeasureSpec,</div><div class=\"line\">                                   <span class=\"keyword\">int</span> parentHeightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class=\"line\">               getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin, lp.width);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class=\"line\">               getPaddingTop() + getPaddingBottom() + lp.topMargin, lp.height);</div><div class=\"line\"></div><div class=\"line\">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要就是调用了measureContentView方法，都是很中规中矩的实现</p>\n<ol>\n<li><strong>onLayout</strong><br>代码就不贴了，根据LayoutParams计算出需要的margin,最主要的Top是由<blockquote>\n<p> int offset = mPtrIndicator.getCurrentPosY();</p>\n</blockquote>\n</li>\n</ol>\n<p>获得的，mPterIndicator是一个单独的组件，用于保存一些实时状态。<br>滑动过程中如果有动画效果，会走到这个方法里，所以及时更新最新的位置很重要，ptr将这一功能剥离出来，这大概就是我所理解的解耦吧。</p>\n<ol>\n<li><strong>dispatchTouchEvent</strong><br>主要的手势处理逻辑都在这里，关于TouchEvent的分发处理，这里不再赘述。<br>简单列出执行顺序:<blockquote>\n<p>ViewGroup.dispatchTouchEvent—-ViewGroup.onInterceptTouchEvent—View.dispatchTouchEvent—– etc 、、、、</p>\n</blockquote>\n</li>\n</ol>\n<p>简书上有作者写出了非常好的关于TouchEvent分发的<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">文章</a>，忘记了的话可以去看看。<br>来看这部分的实现，有删节<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">   \t<span class=\"comment\">//.....</span></div><div class=\"line\">       <span class=\"keyword\">switch</span> (action) &#123;</div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</div><div class=\"line\">               <span class=\"keyword\">if</span> (mPtrIndicator.hasLeftStartPosition()) &#123;</div><div class=\"line\">                   onRelease(<span class=\"keyword\">false</span>); <span class=\"comment\">//手指抬起后的操作</span></div><div class=\"line\">                   <span class=\"comment\">// ......</span></div><div class=\"line\">                   <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">           \t<span class=\"comment\">//取消之前还在运行的Scroller等等。。</span></div><div class=\"line\">               <span class=\"comment\">// The cancel event will be sent once the position is moved.</span></div><div class=\"line\">               <span class=\"comment\">// So let the event pass to children.</span></div><div class=\"line\">               <span class=\"comment\">// fix #93, #102</span></div><div class=\"line\">               dispatchTouchEventSupper(e);</div><div class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;<span class=\"comment\">//这里返回true，child将会受到ACTION_CANCEL</span></div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">               mLastMoveEvent = e; <span class=\"comment\">//这里实时更新装填</span></div><div class=\"line\">               mPtrIndicator.onMove(e.getX(), e.getY());</div><div class=\"line\">               <span class=\"keyword\">float</span> offsetX = mPtrIndicator.getOffsetX();</div><div class=\"line\">               <span class=\"keyword\">float</span> offsetY = mPtrIndicator.getOffsetY();</div><div class=\"line\">              </div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">boolean</span> moveDown = offsetY &gt; <span class=\"number\">0</span>;</div><div class=\"line\">               <span class=\"keyword\">boolean</span> moveUp = !moveDown;</div><div class=\"line\">               <span class=\"keyword\">boolean</span> canMoveUp = mPtrIndicator.hasLeftStartPosition();</div><div class=\"line\"></div><div class=\"line\">               <span class=\"comment\">// disable move when header not reach top</span></div><div class=\"line\">               <span class=\"keyword\">if</span> (moveDown &amp;&amp; mPtrHandler != <span class=\"keyword\">null</span> &amp;&amp; !mPtrHandler.checkCanDoRefresh(<span class=\"keyword\">this</span>, mContent, mHeaderView)) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">if</span> ((moveUp &amp;&amp; canMoveUp) || moveDown) &#123;</div><div class=\"line\">                   movePos(offsetY); <span class=\"comment\">//实现滑动操作的代码</span></div><div class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;<span class=\"comment\">// 后续事件将只会走到此方法，不会再往下传递，直到ACTION_UP，本次手势结束</span></div><div class=\"line\">               &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> dispatchTouchEventSupper(e);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>用户手指按下。。。。。手指滑动。。。。。手指抬起</p>\n<p><strong>ACTION_DOWN</strong> : 手指按下后将TouchEvent交给mPtrIndicator处理，后者保留了当前ptr的位置，高度等信息。在执行ACTION_DOWN时，并没有简单地使用Event.getY，而是保留了当前position的一个备份(这是必要的，因为对于下拉刷新来说，最终需要回到的位置是0，而用户按下的位置可能在contentView比较靠下面的位置。ACTION_DOWN的getY并没有太大意义)。随后调用Scroller的 mScroller.forceFinished(true)方法停止滑动，如果定义了页面自动刷新(就是进来会下拉刷新一次)，还会调用onRelease(true)方法，onRelease方法与ACTION_UP相关。</p>\n<p><strong>ACTION_MOVE</strong> : 手指开始在屏幕上滑动，首先将滑动距离的改变保留到mPtrIndicator中，这里作者将很多坐标计算的方法都拆出来放到这个mPtrIndicator中，暴露出get方法，也使得代码更清晰。在开始滑动之前，先检查下是否是横向滑动，以及是否在(mDisableWhenHorizontalMove，ViewPager需要消费横向手势，这个标志符是为了return super)。<br>往下走，来看这一段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">boolean</span> moveDown = offsetY &gt; <span class=\"number\">0</span>; 新的Event中的y值和mptrIndicator中保留的当前y的差值，所以手指往下拉的话，offset &gt;<span class=\"number\">0</span>,也就是这里的moveDown</div><div class=\"line\"><span class=\"keyword\">boolean</span> moveUp = !moveDown;</div><div class=\"line\"><span class=\"keyword\">boolean</span> canMoveUp = mPtrIndicator.hasLeftStartPosition()<span class=\"comment\">// 检查下当前Event中的y是否大于0，即内容区域是否已经往下走了一点了</span></div></pre></td></tr></table></figure></p>\n<p>接下来，再次询问mPtrHandler能否DoRefresh,将自身和ChildView都交出去，所以可操作性很大<br>大部分的情况下，直接使用一个</p>\n<blockquote>\n<p> return PtrDefaultHandler.checkContentCanBePulledDown(frame, content, header);</p>\n</blockquote>\n<p>使用了一个类似于ViewCompat.canScollVertically的方法，但判断下如果是AbstractListView的话，会调用getFirstVisiblePosition等方法，因为AdapterView能否滑动应该是由其内容能否滑动来决定的。<br>如果这个方法返回true。接着往下走，开始执行View的滑动方法:<br>判断下是否手指在往上拉(moveUp &amp;&amp; canMoveUp)或者往下拉(moveDown),return true，首先事件就不会再往下走，另外后续的ACTION_MOVE_ACTION_UP都只会传递到这个dispatchTouchEvent中<br>实现滑动操作的代码最后会执行这里<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updatePos</span><span class=\"params\">(<span class=\"keyword\">int</span> change)</span> </span>&#123;</div><div class=\"line\">     </div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">boolean</span> isUnderTouch = mPtrIndicator.isUnderTouch();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// once moved, cancel event will be sent to child</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (isUnderTouch &amp;&amp; !mHasSendCancelEvent &amp;&amp; mPtrIndicator.hasMovedAfterPressedDown()) &#123;</div><div class=\"line\">          mHasSendCancelEvent = <span class=\"keyword\">true</span>;</div><div class=\"line\">          sendCancelEvent();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// leave initiated position or just refresh complete</span></div><div class=\"line\">      <span class=\"keyword\">if</span> ((mPtrIndicator.hasJustLeftStartPosition() &amp;&amp; mStatus == PTR_STATUS_INIT) ||</div><div class=\"line\">              (mPtrIndicator.goDownCrossFinishPosition() &amp;&amp; mStatus == PTR_STATUS_COMPLETE &amp;&amp; isEnabledNextPtrAtOnce())) &#123;</div><div class=\"line\"></div><div class=\"line\">          mStatus = PTR_STATUS_PREPARE;</div><div class=\"line\">          mPtrUIHandlerHolder.onUIRefreshPrepare(<span class=\"keyword\">this</span>);<span class=\"comment\">//刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。这个Holder的结构类似于一个链表，一个Holder里面有UIHandler，以及下一个Holder(next)。作用类似于一个集合，等于作者自己实现了这样一个不断循环的消息列表(看起来挺像Message的)。这个Holder的作用在于可以动态添加UIHanlder，相对应的方法都做好了(addHandler)。</span></div><div class=\"line\">          <span class=\"comment\">//再次强调，这里表示**刚开始往下移一点点或者刚刚从下面回到0的位置，可以认为是下拉刷新刚开始和刚结束的时候。此时的状态为STATUS_PREPARED**</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// back to initiated position</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (mPtrIndicator.hasJustBackToStartPosition()) &#123;</div><div class=\"line\">          tryToNotifyReset();</div><div class=\"line\">          <span class=\"comment\">//**刚刚从下面回到0的位置，通知UIHandler的onUIReset()方法,此时的状态为STATUS_INIT**</span></div><div class=\"line\">          <span class=\"comment\">//将整个过程划分的真详细</span></div><div class=\"line\">          <span class=\"comment\">// recover event to children，虽然手指还在屏幕上，处于ACTION_MOVE，但这里由于已经复位，需要把ACTION_DOWN传递下去，这一段比较复杂。</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (isUnderTouch) &#123;</div><div class=\"line\">              sendDownEvent();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// Pull to Refresh</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (mStatus == PTR_STATUS_PREPARE) &#123;<span class=\"comment\">//从上到下依次为0 ， 出现动画临界值， HeadView高度</span></div><div class=\"line\">          <span class=\"comment\">// reach fresh height while moving from top to bottom</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (isUnderTouch &amp;&amp; !isAutoRefresh() &amp;&amp; mPullToRefresh  <span class=\"comment\">// 手指还在屏幕上，不是自动刷新且允许ptr且到达了下滑出现动画效果的临界值，条件还是比较苛刻的</span></div><div class=\"line\">                  &amp;&amp; mPtrIndicator.crossRefreshLineFromTopToBottom()) &#123;</div><div class=\"line\">              tryToPerformRefresh();</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"comment\">// reach header height while auto refresh</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (performAutoRefreshButLater() &amp;&amp; mPtrIndicator.hasJustReachedHeaderHeightFromTopToBottom()) &#123;<span class=\"comment\">//刚刚超过headerView高度一丁点</span></div><div class=\"line\">              tryToPerformRefresh();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//tryToPerformRefresh()方法判断mPtrIndicator.isOverOffsetToRefresh()，满足条件的话进入STATUS_LOADING，这个时候就要开始让动画run了。所以这里调用的是 mPtrUIHandlerHolder.onUIRefreshBegin(this);和mPtrHandler.onRefreshBegin(this);前者是后来手动添加的UIHandler，后者则是在onInFlateFinish中自行判断的，这两个都会被执行。这里扯一句，这个Holder就像一个中间层，持有了UIHandler,所有方法都调用的是后者HanldleUI的方法。facade模式？</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 终于看到实际调用View滑动的代码了，让一个View滑动的方式有很多种，这里采用的是改变X,Y的方式(X = left+translationX;Y = top+translationY) </span></div><div class=\"line\">      mHeaderView.offsetTopAndBottom(change);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!isPinContent()) &#123;</div><div class=\"line\">          mContent.offsetTopAndBottom(change);</div><div class=\"line\">      &#125;</div><div class=\"line\">      invalidate();??我觉得这里好像没有必要这么频繁的调这一句话</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//移动完成之后通知UIHandlerHolder位置改变了，没有通知mUIHandler是因为后者就是mContent和mHeaderView。</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (mPtrUIHandlerHolder.hasHandler()) &#123;</div><div class=\"line\">          mPtrUIHandlerHolder.onUIPositionChange(<span class=\"keyword\">this</span>, isUnderTouch, mStatus, mPtrIndicator);</div><div class=\"line\">      &#125;</div><div class=\"line\">      onPositionChange(isUnderTouch, mStatus, mPtrIndicator);<span class=\"comment\">//最后还预留了一个onPositionChange的空方法，子类可能会有点用吧</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>到这里，ACTION_MOVE已经研究完毕，大部分的分析都在注释里面，只要分清楚滑动过程中的各种STATUS，我觉得还是比较好理解的。MOVE过程中伴随着距离的变化，ptr也进入不同的status，ptr本身其实只做了移动headrView和childView的工作，实际的动画效果等等都是由UIHanlder拿着ptr的实例去做的。关于能够滑动多少距离的问题，由于这里并没有判断，所以，这个contentView的下滑是没有下限的，不过在xml里面有一个自定义的resistance，相当于阻力系数了，设置大一点的话就不会出事。<strong>目前手指还在屏幕上，status等于STATUS_PREPARED或者STATUS_LOADING。借用手机评测那帮人的话来说，跟手</strong></p>\n<p><strong>ACTION_UP</strong>： mPtrIndicator中的mPressed设置为false，标示下当前手指已经不按在屏幕上了。如果这时候的位置&gt;0，就是contentView还没有复位，需要想办法让它”弹回来”，这部分工作交给了onRelease(false)，这个false我猜肯定是后面加上去的(查了下git log果然。。。)。来看OnRelease:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onRelease</span><span class=\"params\">(<span class=\"keyword\">boolean</span> stayForLoading)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      tryToPerformRefresh();<span class=\"comment\">//会检查下当前status!=STATUS_PREPARED的话直接return false，就是不是在刚开始或刚复位的情况下不做；否则继续执行performRefresh操作，其实这样想也符合常理，手指离开了屏幕，ptr应该能够自我判断是否还需要执行动画</span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (mStatus == PTR_STATUS_LOADING) &#123;</div><div class=\"line\">          <span class=\"comment\">// keep header for fresh</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (mKeepHeaderWhenRefresh) &#123;</div><div class=\"line\">              <span class=\"comment\">// scroll header back</span></div><div class=\"line\">              <span class=\"keyword\">if</span> (mPtrIndicator.isOverOffsetToKeepHeaderWhileLoading() &amp;&amp; !stayForLoading) &#123;<span class=\"comment\">//已经过了需要加载动画的位置，statyForLoading这里传进来的是false</span></div><div class=\"line\">                  mScrollChecker.tryToScrollTo(mPtrIndicator.getOffsetToKeepHeaderWhileLoading(), mDurationToClose);<span class=\"comment\">//滑动到加载动画的位置，这里面是不断地post一个runnable，在run方法里面调用之前和ACTION_MOVE里面一样的那个movePos方法，所以重用性还好。也会通知相应的UIHandler或者UIHandlerHolder</span></div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  <span class=\"comment\">// do nothing</span></div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              tryScrollBackToTopWhileLoading();<span class=\"comment\">//这里会一直滑动到0的位置，其实也是不断调用updatPos方法，会将STATUS重置为STATUS_INIT或者STATUS_PREPARED</span></div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (mStatus == PTR_STATUS_COMPLETE) &#123;<span class=\"comment\">//STATUS_COMPLETE通常由外部调用者调用refreshComplete public 方法设置，相当于SwipeRefreshLayout的setRefreshing()，否则将一直停留在加载状态。也就是说需要调用者手动设置关闭，这也符合常理，因为加载本身是需要时间的，把这个设置的时机交给开发者来手动设置几乎是唯一的选择。</span></div><div class=\"line\">              notifyUIRefreshComplete(<span class=\"keyword\">false</span>);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              tryScrollBackToTopAbortRefresh();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>到此，ptr内部只剩下一些getter和setter了，不再解释，结合Demo使用就会有所体会。</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h3><p>ptr的本质就是通过ViewGroup的dispatchTouchEvent将事件拦截在内部进行处理，并将事件过程分发给几个自定义的接口。而内部又添加了一些自定义的变量，并给出getter和setter，使得外部调用者使用起来十分轻松。只要掌握好事件分发处理和View的绘制流程，拆起来还算简单。当然，如果在实际项目中碰到了类似的需求，我倾向于定制一个简单一点的小工具。</p>"},{"title":"Windows10平台安装lxml记录","date":"2016-10-31T07:49:38.000Z","_content":"\n\n前几天尝试使用一个简单的微博爬虫进行操作，导包的时候遇到lxml缺失的问题，找了好久最终在百度知道上找到个能用的，(⊙﹏⊙)b。\n\n###  1. 环境\n1. python2.7, win10 64位\n2. pip 环境变量配置 <!--more-->\n\n### 2. 开始\n1. cmd 命令行敲入\n> pip install wheel\n\n2. 准备lxml安装文件\n   下载[地址](https://pypi.python.org/pypi/lxml/3.4.2)\n   我的是win10 64位，选择 lxml-3.4.2-cp27-none-win_amd54.xhl\n\n3. 下载完成后放到 c:\\python27\\文件夹下\n4. 命令行敲入\n> pip install c:\\python27\\lxml...(刚才的文件名)\n\n5. 最后会提示\n> successfully installeed lxml-3.4.2\n\n这时候关闭pycharm project，重新打开就可以看到导入成功了。\n\n### ref\n- [百度有时候也是挺管用的](http://jingyan.baidu.com/article/cbcede07177b8702f40b4df9.html)\n","source":"_posts/2016-10-31-install-lxml-on-windows.md","raw":"---\ntitle: Windows10平台安装lxml记录\ndate: 2016-10-31 15:49:38\ncategories: blog\ntags: [python]\n---\n\n\n前几天尝试使用一个简单的微博爬虫进行操作，导包的时候遇到lxml缺失的问题，找了好久最终在百度知道上找到个能用的，(⊙﹏⊙)b。\n\n###  1. 环境\n1. python2.7, win10 64位\n2. pip 环境变量配置 <!--more-->\n\n### 2. 开始\n1. cmd 命令行敲入\n> pip install wheel\n\n2. 准备lxml安装文件\n   下载[地址](https://pypi.python.org/pypi/lxml/3.4.2)\n   我的是win10 64位，选择 lxml-3.4.2-cp27-none-win_amd54.xhl\n\n3. 下载完成后放到 c:\\python27\\文件夹下\n4. 命令行敲入\n> pip install c:\\python27\\lxml...(刚才的文件名)\n\n5. 最后会提示\n> successfully installeed lxml-3.4.2\n\n这时候关闭pycharm project，重新打开就可以看到导入成功了。\n\n### ref\n- [百度有时候也是挺管用的](http://jingyan.baidu.com/article/cbcede07177b8702f40b4df9.html)\n","slug":"2016-10-31-install-lxml-on-windows","published":1,"updated":"2017-06-15T15:39:29.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdngk000kbovr28k0jx8g","content":"<p>前几天尝试使用一个简单的微博爬虫进行操作，导包的时候遇到lxml缺失的问题，找了好久最终在百度知道上找到个能用的，(⊙﹏⊙)b。</p>\n<h3 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h3><ol>\n<li>python2.7, win10 64位</li>\n<li>pip 环境变量配置 <a id=\"more\"></a></li>\n</ol>\n<h3 id=\"2-开始\"><a href=\"#2-开始\" class=\"headerlink\" title=\"2. 开始\"></a>2. 开始</h3><ol>\n<li><p>cmd 命令行敲入</p>\n<blockquote>\n<p>pip install wheel</p>\n</blockquote>\n</li>\n<li><p>准备lxml安装文件<br>下载<a href=\"https://pypi.python.org/pypi/lxml/3.4.2\">地址</a><br>我的是win10 64位，选择 lxml-3.4.2-cp27-none-win_amd54.xhl</p>\n</li>\n<li><p>下载完成后放到 c:\\python27\\文件夹下</p>\n</li>\n<li><p>命令行敲入</p>\n<blockquote>\n<p>pip install c:\\python27\\lxml…(刚才的文件名)</p>\n</blockquote>\n</li>\n<li><p>最后会提示</p>\n<blockquote>\n<p>successfully installeed lxml-3.4.2</p>\n</blockquote>\n</li>\n</ol>\n<p>这时候关闭pycharm project，重新打开就可以看到导入成功了。</p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"http://jingyan.baidu.com/article/cbcede07177b8702f40b4df9.html\">百度有时候也是挺管用的</a></li>\n</ul>\n","excerpt":"<p>前几天尝试使用一个简单的微博爬虫进行操作，导包的时候遇到lxml缺失的问题，找了好久最终在百度知道上找到个能用的，(⊙﹏⊙)b。</p>\n<h3 id=\"1-环境\"><a href=\"#1-环境\" class=\"headerlink\" title=\"1. 环境\"></a>1. 环境</h3><ol>\n<li>python2.7, win10 64位</li>\n<li>pip 环境变量配置","more":"</li>\n</ol>\n<h3 id=\"2-开始\"><a href=\"#2-开始\" class=\"headerlink\" title=\"2. 开始\"></a>2. 开始</h3><ol>\n<li><p>cmd 命令行敲入</p>\n<blockquote>\n<p>pip install wheel</p>\n</blockquote>\n</li>\n<li><p>准备lxml安装文件<br>下载<a href=\"https://pypi.python.org/pypi/lxml/3.4.2\">地址</a><br>我的是win10 64位，选择 lxml-3.4.2-cp27-none-win_amd54.xhl</p>\n</li>\n<li><p>下载完成后放到 c:\\python27\\文件夹下</p>\n</li>\n<li><p>命令行敲入</p>\n<blockquote>\n<p>pip install c:\\python27\\lxml…(刚才的文件名)</p>\n</blockquote>\n</li>\n<li><p>最后会提示</p>\n<blockquote>\n<p>successfully installeed lxml-3.4.2</p>\n</blockquote>\n</li>\n</ol>\n<p>这时候关闭pycharm project，重新打开就可以看到导入成功了。</p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"http://jingyan.baidu.com/article/cbcede07177b8702f40b4df9.html\">百度有时候也是挺管用的</a></li>\n</ul>"},{"title":"wrap_content到底多大","date":"2016-11-27T08:46:44.000Z","_content":"\n转眼就十一月了，java的分析越来越少，虽然常常在业务上碰到不少坑。。。\n\n### 问题的由来\n这周碰到一个需要画时间轴样式的自定义View的需求，大概像这样(图片来自网络)：\n![](http://odzl05jxx.bkt.clouddn.com/timelineView.png)\n\n要求，左侧的圆形节点可以自定义Drawable，右侧的文字高度随文字数量变化自适应。\n\n想想也就是自定义ViewGroup的那一套老样子。抄起键盘就开始研(Copy)究(Paste)，写着写着发现不对劲，主要的问题包括:\n\n> 1. 在onMeasure里面拿到的height == 0 , 具体一点就是:\n整个ViewGroup包含多个Item，每个Item包括左侧的自定义View(CustomView)，高度是wrap_content，右边的TextView高度是wrap_content(自适应嘛)。可是debug时发现左侧的自定义View拿到的高度是0，简直日了哈士奇了。随后拿着关键词去Google搜索，还是没有什么收获。\n\n\n```java\n protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);// 这里是UNSPECIFIED, 常规概念里wrap_content对应的应该是AT_MOST\n        final int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        final int heightSize = MeasureSpec.getSize(heightMeasureSpec); // 居然等于0\n    }\n\n```\n回顾这个Item的实现，Item继承自RelativeLayout，左边的View是调用addView(view,RelativeLayout.Layoutparams)加进去的,params设置了一些rules，像是AlignParentLeft这种，记得给左边的View和右边的TextView都设置一个id就好。TextView也是这样addView进去的。后来查到了秋百万对于MeasureSpec的介绍，我想到RelativeLayout的onMeasure会调用两次，在第一次测量的时候，左边的View和右边的TextView都把高度设置为wrap_content了。要命的是这个Item本身添加到UI的方式也是类似的addView(view,RelativeLayout.Layoutparams)方式，这里的height也是wrap_content。即Item本身高度需要由其child决定，左边的child决定不了，只有右边的TextView才能决定。所以第一轮测量下来，左边的View的高度只能是0，右边的TextView高度倒是确定了。这时候Item本身的高度也就能确定了。在第二遍测量的时候，就能顺利拿到高度了。\n\n> 2. 左侧的每个节点上的drawable不画出来\n后来查了下，原因在于我对传进来的drawable检查了大小，太大的话用一个ScaleDrawable转一下。但是，scaleDrawable需要调用setLevel方法才会draw，我这里偷懒直接设置为1了。\n\n\n> 3. Item本身是继承自RelativeLayout，想要使onDraw方法被调用需要在构造函数里设置\nsetWillNotDraw(false)\n这个boolean值默认是true，主要是顾及到性能的原因。\n\n\n\n### ref\n- [How Android caculates view size](https://www.liaohuqiu.net/posts/how-does-android-caculate-the-size-of-child-view/)\n","source":"_posts/2016-11-27-the-size-of-wrap-content.md","raw":"---\ntitle: wrap_content到底多大\ndate: 2016-11-27 16:46:44\ncategories: blog\ntags: [android]\n---\n\n转眼就十一月了，java的分析越来越少，虽然常常在业务上碰到不少坑。。。\n\n### 问题的由来\n这周碰到一个需要画时间轴样式的自定义View的需求，大概像这样(图片来自网络)：\n![](http://odzl05jxx.bkt.clouddn.com/timelineView.png)\n\n要求，左侧的圆形节点可以自定义Drawable，右侧的文字高度随文字数量变化自适应。\n\n想想也就是自定义ViewGroup的那一套老样子。抄起键盘就开始研(Copy)究(Paste)，写着写着发现不对劲，主要的问题包括:\n\n> 1. 在onMeasure里面拿到的height == 0 , 具体一点就是:\n整个ViewGroup包含多个Item，每个Item包括左侧的自定义View(CustomView)，高度是wrap_content，右边的TextView高度是wrap_content(自适应嘛)。可是debug时发现左侧的自定义View拿到的高度是0，简直日了哈士奇了。随后拿着关键词去Google搜索，还是没有什么收获。\n\n\n```java\n protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);// 这里是UNSPECIFIED, 常规概念里wrap_content对应的应该是AT_MOST\n        final int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        final int heightSize = MeasureSpec.getSize(heightMeasureSpec); // 居然等于0\n    }\n\n```\n回顾这个Item的实现，Item继承自RelativeLayout，左边的View是调用addView(view,RelativeLayout.Layoutparams)加进去的,params设置了一些rules，像是AlignParentLeft这种，记得给左边的View和右边的TextView都设置一个id就好。TextView也是这样addView进去的。后来查到了秋百万对于MeasureSpec的介绍，我想到RelativeLayout的onMeasure会调用两次，在第一次测量的时候，左边的View和右边的TextView都把高度设置为wrap_content了。要命的是这个Item本身添加到UI的方式也是类似的addView(view,RelativeLayout.Layoutparams)方式，这里的height也是wrap_content。即Item本身高度需要由其child决定，左边的child决定不了，只有右边的TextView才能决定。所以第一轮测量下来，左边的View的高度只能是0，右边的TextView高度倒是确定了。这时候Item本身的高度也就能确定了。在第二遍测量的时候，就能顺利拿到高度了。\n\n> 2. 左侧的每个节点上的drawable不画出来\n后来查了下，原因在于我对传进来的drawable检查了大小，太大的话用一个ScaleDrawable转一下。但是，scaleDrawable需要调用setLevel方法才会draw，我这里偷懒直接设置为1了。\n\n\n> 3. Item本身是继承自RelativeLayout，想要使onDraw方法被调用需要在构造函数里设置\nsetWillNotDraw(false)\n这个boolean值默认是true，主要是顾及到性能的原因。\n\n\n\n### ref\n- [How Android caculates view size](https://www.liaohuqiu.net/posts/how-does-android-caculate-the-size-of-child-view/)\n","slug":"2016-11-27-the-size-of-wrap-content","published":1,"updated":"2017-07-23T10:43:10.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdngn000nbovrklqt6f62","content":"<p>转眼就十一月了，java的分析越来越少，虽然常常在业务上碰到不少坑。。。</p>\n<h3 id=\"问题的由来\"><a href=\"#问题的由来\" class=\"headerlink\" title=\"问题的由来\"></a>问题的由来</h3><p>这周碰到一个需要画时间轴样式的自定义View的需求，大概像这样(图片来自网络)：<br><img src=\"http://odzl05jxx.bkt.clouddn.com/timelineView.png\" alt=\"\"></p>\n<p>要求，左侧的圆形节点可以自定义Drawable，右侧的文字高度随文字数量变化自适应。</p>\n<p>想想也就是自定义ViewGroup的那一套老样子。抄起键盘就开始研(Copy)究(Paste)，写着写着发现不对劲，主要的问题包括:</p>\n<blockquote>\n<ol>\n<li>在onMeasure里面拿到的height == 0 , 具体一点就是:<br>整个ViewGroup包含多个Item，每个Item包括左侧的自定义View(CustomView)，高度是wrap_content，右边的TextView高度是wrap_content(自适应嘛)。可是debug时发现左侧的自定义View拿到的高度是0，简直日了哈士奇了。随后拿着关键词去Google搜索，还是没有什么收获。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);<span class=\"comment\">// 这里是UNSPECIFIED, 常规概念里wrap_content对应的应该是AT_MOST</span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec); <span class=\"comment\">// 居然等于0</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>回顾这个Item的实现，Item继承自RelativeLayout，左边的View是调用addView(view,RelativeLayout.Layoutparams)加进去的,params设置了一些rules，像是AlignParentLeft这种，记得给左边的View和右边的TextView都设置一个id就好。TextView也是这样addView进去的。后来查到了秋百万对于MeasureSpec的介绍，我想到RelativeLayout的onMeasure会调用两次，在第一次测量的时候，左边的View和右边的TextView都把高度设置为wrap_content了。要命的是这个Item本身添加到UI的方式也是类似的addView(view,RelativeLayout.Layoutparams)方式，这里的height也是wrap_content。即Item本身高度需要由其child决定，左边的child决定不了，只有右边的TextView才能决定。所以第一轮测量下来，左边的View的高度只能是0，右边的TextView高度倒是确定了。这时候Item本身的高度也就能确定了。在第二遍测量的时候，就能顺利拿到高度了。</p>\n<blockquote>\n<ol>\n<li>左侧的每个节点上的drawable不画出来<br>后来查了下，原因在于我对传进来的drawable检查了大小，太大的话用一个ScaleDrawable转一下。但是，scaleDrawable需要调用setLevel方法才会draw，我这里偷懒直接设置为1了。</li>\n</ol>\n<ol>\n<li>Item本身是继承自RelativeLayout，想要使onDraw方法被调用需要在构造函数里设置<br>setWillNotDraw(false)<br>这个boolean值默认是true，主要是顾及到性能的原因。</li>\n</ol>\n</blockquote>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"https://www.liaohuqiu.net/posts/how-does-android-caculate-the-size-of-child-view/\">How Android caculates view size</a></li>\n</ul>\n","excerpt":"","more":"<p>转眼就十一月了，java的分析越来越少，虽然常常在业务上碰到不少坑。。。</p>\n<h3 id=\"问题的由来\"><a href=\"#问题的由来\" class=\"headerlink\" title=\"问题的由来\"></a>问题的由来</h3><p>这周碰到一个需要画时间轴样式的自定义View的需求，大概像这样(图片来自网络)：<br><img src=\"http://odzl05jxx.bkt.clouddn.com/timelineView.png\" alt=\"\"></p>\n<p>要求，左侧的圆形节点可以自定义Drawable，右侧的文字高度随文字数量变化自适应。</p>\n<p>想想也就是自定义ViewGroup的那一套老样子。抄起键盘就开始研(Copy)究(Paste)，写着写着发现不对劲，主要的问题包括:</p>\n<blockquote>\n<ol>\n<li>在onMeasure里面拿到的height == 0 , 具体一点就是:<br>整个ViewGroup包含多个Item，每个Item包括左侧的自定义View(CustomView)，高度是wrap_content，右边的TextView高度是wrap_content(自适应嘛)。可是debug时发现左侧的自定义View拿到的高度是0，简直日了哈士奇了。随后拿着关键词去Google搜索，还是没有什么收获。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);<span class=\"comment\">// 这里是UNSPECIFIED, 常规概念里wrap_content对应的应该是AT_MOST</span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec); <span class=\"comment\">// 居然等于0</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>回顾这个Item的实现，Item继承自RelativeLayout，左边的View是调用addView(view,RelativeLayout.Layoutparams)加进去的,params设置了一些rules，像是AlignParentLeft这种，记得给左边的View和右边的TextView都设置一个id就好。TextView也是这样addView进去的。后来查到了秋百万对于MeasureSpec的介绍，我想到RelativeLayout的onMeasure会调用两次，在第一次测量的时候，左边的View和右边的TextView都把高度设置为wrap_content了。要命的是这个Item本身添加到UI的方式也是类似的addView(view,RelativeLayout.Layoutparams)方式，这里的height也是wrap_content。即Item本身高度需要由其child决定，左边的child决定不了，只有右边的TextView才能决定。所以第一轮测量下来，左边的View的高度只能是0，右边的TextView高度倒是确定了。这时候Item本身的高度也就能确定了。在第二遍测量的时候，就能顺利拿到高度了。</p>\n<blockquote>\n<ol>\n<li>左侧的每个节点上的drawable不画出来<br>后来查了下，原因在于我对传进来的drawable检查了大小，太大的话用一个ScaleDrawable转一下。但是，scaleDrawable需要调用setLevel方法才会draw，我这里偷懒直接设置为1了。</li>\n</ol>\n<ol>\n<li>Item本身是继承自RelativeLayout，想要使onDraw方法被调用需要在构造函数里设置<br>setWillNotDraw(false)<br>这个boolean值默认是true，主要是顾及到性能的原因。</li>\n</ol>\n</blockquote>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"https://www.liaohuqiu.net/posts/how-does-android-caculate-the-size-of-child-view/\">How Android caculates view size</a></li>\n</ul>\n"},{"title":"adb常用命令手册","date":"2016-12-10T13:14:14.000Z","_content":"\n## ADB 常用命令手册\n\n平时在android studio中用command的时候还有点不熟悉，找到一篇博客，记录下来，作为日常参考。希望后期能够有时间把Google IO上添加的一些命令加上来\n<!--more-->\n\n获取序列号：\n > adb get-serialno\n\n查看连接计算机的设备：\n > adb devices\n\n重启机器：\n\n > adb reboot\n\n重启到bootloader，即刷机模式：\n\n> adb reboot bootloader\n\n重启到recovery，即恢复模式：\n\n> adb reboot recovery\n\n查看log：\n\n > adb logcat\n\n终止adb服务进程：\n\n> adb kill-server\n\n重启adb服务进程：\n\n> adb start-server\n\n获取机器MAC地址：\n\n> adb shell  cat /sys/class/net/wlan0/address\n\n获取CPU序列号：\n\n> adb shell cat /proc/cpuinfo\n\n安装APK：\n\n> adb install <apkfile> //比如：adb install baidu.apk\n\n保留数据和缓存文件，重新安装apk：\n\n> adb install -r <apkfile> //比如：adb install -r baidu.apk\n\n安装apk到sd卡：\n\n> adb install -s <apkfile> // 比如：adb install -s baidu.apk\n\n卸载APK：\n\n> adb uninstall <package> //比如：adb uninstall com.baidu.search\n\n卸载app但保留数据和缓存文件：\n\n> adb uninstall -k <package> //比如：adb uninstall -k com.baidu.search\n\n启动应用：\n\n> adb shell am start -n <package_name>/.<activity_class_name>\n\n查看设备cpu和内存占用情况：\n\n> adb shell top\n\n查看占用内存前6的app：\n\n> adb shell top -m 6\n\n刷新一次内存信息，然后返回：\n\n> adb shell top -n 1\n\n查询各进程内存使用情况：\n\n> adb shell procrank\n\n杀死一个进程：\n\n> adb shell kill [pid]\n\n查看进程列表：\n\n> adb shell ps\n\n查看指定进程状态：\n\n> adb shell ps -x [PID]\n\n查看后台services信息：\n\n> adb shell service list\n\n查看当前内存占用：\n\n> adb shell cat /proc/meminfo\n\n查看IO内存分区：\n\n> adb shell cat /proc/iomem\n\n将system分区重新挂载为可读写分区：\n\n> adb remount\n\n从本地复制文件到设备：\n\n> adb push <local> <remote>\n\n从设备复制文件到本地：\n\n> adb pull <remote>  <local>\n\n列出目录下的文件和文件夹，等同于dos中的dir命令：\n\n> adb shell ls\n\n进入文件夹，等同于dos中的cd 命令：\n\n> adb shell cd <folder>\n\n重命名文件：\n\n> adb shell rename path/oldfilename path/newfilename\n\n删除system/avi.apk：\n\n> adb shell rm /system/avi.apk\n\n删除文件夹及其下面所有文件：\n\n> adb shell rm -r <folder>\n\n移动文件：\n\n> adb shell mv path/file newpath/file\n\n设置文件权限：\n\n> adb shell chmod 777 /system/fonts/DroidSansFallback.ttf\n\n新建文件夹：\n\n> adb shell mkdir path/foldelname\n\n查看文件内容：\n\n> adb shell cat <file>\n\n查看wifi密码：\n\n>adb shell cat /data/misc/wifi/*.conf\n\n清除log缓存：\n\n> adb logcat -c\n\n查看bug报告：\n\n> adb bugreport\n\n获取设备名称：\n\n> adb shell cat /system/build.prop\n\n查看ADB帮助：\n\n> adb help\n\n跑monkey：\n\n> adb shell monkey -v -p your.package.name 500\n\n录制视频\n\n> adb shell screenrecord /sdcard/demo.mp4  生成的Demo.mp4文件在根目录下面，默认录制时长180s\n按下ctrl+c 停止录制\n注意，最好在开发者选项里面，把显示触摸操作打开，这样视频中能显示用户点击操作位置\n\n\n\n### Ref: \n\n- [张明云的博客](http://zmywly8866.github.io/2015/01/24/all-adb-command.html)\n","source":"_posts/2016-12-10-adb-command.md","raw":"---\ntitle: adb常用命令手册\ndate: 2016-12-10 21:14:14\ntags:\n - android\n - adb\n---\n\n## ADB 常用命令手册\n\n平时在android studio中用command的时候还有点不熟悉，找到一篇博客，记录下来，作为日常参考。希望后期能够有时间把Google IO上添加的一些命令加上来\n<!--more-->\n\n获取序列号：\n > adb get-serialno\n\n查看连接计算机的设备：\n > adb devices\n\n重启机器：\n\n > adb reboot\n\n重启到bootloader，即刷机模式：\n\n> adb reboot bootloader\n\n重启到recovery，即恢复模式：\n\n> adb reboot recovery\n\n查看log：\n\n > adb logcat\n\n终止adb服务进程：\n\n> adb kill-server\n\n重启adb服务进程：\n\n> adb start-server\n\n获取机器MAC地址：\n\n> adb shell  cat /sys/class/net/wlan0/address\n\n获取CPU序列号：\n\n> adb shell cat /proc/cpuinfo\n\n安装APK：\n\n> adb install <apkfile> //比如：adb install baidu.apk\n\n保留数据和缓存文件，重新安装apk：\n\n> adb install -r <apkfile> //比如：adb install -r baidu.apk\n\n安装apk到sd卡：\n\n> adb install -s <apkfile> // 比如：adb install -s baidu.apk\n\n卸载APK：\n\n> adb uninstall <package> //比如：adb uninstall com.baidu.search\n\n卸载app但保留数据和缓存文件：\n\n> adb uninstall -k <package> //比如：adb uninstall -k com.baidu.search\n\n启动应用：\n\n> adb shell am start -n <package_name>/.<activity_class_name>\n\n查看设备cpu和内存占用情况：\n\n> adb shell top\n\n查看占用内存前6的app：\n\n> adb shell top -m 6\n\n刷新一次内存信息，然后返回：\n\n> adb shell top -n 1\n\n查询各进程内存使用情况：\n\n> adb shell procrank\n\n杀死一个进程：\n\n> adb shell kill [pid]\n\n查看进程列表：\n\n> adb shell ps\n\n查看指定进程状态：\n\n> adb shell ps -x [PID]\n\n查看后台services信息：\n\n> adb shell service list\n\n查看当前内存占用：\n\n> adb shell cat /proc/meminfo\n\n查看IO内存分区：\n\n> adb shell cat /proc/iomem\n\n将system分区重新挂载为可读写分区：\n\n> adb remount\n\n从本地复制文件到设备：\n\n> adb push <local> <remote>\n\n从设备复制文件到本地：\n\n> adb pull <remote>  <local>\n\n列出目录下的文件和文件夹，等同于dos中的dir命令：\n\n> adb shell ls\n\n进入文件夹，等同于dos中的cd 命令：\n\n> adb shell cd <folder>\n\n重命名文件：\n\n> adb shell rename path/oldfilename path/newfilename\n\n删除system/avi.apk：\n\n> adb shell rm /system/avi.apk\n\n删除文件夹及其下面所有文件：\n\n> adb shell rm -r <folder>\n\n移动文件：\n\n> adb shell mv path/file newpath/file\n\n设置文件权限：\n\n> adb shell chmod 777 /system/fonts/DroidSansFallback.ttf\n\n新建文件夹：\n\n> adb shell mkdir path/foldelname\n\n查看文件内容：\n\n> adb shell cat <file>\n\n查看wifi密码：\n\n>adb shell cat /data/misc/wifi/*.conf\n\n清除log缓存：\n\n> adb logcat -c\n\n查看bug报告：\n\n> adb bugreport\n\n获取设备名称：\n\n> adb shell cat /system/build.prop\n\n查看ADB帮助：\n\n> adb help\n\n跑monkey：\n\n> adb shell monkey -v -p your.package.name 500\n\n录制视频\n\n> adb shell screenrecord /sdcard/demo.mp4  生成的Demo.mp4文件在根目录下面，默认录制时长180s\n按下ctrl+c 停止录制\n注意，最好在开发者选项里面，把显示触摸操作打开，这样视频中能显示用户点击操作位置\n\n\n\n### Ref: \n\n- [张明云的博客](http://zmywly8866.github.io/2015/01/24/all-adb-command.html)\n","slug":"2016-12-10-adb-command","published":1,"updated":"2017-06-18T02:32:52.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdngq000qbovrbor67fgb","content":"<h2 id=\"ADB-常用命令手册\"><a href=\"#ADB-常用命令手册\" class=\"headerlink\" title=\"ADB 常用命令手册\"></a>ADB 常用命令手册</h2><p>平时在android studio中用command的时候还有点不熟悉，找到一篇博客，记录下来，作为日常参考。希望后期能够有时间把Google IO上添加的一些命令加上来<br><a id=\"more\"></a></p>\n<p>获取序列号：</p>\n<blockquote>\n<p>adb get-serialno</p>\n</blockquote>\n<p>查看连接计算机的设备：</p>\n<blockquote>\n<p>adb devices</p>\n</blockquote>\n<p>重启机器：</p>\n<blockquote>\n<p>adb reboot</p>\n</blockquote>\n<p>重启到bootloader，即刷机模式：</p>\n<blockquote>\n<p>adb reboot bootloader</p>\n</blockquote>\n<p>重启到recovery，即恢复模式：</p>\n<blockquote>\n<p>adb reboot recovery</p>\n</blockquote>\n<p>查看log：</p>\n<blockquote>\n<p>adb logcat</p>\n</blockquote>\n<p>终止adb服务进程：</p>\n<blockquote>\n<p>adb kill-server</p>\n</blockquote>\n<p>重启adb服务进程：</p>\n<blockquote>\n<p>adb start-server</p>\n</blockquote>\n<p>获取机器MAC地址：</p>\n<blockquote>\n<p>adb shell  cat /sys/class/net/wlan0/address</p>\n</blockquote>\n<p>获取CPU序列号：</p>\n<blockquote>\n<p>adb shell cat /proc/cpuinfo</p>\n</blockquote>\n<p>安装APK：</p>\n<blockquote>\n<p>adb install <apkfile> //比如：adb install baidu.apk</p>\n</blockquote>\n<p>保留数据和缓存文件，重新安装apk：</p>\n<blockquote>\n<p>adb install -r <apkfile> //比如：adb install -r baidu.apk</p>\n</blockquote>\n<p>安装apk到sd卡：</p>\n<blockquote>\n<p>adb install -s <apkfile> // 比如：adb install -s baidu.apk</p>\n</blockquote>\n<p>卸载APK：</p>\n<blockquote>\n<p>adb uninstall <package> //比如：adb uninstall com.baidu.search</p>\n</blockquote>\n<p>卸载app但保留数据和缓存文件：</p>\n<blockquote>\n<p>adb uninstall -k <package> //比如：adb uninstall -k com.baidu.search</p>\n</blockquote>\n<p>启动应用：</p>\n<blockquote>\n<p>adb shell am start -n <package_name>/.<activity_class_name></p>\n</blockquote>\n<p>查看设备cpu和内存占用情况：</p>\n<blockquote>\n<p>adb shell top</p>\n</blockquote>\n<p>查看占用内存前6的app：</p>\n<blockquote>\n<p>adb shell top -m 6</p>\n</blockquote>\n<p>刷新一次内存信息，然后返回：</p>\n<blockquote>\n<p>adb shell top -n 1</p>\n</blockquote>\n<p>查询各进程内存使用情况：</p>\n<blockquote>\n<p>adb shell procrank</p>\n</blockquote>\n<p>杀死一个进程：</p>\n<blockquote>\n<p>adb shell kill [pid]</p>\n</blockquote>\n<p>查看进程列表：</p>\n<blockquote>\n<p>adb shell ps</p>\n</blockquote>\n<p>查看指定进程状态：</p>\n<blockquote>\n<p>adb shell ps -x [PID]</p>\n</blockquote>\n<p>查看后台services信息：</p>\n<blockquote>\n<p>adb shell service list</p>\n</blockquote>\n<p>查看当前内存占用：</p>\n<blockquote>\n<p>adb shell cat /proc/meminfo</p>\n</blockquote>\n<p>查看IO内存分区：</p>\n<blockquote>\n<p>adb shell cat /proc/iomem</p>\n</blockquote>\n<p>将system分区重新挂载为可读写分区：</p>\n<blockquote>\n<p>adb remount</p>\n</blockquote>\n<p>从本地复制文件到设备：</p>\n<blockquote>\n<p>adb push <local> <remote></p>\n</blockquote>\n<p>从设备复制文件到本地：</p>\n<blockquote>\n<p>adb pull <remote>  <local></p>\n</blockquote>\n<p>列出目录下的文件和文件夹，等同于dos中的dir命令：</p>\n<blockquote>\n<p>adb shell ls</p>\n</blockquote>\n<p>进入文件夹，等同于dos中的cd 命令：</p>\n<blockquote>\n<p>adb shell cd <folder></p>\n</blockquote>\n<p>重命名文件：</p>\n<blockquote>\n<p>adb shell rename path/oldfilename path/newfilename</p>\n</blockquote>\n<p>删除system/avi.apk：</p>\n<blockquote>\n<p>adb shell rm /system/avi.apk</p>\n</blockquote>\n<p>删除文件夹及其下面所有文件：</p>\n<blockquote>\n<p>adb shell rm -r <folder></p>\n</blockquote>\n<p>移动文件：</p>\n<blockquote>\n<p>adb shell mv path/file newpath/file</p>\n</blockquote>\n<p>设置文件权限：</p>\n<blockquote>\n<p>adb shell chmod 777 /system/fonts/DroidSansFallback.ttf</p>\n</blockquote>\n<p>新建文件夹：</p>\n<blockquote>\n<p>adb shell mkdir path/foldelname</p>\n</blockquote>\n<p>查看文件内容：</p>\n<blockquote>\n<p>adb shell cat <file></p>\n</blockquote>\n<p>查看wifi密码：</p>\n<blockquote>\n<p>adb shell cat /data/misc/wifi/*.conf</p>\n</blockquote>\n<p>清除log缓存：</p>\n<blockquote>\n<p>adb logcat -c</p>\n</blockquote>\n<p>查看bug报告：</p>\n<blockquote>\n<p>adb bugreport</p>\n</blockquote>\n<p>获取设备名称：</p>\n<blockquote>\n<p>adb shell cat /system/build.prop</p>\n</blockquote>\n<p>查看ADB帮助：</p>\n<blockquote>\n<p>adb help</p>\n</blockquote>\n<p>跑monkey：</p>\n<blockquote>\n<p>adb shell monkey -v -p your.package.name 500</p>\n</blockquote>\n<p>录制视频</p>\n<blockquote>\n<p>adb shell screenrecord /sdcard/demo.mp4  生成的Demo.mp4文件在根目录下面，默认录制时长180s<br>按下ctrl+c 停止录制<br>注意，最好在开发者选项里面，把显示触摸操作打开，这样视频中能显示用户点击操作位置</p>\n</blockquote>\n<h3 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h3><ul>\n<li><a href=\"http://zmywly8866.github.io/2015/01/24/all-adb-command.html\">张明云的博客</a></li>\n</ul>\n","excerpt":"<h2 id=\"ADB-常用命令手册\"><a href=\"#ADB-常用命令手册\" class=\"headerlink\" title=\"ADB 常用命令手册\"></a>ADB 常用命令手册</h2><p>平时在android studio中用command的时候还有点不熟悉，找到一篇博客，记录下来，作为日常参考。希望后期能够有时间把Google IO上添加的一些命令加上来<br>","more":"</p>\n<p>获取序列号：</p>\n<blockquote>\n<p>adb get-serialno</p>\n</blockquote>\n<p>查看连接计算机的设备：</p>\n<blockquote>\n<p>adb devices</p>\n</blockquote>\n<p>重启机器：</p>\n<blockquote>\n<p>adb reboot</p>\n</blockquote>\n<p>重启到bootloader，即刷机模式：</p>\n<blockquote>\n<p>adb reboot bootloader</p>\n</blockquote>\n<p>重启到recovery，即恢复模式：</p>\n<blockquote>\n<p>adb reboot recovery</p>\n</blockquote>\n<p>查看log：</p>\n<blockquote>\n<p>adb logcat</p>\n</blockquote>\n<p>终止adb服务进程：</p>\n<blockquote>\n<p>adb kill-server</p>\n</blockquote>\n<p>重启adb服务进程：</p>\n<blockquote>\n<p>adb start-server</p>\n</blockquote>\n<p>获取机器MAC地址：</p>\n<blockquote>\n<p>adb shell  cat /sys/class/net/wlan0/address</p>\n</blockquote>\n<p>获取CPU序列号：</p>\n<blockquote>\n<p>adb shell cat /proc/cpuinfo</p>\n</blockquote>\n<p>安装APK：</p>\n<blockquote>\n<p>adb install <apkfile> //比如：adb install baidu.apk</p>\n</blockquote>\n<p>保留数据和缓存文件，重新安装apk：</p>\n<blockquote>\n<p>adb install -r <apkfile> //比如：adb install -r baidu.apk</p>\n</blockquote>\n<p>安装apk到sd卡：</p>\n<blockquote>\n<p>adb install -s <apkfile> // 比如：adb install -s baidu.apk</p>\n</blockquote>\n<p>卸载APK：</p>\n<blockquote>\n<p>adb uninstall <package> //比如：adb uninstall com.baidu.search</p>\n</blockquote>\n<p>卸载app但保留数据和缓存文件：</p>\n<blockquote>\n<p>adb uninstall -k <package> //比如：adb uninstall -k com.baidu.search</p>\n</blockquote>\n<p>启动应用：</p>\n<blockquote>\n<p>adb shell am start -n <package_name>/.<activity_class_name></p>\n</blockquote>\n<p>查看设备cpu和内存占用情况：</p>\n<blockquote>\n<p>adb shell top</p>\n</blockquote>\n<p>查看占用内存前6的app：</p>\n<blockquote>\n<p>adb shell top -m 6</p>\n</blockquote>\n<p>刷新一次内存信息，然后返回：</p>\n<blockquote>\n<p>adb shell top -n 1</p>\n</blockquote>\n<p>查询各进程内存使用情况：</p>\n<blockquote>\n<p>adb shell procrank</p>\n</blockquote>\n<p>杀死一个进程：</p>\n<blockquote>\n<p>adb shell kill [pid]</p>\n</blockquote>\n<p>查看进程列表：</p>\n<blockquote>\n<p>adb shell ps</p>\n</blockquote>\n<p>查看指定进程状态：</p>\n<blockquote>\n<p>adb shell ps -x [PID]</p>\n</blockquote>\n<p>查看后台services信息：</p>\n<blockquote>\n<p>adb shell service list</p>\n</blockquote>\n<p>查看当前内存占用：</p>\n<blockquote>\n<p>adb shell cat /proc/meminfo</p>\n</blockquote>\n<p>查看IO内存分区：</p>\n<blockquote>\n<p>adb shell cat /proc/iomem</p>\n</blockquote>\n<p>将system分区重新挂载为可读写分区：</p>\n<blockquote>\n<p>adb remount</p>\n</blockquote>\n<p>从本地复制文件到设备：</p>\n<blockquote>\n<p>adb push <local> <remote></p>\n</blockquote>\n<p>从设备复制文件到本地：</p>\n<blockquote>\n<p>adb pull <remote>  <local></p>\n</blockquote>\n<p>列出目录下的文件和文件夹，等同于dos中的dir命令：</p>\n<blockquote>\n<p>adb shell ls</p>\n</blockquote>\n<p>进入文件夹，等同于dos中的cd 命令：</p>\n<blockquote>\n<p>adb shell cd <folder></p>\n</blockquote>\n<p>重命名文件：</p>\n<blockquote>\n<p>adb shell rename path/oldfilename path/newfilename</p>\n</blockquote>\n<p>删除system/avi.apk：</p>\n<blockquote>\n<p>adb shell rm /system/avi.apk</p>\n</blockquote>\n<p>删除文件夹及其下面所有文件：</p>\n<blockquote>\n<p>adb shell rm -r <folder></p>\n</blockquote>\n<p>移动文件：</p>\n<blockquote>\n<p>adb shell mv path/file newpath/file</p>\n</blockquote>\n<p>设置文件权限：</p>\n<blockquote>\n<p>adb shell chmod 777 /system/fonts/DroidSansFallback.ttf</p>\n</blockquote>\n<p>新建文件夹：</p>\n<blockquote>\n<p>adb shell mkdir path/foldelname</p>\n</blockquote>\n<p>查看文件内容：</p>\n<blockquote>\n<p>adb shell cat <file></p>\n</blockquote>\n<p>查看wifi密码：</p>\n<blockquote>\n<p>adb shell cat /data/misc/wifi/*.conf</p>\n</blockquote>\n<p>清除log缓存：</p>\n<blockquote>\n<p>adb logcat -c</p>\n</blockquote>\n<p>查看bug报告：</p>\n<blockquote>\n<p>adb bugreport</p>\n</blockquote>\n<p>获取设备名称：</p>\n<blockquote>\n<p>adb shell cat /system/build.prop</p>\n</blockquote>\n<p>查看ADB帮助：</p>\n<blockquote>\n<p>adb help</p>\n</blockquote>\n<p>跑monkey：</p>\n<blockquote>\n<p>adb shell monkey -v -p your.package.name 500</p>\n</blockquote>\n<p>录制视频</p>\n<blockquote>\n<p>adb shell screenrecord /sdcard/demo.mp4  生成的Demo.mp4文件在根目录下面，默认录制时长180s<br>按下ctrl+c 停止录制<br>注意，最好在开发者选项里面，把显示触摸操作打开，这样视频中能显示用户点击操作位置</p>\n</blockquote>\n<h3 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h3><ul>\n<li><a href=\"http://zmywly8866.github.io/2015/01/24/all-adb-command.html\">张明云的博客</a></li>\n</ul>"},{"title":"Python 3 学习记录","date":"2016-12-24T14:06:37.000Z","_content":"\n\n### 人生苦短，Python是岸\n\n![implementing dumb features](http://odzl05jxx.bkt.clouddn.com/46ee54dd915d71da90e435703d4568fb.jpg?imageView2/2/w/600)\n\n<!-- more -->\n### 1. Python的一些缺点\n引用[廖雪峰的官方网站](http://www.liaoxuefeng.com/)上的话，Python一个是慢，一个是代码不能加密\n\n> 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。\n\n> 第二个缺点就是代码不能加密\n\n> GIL导致的多线程低效率\n\n以下内容出自[静觅 » Python爬虫进阶五之多线程的用法](http://cuiqingcai.com/3325.html)\n```text\n1、GIL是什么？\n\nGIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。\n\n2、每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）\n\n在Python多线程下，每个线程的执行方式：\n\n获取GIL\n执行代码直到sleep或者是python虚拟机将其挂起。\n释放GIL\n可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。\n\n在Python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是Python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。\n\n而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。\n```\n\n### 2. 安装package各种can't resolve XXX\n[no module named urllib2](http://stackoverflow.com/questions/2792650/python3-error-import-error-no-module-name-urllib2)\n\n> The urllib2 module has been split across several modules in Python 3 named urllib.request and urllib.error. The 2to3 tool will automatically adapt imports when converting your sources to Python 3.\n\nThis is what look like on py 2.7\n\n```python\nimport urllib2\nreq = urllib2.Request(url,headers=header)\nhtml = urllib2.urlopen(req)\nhtml_data = html.read\nhtml_path = etree.HTML(html_data)\n```   \n\non Python 3.X\n```python\nfrom urllib.request import urlopen\nfrom urllib.request import Request\n\nreq = Request(img_url, headers=headers)\nurlhtml = urlopen(req)\n```\n\n\n### 3. pip install XXXX\n安装package的方式 pip install xxxx....\n** if not working**\n![](http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/500)\n\n\n### 4. List、tuple、dict、set以及基本的数据类型\n\n```python\n list   mylist = ['Tom','Jerry','Henry']\n        mylist[0] = 'Tom'\n\n tuple  mytuple = ('rock','pop','jazz')\n         mytuple[0] = 'rock'\n\n tuple在初始化时就已经确定，不能修改\n\n dict: d={'name':'tom','job':'doctor','age',99}\n        d['name'] = 'tom'\n\n set:  s = set([1,2,3]) # 需要传入一个list作为参数\n    >> s\n    {1,2,3}\n    set无序，不可有重复元素\n    set和dict的区别在于前者没有存储value，两者内部都不能有重复元素(key)\n```\ntuple用的比较多，例如有多个返回值的函数，Python其实返回了一个Tuple。\n\n### 类名应该写成驼峰样式，变量名应该小写\nclass name should be cammelCase, Arguments,variable name should be lowercase\n\n循环\n```python\n for i in range(2, 5):\n        print(i)\n>>> result: 2 3 4 左闭右开\n\n条件判断\n\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n### 函数参数相关，函数组合（一共五种）\n位置参数，默认参数，可变参数，关键字参数，命名关键字参数\n\n定义一个函数可以带上默认值，默认值是一个固定的对象，上次操作的值会保留到下一次调用\n```python\ndef sell(name,price,amount=1):\n    print(price*amount)\n\nsell('product',26)\nsell('product',26,2)\n\n>>> 26    \n>>> 52    \n```\n\n默认参数函数\n```python\ndef power(x, n=2): #这里的n=2就是默认参数，注意，默认参数应该是不可变对象,例如str、None这种\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n\npower(5) >> 25\npower(5,2) >>>25    \n```\n\n可变参数函数# 定义的时候在参数前面加一个*号就可以了，内部会默认组装成一个tuple\n```python\ndef calc(*numbers): #函数内部接收到的是一个tuple\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\ncalc(1,2)\n\ncalc(2,3,5)    \n\nnums = [1,2,3]\ncal(*nums)#把tuple内的元素作为参数传进去\n```\n关键字参数\n```python\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n\n>>> person('Michael', 30)\nname: Michael age: 30 other: {}\n\n内部自动将关键字参数转换成一个dict    \n```\n命名关键字函数\n```python\ndef shoppping(name,time,*,price,count)# price可以有默认值\n    print(price*count)\n\n>> shopping(john,0325,price=39,count=5)\n>> 195\n```\n\n\n### 5. 爬虫相关\nChrome自带开发者工具，可以查看每一个request的header，cookies等信息。模拟浏览器行为比较有效。ctrl+shift+R神器\n### 5.1 Request, Urllib2\n\n### 5.2 UnicodeEncodeError: 'ascii' codec can't encode characters in position\n\n\n```\n# how to invoke this error\nb = \"this is english within ascii range\".encode('ascii')  # totally fine\n\ns = \"你好\".encode('ascii')\n# this will raise an error ,UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)>\n\n\n\n print((b\"totally cool binary representation of english words within ascii range\").decode('ascii'))\n print((b\"totally cool binary cause utf-8 include ascii\").decode('utf-8'))\n # 完全正常\n\n\n # eg.\nstring = \"你好啊\"\nbinary_string = b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a'\nbinary_string_2_string = bstring.decode('utf-8')\n\n\ncode :\nprint(string)  \nprint(string.encode('utf-8'))\nprint(bstring2string)\nprint(bstring2string)\n\nprint(which_instance_is_this(string))\nprint(which_instance_is_this(bstring))\nprint(which_instance_is_this(bstring2string))\n\n\noutputs:\n你好啊\nb'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a'\n你好啊\n你好啊\n\nis str\nis byte\nis str\n\n**Since Python 3.0, the language features a str type that contain Unicode characters, meaning any string created using \"unicode rocks!\", 'unicode rocks!', or the triple-quoted string syntax is stored as Unicode.**\n\n冒号里面的都是str，都是unicode的集合。生成unicode可以用chr(12345) ，该方法接受一个integer返回一个长度为1的Unicode String。\n反过来可以用ord(你) 生成“你”这个字在unicode中的编号\n\n\nprint(chr(20320))   >>>> 你\nprint(ord('你'))    >>>> 20320 #这里只能用长度为1的string\n\nbinary to string is called decode ,string to binary is encode\nbytes.decode('utf-8')   <----> str.encode('utf-8')\n\n回到UnicodeEncodeError: 'ascii' codec can't encode characters in position\nstr.encode('ascii')，unicode字符超出了ascii的范围，无法decode成binary\n```\n\n### 6.一些细节\n文件读写的各种模式以及解码问题\n```python\n with open(filepath, 'r', encoding=\"utf8\") as f:\n    f.write('最好用utf8读和写文件')\n    #已经自动做好close文件的工作\n```\n\n how to upgrade installed packages?\n\n> pip install --upgrade setuptools\n\n\n\n<!-- install mongoDb(better performance than sql) -->\n<!-- install pip -->\n\n\n\ngrep log in command console\nbasic grammars\nnetwork, disk ,database, io , dic, list ,etc\nclass object orientated  \n\n\n\n\n### Reference\n- [廖雪峰的官方网站](http://www.liaoxuefeng.com/)\n- [use python and mongoDb as backend](https://zhuanlan.zhihu.com/p/20488077?columnSlug=kotandroid)\n- [静觅](http://cuiqingcai.com/category/technique/python)\n- [unicodeencodeerror-ascii-codec-cant-encode-character](https://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20?rq=1)\n- [Droidcon NYC 2016 - Decoding the Secrets of Binary Data](https://www.youtube.com/watch?v=T_p22jMZSrk)\n- [Jake Wharton and Jesse Wilson - Death, Taxes, and HTTP](https://www.youtube.com/watch?v=6uroXz5l7Gk)\n- [Droidcon Montreal Jake Wharton - A Few Ok Libraries](https://www.youtube.com/watch?v=WvyScM_S88c)\n- [Jesse Wilson - Coordinating Space and Time](https://www.youtube.com/watch?v=yS0Nc-L1Uuk)\n","source":"_posts/2016-12-24-Python-UnicodeEncodeError.md","raw":"---\ntitle: Python 3 学习记录\ndate: 2016-12-24 22:06:37\ncategories: blog\ntags: [python]\n---\n\n\n### 人生苦短，Python是岸\n\n![implementing dumb features](http://odzl05jxx.bkt.clouddn.com/46ee54dd915d71da90e435703d4568fb.jpg?imageView2/2/w/600)\n\n<!-- more -->\n### 1. Python的一些缺点\n引用[廖雪峰的官方网站](http://www.liaoxuefeng.com/)上的话，Python一个是慢，一个是代码不能加密\n\n> 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。\n\n> 第二个缺点就是代码不能加密\n\n> GIL导致的多线程低效率\n\n以下内容出自[静觅 » Python爬虫进阶五之多线程的用法](http://cuiqingcai.com/3325.html)\n```text\n1、GIL是什么？\n\nGIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。\n\n2、每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）\n\n在Python多线程下，每个线程的执行方式：\n\n获取GIL\n执行代码直到sleep或者是python虚拟机将其挂起。\n释放GIL\n可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。\n\n在Python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是Python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。\n\n而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。\n```\n\n### 2. 安装package各种can't resolve XXX\n[no module named urllib2](http://stackoverflow.com/questions/2792650/python3-error-import-error-no-module-name-urllib2)\n\n> The urllib2 module has been split across several modules in Python 3 named urllib.request and urllib.error. The 2to3 tool will automatically adapt imports when converting your sources to Python 3.\n\nThis is what look like on py 2.7\n\n```python\nimport urllib2\nreq = urllib2.Request(url,headers=header)\nhtml = urllib2.urlopen(req)\nhtml_data = html.read\nhtml_path = etree.HTML(html_data)\n```   \n\non Python 3.X\n```python\nfrom urllib.request import urlopen\nfrom urllib.request import Request\n\nreq = Request(img_url, headers=headers)\nurlhtml = urlopen(req)\n```\n\n\n### 3. pip install XXXX\n安装package的方式 pip install xxxx....\n** if not working**\n![](http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/500)\n\n\n### 4. List、tuple、dict、set以及基本的数据类型\n\n```python\n list   mylist = ['Tom','Jerry','Henry']\n        mylist[0] = 'Tom'\n\n tuple  mytuple = ('rock','pop','jazz')\n         mytuple[0] = 'rock'\n\n tuple在初始化时就已经确定，不能修改\n\n dict: d={'name':'tom','job':'doctor','age',99}\n        d['name'] = 'tom'\n\n set:  s = set([1,2,3]) # 需要传入一个list作为参数\n    >> s\n    {1,2,3}\n    set无序，不可有重复元素\n    set和dict的区别在于前者没有存储value，两者内部都不能有重复元素(key)\n```\ntuple用的比较多，例如有多个返回值的函数，Python其实返回了一个Tuple。\n\n### 类名应该写成驼峰样式，变量名应该小写\nclass name should be cammelCase, Arguments,variable name should be lowercase\n\n循环\n```python\n for i in range(2, 5):\n        print(i)\n>>> result: 2 3 4 左闭右开\n\n条件判断\n\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n### 函数参数相关，函数组合（一共五种）\n位置参数，默认参数，可变参数，关键字参数，命名关键字参数\n\n定义一个函数可以带上默认值，默认值是一个固定的对象，上次操作的值会保留到下一次调用\n```python\ndef sell(name,price,amount=1):\n    print(price*amount)\n\nsell('product',26)\nsell('product',26,2)\n\n>>> 26    \n>>> 52    \n```\n\n默认参数函数\n```python\ndef power(x, n=2): #这里的n=2就是默认参数，注意，默认参数应该是不可变对象,例如str、None这种\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n\npower(5) >> 25\npower(5,2) >>>25    \n```\n\n可变参数函数# 定义的时候在参数前面加一个*号就可以了，内部会默认组装成一个tuple\n```python\ndef calc(*numbers): #函数内部接收到的是一个tuple\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\ncalc(1,2)\n\ncalc(2,3,5)    \n\nnums = [1,2,3]\ncal(*nums)#把tuple内的元素作为参数传进去\n```\n关键字参数\n```python\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n\n>>> person('Michael', 30)\nname: Michael age: 30 other: {}\n\n内部自动将关键字参数转换成一个dict    \n```\n命名关键字函数\n```python\ndef shoppping(name,time,*,price,count)# price可以有默认值\n    print(price*count)\n\n>> shopping(john,0325,price=39,count=5)\n>> 195\n```\n\n\n### 5. 爬虫相关\nChrome自带开发者工具，可以查看每一个request的header，cookies等信息。模拟浏览器行为比较有效。ctrl+shift+R神器\n### 5.1 Request, Urllib2\n\n### 5.2 UnicodeEncodeError: 'ascii' codec can't encode characters in position\n\n\n```\n# how to invoke this error\nb = \"this is english within ascii range\".encode('ascii')  # totally fine\n\ns = \"你好\".encode('ascii')\n# this will raise an error ,UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)>\n\n\n\n print((b\"totally cool binary representation of english words within ascii range\").decode('ascii'))\n print((b\"totally cool binary cause utf-8 include ascii\").decode('utf-8'))\n # 完全正常\n\n\n # eg.\nstring = \"你好啊\"\nbinary_string = b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a'\nbinary_string_2_string = bstring.decode('utf-8')\n\n\ncode :\nprint(string)  \nprint(string.encode('utf-8'))\nprint(bstring2string)\nprint(bstring2string)\n\nprint(which_instance_is_this(string))\nprint(which_instance_is_this(bstring))\nprint(which_instance_is_this(bstring2string))\n\n\noutputs:\n你好啊\nb'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a'\n你好啊\n你好啊\n\nis str\nis byte\nis str\n\n**Since Python 3.0, the language features a str type that contain Unicode characters, meaning any string created using \"unicode rocks!\", 'unicode rocks!', or the triple-quoted string syntax is stored as Unicode.**\n\n冒号里面的都是str，都是unicode的集合。生成unicode可以用chr(12345) ，该方法接受一个integer返回一个长度为1的Unicode String。\n反过来可以用ord(你) 生成“你”这个字在unicode中的编号\n\n\nprint(chr(20320))   >>>> 你\nprint(ord('你'))    >>>> 20320 #这里只能用长度为1的string\n\nbinary to string is called decode ,string to binary is encode\nbytes.decode('utf-8')   <----> str.encode('utf-8')\n\n回到UnicodeEncodeError: 'ascii' codec can't encode characters in position\nstr.encode('ascii')，unicode字符超出了ascii的范围，无法decode成binary\n```\n\n### 6.一些细节\n文件读写的各种模式以及解码问题\n```python\n with open(filepath, 'r', encoding=\"utf8\") as f:\n    f.write('最好用utf8读和写文件')\n    #已经自动做好close文件的工作\n```\n\n how to upgrade installed packages?\n\n> pip install --upgrade setuptools\n\n\n\n<!-- install mongoDb(better performance than sql) -->\n<!-- install pip -->\n\n\n\ngrep log in command console\nbasic grammars\nnetwork, disk ,database, io , dic, list ,etc\nclass object orientated  \n\n\n\n\n### Reference\n- [廖雪峰的官方网站](http://www.liaoxuefeng.com/)\n- [use python and mongoDb as backend](https://zhuanlan.zhihu.com/p/20488077?columnSlug=kotandroid)\n- [静觅](http://cuiqingcai.com/category/technique/python)\n- [unicodeencodeerror-ascii-codec-cant-encode-character](https://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20?rq=1)\n- [Droidcon NYC 2016 - Decoding the Secrets of Binary Data](https://www.youtube.com/watch?v=T_p22jMZSrk)\n- [Jake Wharton and Jesse Wilson - Death, Taxes, and HTTP](https://www.youtube.com/watch?v=6uroXz5l7Gk)\n- [Droidcon Montreal Jake Wharton - A Few Ok Libraries](https://www.youtube.com/watch?v=WvyScM_S88c)\n- [Jesse Wilson - Coordinating Space and Time](https://www.youtube.com/watch?v=yS0Nc-L1Uuk)\n","slug":"2016-12-24-Python-UnicodeEncodeError","published":1,"updated":"2017-07-23T10:43:10.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdngv000ubovrg72z1acl","content":"<h3 id=\"人生苦短，Python是岸\"><a href=\"#人生苦短，Python是岸\" class=\"headerlink\" title=\"人生苦短，Python是岸\"></a>人生苦短，Python是岸</h3><p><img src=\"http://odzl05jxx.bkt.clouddn.com/46ee54dd915d71da90e435703d4568fb.jpg?imageView2/2/w/600\" alt=\"implementing dumb features\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-Python的一些缺点\"><a href=\"#1-Python的一些缺点\" class=\"headerlink\" title=\"1. Python的一些缺点\"></a>1. Python的一些缺点</h3><p>引用<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的官方网站</a>上的话，Python一个是慢，一个是代码不能加密</p>\n<blockquote>\n<p>第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</p>\n<p>第二个缺点就是代码不能加密</p>\n<p>GIL导致的多线程低效率</p>\n</blockquote>\n<p>以下内容出自<a href=\"http://cuiqingcai.com/3325.html\">静觅 » Python爬虫进阶五之多线程的用法</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">1、GIL是什么？</div><div class=\"line\"></div><div class=\"line\">GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。</div><div class=\"line\"></div><div class=\"line\">2、每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）</div><div class=\"line\"></div><div class=\"line\">在Python多线程下，每个线程的执行方式：</div><div class=\"line\"></div><div class=\"line\">获取GIL</div><div class=\"line\">执行代码直到sleep或者是python虚拟机将其挂起。</div><div class=\"line\">释放GIL</div><div class=\"line\">可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。</div><div class=\"line\"></div><div class=\"line\">在Python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是Python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。</div><div class=\"line\"></div><div class=\"line\">而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-安装package各种can’t-resolve-XXX\"><a href=\"#2-安装package各种can’t-resolve-XXX\" class=\"headerlink\" title=\"2. 安装package各种can’t resolve XXX\"></a>2. 安装package各种can’t resolve XXX</h3><p><a href=\"http://stackoverflow.com/questions/2792650/python3-error-import-error-no-module-name-urllib2\">no module named urllib2</a></p>\n<blockquote>\n<p>The urllib2 module has been split across several modules in Python 3 named urllib.request and urllib.error. The 2to3 tool will automatically adapt imports when converting your sources to Python 3.</p>\n</blockquote>\n<p>This is what look like on py 2.7</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> urllib2</div><div class=\"line\">req = urllib2.Request(url,headers=header)</div><div class=\"line\">html = urllib2.urlopen(req)</div><div class=\"line\">html_data = html.read</div><div class=\"line\">html_path = etree.HTML(html_data)</div><div class=\"line\">```   </div><div class=\"line\"></div><div class=\"line\">on Python <span class=\"number\">3.</span>X</div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> urllib.request <span class=\"keyword\">import</span> urlopen</div><div class=\"line\"><span class=\"keyword\">from</span> urllib.request <span class=\"keyword\">import</span> Request</div><div class=\"line\"></div><div class=\"line\">req = Request(img_url, headers=headers)</div><div class=\"line\">urlhtml = urlopen(req)</div></pre></td></tr></table></figure>\n<h3 id=\"3-pip-install-XXXX\"><a href=\"#3-pip-install-XXXX\" class=\"headerlink\" title=\"3. pip install XXXX\"></a>3. pip install XXXX</h3><p>安装package的方式 pip install xxxx….<br><strong> if not working</strong><br><img src=\"http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/500\" alt=\"\"></p>\n<h3 id=\"4-List、tuple、dict、set以及基本的数据类型\"><a href=\"#4-List、tuple、dict、set以及基本的数据类型\" class=\"headerlink\" title=\"4. List、tuple、dict、set以及基本的数据类型\"></a>4. List、tuple、dict、set以及基本的数据类型</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">list   mylist = [<span class=\"string\">'Tom'</span>,<span class=\"string\">'Jerry'</span>,<span class=\"string\">'Henry'</span>]</div><div class=\"line\">       mylist[<span class=\"number\">0</span>] = <span class=\"string\">'Tom'</span></div><div class=\"line\"></div><div class=\"line\">tuple  mytuple = (<span class=\"string\">'rock'</span>,<span class=\"string\">'pop'</span>,<span class=\"string\">'jazz'</span>)</div><div class=\"line\">        mytuple[<span class=\"number\">0</span>] = <span class=\"string\">'rock'</span></div><div class=\"line\"></div><div class=\"line\">tuple在初始化时就已经确定，不能修改</div><div class=\"line\"></div><div class=\"line\">dict: d=&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'tom'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'doctor'</span>,<span class=\"string\">'age'</span>,<span class=\"number\">99</span>&#125;</div><div class=\"line\">       d[<span class=\"string\">'name'</span>] = <span class=\"string\">'tom'</span></div><div class=\"line\"></div><div class=\"line\">set:  s = set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\"># 需要传入一个list作为参数</span></div><div class=\"line\">   &gt;&gt; s</div><div class=\"line\">   &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</div><div class=\"line\">   set无序，不可有重复元素</div><div class=\"line\">   set和dict的区别在于前者没有存储value，两者内部都不能有重复元素(key)</div></pre></td></tr></table></figure>\n<p>tuple用的比较多，例如有多个返回值的函数，Python其实返回了一个Tuple。</p>\n<h3 id=\"类名应该写成驼峰样式，变量名应该小写\"><a href=\"#类名应该写成驼峰样式，变量名应该小写\" class=\"headerlink\" title=\"类名应该写成驼峰样式，变量名应该小写\"></a>类名应该写成驼峰样式，变量名应该小写</h3><p>class name should be cammelCase, Arguments,variable name should be lowercase</p>\n<p>循环<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, <span class=\"number\">5</span>):</div><div class=\"line\">        print(i)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>result: <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> 左闭右开</div><div class=\"line\"></div><div class=\"line\">条件判断</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        L = []</div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<h3 id=\"函数参数相关，函数组合（一共五种）\"><a href=\"#函数参数相关，函数组合（一共五种）\" class=\"headerlink\" title=\"函数参数相关，函数组合（一共五种）\"></a>函数参数相关，函数组合（一共五种）</h3><p>位置参数，默认参数，可变参数，关键字参数，命名关键字参数</p>\n<p>定义一个函数可以带上默认值，默认值是一个固定的对象，上次操作的值会保留到下一次调用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sell</span><span class=\"params\">(name,price,amount=<span class=\"number\">1</span>)</span>:</span></div><div class=\"line\">    print(price*amount)</div><div class=\"line\"></div><div class=\"line\">sell(<span class=\"string\">'product'</span>,<span class=\"number\">26</span>)</div><div class=\"line\">sell(<span class=\"string\">'product'</span>,<span class=\"number\">26</span>,<span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">26</span>    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">52</span></div></pre></td></tr></table></figure></p>\n<p>默认参数函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(x, n=<span class=\"number\">2</span>)</span>:</span> <span class=\"comment\">#这里的n=2就是默认参数，注意，默认参数应该是不可变对象,例如str、None这种</span></div><div class=\"line\">    s = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        n = n - <span class=\"number\">1</span></div><div class=\"line\">        s = s * x</div><div class=\"line\">    <span class=\"keyword\">return</span> s</div><div class=\"line\"></div><div class=\"line\">power(<span class=\"number\">5</span>) &gt;&gt; <span class=\"number\">25</span></div><div class=\"line\">power(<span class=\"number\">5</span>,<span class=\"number\">2</span>) &gt;&gt;&gt;<span class=\"number\">25</span></div></pre></td></tr></table></figure></p>\n<p>可变参数函数# 定义的时候在参数前面加一个*号就可以了，内部会默认组装成一个tuple<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span> <span class=\"comment\">#函数内部接收到的是一个tuple</span></div><div class=\"line\">    sum = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> numbers:</div><div class=\"line\">        sum = sum + n * n</div><div class=\"line\">    <span class=\"keyword\">return</span> sum</div><div class=\"line\"></div><div class=\"line\">calc(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\">calc(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>)    </div><div class=\"line\"></div><div class=\"line\">nums = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</div><div class=\"line\">cal(*nums)<span class=\"comment\">#把tuple内的元素作为参数传进去</span></div></pre></td></tr></table></figure></p>\n<p>关键字参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Michael'</span>, <span class=\"number\">30</span>)</div><div class=\"line\">name: Michael age: <span class=\"number\">30</span> other: &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">内部自动将关键字参数转换成一个dict</div></pre></td></tr></table></figure></p>\n<p>命名关键字函数<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">def shoppping(name,time,*,price,count)# price可以有默认值</div><div class=\"line\">    print(price*count)</div><div class=\"line\"></div><div class=\"line\">&gt;&gt; shopping(john,0325,price=39,count=5)</div><div class=\"line\">&gt;&gt; 195</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-爬虫相关\"><a href=\"#5-爬虫相关\" class=\"headerlink\" title=\"5. 爬虫相关\"></a>5. 爬虫相关</h3><p>Chrome自带开发者工具，可以查看每一个request的header，cookies等信息。模拟浏览器行为比较有效。ctrl+shift+R神器</p>\n<h3 id=\"5-1-Request-Urllib2\"><a href=\"#5-1-Request-Urllib2\" class=\"headerlink\" title=\"5.1 Request, Urllib2\"></a>5.1 Request, Urllib2</h3><h3 id=\"5-2-UnicodeEncodeError-‘ascii’-codec-can’t-encode-characters-in-position\"><a href=\"#5-2-UnicodeEncodeError-‘ascii’-codec-can’t-encode-characters-in-position\" class=\"headerlink\" title=\"5.2 UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position\"></a>5.2 UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"># how to invoke this error</div><div class=\"line\">b = &quot;this is english within ascii range&quot;.encode(&apos;ascii&apos;)  # totally fine</div><div class=\"line\"></div><div class=\"line\">s = &quot;你好&quot;.encode(&apos;ascii&apos;)</div><div class=\"line\"># this will raise an error ,UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> print((b&quot;totally cool binary representation of english words within ascii range&quot;).decode(&apos;ascii&apos;))</div><div class=\"line\"> print((b&quot;totally cool binary cause utf-8 include ascii&quot;).decode(&apos;utf-8&apos;))</div><div class=\"line\"> # 完全正常</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> # eg.</div><div class=\"line\">string = &quot;你好啊&quot;</div><div class=\"line\">binary_string = b&apos;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a&apos;</div><div class=\"line\">binary_string_2_string = bstring.decode(&apos;utf-8&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">code :</div><div class=\"line\">print(string)  </div><div class=\"line\">print(string.encode(&apos;utf-8&apos;))</div><div class=\"line\">print(bstring2string)</div><div class=\"line\">print(bstring2string)</div><div class=\"line\"></div><div class=\"line\">print(which_instance_is_this(string))</div><div class=\"line\">print(which_instance_is_this(bstring))</div><div class=\"line\">print(which_instance_is_this(bstring2string))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">outputs:</div><div class=\"line\">你好啊</div><div class=\"line\">b&apos;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a&apos;</div><div class=\"line\">你好啊</div><div class=\"line\">你好啊</div><div class=\"line\"></div><div class=\"line\">is str</div><div class=\"line\">is byte</div><div class=\"line\">is str</div><div class=\"line\"></div><div class=\"line\">**Since Python 3.0, the language features a str type that contain Unicode characters, meaning any string created using &quot;unicode rocks!&quot;, &apos;unicode rocks!&apos;, or the triple-quoted string syntax is stored as Unicode.**</div><div class=\"line\"></div><div class=\"line\">冒号里面的都是str，都是unicode的集合。生成unicode可以用chr(12345) ，该方法接受一个integer返回一个长度为1的Unicode String。</div><div class=\"line\">反过来可以用ord(你) 生成“你”这个字在unicode中的编号</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">print(chr(20320))   &gt;&gt;&gt;&gt; 你</div><div class=\"line\">print(ord(&apos;你&apos;))    &gt;&gt;&gt;&gt; 20320 #这里只能用长度为1的string</div><div class=\"line\"></div><div class=\"line\">binary to string is called decode ,string to binary is encode</div><div class=\"line\">bytes.decode(&apos;utf-8&apos;)   &lt;----&gt; str.encode(&apos;utf-8&apos;)</div><div class=\"line\"></div><div class=\"line\">回到UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position</div><div class=\"line\">str.encode(&apos;ascii&apos;)，unicode字符超出了ascii的范围，无法decode成binary</div></pre></td></tr></table></figure>\n<h3 id=\"6-一些细节\"><a href=\"#6-一些细节\" class=\"headerlink\" title=\"6.一些细节\"></a>6.一些细节</h3><p>文件读写的各种模式以及解码问题<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(filepath, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">\"utf8\"</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">   f.write(<span class=\"string\">'最好用utf8读和写文件'</span>)</div><div class=\"line\">   <span class=\"comment\">#已经自动做好close文件的工作</span></div></pre></td></tr></table></figure></p>\n<p> how to upgrade installed packages?</p>\n<blockquote>\n<p>pip install –upgrade setuptools</p>\n</blockquote>\n<!-- install mongoDb(better performance than sql) -->\n<!-- install pip -->\n<p>grep log in command console<br>basic grammars<br>network, disk ,database, io , dic, list ,etc<br>class object orientated  </p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"http://www.liaoxuefeng.com/\">廖雪峰的官方网站</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20488077?columnSlug=kotandroid\">use python and mongoDb as backend</a></li>\n<li><a href=\"http://cuiqingcai.com/category/technique/python\">静觅</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20?rq=1\">unicodeencodeerror-ascii-codec-cant-encode-character</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=T_p22jMZSrk\">Droidcon NYC 2016 - Decoding the Secrets of Binary Data</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=6uroXz5l7Gk\">Jake Wharton and Jesse Wilson - Death, Taxes, and HTTP</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=WvyScM_S88c\">Droidcon Montreal Jake Wharton - A Few Ok Libraries</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=yS0Nc-L1Uuk\">Jesse Wilson - Coordinating Space and Time</a></li>\n</ul>\n","excerpt":"<h3 id=\"人生苦短，Python是岸\"><a href=\"#人生苦短，Python是岸\" class=\"headerlink\" title=\"人生苦短，Python是岸\"></a>人生苦短，Python是岸</h3><p><img src=\"http://odzl05jxx.bkt.clouddn.com/46ee54dd915d71da90e435703d4568fb.jpg?imageView2/2/w/600\" alt=\"implementing dumb features\"></p>","more":"<h3 id=\"1-Python的一些缺点\"><a href=\"#1-Python的一些缺点\" class=\"headerlink\" title=\"1. Python的一些缺点\"></a>1. Python的一些缺点</h3><p>引用<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的官方网站</a>上的话，Python一个是慢，一个是代码不能加密</p>\n<blockquote>\n<p>第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</p>\n<p>第二个缺点就是代码不能加密</p>\n<p>GIL导致的多线程低效率</p>\n</blockquote>\n<p>以下内容出自<a href=\"http://cuiqingcai.com/3325.html\">静觅 » Python爬虫进阶五之多线程的用法</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">1、GIL是什么？</div><div class=\"line\"></div><div class=\"line\">GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。</div><div class=\"line\"></div><div class=\"line\">2、每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）</div><div class=\"line\"></div><div class=\"line\">在Python多线程下，每个线程的执行方式：</div><div class=\"line\"></div><div class=\"line\">获取GIL</div><div class=\"line\">执行代码直到sleep或者是python虚拟机将其挂起。</div><div class=\"line\">释放GIL</div><div class=\"line\">可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。</div><div class=\"line\"></div><div class=\"line\">在Python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是Python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。</div><div class=\"line\"></div><div class=\"line\">而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-安装package各种can’t-resolve-XXX\"><a href=\"#2-安装package各种can’t-resolve-XXX\" class=\"headerlink\" title=\"2. 安装package各种can’t resolve XXX\"></a>2. 安装package各种can’t resolve XXX</h3><p><a href=\"http://stackoverflow.com/questions/2792650/python3-error-import-error-no-module-name-urllib2\">no module named urllib2</a></p>\n<blockquote>\n<p>The urllib2 module has been split across several modules in Python 3 named urllib.request and urllib.error. The 2to3 tool will automatically adapt imports when converting your sources to Python 3.</p>\n</blockquote>\n<p>This is what look like on py 2.7</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> urllib2</div><div class=\"line\">req = urllib2.Request(url,headers=header)</div><div class=\"line\">html = urllib2.urlopen(req)</div><div class=\"line\">html_data = html.read</div><div class=\"line\">html_path = etree.HTML(html_data)</div><div class=\"line\">```   </div><div class=\"line\"></div><div class=\"line\">on Python <span class=\"number\">3.</span>X</div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> urllib.request <span class=\"keyword\">import</span> urlopen</div><div class=\"line\"><span class=\"keyword\">from</span> urllib.request <span class=\"keyword\">import</span> Request</div><div class=\"line\"></div><div class=\"line\">req = Request(img_url, headers=headers)</div><div class=\"line\">urlhtml = urlopen(req)</div></pre></td></tr></table></figure>\n<h3 id=\"3-pip-install-XXXX\"><a href=\"#3-pip-install-XXXX\" class=\"headerlink\" title=\"3. pip install XXXX\"></a>3. pip install XXXX</h3><p>安装package的方式 pip install xxxx….<br><strong> if not working</strong><br><img src=\"http://odzl05jxx.bkt.clouddn.com/Googling%20the%20Error%20Message.jpg?imageView2/2/w/500\" alt=\"\"></p>\n<h3 id=\"4-List、tuple、dict、set以及基本的数据类型\"><a href=\"#4-List、tuple、dict、set以及基本的数据类型\" class=\"headerlink\" title=\"4. List、tuple、dict、set以及基本的数据类型\"></a>4. List、tuple、dict、set以及基本的数据类型</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">list   mylist = [<span class=\"string\">'Tom'</span>,<span class=\"string\">'Jerry'</span>,<span class=\"string\">'Henry'</span>]</div><div class=\"line\">       mylist[<span class=\"number\">0</span>] = <span class=\"string\">'Tom'</span></div><div class=\"line\"></div><div class=\"line\">tuple  mytuple = (<span class=\"string\">'rock'</span>,<span class=\"string\">'pop'</span>,<span class=\"string\">'jazz'</span>)</div><div class=\"line\">        mytuple[<span class=\"number\">0</span>] = <span class=\"string\">'rock'</span></div><div class=\"line\"></div><div class=\"line\">tuple在初始化时就已经确定，不能修改</div><div class=\"line\"></div><div class=\"line\">dict: d=&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'tom'</span>,<span class=\"string\">'job'</span>:<span class=\"string\">'doctor'</span>,<span class=\"string\">'age'</span>,<span class=\"number\">99</span>&#125;</div><div class=\"line\">       d[<span class=\"string\">'name'</span>] = <span class=\"string\">'tom'</span></div><div class=\"line\"></div><div class=\"line\">set:  s = set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\"># 需要传入一个list作为参数</span></div><div class=\"line\">   &gt;&gt; s</div><div class=\"line\">   &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</div><div class=\"line\">   set无序，不可有重复元素</div><div class=\"line\">   set和dict的区别在于前者没有存储value，两者内部都不能有重复元素(key)</div></pre></td></tr></table></figure>\n<p>tuple用的比较多，例如有多个返回值的函数，Python其实返回了一个Tuple。</p>\n<h3 id=\"类名应该写成驼峰样式，变量名应该小写\"><a href=\"#类名应该写成驼峰样式，变量名应该小写\" class=\"headerlink\" title=\"类名应该写成驼峰样式，变量名应该小写\"></a>类名应该写成驼峰样式，变量名应该小写</h3><p>class name should be cammelCase, Arguments,variable name should be lowercase</p>\n<p>循环<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, <span class=\"number\">5</span>):</div><div class=\"line\">        print(i)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>result: <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> 左闭右开</div><div class=\"line\"></div><div class=\"line\">条件判断</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        L = []</div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<h3 id=\"函数参数相关，函数组合（一共五种）\"><a href=\"#函数参数相关，函数组合（一共五种）\" class=\"headerlink\" title=\"函数参数相关，函数组合（一共五种）\"></a>函数参数相关，函数组合（一共五种）</h3><p>位置参数，默认参数，可变参数，关键字参数，命名关键字参数</p>\n<p>定义一个函数可以带上默认值，默认值是一个固定的对象，上次操作的值会保留到下一次调用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sell</span><span class=\"params\">(name,price,amount=<span class=\"number\">1</span>)</span>:</span></div><div class=\"line\">    print(price*amount)</div><div class=\"line\"></div><div class=\"line\">sell(<span class=\"string\">'product'</span>,<span class=\"number\">26</span>)</div><div class=\"line\">sell(<span class=\"string\">'product'</span>,<span class=\"number\">26</span>,<span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">26</span>    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">52</span></div></pre></td></tr></table></figure></p>\n<p>默认参数函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(x, n=<span class=\"number\">2</span>)</span>:</span> <span class=\"comment\">#这里的n=2就是默认参数，注意，默认参数应该是不可变对象,例如str、None这种</span></div><div class=\"line\">    s = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        n = n - <span class=\"number\">1</span></div><div class=\"line\">        s = s * x</div><div class=\"line\">    <span class=\"keyword\">return</span> s</div><div class=\"line\"></div><div class=\"line\">power(<span class=\"number\">5</span>) &gt;&gt; <span class=\"number\">25</span></div><div class=\"line\">power(<span class=\"number\">5</span>,<span class=\"number\">2</span>) &gt;&gt;&gt;<span class=\"number\">25</span></div></pre></td></tr></table></figure></p>\n<p>可变参数函数# 定义的时候在参数前面加一个*号就可以了，内部会默认组装成一个tuple<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span> <span class=\"comment\">#函数内部接收到的是一个tuple</span></div><div class=\"line\">    sum = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> numbers:</div><div class=\"line\">        sum = sum + n * n</div><div class=\"line\">    <span class=\"keyword\">return</span> sum</div><div class=\"line\"></div><div class=\"line\">calc(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\">calc(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>)    </div><div class=\"line\"></div><div class=\"line\">nums = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</div><div class=\"line\">cal(*nums)<span class=\"comment\">#把tuple内的元素作为参数传进去</span></div></pre></td></tr></table></figure></p>\n<p>关键字参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Michael'</span>, <span class=\"number\">30</span>)</div><div class=\"line\">name: Michael age: <span class=\"number\">30</span> other: &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">内部自动将关键字参数转换成一个dict</div></pre></td></tr></table></figure></p>\n<p>命名关键字函数<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">def shoppping(name,time,*,price,count)# price可以有默认值</div><div class=\"line\">    print(price*count)</div><div class=\"line\"></div><div class=\"line\">&gt;&gt; shopping(john,0325,price=39,count=5)</div><div class=\"line\">&gt;&gt; 195</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-爬虫相关\"><a href=\"#5-爬虫相关\" class=\"headerlink\" title=\"5. 爬虫相关\"></a>5. 爬虫相关</h3><p>Chrome自带开发者工具，可以查看每一个request的header，cookies等信息。模拟浏览器行为比较有效。ctrl+shift+R神器</p>\n<h3 id=\"5-1-Request-Urllib2\"><a href=\"#5-1-Request-Urllib2\" class=\"headerlink\" title=\"5.1 Request, Urllib2\"></a>5.1 Request, Urllib2</h3><h3 id=\"5-2-UnicodeEncodeError-‘ascii’-codec-can’t-encode-characters-in-position\"><a href=\"#5-2-UnicodeEncodeError-‘ascii’-codec-can’t-encode-characters-in-position\" class=\"headerlink\" title=\"5.2 UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position\"></a>5.2 UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"># how to invoke this error</div><div class=\"line\">b = &quot;this is english within ascii range&quot;.encode(&apos;ascii&apos;)  # totally fine</div><div class=\"line\"></div><div class=\"line\">s = &quot;你好&quot;.encode(&apos;ascii&apos;)</div><div class=\"line\"># this will raise an error ,UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> print((b&quot;totally cool binary representation of english words within ascii range&quot;).decode(&apos;ascii&apos;))</div><div class=\"line\"> print((b&quot;totally cool binary cause utf-8 include ascii&quot;).decode(&apos;utf-8&apos;))</div><div class=\"line\"> # 完全正常</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> # eg.</div><div class=\"line\">string = &quot;你好啊&quot;</div><div class=\"line\">binary_string = b&apos;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a&apos;</div><div class=\"line\">binary_string_2_string = bstring.decode(&apos;utf-8&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">code :</div><div class=\"line\">print(string)  </div><div class=\"line\">print(string.encode(&apos;utf-8&apos;))</div><div class=\"line\">print(bstring2string)</div><div class=\"line\">print(bstring2string)</div><div class=\"line\"></div><div class=\"line\">print(which_instance_is_this(string))</div><div class=\"line\">print(which_instance_is_this(bstring))</div><div class=\"line\">print(which_instance_is_this(bstring2string))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">outputs:</div><div class=\"line\">你好啊</div><div class=\"line\">b&apos;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a&apos;</div><div class=\"line\">你好啊</div><div class=\"line\">你好啊</div><div class=\"line\"></div><div class=\"line\">is str</div><div class=\"line\">is byte</div><div class=\"line\">is str</div><div class=\"line\"></div><div class=\"line\">**Since Python 3.0, the language features a str type that contain Unicode characters, meaning any string created using &quot;unicode rocks!&quot;, &apos;unicode rocks!&apos;, or the triple-quoted string syntax is stored as Unicode.**</div><div class=\"line\"></div><div class=\"line\">冒号里面的都是str，都是unicode的集合。生成unicode可以用chr(12345) ，该方法接受一个integer返回一个长度为1的Unicode String。</div><div class=\"line\">反过来可以用ord(你) 生成“你”这个字在unicode中的编号</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">print(chr(20320))   &gt;&gt;&gt;&gt; 你</div><div class=\"line\">print(ord(&apos;你&apos;))    &gt;&gt;&gt;&gt; 20320 #这里只能用长度为1的string</div><div class=\"line\"></div><div class=\"line\">binary to string is called decode ,string to binary is encode</div><div class=\"line\">bytes.decode(&apos;utf-8&apos;)   &lt;----&gt; str.encode(&apos;utf-8&apos;)</div><div class=\"line\"></div><div class=\"line\">回到UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position</div><div class=\"line\">str.encode(&apos;ascii&apos;)，unicode字符超出了ascii的范围，无法decode成binary</div></pre></td></tr></table></figure>\n<h3 id=\"6-一些细节\"><a href=\"#6-一些细节\" class=\"headerlink\" title=\"6.一些细节\"></a>6.一些细节</h3><p>文件读写的各种模式以及解码问题<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(filepath, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">\"utf8\"</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">   f.write(<span class=\"string\">'最好用utf8读和写文件'</span>)</div><div class=\"line\">   <span class=\"comment\">#已经自动做好close文件的工作</span></div></pre></td></tr></table></figure></p>\n<p> how to upgrade installed packages?</p>\n<blockquote>\n<p>pip install –upgrade setuptools</p>\n</blockquote>\n<!-- install mongoDb(better performance than sql) -->\n<!-- install pip -->\n<p>grep log in command console<br>basic grammars<br>network, disk ,database, io , dic, list ,etc<br>class object orientated  </p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"http://www.liaoxuefeng.com/\">廖雪峰的官方网站</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20488077?columnSlug=kotandroid\">use python and mongoDb as backend</a></li>\n<li><a href=\"http://cuiqingcai.com/category/technique/python\">静觅</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20?rq=1\">unicodeencodeerror-ascii-codec-cant-encode-character</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=T_p22jMZSrk\">Droidcon NYC 2016 - Decoding the Secrets of Binary Data</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=6uroXz5l7Gk\">Jake Wharton and Jesse Wilson - Death, Taxes, and HTTP</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=WvyScM_S88c\">Droidcon Montreal Jake Wharton - A Few Ok Libraries</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=yS0Nc-L1Uuk\">Jesse Wilson - Coordinating Space and Time</a></li>\n</ul>"},{"title":"使用AnnotationProcessor自动生成代码","date":"2016-12-31T14:42:15.000Z","_content":"\n\n![](http://odzl05jxx.bkt.clouddn.com/apt_01.JPG?imageView2/2/w/500)\n记得Romain Guy在一次DroidCon上曾说过:\n\n> As I understand, modern java development are all about wrting annaotation Processors and not wrting code anymore...\n\n全场观众大笑。。。\n\n这之后经常看到Jack Wharton在演讲中提到\"My Hypothetical Annotation Processor...\" ，后来才意识到像Retrofit，ButterKnife这些都是使用了注解的方式。\n <!--more-->\n\n\n\n### 1. 原理介绍\nAnnotation Processoring Tool是javac的一部分，它会在编译期生成新的.java文件（不是class文件）\n定义一个Annotation的语法如下：\n```java\n@Documented\n@Target(ElementType.TYPE)  //这说明生成的注解能够放在class,interface,enum等类型上。不能放在method上\n@Retention(RetentionPolicy.SOURCE)  //指明在编译器有效\npublic @interface Builder {  //@interface就像class,interface,enum一样\n}\n```\n\n### 2.Annotation Processor是生成新代码的实现类\n大致的实现例如：\n```java\npublic class PojoStringProcessor extends AbstractProcessor {\n    private static final String ANNOTATION = \"@\" + PojoString.class.getSimpleName();\n    private static final String CLASS_NAME = \"StringUtil\";\n    private Messager messager; //有点像Logger,用于输出信息\n    private Filer filer //可以获得Build Path，用于生成文件\n\n    //public构造函数不写也会自动加上\n\n    // init做一些初始化操作\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        messager = processingEnv.getMessager();\n        this.filer = processingEnv.getFiler();\n    }\n\n    //apt在检查被注解的class时，会返回你需要的注解类型\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        return immutableSet.of(Builder.class.getCanonicalName());\n    }\n\n\t //java7,java8 有点像android的targetSdk Version\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }\n\n\n\n    //重点\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        ArrayList<AnnotatedClass> annotatedClasses = new ArrayList<>();\n        for (Element element : roundEnv.getElementsAnnotatedWith(PojoString.class)) {\n            TypeElement typeElement = (TypeElement) element;\n            if (!isValidClass(typeElement)) {\n                return true; //apt找到的所有被注解的class\n            }\n\n            try {\n                annotatedClasses.add(buildAnnotatedClass(typeElement));\n            } catch (IOException e) {\n                String message = String.format(\"Couldn't process class %s: %s\", typeElement,\n                        e.getMessage());\n                messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n                e.printStackTrace();\n            }\n\n\n        }\n        try {\n            generate(annotatedClasses);\n        } catch (IOException e) {\n            messager.printMessage(Diagnostic.Kind.ERROR, \"Couldn't generate class\");\n        }\n\n        return true;\n    }\n\n\n}\n\n```\n几个重要的方法解释下：\n- roundEnv: apt分两步：1. apt发现被注解的代码，提供给我们写的processor，后者生成新的java代码(apt还未处理这部分新代码)。\n2. apt发现新代码，提供给我们的Processor，不生成新代码。完成processing。（后面提供给编译）\n\n\nServiceLoader Discovery File（这货在jar中）\n//META-INFO/services/javax.annotations.processing.Processor文件中写入\ncom.example.annotation.BuilderProcessor// class包名\n//这里声明所有的processor，这里可以include别的processor\n\n语法：\n```java\napp/build.gradle\n\ndependencies{\n\tcompile project(': annotation')\n\n\tapt project (':processor')\n}\n//apt 表示processor中的方法不会带到distributed apk中,方法数不用担心了\n//https://bitbucket.org/hvisser/android-apt\n//https://github.com/tbroyer/gradle-apt-plugin\n```\n\n\n\n继承AbstractProcessor，必须要有一个无参public构造函数\n\n\n### 3. 生成新的java方法\n首先添加依赖，square的javaPoet\n\n假设想生成的代码是这样的\n```java\npublic final class UserBuilder{\n\t\n\tprivate String userName;\n\n\tpublic UserBuilder username(String username){\n\t\tthis.username = username;\n\t\treturen this;\n\t}\n\n}\n\n```\n- 生成变量\n![](http://odzl05jxx.bkt.clouddn.com/apt_field.JPG)\n\n- 生成方法\n![](http://odzl05jxx.bkt.clouddn.com/apt_methods.JPG)\n\n- 生成class:\n![](http://odzl05jxx.bkt.clouddn.com/apt_class.JPG)\n\n直接截图了\n- 主要步骤\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_steps.JPG)\n\nmeta_data\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_meta_data.JPG)\n\n- 生成private field和public setter:\n> FiledSpec username = FiledSpec.builder(String.class,\"username\",Modifier.PRIVATE).build();\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_fields.JPG)\n\n\n- 生成build method\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_build_method.JPG)\n\n- 生成builder\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_create_builder.JPG)\n\n- 写java文件：\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_write_java_file.JPG)\n\n\n\n\n### 4. 注意的地方\ndnot't put annotation processors in a compile configuration, use the Android Apt plugin。 \n\nif you using jack, jack has support for annotation processors.\n\nif it's only a java, could use the Gradle Apt Plugin\n\n我们写的processor不会带到生成的apk中，但生成的代码会。这也正是想要的目的。\n\n\n### ref\n - [android gradle plugin 2.3的兼容问题](https://code.google.com/p/android/issues/detail?id=227612)\n - [Android沉思录](http://yeungeek.com/2016/04/27/Android%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BA%8C-Annotation-Processing-Tool)\n - [Droidcon NYC 2016 - @Eliminate(\"Boilerplate\")](https://www.youtube.com/watch?v=NBkl_SIHUr8)\n - [Gradle Apt Plugin](https://github.com/tbroyer/gradle-apt-plugin)\n - [Andorid Apt Plugin](https://bitbucket.org/hvisser/android-apt)","source":"_posts/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor.md","raw":"---\ntitle: 使用AnnotationProcessor自动生成代码\ndate: 2016-12-31 22:42:15\ncategories: blog \ntags: [android,annotation]\n---\n\n\n![](http://odzl05jxx.bkt.clouddn.com/apt_01.JPG?imageView2/2/w/500)\n记得Romain Guy在一次DroidCon上曾说过:\n\n> As I understand, modern java development are all about wrting annaotation Processors and not wrting code anymore...\n\n全场观众大笑。。。\n\n这之后经常看到Jack Wharton在演讲中提到\"My Hypothetical Annotation Processor...\" ，后来才意识到像Retrofit，ButterKnife这些都是使用了注解的方式。\n <!--more-->\n\n\n\n### 1. 原理介绍\nAnnotation Processoring Tool是javac的一部分，它会在编译期生成新的.java文件（不是class文件）\n定义一个Annotation的语法如下：\n```java\n@Documented\n@Target(ElementType.TYPE)  //这说明生成的注解能够放在class,interface,enum等类型上。不能放在method上\n@Retention(RetentionPolicy.SOURCE)  //指明在编译器有效\npublic @interface Builder {  //@interface就像class,interface,enum一样\n}\n```\n\n### 2.Annotation Processor是生成新代码的实现类\n大致的实现例如：\n```java\npublic class PojoStringProcessor extends AbstractProcessor {\n    private static final String ANNOTATION = \"@\" + PojoString.class.getSimpleName();\n    private static final String CLASS_NAME = \"StringUtil\";\n    private Messager messager; //有点像Logger,用于输出信息\n    private Filer filer //可以获得Build Path，用于生成文件\n\n    //public构造函数不写也会自动加上\n\n    // init做一些初始化操作\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        messager = processingEnv.getMessager();\n        this.filer = processingEnv.getFiler();\n    }\n\n    //apt在检查被注解的class时，会返回你需要的注解类型\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        return immutableSet.of(Builder.class.getCanonicalName());\n    }\n\n\t //java7,java8 有点像android的targetSdk Version\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }\n\n\n\n    //重点\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        ArrayList<AnnotatedClass> annotatedClasses = new ArrayList<>();\n        for (Element element : roundEnv.getElementsAnnotatedWith(PojoString.class)) {\n            TypeElement typeElement = (TypeElement) element;\n            if (!isValidClass(typeElement)) {\n                return true; //apt找到的所有被注解的class\n            }\n\n            try {\n                annotatedClasses.add(buildAnnotatedClass(typeElement));\n            } catch (IOException e) {\n                String message = String.format(\"Couldn't process class %s: %s\", typeElement,\n                        e.getMessage());\n                messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n                e.printStackTrace();\n            }\n\n\n        }\n        try {\n            generate(annotatedClasses);\n        } catch (IOException e) {\n            messager.printMessage(Diagnostic.Kind.ERROR, \"Couldn't generate class\");\n        }\n\n        return true;\n    }\n\n\n}\n\n```\n几个重要的方法解释下：\n- roundEnv: apt分两步：1. apt发现被注解的代码，提供给我们写的processor，后者生成新的java代码(apt还未处理这部分新代码)。\n2. apt发现新代码，提供给我们的Processor，不生成新代码。完成processing。（后面提供给编译）\n\n\nServiceLoader Discovery File（这货在jar中）\n//META-INFO/services/javax.annotations.processing.Processor文件中写入\ncom.example.annotation.BuilderProcessor// class包名\n//这里声明所有的processor，这里可以include别的processor\n\n语法：\n```java\napp/build.gradle\n\ndependencies{\n\tcompile project(': annotation')\n\n\tapt project (':processor')\n}\n//apt 表示processor中的方法不会带到distributed apk中,方法数不用担心了\n//https://bitbucket.org/hvisser/android-apt\n//https://github.com/tbroyer/gradle-apt-plugin\n```\n\n\n\n继承AbstractProcessor，必须要有一个无参public构造函数\n\n\n### 3. 生成新的java方法\n首先添加依赖，square的javaPoet\n\n假设想生成的代码是这样的\n```java\npublic final class UserBuilder{\n\t\n\tprivate String userName;\n\n\tpublic UserBuilder username(String username){\n\t\tthis.username = username;\n\t\treturen this;\n\t}\n\n}\n\n```\n- 生成变量\n![](http://odzl05jxx.bkt.clouddn.com/apt_field.JPG)\n\n- 生成方法\n![](http://odzl05jxx.bkt.clouddn.com/apt_methods.JPG)\n\n- 生成class:\n![](http://odzl05jxx.bkt.clouddn.com/apt_class.JPG)\n\n直接截图了\n- 主要步骤\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_steps.JPG)\n\nmeta_data\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_meta_data.JPG)\n\n- 生成private field和public setter:\n> FiledSpec username = FiledSpec.builder(String.class,\"username\",Modifier.PRIVATE).build();\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_fields.JPG)\n\n\n- 生成build method\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_build_method.JPG)\n\n- 生成builder\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_create_builder.JPG)\n\n- 写java文件：\n![](http://odzl05jxx.bkt.clouddn.com/apt_process_write_java_file.JPG)\n\n\n\n\n### 4. 注意的地方\ndnot't put annotation processors in a compile configuration, use the Android Apt plugin。 \n\nif you using jack, jack has support for annotation processors.\n\nif it's only a java, could use the Gradle Apt Plugin\n\n我们写的processor不会带到生成的apk中，但生成的代码会。这也正是想要的目的。\n\n\n### ref\n - [android gradle plugin 2.3的兼容问题](https://code.google.com/p/android/issues/detail?id=227612)\n - [Android沉思录](http://yeungeek.com/2016/04/27/Android%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BA%8C-Annotation-Processing-Tool)\n - [Droidcon NYC 2016 - @Eliminate(\"Boilerplate\")](https://www.youtube.com/watch?v=NBkl_SIHUr8)\n - [Gradle Apt Plugin](https://github.com/tbroyer/gradle-apt-plugin)\n - [Andorid Apt Plugin](https://bitbucket.org/hvisser/android-apt)","slug":"2016-12-31-Eliminating-BoilPlate-AnnotationProcessor","published":1,"updated":"2017-04-23T10:51:22.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnh0000xbovrlgomfb61","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_01.JPG?imageView2/2/w/500\" alt=\"\"><br>记得Romain Guy在一次DroidCon上曾说过:</p>\n<blockquote>\n<p>As I understand, modern java development are all about wrting annaotation Processors and not wrting code anymore…</p>\n</blockquote>\n<p>全场观众大笑。。。</p>\n<p>这之后经常看到Jack Wharton在演讲中提到”My Hypothetical Annotation Processor…” ，后来才意识到像Retrofit，ButterKnife这些都是使用了注解的方式。<br> <a id=\"more\"></a></p>\n<h3 id=\"1-原理介绍\"><a href=\"#1-原理介绍\" class=\"headerlink\" title=\"1. 原理介绍\"></a>1. 原理介绍</h3><p>Annotation Processoring Tool是javac的一部分，它会在编译期生成新的.java文件（不是class文件）<br>定义一个Annotation的语法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)  <span class=\"comment\">//这说明生成的注解能够放在class,interface,enum等类型上。不能放在method上</span></div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)  <span class=\"comment\">//指明在编译器有效</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Builder &#123;  <span class=\"comment\">//@interface就像class,interface,enum一样</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-Annotation-Processor是生成新代码的实现类\"><a href=\"#2-Annotation-Processor是生成新代码的实现类\" class=\"headerlink\" title=\"2.Annotation Processor是生成新代码的实现类\"></a>2.Annotation Processor是生成新代码的实现类</h3><p>大致的实现例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PojoStringProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ANNOTATION = <span class=\"string\">\"@\"</span> + PojoString.class.getSimpleName();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLASS_NAME = <span class=\"string\">\"StringUtil\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> Messager messager; <span class=\"comment\">//有点像Logger,用于输出信息</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Filer filer <span class=\"comment\">//可以获得Build Path，用于生成文件</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//public构造函数不写也会自动加上</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// init做一些初始化操作</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnv);</div><div class=\"line\">        messager = processingEnv.getMessager();</div><div class=\"line\">        <span class=\"keyword\">this</span>.filer = processingEnv.getFiler();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//apt在检查被注解的class时，会返回你需要的注解类型</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> immutableSet.of(Builder.class.getCanonicalName());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">true <span class=\"comment\">//java7,java8 有点像android的targetSdk Version</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> SourceVersion.latestSupported();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//重点</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</div><div class=\"line\">        ArrayList&lt;AnnotatedClass&gt; annotatedClasses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Element element : roundEnv.getElementsAnnotatedWith(PojoString.class)) &#123;</div><div class=\"line\">            TypeElement typeElement = (TypeElement) element;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!isValidClass(typeElement)) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">//apt找到的所有被注解的class</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                annotatedClasses.add(buildAnnotatedClass(typeElement));</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                String message = String.format(<span class=\"string\">\"Couldn't process class %s: %s\"</span>, typeElement,</div><div class=\"line\">                        e.getMessage());</div><div class=\"line\">                messager.printMessage(Diagnostic.Kind.ERROR, message, element);</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            generate(annotatedClasses);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR, <span class=\"string\">\"Couldn't generate class\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>几个重要的方法解释下：</p>\n<ul>\n<li>roundEnv: apt分两步：1. apt发现被注解的代码，提供给我们写的processor，后者生成新的java代码(apt还未处理这部分新代码)。</li>\n</ul>\n<ol>\n<li>apt发现新代码，提供给我们的Processor，不生成新代码。完成processing。（后面提供给编译）</li>\n</ol>\n<p>ServiceLoader Discovery File（这货在jar中）<br>//META-INFO/services/javax.annotations.processing.Processor文件中写入<br>com.example.annotation.BuilderProcessor// class包名<br>//这里声明所有的processor，这里可以include别的processor</p>\n<p>语法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">app/build.gradle</div><div class=\"line\"></div><div class=\"line\">dependencies&#123;</div><div class=\"line\">true<span class=\"function\">compile <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">': annotation'</span>)</span></div><div class=\"line\"></div><div class=\"line\">trueapt <span class=\"title\">project</span> <span class=\"params\">(<span class=\"string\">':processor'</span>)</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//apt 表示processor中的方法不会带到distributed apk中,方法数不用担心了</span></div><div class=\"line\"><span class=\"comment\">//https://bitbucket.org/hvisser/android-apt</span></div><div class=\"line\"><span class=\"comment\">//https://github.com/tbroyer/gradle-apt-plugin</span></span></div></pre></td></tr></table></figure></p>\n<p>继承AbstractProcessor，必须要有一个无参public构造函数</p>\n<h3 id=\"3-生成新的java方法\"><a href=\"#3-生成新的java方法\" class=\"headerlink\" title=\"3. 生成新的java方法\"></a>3. 生成新的java方法</h3><p>首先添加依赖，square的javaPoet</p>\n<p>假设想生成的代码是这样的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserBuilder</span></span>&#123;</div><div class=\"line\">true</div><div class=\"line\">true<span class=\"keyword\">private</span> String userName;</div><div class=\"line\"></div><div class=\"line\">true<span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">username</span><span class=\"params\">(String username)</span></span>&#123;</div><div class=\"line\">truetrue<span class=\"keyword\">this</span>.username = username;</div><div class=\"line\">truetruereturen <span class=\"keyword\">this</span>;</div><div class=\"line\">true&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>生成变量<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_field.JPG\" alt=\"\"></p>\n</li>\n<li><p>生成方法<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_methods.JPG\" alt=\"\"></p>\n</li>\n<li><p>生成class:<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_class.JPG\" alt=\"\"></p>\n</li>\n</ul>\n<p>直接截图了</p>\n<ul>\n<li>主要步骤<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_steps.JPG\" alt=\"\"></li>\n</ul>\n<p>meta_data<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_meta_data.JPG\" alt=\"\"></p>\n<ul>\n<li>生成private field和public setter:<blockquote>\n<p>FiledSpec username = FiledSpec.builder(String.class,”username”,Modifier.PRIVATE).build();<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_fields.JPG\" alt=\"\"></p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>生成build method<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_build_method.JPG\" alt=\"\"></p>\n</li>\n<li><p>生成builder<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_create_builder.JPG\" alt=\"\"></p>\n</li>\n<li><p>写java文件：<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_write_java_file.JPG\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"4-注意的地方\"><a href=\"#4-注意的地方\" class=\"headerlink\" title=\"4. 注意的地方\"></a>4. 注意的地方</h3><p>dnot’t put annotation processors in a compile configuration, use the Android Apt plugin。 </p>\n<p>if you using jack, jack has support for annotation processors.</p>\n<p>if it’s only a java, could use the Gradle Apt Plugin</p>\n<p>我们写的processor不会带到生成的apk中，但生成的代码会。这也正是想要的目的。</p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"https://code.google.com/p/android/issues/detail?id=227612\">android gradle plugin 2.3的兼容问题</a></li>\n<li><a href=\"http://yeungeek.com/2016/04/27/Android%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BA%8C-Annotation-Processing-Tool\">Android沉思录</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=NBkl_SIHUr8\">Droidcon NYC 2016 - @Eliminate(“Boilerplate”)</a></li>\n<li><a href=\"https://github.com/tbroyer/gradle-apt-plugin\">Gradle Apt Plugin</a></li>\n<li><a href=\"https://bitbucket.org/hvisser/android-apt\">Andorid Apt Plugin</a></li>\n</ul>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_01.JPG?imageView2/2/w/500\" alt=\"\"><br>记得Romain Guy在一次DroidCon上曾说过:</p>\n<blockquote>\n<p>As I understand, modern java development are all about wrting annaotation Processors and not wrting code anymore…</p>\n</blockquote>\n<p>全场观众大笑。。。</p>\n<p>这之后经常看到Jack Wharton在演讲中提到”My Hypothetical Annotation Processor…” ，后来才意识到像Retrofit，ButterKnife这些都是使用了注解的方式。<br>","more":"</p>\n<h3 id=\"1-原理介绍\"><a href=\"#1-原理介绍\" class=\"headerlink\" title=\"1. 原理介绍\"></a>1. 原理介绍</h3><p>Annotation Processoring Tool是javac的一部分，它会在编译期生成新的.java文件（不是class文件）<br>定义一个Annotation的语法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)  <span class=\"comment\">//这说明生成的注解能够放在class,interface,enum等类型上。不能放在method上</span></div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)  <span class=\"comment\">//指明在编译器有效</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Builder &#123;  <span class=\"comment\">//@interface就像class,interface,enum一样</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-Annotation-Processor是生成新代码的实现类\"><a href=\"#2-Annotation-Processor是生成新代码的实现类\" class=\"headerlink\" title=\"2.Annotation Processor是生成新代码的实现类\"></a>2.Annotation Processor是生成新代码的实现类</h3><p>大致的实现例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PojoStringProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ANNOTATION = <span class=\"string\">\"@\"</span> + PojoString.class.getSimpleName();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLASS_NAME = <span class=\"string\">\"StringUtil\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> Messager messager; <span class=\"comment\">//有点像Logger,用于输出信息</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Filer filer <span class=\"comment\">//可以获得Build Path，用于生成文件</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//public构造函数不写也会自动加上</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// init做一些初始化操作</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnv);</div><div class=\"line\">        messager = processingEnv.getMessager();</div><div class=\"line\">        <span class=\"keyword\">this</span>.filer = processingEnv.getFiler();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//apt在检查被注解的class时，会返回你需要的注解类型</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> immutableSet.of(Builder.class.getCanonicalName());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">true <span class=\"comment\">//java7,java8 有点像android的targetSdk Version</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> SourceVersion.latestSupported();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//重点</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</div><div class=\"line\">        ArrayList&lt;AnnotatedClass&gt; annotatedClasses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Element element : roundEnv.getElementsAnnotatedWith(PojoString.class)) &#123;</div><div class=\"line\">            TypeElement typeElement = (TypeElement) element;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!isValidClass(typeElement)) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">//apt找到的所有被注解的class</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                annotatedClasses.add(buildAnnotatedClass(typeElement));</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                String message = String.format(<span class=\"string\">\"Couldn't process class %s: %s\"</span>, typeElement,</div><div class=\"line\">                        e.getMessage());</div><div class=\"line\">                messager.printMessage(Diagnostic.Kind.ERROR, message, element);</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            generate(annotatedClasses);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR, <span class=\"string\">\"Couldn't generate class\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>几个重要的方法解释下：</p>\n<ul>\n<li>roundEnv: apt分两步：1. apt发现被注解的代码，提供给我们写的processor，后者生成新的java代码(apt还未处理这部分新代码)。</li>\n</ul>\n<ol>\n<li>apt发现新代码，提供给我们的Processor，不生成新代码。完成processing。（后面提供给编译）</li>\n</ol>\n<p>ServiceLoader Discovery File（这货在jar中）<br>//META-INFO/services/javax.annotations.processing.Processor文件中写入<br>com.example.annotation.BuilderProcessor// class包名<br>//这里声明所有的processor，这里可以include别的processor</p>\n<p>语法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">app/build.gradle</div><div class=\"line\"></div><div class=\"line\">dependencies&#123;</div><div class=\"line\">true<span class=\"function\">compile <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">': annotation'</span>)</span></div><div class=\"line\"></div><div class=\"line\">trueapt <span class=\"title\">project</span> <span class=\"params\">(<span class=\"string\">':processor'</span>)</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//apt 表示processor中的方法不会带到distributed apk中,方法数不用担心了</span></div><div class=\"line\"><span class=\"comment\">//https://bitbucket.org/hvisser/android-apt</span></div><div class=\"line\"><span class=\"comment\">//https://github.com/tbroyer/gradle-apt-plugin</span></span></div></pre></td></tr></table></figure></p>\n<p>继承AbstractProcessor，必须要有一个无参public构造函数</p>\n<h3 id=\"3-生成新的java方法\"><a href=\"#3-生成新的java方法\" class=\"headerlink\" title=\"3. 生成新的java方法\"></a>3. 生成新的java方法</h3><p>首先添加依赖，square的javaPoet</p>\n<p>假设想生成的代码是这样的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserBuilder</span></span>&#123;</div><div class=\"line\">true</div><div class=\"line\">true<span class=\"keyword\">private</span> String userName;</div><div class=\"line\"></div><div class=\"line\">true<span class=\"function\"><span class=\"keyword\">public</span> UserBuilder <span class=\"title\">username</span><span class=\"params\">(String username)</span></span>&#123;</div><div class=\"line\">truetrue<span class=\"keyword\">this</span>.username = username;</div><div class=\"line\">truetruereturen <span class=\"keyword\">this</span>;</div><div class=\"line\">true&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>生成变量<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_field.JPG\" alt=\"\"></p>\n</li>\n<li><p>生成方法<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_methods.JPG\" alt=\"\"></p>\n</li>\n<li><p>生成class:<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_class.JPG\" alt=\"\"></p>\n</li>\n</ul>\n<p>直接截图了</p>\n<ul>\n<li>主要步骤<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_steps.JPG\" alt=\"\"></li>\n</ul>\n<p>meta_data<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_meta_data.JPG\" alt=\"\"></p>\n<ul>\n<li>生成private field和public setter:<blockquote>\n<p>FiledSpec username = FiledSpec.builder(String.class,”username”,Modifier.PRIVATE).build();<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_fields.JPG\" alt=\"\"></p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>生成build method<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_build_method.JPG\" alt=\"\"></p>\n</li>\n<li><p>生成builder<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_create_builder.JPG\" alt=\"\"></p>\n</li>\n<li><p>写java文件：<br><img src=\"http://odzl05jxx.bkt.clouddn.com/apt_process_write_java_file.JPG\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"4-注意的地方\"><a href=\"#4-注意的地方\" class=\"headerlink\" title=\"4. 注意的地方\"></a>4. 注意的地方</h3><p>dnot’t put annotation processors in a compile configuration, use the Android Apt plugin。 </p>\n<p>if you using jack, jack has support for annotation processors.</p>\n<p>if it’s only a java, could use the Gradle Apt Plugin</p>\n<p>我们写的processor不会带到生成的apk中，但生成的代码会。这也正是想要的目的。</p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"https://code.google.com/p/android/issues/detail?id=227612\">android gradle plugin 2.3的兼容问题</a></li>\n<li><a href=\"http://yeungeek.com/2016/04/27/Android%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BA%8C-Annotation-Processing-Tool\">Android沉思录</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=NBkl_SIHUr8\">Droidcon NYC 2016 - @Eliminate(“Boilerplate”)</a></li>\n<li><a href=\"https://github.com/tbroyer/gradle-apt-plugin\">Gradle Apt Plugin</a></li>\n<li><a href=\"https://bitbucket.org/hvisser/android-apt\">Andorid Apt Plugin</a></li>\n</ul>"},{"title":"linux基本命令介绍","date":"2017-01-07T07:38:43.000Z","top":1,"_content":"\n一些常用的linux基本命令,仅作为参考。</br>\n![](http://odzl05jxx.bkt.clouddn.com/849c18412f8e7a0b18df09f6f87e6516.jpg?imageView2/2/w/600)\n <!--more-->\n\n首先是连接vps的ssh(Secure Shell)工具，putty或者xshell都可以。\n\n## 速查手册\n1. [文件操作](#1-文件操作常用命令)\n2. [Vi文本编辑器](#2-Vi文本编辑器)\n3. [bash脚本怎么写](#3-linux下shell脚本语句的语法)\n4. [用户和用户组的问题](#4-用户和用户组的问题)\n5. [文件权限](#5-文件权限的问题)\n6. [管道](#6-管道)\n7. [硬件相关的命令](#7-硬件相关的命令)\n8. [SS相关的命令](#8-SS相关的命令)\n9. [网络监控](#9-网络监控)\n10. [查看进程](#10-查看进程)\n11.[通用配置](#11-常用配置)\n\n[参考](#参考)\n\n\n### 1. 文件操作常用命令\n\n```shell\n- > cd //进入目录\n- > cd /  返回根目录\n- > pwd // 显示当前目录\n- > ls // 显示当前目录下内容\n\n- > mkdir //新建目录\n- > rmdir //删除目录,如果目录不为空，\n- >使用 rm -r //递归删除\n- > rm -rf //强制删除\n\n文件名一般不支持空格，如果真有的话得用单引号括起来，像这样:\n-> rm -f 'my file'\n-> mv a.mp4 b.mp4 //mv虽然是移动（Windows中的剪切）操作，但这种情况下就等同于重命名了，亲测有效\n\n# 重命名\nrename是实际意义上的重命名命令，但rename接受三个参数\n\n- > touch filename //创建文件，后缀在linux下没意义\n\n```\n\n\n\n复制粘贴：\n```shell\n- > cp a b //把a复制一份，命名为b\n\n- > cp d1 d2 // 这样是不行的，复制目录需要加上-r ，即\n- > cp -r d1 d2\n\n移动(左边是被移动的文件或目录，右边是目标路径)：\n\n- > mv d1 /  把d1移动到相对路径，也就是根目录下\n- > mv d1 ../把d1往上移动一层\n- > mv d1 ../../\n```\n\n\n\n###重定向\n\n```\n重定向输出 >\nls  > lsoutput.txt #用于将输出的结果写入一个新的文本文件中\necho 'hey man' # 类似于print\necho 'hello' > log.txt #把这句话写入到文本中 ，覆盖其原有内容\n\n重定向输入 <\nwall < aa.txt # wall是向所有用户发广播， 即从aa.txt中读取内容，然后广播发出去\n\n\n#service命令\nservice XXX start/stop/status #原理是将这些程序注册成为系统服务，这样调用这些程序的时候就不需要写一大堆绝对路径了，具体用法help已经很详细了。\n\nzip –q –r video.zip /home/video\nzip –q –r video.zip .  # .代表当前目录\n\n```\n\n\n\n### 2. Vi文本编辑器\n```shell\n- > vi 3.txt // 如果有则编辑，没有则直接创建\n\nVi分为命令模式和编辑模式，一进来是命令模式，输入'a'进入编辑模式\n切换回命令模式按'esc'\n命令模式下 :w 表示存盘\n- :q 退出\n\n- :wq 保存并退出\n- :q! 不保存退出（无内容变化）\n```\n\n\n在编辑模式下,输入 'dd'删除一行 ，输入'dw'删除一个词\n输入'o'插入一行。。。。。。\n\n\n\n\n\n```shell\n- > more filename//查看文件内容\n\n- > cat filename //正序查看文件内容\n\n- > tac filename //逆序查看文件内容\n\n- > head - 3 filename //只查看文件前面三行\n- > tail - 3 filename //只查看倒数后三行\n\n\n\n```\n\n\n更多命令如 find 、 whereis 、 Li(Link)\n查找：\n```shell\nfind / -name filename  //在根目录下查找文件\nfind /etc -name filename //在etc目录下查找文件\n\ngrep stringtofind filename //在指定的文本文件中查找指定的字符串\n\nwhereis ls //查看ls命令所执行的是哪个文件及其位置(查看系统文件所在路径)\n\n```\n\n### 3. linux下shell脚本语句的语法\nlinux大小写敏感\neg:\n```shell\n#!/bin/sh\nmyPath=\"/var/log/httpd/\"\nmyFile=\"/var /log/httpd/access.log\"\n#这里的-x 参数判断$myPath是否存在并且是否具有可执行权限\nif [ ! -x \"$myPath\"]; then\nmkdir \"$myPath\"\nfi\n#这里的-d 参数判断$myPath是否存在\nif [ ! -d \"$myPath\"]; then\nmkdir \"$myPath\"\nfi\n#这里的-f参数判断$myFile是否存在\nif [ ! -f \"$myFile\" ]; then\ntouch \"$myFile\"\nfi\n#其他参数还有-n,-n是判断一个变量是否是否有值\nif [ ! -n \"$myVar\" ]; then\necho \"$myVar is empty\"\nexit 0\nfi\n#两个变量判断是否相等\nif [ \"$var1\" == \"$var2\" ]; then  //if 后面必须加then\necho '$var1 eq $var2'\nelse\necho '$var1 not eq $var2'\nfi //else后面必须加fi\n\n\n       if list then\n           do something here\n       elif list then\n           do another thing here\n       else\n         do something else here\n       fi  \n```\n\neg: echo类似于print\n```shell\n例：myvar=“Hi there！”\n\n    echo $myvar\n\n    echo \"$myvar\"\n\n    echo ' $myvar'\n\n    echo \\$myvar\n\n将会输出如下：Hi there！\n\n              Hi there!\n\n              $myvar\n\n              $myvar\n```\n\n\n### 4. 用户和用户组的问题\n```shell\nuseradd user //添加用户，(-g 指定用户所在用户组)/home目录下会多一个user的目录，作为该用户的主目录\n\npasswd user //设置user的密码，会提示输入密码，密码不会显示在窗口中\n\ncd /etc >>> more passwd  ，这里面会显示所有的用户\nmore group ,显示用户组的信息\ngroupadd groupname //添加一个用户组\n\n//删除用户\nuserdel user //删除一个用户\n还需要删除该用户的主目录(rm -rf user)\n\n重启机器，登录页面选择新用户即可完成用户切换\n\n或者使用 su testuser 切换到testuser身份\nexit就回到root用户的身份\n\n新用户登录时，默认的pwd是该用户的主目录\n```\n\n\n\n\n### 5. 文件权限的问题\nls命令执行显示的文件前一般带有一串信息\n第一位：\n- 代表文件\nl代表链接\nd代表目录\n\n后面九位划分为三块，可能的权限有这么几种\nr(read权限)w(写权限)-(无权限)x(执行权限)\n\n第一组代表所有者(u)权限，第二组代表与所有者一个用户组的用户(g)的权限，第三组代表其他用户(0)的权限\n\n更改文件权限命令: chmod\n```shell\nchmod +x filename //加上可执行权限，所有用户都加上了\nchmod u+x filename //给当前用户加上可执行权限\n//其他命令不一一列举\n\n> u ：目录或者文件的当前的用户\n  g ：目录或者文件的当前的群组\n  o ：除了目录或者文件的当前用户或群组之外的用户或者群组\n  a ：所有的用户及群组\n\n\n> r ：读权限，用数字4表示\n  w ：写权限，用数字2表示\n  x ：执行权限，用数字1表示\n  - ：删除权限，用数字0表示\n\n所以给所有用户增加a.txt文件的可执行权限就像这样\nchmod a+x a.txt\n#其余自行发挥\nchmod a-x a.txt  #删除所有用户的可执行权限\n\n\nchmod 755 filename  \n751应该是读/写/执行\nchomod 444 filename# 为所有用户分配读权限\nchmod 777 filename //全部权限都有了，其实上面的9位就是这三位数每一位的二进制拼起来的\n755 就是 111101101,也就对应上面的权限九位字母\n\nchown -R Jane /foldername # 把flodername文件夹的所有者改为Jane， -R 表示递归，会保证所有子文件夹的所有者也被更改\n\n```\n\n更改文件所有者\n\n- > chown username filename\n\n\n### 6. 管道\n将一个命令的输出传送给另一个命令，作为另一个命令的输入\neg: 中间那条竖线叫做管道连接符\n```shell\n$ cat /etc/passwd | grep usernametofind\n$ ls -l | grep \"^d\"\n$ ls -l * | grep \"^-\" | wc -|   //\"^-\"表示不列出目录或链接，只展示目录；wc是数行数\n$ ls -l | grep \"^d\" //只列出目录\n```\n\n\n### 7. 硬件相关的命令\n\n[VPS跑分软件](https://github.com/Teddysun/across)\n\n\n> git clone下来\ncd across\nwget -qO- bench.sh | bash （亲测可用，也可以自己看Readme）\n或者 > curl -Lso- bench.sh | bash\n\n\n### BandWagon\n```\n----------------------------------------------------------------------\nCPU model            : Intel(R) Xeon(R) CPU E3-1275 v5 @ 3.60GHz\nNumber of cores      : 1\nCPU frequency        : 3600.041 MHz\nTotal size of Disk   : 12.0 GB (10.0 GB Used)\nTotal amount of Mem  : 256 MB (217 MB Used)\nTotal amount of Swap : 128 MB (122 MB Used)\nSystem uptime        : 2 days, 4 hour 20 min\nLoad average         : 0.06, 0.05, 0.01\nOS                   : Ubuntu 14.04.1 LTS\nArch                 : i686 (32 Bit)\nKernel               : 2.6.32-042stab123.3\n----------------------------------------------------------------------\nI/O speed(1st run)   : 855 MB/s\nI/O speed(2nd run)   : 1.0 GB/s\nI/O speed(3rd run)   : 1.0 GB/s\nAverage I/O speed    : 967.7 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         76.5MB/s\nLinode, Tokyo, JP               106.187.96.148          17.6MB/s\nLinode, Singapore, SG           139.162.23.4            8.18MB/s\nLinode, London, UK              176.58.107.39           8.67MB/s\nLinode, Frankfurt, DE           139.162.130.8           12.8MB/s\nLinode, Fremont, CA             50.116.14.9             9.40MB/s\nSoftlayer, Dallas, TX           173.192.68.18           62.3MB/s\nSoftlayer, Seattle, WA          67.228.112.250          66.0MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            12.2MB/s\nSoftlayer, Singapore, SG        119.81.28.170           11.8MB/s\nSoftlayer, HongKong, CN         119.81.130.170          13.2MB/s\n----------------------------------------------------------------------\n\n```\n### BuyVm\n```\nCPU model            : Intel(R) Xeon(R) CPU           L5639  @ 2.13GHz\nNumber of cores      : 1\nCPU frequency        : 2000.070 MHz\nTotal size of Disk   : 15.0 GB (1.3 GB Used)\nTotal amount of Mem  : 128 MB (80 MB Used)\nTotal amount of Swap : 128 MB (32 MB Used)\nSystem uptime        : 0 days, 22 hour 28 min\nLoad average         : 0.10, 0.04, 0.05\nOS                   : Ubuntu 14.04.2 LTS\nArch                 : i686 (32 Bit)\nKernel               : 2.6.32-openvz-042stab116.2-amd64\n----------------------------------------------------------------------\nI/O speed(1st run)   : 102 MB/s\nI/O speed(2nd run)   : 97.1 MB/s\nI/O speed(3rd run)   : 147 MB/s\nAverage I/O speed    : 115.4 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         14.7MB/s\nLinode, Tokyo, JP               106.187.96.148          6.15MB/s\nLinode, Singapore, SG           139.162.23.4            2.54MB/s\nLinode, London, UK              176.58.107.39           2.99MB/s\nLinode, Frankfurt, DE           139.162.130.8           2.96MB/s\nLinode, Fremont, CA             50.116.14.9             4.27MB/s\nSoftlayer, Dallas, TX           173.192.68.18           11.7MB/s\nSoftlayer, Seattle, WA          67.228.112.250          13.0MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            1.89MB/s\nSoftlayer, Singapore, SG        119.81.28.170           3.26MB/s\nSoftlayer, HongKong, CN         119.81.130.170          3.72MB/s\n----------------------------------------------------------------------\n```\n\n### DigitalOcean Los Angeles\n\n```\n----------------------------------------------------------------------\nCPU model            : Intel(R) Xeon(R) CPU E5-2650L v3 @ 1.80GHz\nNumber of cores      : 1\nCPU frequency        : 1799.998 MHz\nTotal size of Disk   : 20.2 GB (1.0 GB Used)\nTotal amount of Mem  : 488 MB (33 MB Used)\nTotal amount of Swap : 0 MB (0 MB Used)\nSystem uptime        : 0 days, 0 hour 3 min\nLoad average         : 0.16, 0.10, 0.03\nOS                   : Ubuntu 16.04.2 LTS\nArch                 : x86_64 (64 Bit)\nKernel               : 4.4.0-78-generic\n----------------------------------------------------------------------\nI/O speed(1st run)   : 581 MB/s\nI/O speed(2nd run)   : 711 MB/s\nI/O speed(3rd run)   : 777 MB/s\nAverage I/O speed    : 689.7 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         161MB/s\nLinode, Tokyo, JP               106.187.96.148          15.7MB/s\nLinode, Singapore, SG           139.162.23.4            5.96MB/s\nLinode, London, UK              176.58.107.39           5.71MB/s\nLinode, Frankfurt, DE           139.162.130.8           6.45MB/s\nLinode, Fremont, CA             50.116.14.9             30.4MB/s\nSoftlayer, Dallas, TX           173.192.68.18           29.9MB/s\nSoftlayer, Seattle, WA          67.228.112.250          57.7MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            3.64MB/s\nSoftlayer, Singapore, SG        119.81.28.170           7.59MB/s\nSoftlayer, HongKong, CN         119.81.130.170          8.84MB/s\n----------------------------------------------------------------------\n```\n\n### DigitalOcean Sinapore (ip adress lokks like Russian)\n```\n----------------------------------------------------------------------\nCPU model            : Intel(R) Xeon(R) CPU E5-2630L 0 @ 2.00GHz\nNumber of cores      : 1\nCPU frequency        : 1999.999 MHz\nTotal size of Disk   : 20.2 GB (1.0 GB Used)\nTotal amount of Mem  : 488 MB (36 MB Used)\nTotal amount of Swap : 0 MB (0 MB Used)\nSystem uptime        : 0 days, 0 hour 2 min\nLoad average         : 0.17, 0.20, 0.09\nOS                   : Ubuntu 16.04.2 LTS\nArch                 : x86_64 (64 Bit)\nKernel               : 4.4.0-78-generic\n----------------------------------------------------------------------\nI/O speed(1st run)   : 662 MB/s\nI/O speed(2nd run)   : 741 MB/s\nI/O speed(3rd run)   : 728 MB/s\nAverage I/O speed    : 710.3 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         20.8MB/s\nLinode, Tokyo, JP               106.187.96.148          18.6MB/s\nLinode, Singapore, SG           139.162.23.4            83.8MB/s\nLinode, London, UK              176.58.107.39           5.71MB/s\nLinode, Frankfurt, DE           139.162.130.8           8.13MB/s\nLinode, Fremont, CA             50.116.14.9             2.82MB/s\nSoftlayer, Dallas, TX           173.192.68.18           6.18MB/s\nSoftlayer, Seattle, WA          67.228.112.250          8.47MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            6.77MB/s\nSoftlayer, Singapore, SG        119.81.28.170           97.9MB/s\nSoftlayer, HongKong, CN         119.81.130.170          35.2MB/s\n----------------------------------------------------------------------\n\n```\n\n\n查看硬盘存储空间:\n````\ndf -h //h的意思是human-readable\ndu -sh //查看当前directory的大小\ndu -h //查看当前目录下各个子目录分别的大小\ndh -h img// 查看img目录下文件及文件夹的大小\ndh -h img/1.jpg //查看指定文件的大小\n````\n\n查看cpu信息\n> cat /proc/cpuinfo\n\n查看内存\n>free -m\nfree -h # human readable\n\n修改默认安全设置\n> vi /etc/ssh/ssd_config\n\n\n添加或修改\n\n```\nPort 22 (ssh默认端口修改)\nPermitRootLogin without-Password no\nAllowUsers userName\n```\n压缩文件命令\n将/home/video/ 这个目录下所有文件和文件夹打包为当前目录下的video.zip\n\nzip –q –r -v video.zip . #加上一个-v主要是为了能够实时查看输出\n\n\n文件传输（linux ->windows）： 一般使用putty ssh到Linux主机，想要把Linux上的文件弄到Windows中，需要使用pscp工具。下载好pscp.exe后，放到c:/windows/system32下面。打开cmd。输入命令\npscp -r root@202.123.123.123:\"/root/fileonServer.mp4\" d:/whateveriwantonmyPc.mp4  ，确认后输入root密码就好了。我主要是用来下载视频的。\n有时候会出现Connection Refused Error。\n> netstat -anp | grep sshd\n\n\n看下跑在哪个端口\n然后\n> pscp -P 12345-r root@202.123.123.123:\"/root/fileonServer.mp4\" d:/whateveriwantonmyPc.mp4  -p要大写\n\n\n\n\n### 8. SS相关的命令\n```\n  1. 刚装好的ubuntu需要执行以下步骤\n  安装git > apt-get install git\n  安装python > apt-get install python-2.7\n  安装python-setuptools > apt-get install python-setuptools\n  检查是否安装好： python --version\n\n\n  2. 下载shadowsocks源码编译\n > git clone https://github.com/shadowsocks/shadowsocks\n  # 记得切换到master分支\n  python setup.py build\n  python setup.py install\n\n  检查下版本 ssserver --version\n\n  3. 编辑配置文件\n  vim config.json\n  {\n   \"server\":\"my_server_ip\",\n   \"server_port\":8388,\n   \"local_address\": \"127.0.0.1\",\n   \"local_port\":1080,\n   \"password\":\"mypassword\",\n   \"timeout\":300,\n   \"method\":\"aes-256-cfb\",\n   \"fast_open\": false\n}\n\nssserver -c config.json -d start #启动完成\n\n检查下是否启动了\nps -ef |grep sss\n\nss 命令\nssserver -c /etc/shadowsocks/config.json # 前台运行\n\n- 后台运行和停止\nssserver -c /etc/shadowsocks.json -d start\nssserver -c /etc/shadowsocks.json -d stop\n\n- 加入开机启动\n\n在/etc/rc.local中加入\nsudo ssserver -c /etc/shadowsocks.json --user username -d start - 不要总是用root用户做事，adduser来做，给sudo权限即可\n\n[ShadowsocksR](https://github.com/breakwa11/shadowsocks-rss/wiki)启动后台运行命令\n> python server.py -p 443 -k password -m aes-256-cfb -O auth_sha1_v4 -o http_simple -d start\n\n[net-speeder](https://zhgcao.github.io/2016/05/26/ubuntu-install-net-speeder/)\nvenetX，OpenVZ架构\n\ncd net-speeder-master/\nsh build.sh -DCOOKED\n\nXen，KVM，物理机\ncd net-speeder-master/\nsh build.sh\n\n\n加速所有ip协议数据\n\n> ./net_speeder venet0 \"ip\"\n\n只加速指定端口，例如只加速TCP协议的 8989端口\n前提是切换到net-speeder的目录下\n> ./net_speeder venet0:0 \"tcp src port 8989\"\n\n./net_speeder venet0 \"ip\"\n\n只加速指定端口，例如只加速TCP协议的 8989端口\n前提是切换到net-speeder的目录下\n ./net_speeder venet0:0 \"tcp src port 8989\"\n\n\n [KVM架构升级内核开启BBR](https://qiujunya.com/linodebbr.html)\n```\n\n### 9. 网络监控\n\n\n```\ntcpdump -i \"venet0:0\"  //抓包的\ntcpdump -c 10 //count\ntcpdump -c -A  //Asicii码形式展示出来每个package\ntcpdump -c 5 -i wlo1 // 监听某一个网卡\ntcpdump -c 5 -i wlo1 port 22// 监听某一个网卡某一个端口\n\ntcpdump version 4.5.1\nlibpcap version 1.5.3\nUsage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ]\n                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\n                [ -i interface ] [ -j tstamptype ] [ -M secret ]\n                [ -P in|out|inout ]\n                [ -r file ] [ -s snaplen ] [ -T type ] [ -V file ] [ -w file ]\n                [ -W filecount ] [ -y datalinktype ] [ -z command ]\n                [ -Z user ] [ expression ]\n```\n\ntcpdump结合wireshark可实现完整的网络抓包\n\n```\nnetstat\nnetstat -i // 查看某个网络接口发出和接收了多少byte的数据\nnetstat -ta //当前active的网络连接\nnetstat -tan //以ip地址的方式展示出来\n```\n\n```\nifconfig // 查看机器上的网卡\nen01 //Ethernet\n注意 RX bytes(接收到的数据)和TX bytes(发送出去的数据)后面的数字\n```\n\n\n\n\n### 10.查看进程\n\n[起一个进程，后台运行，关掉终端照样跑的那种](https://stackoverflow.com/questions/4797050/how-to-run-process-as-background-and-never-die)\n\n>  nohup node server.js > /dev/null 2>&1 &\n\n```\nnohup node server.js > /dev/null 2>&1 &\n\n1. nohup means: Do not terminate this process even when the stty is cut off.\n2. > /dev/null means: stdout goes to /dev/null (which is a dummy device that does not record any output).\n3. 2>&1 means: stderr also goes to the stdout (which is already redirected to /dev/null). You may replace &1 with a file path to keep a log of errors, e.g.: 2>/tmp/myLog\n4. & at the end means: run this command as a background task.\n```\n\n\n```\ntop 动态显示\nPID：进程的ID[参数解释](http://www.cnblogs.com/gaojun/p/3406096.html)\n　　USER：进程所有者\n　　PR：进程的优先级别，越小越优先被执行\n　　NInice：值\n　　VIRT：进程占用的虚拟内存\n　　RES：进程占用的物理内存\n　　SHR：进程使用的共享内存\n　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数\n　　%CPU：进程占用CPU的使用率\n　　%MEM：进程使用的物理内存和总内存的百分比\n　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。\n　　COMMAND：进程启动命令名称\n\nps a 显示现行终端机下的所有程序，包括其他用户的程序。\n\n**看下某个进程跑在哪个端口**\n netstat -anp | grep sshd\n\nps | grep 类似于 pgrep XXX //查找某个进程\n\n进程命令\n*实时监控，1秒刷新一次*\nwatch -n 1 ps -aux --sort=-pmem,-pcpu\n```\n查看端口占用\n```\n#列出所有端口的占用情况\nnetstat -anp\nlsof -i # 这个也行\n#查看哪个进程占了http端口(其实就是80了)\nlsof -i:80\n#查看某个进程占了哪些端口\nnetstat -anp|grep pid\n```\n\n//杀进程（如果进程不属于当前用户，要sudo）\n> 杀进程，慎用。\nkill -9 进程id // 9直接干掉进程，慎用。。。\nkill pid // 这个和kill 15是一样的 //15表示terminate,请求进程停下来  \n\nkill -l //列出进程及id\n\nkillall nginx ->> 干掉nginx的所有进程\n\npkill -u username //干掉所有属于某一个用户的ps\n\nSignal (信号)  man signal\n\n进程状态\nrunnable、sleeping、zombie、stop\n\n//更改友善度,数字越小越不友好\nnice -n 15 /.....   命令path。启动的时候确定nice\nrenice -s pid //更改友善度\n\ndf -ah  // 查看mounted文件系统\nproc\n\n\n\n\n\n\n### 11 .常用配置\n\n> 查看登陆失败日志\ngrep \"Failed password for root\" /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr | more\n\n防范措施\n修改登陆端口号\nsudo vi /etc/ssh/sshd_config\nPort 4484\nPermitRootLogin no\n\n修改完成后重启ssh\n/etc/init.d/ssh restart\n\n\n\n[编码的修改](https://perlgeek.de/en/article/set-up-a-clean-utf8-environment)\n更改locale为utf-8(ubuntu)\n>\nvi ~/.bashrc\n\n# add these lines\nexport LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\nexport LANGUAGE=en_US.UTF-8\n\nsudo locale-gen \"en_US.UTF-8\"\nsudo dpkg-reconfigure locales\n\n\n\n\n### 参考\n\n\n- ![](http://odzl05jxx.bkt.clouddn.com/fork_you_git.jpg)\n- [文件大小查看命令](https://my.oschina.net/liting/blog/392051)\n- [文件压缩命令](http://blog.sina.com.cn/s/blog_7479f7990100zwkp.html)\n- [硬件查询](https://my.oschina.net/hunterli/blog/140783)\n- [Python源码编译安装ss](http://www.jianshu.com/p/3d80c7cb7b17)\n- [源码编译安装ss](http://blog.csdn.net/program_thinker/article/details/45787395)\n- [修改系统编码为utf-8](https://askubuntu.com/questions/162391/how-do-i-fix-my-locale-issue)\n","source":"_posts/2017-01-07-Linux-Basic-Commands.md","raw":"---\ntitle: linux基本命令介绍\ndate: 2017-01-07 15:38:43\ncategories: blog\ntags: [置顶,linux,tools]\ntop : 1\n---\n\n一些常用的linux基本命令,仅作为参考。</br>\n![](http://odzl05jxx.bkt.clouddn.com/849c18412f8e7a0b18df09f6f87e6516.jpg?imageView2/2/w/600)\n <!--more-->\n\n首先是连接vps的ssh(Secure Shell)工具，putty或者xshell都可以。\n\n## 速查手册\n1. [文件操作](#1-文件操作常用命令)\n2. [Vi文本编辑器](#2-Vi文本编辑器)\n3. [bash脚本怎么写](#3-linux下shell脚本语句的语法)\n4. [用户和用户组的问题](#4-用户和用户组的问题)\n5. [文件权限](#5-文件权限的问题)\n6. [管道](#6-管道)\n7. [硬件相关的命令](#7-硬件相关的命令)\n8. [SS相关的命令](#8-SS相关的命令)\n9. [网络监控](#9-网络监控)\n10. [查看进程](#10-查看进程)\n11.[通用配置](#11-常用配置)\n\n[参考](#参考)\n\n\n### 1. 文件操作常用命令\n\n```shell\n- > cd //进入目录\n- > cd /  返回根目录\n- > pwd // 显示当前目录\n- > ls // 显示当前目录下内容\n\n- > mkdir //新建目录\n- > rmdir //删除目录,如果目录不为空，\n- >使用 rm -r //递归删除\n- > rm -rf //强制删除\n\n文件名一般不支持空格，如果真有的话得用单引号括起来，像这样:\n-> rm -f 'my file'\n-> mv a.mp4 b.mp4 //mv虽然是移动（Windows中的剪切）操作，但这种情况下就等同于重命名了，亲测有效\n\n# 重命名\nrename是实际意义上的重命名命令，但rename接受三个参数\n\n- > touch filename //创建文件，后缀在linux下没意义\n\n```\n\n\n\n复制粘贴：\n```shell\n- > cp a b //把a复制一份，命名为b\n\n- > cp d1 d2 // 这样是不行的，复制目录需要加上-r ，即\n- > cp -r d1 d2\n\n移动(左边是被移动的文件或目录，右边是目标路径)：\n\n- > mv d1 /  把d1移动到相对路径，也就是根目录下\n- > mv d1 ../把d1往上移动一层\n- > mv d1 ../../\n```\n\n\n\n###重定向\n\n```\n重定向输出 >\nls  > lsoutput.txt #用于将输出的结果写入一个新的文本文件中\necho 'hey man' # 类似于print\necho 'hello' > log.txt #把这句话写入到文本中 ，覆盖其原有内容\n\n重定向输入 <\nwall < aa.txt # wall是向所有用户发广播， 即从aa.txt中读取内容，然后广播发出去\n\n\n#service命令\nservice XXX start/stop/status #原理是将这些程序注册成为系统服务，这样调用这些程序的时候就不需要写一大堆绝对路径了，具体用法help已经很详细了。\n\nzip –q –r video.zip /home/video\nzip –q –r video.zip .  # .代表当前目录\n\n```\n\n\n\n### 2. Vi文本编辑器\n```shell\n- > vi 3.txt // 如果有则编辑，没有则直接创建\n\nVi分为命令模式和编辑模式，一进来是命令模式，输入'a'进入编辑模式\n切换回命令模式按'esc'\n命令模式下 :w 表示存盘\n- :q 退出\n\n- :wq 保存并退出\n- :q! 不保存退出（无内容变化）\n```\n\n\n在编辑模式下,输入 'dd'删除一行 ，输入'dw'删除一个词\n输入'o'插入一行。。。。。。\n\n\n\n\n\n```shell\n- > more filename//查看文件内容\n\n- > cat filename //正序查看文件内容\n\n- > tac filename //逆序查看文件内容\n\n- > head - 3 filename //只查看文件前面三行\n- > tail - 3 filename //只查看倒数后三行\n\n\n\n```\n\n\n更多命令如 find 、 whereis 、 Li(Link)\n查找：\n```shell\nfind / -name filename  //在根目录下查找文件\nfind /etc -name filename //在etc目录下查找文件\n\ngrep stringtofind filename //在指定的文本文件中查找指定的字符串\n\nwhereis ls //查看ls命令所执行的是哪个文件及其位置(查看系统文件所在路径)\n\n```\n\n### 3. linux下shell脚本语句的语法\nlinux大小写敏感\neg:\n```shell\n#!/bin/sh\nmyPath=\"/var/log/httpd/\"\nmyFile=\"/var /log/httpd/access.log\"\n#这里的-x 参数判断$myPath是否存在并且是否具有可执行权限\nif [ ! -x \"$myPath\"]; then\nmkdir \"$myPath\"\nfi\n#这里的-d 参数判断$myPath是否存在\nif [ ! -d \"$myPath\"]; then\nmkdir \"$myPath\"\nfi\n#这里的-f参数判断$myFile是否存在\nif [ ! -f \"$myFile\" ]; then\ntouch \"$myFile\"\nfi\n#其他参数还有-n,-n是判断一个变量是否是否有值\nif [ ! -n \"$myVar\" ]; then\necho \"$myVar is empty\"\nexit 0\nfi\n#两个变量判断是否相等\nif [ \"$var1\" == \"$var2\" ]; then  //if 后面必须加then\necho '$var1 eq $var2'\nelse\necho '$var1 not eq $var2'\nfi //else后面必须加fi\n\n\n       if list then\n           do something here\n       elif list then\n           do another thing here\n       else\n         do something else here\n       fi  \n```\n\neg: echo类似于print\n```shell\n例：myvar=“Hi there！”\n\n    echo $myvar\n\n    echo \"$myvar\"\n\n    echo ' $myvar'\n\n    echo \\$myvar\n\n将会输出如下：Hi there！\n\n              Hi there!\n\n              $myvar\n\n              $myvar\n```\n\n\n### 4. 用户和用户组的问题\n```shell\nuseradd user //添加用户，(-g 指定用户所在用户组)/home目录下会多一个user的目录，作为该用户的主目录\n\npasswd user //设置user的密码，会提示输入密码，密码不会显示在窗口中\n\ncd /etc >>> more passwd  ，这里面会显示所有的用户\nmore group ,显示用户组的信息\ngroupadd groupname //添加一个用户组\n\n//删除用户\nuserdel user //删除一个用户\n还需要删除该用户的主目录(rm -rf user)\n\n重启机器，登录页面选择新用户即可完成用户切换\n\n或者使用 su testuser 切换到testuser身份\nexit就回到root用户的身份\n\n新用户登录时，默认的pwd是该用户的主目录\n```\n\n\n\n\n### 5. 文件权限的问题\nls命令执行显示的文件前一般带有一串信息\n第一位：\n- 代表文件\nl代表链接\nd代表目录\n\n后面九位划分为三块，可能的权限有这么几种\nr(read权限)w(写权限)-(无权限)x(执行权限)\n\n第一组代表所有者(u)权限，第二组代表与所有者一个用户组的用户(g)的权限，第三组代表其他用户(0)的权限\n\n更改文件权限命令: chmod\n```shell\nchmod +x filename //加上可执行权限，所有用户都加上了\nchmod u+x filename //给当前用户加上可执行权限\n//其他命令不一一列举\n\n> u ：目录或者文件的当前的用户\n  g ：目录或者文件的当前的群组\n  o ：除了目录或者文件的当前用户或群组之外的用户或者群组\n  a ：所有的用户及群组\n\n\n> r ：读权限，用数字4表示\n  w ：写权限，用数字2表示\n  x ：执行权限，用数字1表示\n  - ：删除权限，用数字0表示\n\n所以给所有用户增加a.txt文件的可执行权限就像这样\nchmod a+x a.txt\n#其余自行发挥\nchmod a-x a.txt  #删除所有用户的可执行权限\n\n\nchmod 755 filename  \n751应该是读/写/执行\nchomod 444 filename# 为所有用户分配读权限\nchmod 777 filename //全部权限都有了，其实上面的9位就是这三位数每一位的二进制拼起来的\n755 就是 111101101,也就对应上面的权限九位字母\n\nchown -R Jane /foldername # 把flodername文件夹的所有者改为Jane， -R 表示递归，会保证所有子文件夹的所有者也被更改\n\n```\n\n更改文件所有者\n\n- > chown username filename\n\n\n### 6. 管道\n将一个命令的输出传送给另一个命令，作为另一个命令的输入\neg: 中间那条竖线叫做管道连接符\n```shell\n$ cat /etc/passwd | grep usernametofind\n$ ls -l | grep \"^d\"\n$ ls -l * | grep \"^-\" | wc -|   //\"^-\"表示不列出目录或链接，只展示目录；wc是数行数\n$ ls -l | grep \"^d\" //只列出目录\n```\n\n\n### 7. 硬件相关的命令\n\n[VPS跑分软件](https://github.com/Teddysun/across)\n\n\n> git clone下来\ncd across\nwget -qO- bench.sh | bash （亲测可用，也可以自己看Readme）\n或者 > curl -Lso- bench.sh | bash\n\n\n### BandWagon\n```\n----------------------------------------------------------------------\nCPU model            : Intel(R) Xeon(R) CPU E3-1275 v5 @ 3.60GHz\nNumber of cores      : 1\nCPU frequency        : 3600.041 MHz\nTotal size of Disk   : 12.0 GB (10.0 GB Used)\nTotal amount of Mem  : 256 MB (217 MB Used)\nTotal amount of Swap : 128 MB (122 MB Used)\nSystem uptime        : 2 days, 4 hour 20 min\nLoad average         : 0.06, 0.05, 0.01\nOS                   : Ubuntu 14.04.1 LTS\nArch                 : i686 (32 Bit)\nKernel               : 2.6.32-042stab123.3\n----------------------------------------------------------------------\nI/O speed(1st run)   : 855 MB/s\nI/O speed(2nd run)   : 1.0 GB/s\nI/O speed(3rd run)   : 1.0 GB/s\nAverage I/O speed    : 967.7 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         76.5MB/s\nLinode, Tokyo, JP               106.187.96.148          17.6MB/s\nLinode, Singapore, SG           139.162.23.4            8.18MB/s\nLinode, London, UK              176.58.107.39           8.67MB/s\nLinode, Frankfurt, DE           139.162.130.8           12.8MB/s\nLinode, Fremont, CA             50.116.14.9             9.40MB/s\nSoftlayer, Dallas, TX           173.192.68.18           62.3MB/s\nSoftlayer, Seattle, WA          67.228.112.250          66.0MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            12.2MB/s\nSoftlayer, Singapore, SG        119.81.28.170           11.8MB/s\nSoftlayer, HongKong, CN         119.81.130.170          13.2MB/s\n----------------------------------------------------------------------\n\n```\n### BuyVm\n```\nCPU model            : Intel(R) Xeon(R) CPU           L5639  @ 2.13GHz\nNumber of cores      : 1\nCPU frequency        : 2000.070 MHz\nTotal size of Disk   : 15.0 GB (1.3 GB Used)\nTotal amount of Mem  : 128 MB (80 MB Used)\nTotal amount of Swap : 128 MB (32 MB Used)\nSystem uptime        : 0 days, 22 hour 28 min\nLoad average         : 0.10, 0.04, 0.05\nOS                   : Ubuntu 14.04.2 LTS\nArch                 : i686 (32 Bit)\nKernel               : 2.6.32-openvz-042stab116.2-amd64\n----------------------------------------------------------------------\nI/O speed(1st run)   : 102 MB/s\nI/O speed(2nd run)   : 97.1 MB/s\nI/O speed(3rd run)   : 147 MB/s\nAverage I/O speed    : 115.4 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         14.7MB/s\nLinode, Tokyo, JP               106.187.96.148          6.15MB/s\nLinode, Singapore, SG           139.162.23.4            2.54MB/s\nLinode, London, UK              176.58.107.39           2.99MB/s\nLinode, Frankfurt, DE           139.162.130.8           2.96MB/s\nLinode, Fremont, CA             50.116.14.9             4.27MB/s\nSoftlayer, Dallas, TX           173.192.68.18           11.7MB/s\nSoftlayer, Seattle, WA          67.228.112.250          13.0MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            1.89MB/s\nSoftlayer, Singapore, SG        119.81.28.170           3.26MB/s\nSoftlayer, HongKong, CN         119.81.130.170          3.72MB/s\n----------------------------------------------------------------------\n```\n\n### DigitalOcean Los Angeles\n\n```\n----------------------------------------------------------------------\nCPU model            : Intel(R) Xeon(R) CPU E5-2650L v3 @ 1.80GHz\nNumber of cores      : 1\nCPU frequency        : 1799.998 MHz\nTotal size of Disk   : 20.2 GB (1.0 GB Used)\nTotal amount of Mem  : 488 MB (33 MB Used)\nTotal amount of Swap : 0 MB (0 MB Used)\nSystem uptime        : 0 days, 0 hour 3 min\nLoad average         : 0.16, 0.10, 0.03\nOS                   : Ubuntu 16.04.2 LTS\nArch                 : x86_64 (64 Bit)\nKernel               : 4.4.0-78-generic\n----------------------------------------------------------------------\nI/O speed(1st run)   : 581 MB/s\nI/O speed(2nd run)   : 711 MB/s\nI/O speed(3rd run)   : 777 MB/s\nAverage I/O speed    : 689.7 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         161MB/s\nLinode, Tokyo, JP               106.187.96.148          15.7MB/s\nLinode, Singapore, SG           139.162.23.4            5.96MB/s\nLinode, London, UK              176.58.107.39           5.71MB/s\nLinode, Frankfurt, DE           139.162.130.8           6.45MB/s\nLinode, Fremont, CA             50.116.14.9             30.4MB/s\nSoftlayer, Dallas, TX           173.192.68.18           29.9MB/s\nSoftlayer, Seattle, WA          67.228.112.250          57.7MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            3.64MB/s\nSoftlayer, Singapore, SG        119.81.28.170           7.59MB/s\nSoftlayer, HongKong, CN         119.81.130.170          8.84MB/s\n----------------------------------------------------------------------\n```\n\n### DigitalOcean Sinapore (ip adress lokks like Russian)\n```\n----------------------------------------------------------------------\nCPU model            : Intel(R) Xeon(R) CPU E5-2630L 0 @ 2.00GHz\nNumber of cores      : 1\nCPU frequency        : 1999.999 MHz\nTotal size of Disk   : 20.2 GB (1.0 GB Used)\nTotal amount of Mem  : 488 MB (36 MB Used)\nTotal amount of Swap : 0 MB (0 MB Used)\nSystem uptime        : 0 days, 0 hour 2 min\nLoad average         : 0.17, 0.20, 0.09\nOS                   : Ubuntu 16.04.2 LTS\nArch                 : x86_64 (64 Bit)\nKernel               : 4.4.0-78-generic\n----------------------------------------------------------------------\nI/O speed(1st run)   : 662 MB/s\nI/O speed(2nd run)   : 741 MB/s\nI/O speed(3rd run)   : 728 MB/s\nAverage I/O speed    : 710.3 MB/s\n----------------------------------------------------------------------\nNode Name                       IPv4 address            Download Speed\nCacheFly                        205.234.175.175         20.8MB/s\nLinode, Tokyo, JP               106.187.96.148          18.6MB/s\nLinode, Singapore, SG           139.162.23.4            83.8MB/s\nLinode, London, UK              176.58.107.39           5.71MB/s\nLinode, Frankfurt, DE           139.162.130.8           8.13MB/s\nLinode, Fremont, CA             50.116.14.9             2.82MB/s\nSoftlayer, Dallas, TX           173.192.68.18           6.18MB/s\nSoftlayer, Seattle, WA          67.228.112.250          8.47MB/s\nSoftlayer, Frankfurt, DE        159.122.69.4            6.77MB/s\nSoftlayer, Singapore, SG        119.81.28.170           97.9MB/s\nSoftlayer, HongKong, CN         119.81.130.170          35.2MB/s\n----------------------------------------------------------------------\n\n```\n\n\n查看硬盘存储空间:\n````\ndf -h //h的意思是human-readable\ndu -sh //查看当前directory的大小\ndu -h //查看当前目录下各个子目录分别的大小\ndh -h img// 查看img目录下文件及文件夹的大小\ndh -h img/1.jpg //查看指定文件的大小\n````\n\n查看cpu信息\n> cat /proc/cpuinfo\n\n查看内存\n>free -m\nfree -h # human readable\n\n修改默认安全设置\n> vi /etc/ssh/ssd_config\n\n\n添加或修改\n\n```\nPort 22 (ssh默认端口修改)\nPermitRootLogin without-Password no\nAllowUsers userName\n```\n压缩文件命令\n将/home/video/ 这个目录下所有文件和文件夹打包为当前目录下的video.zip\n\nzip –q –r -v video.zip . #加上一个-v主要是为了能够实时查看输出\n\n\n文件传输（linux ->windows）： 一般使用putty ssh到Linux主机，想要把Linux上的文件弄到Windows中，需要使用pscp工具。下载好pscp.exe后，放到c:/windows/system32下面。打开cmd。输入命令\npscp -r root@202.123.123.123:\"/root/fileonServer.mp4\" d:/whateveriwantonmyPc.mp4  ，确认后输入root密码就好了。我主要是用来下载视频的。\n有时候会出现Connection Refused Error。\n> netstat -anp | grep sshd\n\n\n看下跑在哪个端口\n然后\n> pscp -P 12345-r root@202.123.123.123:\"/root/fileonServer.mp4\" d:/whateveriwantonmyPc.mp4  -p要大写\n\n\n\n\n### 8. SS相关的命令\n```\n  1. 刚装好的ubuntu需要执行以下步骤\n  安装git > apt-get install git\n  安装python > apt-get install python-2.7\n  安装python-setuptools > apt-get install python-setuptools\n  检查是否安装好： python --version\n\n\n  2. 下载shadowsocks源码编译\n > git clone https://github.com/shadowsocks/shadowsocks\n  # 记得切换到master分支\n  python setup.py build\n  python setup.py install\n\n  检查下版本 ssserver --version\n\n  3. 编辑配置文件\n  vim config.json\n  {\n   \"server\":\"my_server_ip\",\n   \"server_port\":8388,\n   \"local_address\": \"127.0.0.1\",\n   \"local_port\":1080,\n   \"password\":\"mypassword\",\n   \"timeout\":300,\n   \"method\":\"aes-256-cfb\",\n   \"fast_open\": false\n}\n\nssserver -c config.json -d start #启动完成\n\n检查下是否启动了\nps -ef |grep sss\n\nss 命令\nssserver -c /etc/shadowsocks/config.json # 前台运行\n\n- 后台运行和停止\nssserver -c /etc/shadowsocks.json -d start\nssserver -c /etc/shadowsocks.json -d stop\n\n- 加入开机启动\n\n在/etc/rc.local中加入\nsudo ssserver -c /etc/shadowsocks.json --user username -d start - 不要总是用root用户做事，adduser来做，给sudo权限即可\n\n[ShadowsocksR](https://github.com/breakwa11/shadowsocks-rss/wiki)启动后台运行命令\n> python server.py -p 443 -k password -m aes-256-cfb -O auth_sha1_v4 -o http_simple -d start\n\n[net-speeder](https://zhgcao.github.io/2016/05/26/ubuntu-install-net-speeder/)\nvenetX，OpenVZ架构\n\ncd net-speeder-master/\nsh build.sh -DCOOKED\n\nXen，KVM，物理机\ncd net-speeder-master/\nsh build.sh\n\n\n加速所有ip协议数据\n\n> ./net_speeder venet0 \"ip\"\n\n只加速指定端口，例如只加速TCP协议的 8989端口\n前提是切换到net-speeder的目录下\n> ./net_speeder venet0:0 \"tcp src port 8989\"\n\n./net_speeder venet0 \"ip\"\n\n只加速指定端口，例如只加速TCP协议的 8989端口\n前提是切换到net-speeder的目录下\n ./net_speeder venet0:0 \"tcp src port 8989\"\n\n\n [KVM架构升级内核开启BBR](https://qiujunya.com/linodebbr.html)\n```\n\n### 9. 网络监控\n\n\n```\ntcpdump -i \"venet0:0\"  //抓包的\ntcpdump -c 10 //count\ntcpdump -c -A  //Asicii码形式展示出来每个package\ntcpdump -c 5 -i wlo1 // 监听某一个网卡\ntcpdump -c 5 -i wlo1 port 22// 监听某一个网卡某一个端口\n\ntcpdump version 4.5.1\nlibpcap version 1.5.3\nUsage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ]\n                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\n                [ -i interface ] [ -j tstamptype ] [ -M secret ]\n                [ -P in|out|inout ]\n                [ -r file ] [ -s snaplen ] [ -T type ] [ -V file ] [ -w file ]\n                [ -W filecount ] [ -y datalinktype ] [ -z command ]\n                [ -Z user ] [ expression ]\n```\n\ntcpdump结合wireshark可实现完整的网络抓包\n\n```\nnetstat\nnetstat -i // 查看某个网络接口发出和接收了多少byte的数据\nnetstat -ta //当前active的网络连接\nnetstat -tan //以ip地址的方式展示出来\n```\n\n```\nifconfig // 查看机器上的网卡\nen01 //Ethernet\n注意 RX bytes(接收到的数据)和TX bytes(发送出去的数据)后面的数字\n```\n\n\n\n\n### 10.查看进程\n\n[起一个进程，后台运行，关掉终端照样跑的那种](https://stackoverflow.com/questions/4797050/how-to-run-process-as-background-and-never-die)\n\n>  nohup node server.js > /dev/null 2>&1 &\n\n```\nnohup node server.js > /dev/null 2>&1 &\n\n1. nohup means: Do not terminate this process even when the stty is cut off.\n2. > /dev/null means: stdout goes to /dev/null (which is a dummy device that does not record any output).\n3. 2>&1 means: stderr also goes to the stdout (which is already redirected to /dev/null). You may replace &1 with a file path to keep a log of errors, e.g.: 2>/tmp/myLog\n4. & at the end means: run this command as a background task.\n```\n\n\n```\ntop 动态显示\nPID：进程的ID[参数解释](http://www.cnblogs.com/gaojun/p/3406096.html)\n　　USER：进程所有者\n　　PR：进程的优先级别，越小越优先被执行\n　　NInice：值\n　　VIRT：进程占用的虚拟内存\n　　RES：进程占用的物理内存\n　　SHR：进程使用的共享内存\n　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数\n　　%CPU：进程占用CPU的使用率\n　　%MEM：进程使用的物理内存和总内存的百分比\n　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。\n　　COMMAND：进程启动命令名称\n\nps a 显示现行终端机下的所有程序，包括其他用户的程序。\n\n**看下某个进程跑在哪个端口**\n netstat -anp | grep sshd\n\nps | grep 类似于 pgrep XXX //查找某个进程\n\n进程命令\n*实时监控，1秒刷新一次*\nwatch -n 1 ps -aux --sort=-pmem,-pcpu\n```\n查看端口占用\n```\n#列出所有端口的占用情况\nnetstat -anp\nlsof -i # 这个也行\n#查看哪个进程占了http端口(其实就是80了)\nlsof -i:80\n#查看某个进程占了哪些端口\nnetstat -anp|grep pid\n```\n\n//杀进程（如果进程不属于当前用户，要sudo）\n> 杀进程，慎用。\nkill -9 进程id // 9直接干掉进程，慎用。。。\nkill pid // 这个和kill 15是一样的 //15表示terminate,请求进程停下来  \n\nkill -l //列出进程及id\n\nkillall nginx ->> 干掉nginx的所有进程\n\npkill -u username //干掉所有属于某一个用户的ps\n\nSignal (信号)  man signal\n\n进程状态\nrunnable、sleeping、zombie、stop\n\n//更改友善度,数字越小越不友好\nnice -n 15 /.....   命令path。启动的时候确定nice\nrenice -s pid //更改友善度\n\ndf -ah  // 查看mounted文件系统\nproc\n\n\n\n\n\n\n### 11 .常用配置\n\n> 查看登陆失败日志\ngrep \"Failed password for root\" /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr | more\n\n防范措施\n修改登陆端口号\nsudo vi /etc/ssh/sshd_config\nPort 4484\nPermitRootLogin no\n\n修改完成后重启ssh\n/etc/init.d/ssh restart\n\n\n\n[编码的修改](https://perlgeek.de/en/article/set-up-a-clean-utf8-environment)\n更改locale为utf-8(ubuntu)\n>\nvi ~/.bashrc\n\n# add these lines\nexport LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\nexport LANGUAGE=en_US.UTF-8\n\nsudo locale-gen \"en_US.UTF-8\"\nsudo dpkg-reconfigure locales\n\n\n\n\n### 参考\n\n\n- ![](http://odzl05jxx.bkt.clouddn.com/fork_you_git.jpg)\n- [文件大小查看命令](https://my.oschina.net/liting/blog/392051)\n- [文件压缩命令](http://blog.sina.com.cn/s/blog_7479f7990100zwkp.html)\n- [硬件查询](https://my.oschina.net/hunterli/blog/140783)\n- [Python源码编译安装ss](http://www.jianshu.com/p/3d80c7cb7b17)\n- [源码编译安装ss](http://blog.csdn.net/program_thinker/article/details/45787395)\n- [修改系统编码为utf-8](https://askubuntu.com/questions/162391/how-do-i-fix-my-locale-issue)\n","slug":"2017-01-07-Linux-Basic-Commands","published":1,"updated":"2017-07-23T11:24:00.414Z","_id":"cj5gmdnh80010bovr38nskbjn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一些常用的linux基本命令,仅作为参考。</br><br><img src=\"http://odzl05jxx.bkt.clouddn.com/849c18412f8e7a0b18df09f6f87e6516.jpg?imageView2/2/w/600\" alt=\"\"><br> <a id=\"more\"></a></p>\n<p>首先是连接vps的ssh(Secure Shell)工具，putty或者xshell都可以。</p>\n<h2 id=\"速查手册\"><a href=\"#速查手册\" class=\"headerlink\" title=\"速查手册\"></a>速查手册</h2><ol>\n<li><a href=\"#1-文件操作常用命令\">文件操作</a></li>\n<li><a href=\"#2-Vi文本编辑器\">Vi文本编辑器</a></li>\n<li><a href=\"#3-linux下shell脚本语句的语法\">bash脚本怎么写</a></li>\n<li><a href=\"#4-用户和用户组的问题\">用户和用户组的问题</a></li>\n<li><a href=\"#5-文件权限的问题\">文件权限</a></li>\n<li><a href=\"#6-管道\">管道</a></li>\n<li><a href=\"#7-硬件相关的命令\">硬件相关的命令</a></li>\n<li><a href=\"#8-SS相关的命令\">SS相关的命令</a></li>\n<li><a href=\"#9-网络监控\">网络监控</a></li>\n<li><a href=\"#10-查看进程\">查看进程</a><br>11.<a href=\"#11-常用配置\">通用配置</a></li>\n</ol>\n<p><a href=\"#参考\">参考</a></p>\n<h3 id=\"1-文件操作常用命令\"><a href=\"#1-文件操作常用命令\" class=\"headerlink\" title=\"1. 文件操作常用命令\"></a>1. 文件操作常用命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; cd //进入目录</div><div class=\"line\">- &gt; cd /  返回根目录</div><div class=\"line\">- &gt; pwd // 显示当前目录</div><div class=\"line\">- &gt; ls // 显示当前目录下内容</div><div class=\"line\"></div><div class=\"line\">- &gt; mkdir //新建目录</div><div class=\"line\">- &gt; rmdir //删除目录,如果目录不为空，</div><div class=\"line\">- &gt;使用 rm -r //递归删除</div><div class=\"line\">- &gt; rm -rf //强制删除</div><div class=\"line\"></div><div class=\"line\">文件名一般不支持空格，如果真有的话得用单引号括起来，像这样:</div><div class=\"line\">-&gt; rm -f &apos;my file&apos;</div><div class=\"line\">-&gt; mv a.mp4 b.mp4 //mv虽然是移动（Windows中的剪切）操作，但这种情况下就等同于重命名了，亲测有效</div><div class=\"line\"></div><div class=\"line\"># 重命名</div><div class=\"line\">rename是实际意义上的重命名命令，但rename接受三个参数</div><div class=\"line\"></div><div class=\"line\">- &gt; touch filename //创建文件，后缀在linux下没意义</div></pre></td></tr></table></figure>\n<p>复制粘贴：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; cp a b //把a复制一份，命名为b</div><div class=\"line\"></div><div class=\"line\">- &gt; cp d1 d2 // 这样是不行的，复制目录需要加上-r ，即</div><div class=\"line\">- &gt; cp -r d1 d2</div><div class=\"line\"></div><div class=\"line\">移动(左边是被移动的文件或目录，右边是目标路径)：</div><div class=\"line\"></div><div class=\"line\">- &gt; mv d1 /  把d1移动到相对路径，也就是根目录下</div><div class=\"line\">- &gt; mv d1 ../把d1往上移动一层</div><div class=\"line\">- &gt; mv d1 ../../</div></pre></td></tr></table></figure></p>\n<p>###重定向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">重定向输出 &gt;</div><div class=\"line\">ls  &gt; lsoutput.txt #用于将输出的结果写入一个新的文本文件中</div><div class=\"line\">echo &apos;hey man&apos; # 类似于print</div><div class=\"line\">echo &apos;hello&apos; &gt; log.txt #把这句话写入到文本中 ，覆盖其原有内容</div><div class=\"line\"></div><div class=\"line\">重定向输入 &lt;</div><div class=\"line\">wall &lt; aa.txt # wall是向所有用户发广播， 即从aa.txt中读取内容，然后广播发出去</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#service命令</div><div class=\"line\">service XXX start/stop/status #原理是将这些程序注册成为系统服务，这样调用这些程序的时候就不需要写一大堆绝对路径了，具体用法help已经很详细了。</div><div class=\"line\"></div><div class=\"line\">zip –q –r video.zip /home/video</div><div class=\"line\">zip –q –r video.zip .  # .代表当前目录</div></pre></td></tr></table></figure>\n<h3 id=\"2-Vi文本编辑器\"><a href=\"#2-Vi文本编辑器\" class=\"headerlink\" title=\"2. Vi文本编辑器\"></a>2. Vi文本编辑器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; vi 3.txt // 如果有则编辑，没有则直接创建</div><div class=\"line\"></div><div class=\"line\">Vi分为命令模式和编辑模式，一进来是命令模式，输入&apos;a&apos;进入编辑模式</div><div class=\"line\">切换回命令模式按&apos;esc&apos;</div><div class=\"line\">命令模式下 :w 表示存盘</div><div class=\"line\">- :q 退出</div><div class=\"line\"></div><div class=\"line\">- :wq 保存并退出</div><div class=\"line\">- :q! 不保存退出（无内容变化）</div></pre></td></tr></table></figure>\n<p>在编辑模式下,输入 ‘dd’删除一行 ，输入’dw’删除一个词<br>输入’o’插入一行。。。。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; more filename//查看文件内容</div><div class=\"line\"></div><div class=\"line\">- &gt; cat filename //正序查看文件内容</div><div class=\"line\"></div><div class=\"line\">- &gt; tac filename //逆序查看文件内容</div><div class=\"line\"></div><div class=\"line\">- &gt; head - 3 filename //只查看文件前面三行</div><div class=\"line\">- &gt; tail - 3 filename //只查看倒数后三行</div></pre></td></tr></table></figure>\n<p>更多命令如 find 、 whereis 、 Li(Link)<br>查找：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">find / -name filename  //在根目录下查找文件</div><div class=\"line\">find /etc -name filename //在etc目录下查找文件</div><div class=\"line\"></div><div class=\"line\">grep stringtofind filename //在指定的文本文件中查找指定的字符串</div><div class=\"line\"></div><div class=\"line\">whereis ls //查看ls命令所执行的是哪个文件及其位置(查看系统文件所在路径)</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-linux下shell脚本语句的语法\"><a href=\"#3-linux下shell脚本语句的语法\" class=\"headerlink\" title=\"3. linux下shell脚本语句的语法\"></a>3. linux下shell脚本语句的语法</h3><p>linux大小写敏感<br>eg:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">myPath=&quot;/var/log/httpd/&quot;</div><div class=\"line\">myFile=&quot;/var /log/httpd/access.log&quot;</div><div class=\"line\">#这里的-x 参数判断$myPath是否存在并且是否具有可执行权限</div><div class=\"line\">if [ ! -x &quot;$myPath&quot;]; then</div><div class=\"line\">mkdir &quot;$myPath&quot;</div><div class=\"line\">fi</div><div class=\"line\">#这里的-d 参数判断$myPath是否存在</div><div class=\"line\">if [ ! -d &quot;$myPath&quot;]; then</div><div class=\"line\">mkdir &quot;$myPath&quot;</div><div class=\"line\">fi</div><div class=\"line\">#这里的-f参数判断$myFile是否存在</div><div class=\"line\">if [ ! -f &quot;$myFile&quot; ]; then</div><div class=\"line\">touch &quot;$myFile&quot;</div><div class=\"line\">fi</div><div class=\"line\">#其他参数还有-n,-n是判断一个变量是否是否有值</div><div class=\"line\">if [ ! -n &quot;$myVar&quot; ]; then</div><div class=\"line\">echo &quot;$myVar is empty&quot;</div><div class=\"line\">exit 0</div><div class=\"line\">fi</div><div class=\"line\">#两个变量判断是否相等</div><div class=\"line\">if [ &quot;$var1&quot; == &quot;$var2&quot; ]; then  //if 后面必须加then</div><div class=\"line\">echo &apos;$var1 eq $var2&apos;</div><div class=\"line\">else</div><div class=\"line\">echo &apos;$var1 not eq $var2&apos;</div><div class=\"line\">fi //else后面必须加fi</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">       if list then</div><div class=\"line\">           do something here</div><div class=\"line\">       elif list then</div><div class=\"line\">           do another thing here</div><div class=\"line\">       else</div><div class=\"line\">         do something else here</div><div class=\"line\">       fi</div></pre></td></tr></table></figure></p>\n<p>eg: echo类似于print<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">例：myvar=“Hi there！”</div><div class=\"line\"></div><div class=\"line\">    echo $myvar</div><div class=\"line\"></div><div class=\"line\">    echo &quot;$myvar&quot;</div><div class=\"line\"></div><div class=\"line\">    echo &apos; $myvar&apos;</div><div class=\"line\"></div><div class=\"line\">    echo \\$myvar</div><div class=\"line\"></div><div class=\"line\">将会输出如下：Hi there！</div><div class=\"line\"></div><div class=\"line\">              Hi there!</div><div class=\"line\"></div><div class=\"line\">              $myvar</div><div class=\"line\"></div><div class=\"line\">              $myvar</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-用户和用户组的问题\"><a href=\"#4-用户和用户组的问题\" class=\"headerlink\" title=\"4. 用户和用户组的问题\"></a>4. 用户和用户组的问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd user //添加用户，(-g 指定用户所在用户组)/home目录下会多一个user的目录，作为该用户的主目录</div><div class=\"line\"></div><div class=\"line\">passwd user //设置user的密码，会提示输入密码，密码不会显示在窗口中</div><div class=\"line\"></div><div class=\"line\">cd /etc &gt;&gt;&gt; more passwd  ，这里面会显示所有的用户</div><div class=\"line\">more group ,显示用户组的信息</div><div class=\"line\">groupadd groupname //添加一个用户组</div><div class=\"line\"></div><div class=\"line\">//删除用户</div><div class=\"line\">userdel user //删除一个用户</div><div class=\"line\">还需要删除该用户的主目录(rm -rf user)</div><div class=\"line\"></div><div class=\"line\">重启机器，登录页面选择新用户即可完成用户切换</div><div class=\"line\"></div><div class=\"line\">或者使用 su testuser 切换到testuser身份</div><div class=\"line\">exit就回到root用户的身份</div><div class=\"line\"></div><div class=\"line\">新用户登录时，默认的pwd是该用户的主目录</div></pre></td></tr></table></figure>\n<h3 id=\"5-文件权限的问题\"><a href=\"#5-文件权限的问题\" class=\"headerlink\" title=\"5. 文件权限的问题\"></a>5. 文件权限的问题</h3><p>ls命令执行显示的文件前一般带有一串信息<br>第一位：</p>\n<ul>\n<li>代表文件<br>l代表链接<br>d代表目录</li>\n</ul>\n<p>后面九位划分为三块，可能的权限有这么几种<br>r(read权限)w(写权限)-(无权限)x(执行权限)</p>\n<p>第一组代表所有者(u)权限，第二组代表与所有者一个用户组的用户(g)的权限，第三组代表其他用户(0)的权限</p>\n<p>更改文件权限命令: chmod<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x filename //加上可执行权限，所有用户都加上了</div><div class=\"line\">chmod u+x filename //给当前用户加上可执行权限</div><div class=\"line\">//其他命令不一一列举</div><div class=\"line\"></div><div class=\"line\">&gt; u ：目录或者文件的当前的用户</div><div class=\"line\">  g ：目录或者文件的当前的群组</div><div class=\"line\">  o ：除了目录或者文件的当前用户或群组之外的用户或者群组</div><div class=\"line\">  a ：所有的用户及群组</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&gt; r ：读权限，用数字4表示</div><div class=\"line\">  w ：写权限，用数字2表示</div><div class=\"line\">  x ：执行权限，用数字1表示</div><div class=\"line\">  - ：删除权限，用数字0表示</div><div class=\"line\"></div><div class=\"line\">所以给所有用户增加a.txt文件的可执行权限就像这样</div><div class=\"line\">chmod a+x a.txt</div><div class=\"line\">#其余自行发挥</div><div class=\"line\">chmod a-x a.txt  #删除所有用户的可执行权限</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">chmod 755 filename  </div><div class=\"line\">751应该是读/写/执行</div><div class=\"line\">chomod 444 filename# 为所有用户分配读权限</div><div class=\"line\">chmod 777 filename //全部权限都有了，其实上面的9位就是这三位数每一位的二进制拼起来的</div><div class=\"line\">755 就是 111101101,也就对应上面的权限九位字母</div><div class=\"line\"></div><div class=\"line\">chown -R Jane /foldername # 把flodername文件夹的所有者改为Jane， -R 表示递归，会保证所有子文件夹的所有者也被更改</div></pre></td></tr></table></figure></p>\n<p>更改文件所有者</p>\n<ul>\n<li><blockquote>\n<p>chown username filename</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"6-管道\"><a href=\"#6-管道\" class=\"headerlink\" title=\"6. 管道\"></a>6. 管道</h3><p>将一个命令的输出传送给另一个命令，作为另一个命令的输入<br>eg: 中间那条竖线叫做管道连接符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cat /etc/passwd | grep usernametofind</div><div class=\"line\">$ ls -l | grep &quot;^d&quot;</div><div class=\"line\">$ ls -l * | grep &quot;^-&quot; | wc -|   //&quot;^-&quot;表示不列出目录或链接，只展示目录；wc是数行数</div><div class=\"line\">$ ls -l | grep &quot;^d&quot; //只列出目录</div></pre></td></tr></table></figure></p>\n<h3 id=\"7-硬件相关的命令\"><a href=\"#7-硬件相关的命令\" class=\"headerlink\" title=\"7. 硬件相关的命令\"></a>7. 硬件相关的命令</h3><p><a href=\"https://github.com/Teddysun/across\">VPS跑分软件</a></p>\n<blockquote>\n<p>git clone下来<br>cd across<br>wget -qO- bench.sh | bash （亲测可用，也可以自己看Readme）<br>或者 &gt; curl -Lso- bench.sh | bash</p>\n</blockquote>\n<h3 id=\"BandWagon\"><a href=\"#BandWagon\" class=\"headerlink\" title=\"BandWagon\"></a>BandWagon</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU E3-1275 v5 @ 3.60GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 3600.041 MHz</div><div class=\"line\">Total size of Disk   : 12.0 GB (10.0 GB Used)</div><div class=\"line\">Total amount of Mem  : 256 MB (217 MB Used)</div><div class=\"line\">Total amount of Swap : 128 MB (122 MB Used)</div><div class=\"line\">System uptime        : 2 days, 4 hour 20 min</div><div class=\"line\">Load average         : 0.06, 0.05, 0.01</div><div class=\"line\">OS                   : Ubuntu 14.04.1 LTS</div><div class=\"line\">Arch                 : i686 (32 Bit)</div><div class=\"line\">Kernel               : 2.6.32-042stab123.3</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 855 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 1.0 GB/s</div><div class=\"line\">I/O speed(3rd run)   : 1.0 GB/s</div><div class=\"line\">Average I/O speed    : 967.7 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         76.5MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          17.6MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            8.18MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           8.67MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           12.8MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             9.40MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           62.3MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          66.0MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            12.2MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           11.8MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          13.2MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<h3 id=\"BuyVm\"><a href=\"#BuyVm\" class=\"headerlink\" title=\"BuyVm\"></a>BuyVm</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU           L5639  @ 2.13GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 2000.070 MHz</div><div class=\"line\">Total size of Disk   : 15.0 GB (1.3 GB Used)</div><div class=\"line\">Total amount of Mem  : 128 MB (80 MB Used)</div><div class=\"line\">Total amount of Swap : 128 MB (32 MB Used)</div><div class=\"line\">System uptime        : 0 days, 22 hour 28 min</div><div class=\"line\">Load average         : 0.10, 0.04, 0.05</div><div class=\"line\">OS                   : Ubuntu 14.04.2 LTS</div><div class=\"line\">Arch                 : i686 (32 Bit)</div><div class=\"line\">Kernel               : 2.6.32-openvz-042stab116.2-amd64</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 102 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 97.1 MB/s</div><div class=\"line\">I/O speed(3rd run)   : 147 MB/s</div><div class=\"line\">Average I/O speed    : 115.4 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         14.7MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          6.15MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            2.54MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           2.99MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           2.96MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             4.27MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           11.7MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          13.0MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            1.89MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           3.26MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          3.72MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<h3 id=\"DigitalOcean-Los-Angeles\"><a href=\"#DigitalOcean-Los-Angeles\" class=\"headerlink\" title=\"DigitalOcean Los Angeles\"></a>DigitalOcean Los Angeles</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU E5-2650L v3 @ 1.80GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 1799.998 MHz</div><div class=\"line\">Total size of Disk   : 20.2 GB (1.0 GB Used)</div><div class=\"line\">Total amount of Mem  : 488 MB (33 MB Used)</div><div class=\"line\">Total amount of Swap : 0 MB (0 MB Used)</div><div class=\"line\">System uptime        : 0 days, 0 hour 3 min</div><div class=\"line\">Load average         : 0.16, 0.10, 0.03</div><div class=\"line\">OS                   : Ubuntu 16.04.2 LTS</div><div class=\"line\">Arch                 : x86_64 (64 Bit)</div><div class=\"line\">Kernel               : 4.4.0-78-generic</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 581 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 711 MB/s</div><div class=\"line\">I/O speed(3rd run)   : 777 MB/s</div><div class=\"line\">Average I/O speed    : 689.7 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         161MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          15.7MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            5.96MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           5.71MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           6.45MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             30.4MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           29.9MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          57.7MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            3.64MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           7.59MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          8.84MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<h3 id=\"DigitalOcean-Sinapore-ip-adress-lokks-like-Russian\"><a href=\"#DigitalOcean-Sinapore-ip-adress-lokks-like-Russian\" class=\"headerlink\" title=\"DigitalOcean Sinapore (ip adress lokks like Russian)\"></a>DigitalOcean Sinapore (ip adress lokks like Russian)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU E5-2630L 0 @ 2.00GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 1999.999 MHz</div><div class=\"line\">Total size of Disk   : 20.2 GB (1.0 GB Used)</div><div class=\"line\">Total amount of Mem  : 488 MB (36 MB Used)</div><div class=\"line\">Total amount of Swap : 0 MB (0 MB Used)</div><div class=\"line\">System uptime        : 0 days, 0 hour 2 min</div><div class=\"line\">Load average         : 0.17, 0.20, 0.09</div><div class=\"line\">OS                   : Ubuntu 16.04.2 LTS</div><div class=\"line\">Arch                 : x86_64 (64 Bit)</div><div class=\"line\">Kernel               : 4.4.0-78-generic</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 662 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 741 MB/s</div><div class=\"line\">I/O speed(3rd run)   : 728 MB/s</div><div class=\"line\">Average I/O speed    : 710.3 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         20.8MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          18.6MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            83.8MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           5.71MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           8.13MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             2.82MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           6.18MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          8.47MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            6.77MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           97.9MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          35.2MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>查看硬盘存储空间:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">df -h //h的意思是human-readable</div><div class=\"line\">du -sh //查看当前directory的大小</div><div class=\"line\">du -h //查看当前目录下各个子目录分别的大小</div><div class=\"line\">dh -h img// 查看img目录下文件及文件夹的大小</div><div class=\"line\">dh -h img/1.jpg //查看指定文件的大小</div></pre></td></tr></table></figure></p>\n<p>查看cpu信息</p>\n<blockquote>\n<p>cat /proc/cpuinfo</p>\n</blockquote>\n<p>查看内存</p>\n<blockquote>\n<p>free -m<br>free -h # human readable</p>\n</blockquote>\n<p>修改默认安全设置</p>\n<blockquote>\n<p>vi /etc/ssh/ssd_config</p>\n</blockquote>\n<p>添加或修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Port 22 (ssh默认端口修改)</div><div class=\"line\">PermitRootLogin without-Password no</div><div class=\"line\">AllowUsers userName</div></pre></td></tr></table></figure>\n<p>压缩文件命令<br>将/home/video/ 这个目录下所有文件和文件夹打包为当前目录下的video.zip</p>\n<p>zip –q –r -v video.zip . #加上一个-v主要是为了能够实时查看输出</p>\n<p>文件传输（linux -&gt;windows）： 一般使用putty ssh到Linux主机，想要把Linux上的文件弄到Windows中，需要使用pscp工具。下载好pscp.exe后，放到c:/windows/system32下面。打开cmd。输入命令<br>pscp -r root@202.123.123.123:”/root/fileonServer.mp4” d:/whateveriwantonmyPc.mp4  ，确认后输入root密码就好了。我主要是用来下载视频的。<br>有时候会出现Connection Refused Error。</p>\n<blockquote>\n<p>netstat -anp | grep sshd</p>\n</blockquote>\n<p>看下跑在哪个端口<br>然后</p>\n<blockquote>\n<p>pscp -P 12345-r root@202.123.123.123:”/root/fileonServer.mp4” d:/whateveriwantonmyPc.mp4  -p要大写</p>\n</blockquote>\n<h3 id=\"8-SS相关的命令\"><a href=\"#8-SS相关的命令\" class=\"headerlink\" title=\"8. SS相关的命令\"></a>8. SS相关的命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">  1. 刚装好的ubuntu需要执行以下步骤</div><div class=\"line\">  安装git &gt; apt-get install git</div><div class=\"line\">  安装python &gt; apt-get install python-2.7</div><div class=\"line\">  安装python-setuptools &gt; apt-get install python-setuptools</div><div class=\"line\">  检查是否安装好： python --version</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  2. 下载shadowsocks源码编译</div><div class=\"line\"> &gt; git clone https://github.com/shadowsocks/shadowsocks</div><div class=\"line\">  # 记得切换到master分支</div><div class=\"line\">  python setup.py build</div><div class=\"line\">  python setup.py install</div><div class=\"line\"></div><div class=\"line\">  检查下版本 ssserver --version</div><div class=\"line\"></div><div class=\"line\">  3. 编辑配置文件</div><div class=\"line\">  vim config.json</div><div class=\"line\">  &#123;</div><div class=\"line\">   &quot;server&quot;:&quot;my_server_ip&quot;,</div><div class=\"line\">   &quot;server_port&quot;:8388,</div><div class=\"line\">   &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">   &quot;local_port&quot;:1080,</div><div class=\"line\">   &quot;password&quot;:&quot;mypassword&quot;,</div><div class=\"line\">   &quot;timeout&quot;:300,</div><div class=\"line\">   &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">   &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ssserver -c config.json -d start #启动完成</div><div class=\"line\"></div><div class=\"line\">检查下是否启动了</div><div class=\"line\">ps -ef |grep sss</div><div class=\"line\"></div><div class=\"line\">ss 命令</div><div class=\"line\">ssserver -c /etc/shadowsocks/config.json # 前台运行</div><div class=\"line\"></div><div class=\"line\">- 后台运行和停止</div><div class=\"line\">ssserver -c /etc/shadowsocks.json -d start</div><div class=\"line\">ssserver -c /etc/shadowsocks.json -d stop</div><div class=\"line\"></div><div class=\"line\">- 加入开机启动</div><div class=\"line\"></div><div class=\"line\">在/etc/rc.local中加入</div><div class=\"line\">sudo ssserver -c /etc/shadowsocks.json --user username -d start - 不要总是用root用户做事，adduser来做，给sudo权限即可</div><div class=\"line\"></div><div class=\"line\">[ShadowsocksR](https://github.com/breakwa11/shadowsocks-rss/wiki)启动后台运行命令</div><div class=\"line\">&gt; python server.py -p 443 -k password -m aes-256-cfb -O auth_sha1_v4 -o http_simple -d start</div><div class=\"line\"></div><div class=\"line\">[net-speeder](https://zhgcao.github.io/2016/05/26/ubuntu-install-net-speeder/)</div><div class=\"line\">venetX，OpenVZ架构</div><div class=\"line\"></div><div class=\"line\">cd net-speeder-master/</div><div class=\"line\">sh build.sh -DCOOKED</div><div class=\"line\"></div><div class=\"line\">Xen，KVM，物理机</div><div class=\"line\">cd net-speeder-master/</div><div class=\"line\">sh build.sh</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">加速所有ip协议数据</div><div class=\"line\"></div><div class=\"line\">&gt; ./net_speeder venet0 &quot;ip&quot;</div><div class=\"line\"></div><div class=\"line\">只加速指定端口，例如只加速TCP协议的 8989端口</div><div class=\"line\">前提是切换到net-speeder的目录下</div><div class=\"line\">&gt; ./net_speeder venet0:0 &quot;tcp src port 8989&quot;</div><div class=\"line\"></div><div class=\"line\">./net_speeder venet0 &quot;ip&quot;</div><div class=\"line\"></div><div class=\"line\">只加速指定端口，例如只加速TCP协议的 8989端口</div><div class=\"line\">前提是切换到net-speeder的目录下</div><div class=\"line\"> ./net_speeder venet0:0 &quot;tcp src port 8989&quot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> [KVM架构升级内核开启BBR](https://qiujunya.com/linodebbr.html)</div></pre></td></tr></table></figure>\n<h3 id=\"9-网络监控\"><a href=\"#9-网络监控\" class=\"headerlink\" title=\"9. 网络监控\"></a>9. 网络监控</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">tcpdump -i &quot;venet0:0&quot;  //抓包的</div><div class=\"line\">tcpdump -c 10 //count</div><div class=\"line\">tcpdump -c -A  //Asicii码形式展示出来每个package</div><div class=\"line\">tcpdump -c 5 -i wlo1 // 监听某一个网卡</div><div class=\"line\">tcpdump -c 5 -i wlo1 port 22// 监听某一个网卡某一个端口</div><div class=\"line\"></div><div class=\"line\">tcpdump version 4.5.1</div><div class=\"line\">libpcap version 1.5.3</div><div class=\"line\">Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ]</div><div class=\"line\">                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]</div><div class=\"line\">                [ -i interface ] [ -j tstamptype ] [ -M secret ]</div><div class=\"line\">                [ -P in|out|inout ]</div><div class=\"line\">                [ -r file ] [ -s snaplen ] [ -T type ] [ -V file ] [ -w file ]</div><div class=\"line\">                [ -W filecount ] [ -y datalinktype ] [ -z command ]</div><div class=\"line\">                [ -Z user ] [ expression ]</div></pre></td></tr></table></figure>\n<p>tcpdump结合wireshark可实现完整的网络抓包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">netstat</div><div class=\"line\">netstat -i // 查看某个网络接口发出和接收了多少byte的数据</div><div class=\"line\">netstat -ta //当前active的网络连接</div><div class=\"line\">netstat -tan //以ip地址的方式展示出来</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ifconfig // 查看机器上的网卡</div><div class=\"line\">en01 //Ethernet</div><div class=\"line\">注意 RX bytes(接收到的数据)和TX bytes(发送出去的数据)后面的数字</div></pre></td></tr></table></figure>\n<h3 id=\"10-查看进程\"><a href=\"#10-查看进程\" class=\"headerlink\" title=\"10.查看进程\"></a>10.查看进程</h3><p><a href=\"https://stackoverflow.com/questions/4797050/how-to-run-process-as-background-and-never-die\">起一个进程，后台运行，关掉终端照样跑的那种</a></p>\n<blockquote>\n<p> nohup node server.js &gt; /dev/null 2&gt;&amp;1 &amp;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup node server.js &gt; /dev/null 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">1. nohup means: Do not terminate this process even when the stty is cut off.</div><div class=\"line\">2. &gt; /dev/null means: stdout goes to /dev/null (which is a dummy device that does not record any output).</div><div class=\"line\">3. 2&gt;&amp;1 means: stderr also goes to the stdout (which is already redirected to /dev/null). You may replace &amp;1 with a file path to keep a log of errors, e.g.: 2&gt;/tmp/myLog</div><div class=\"line\">4. &amp; at the end means: run this command as a background task.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">top 动态显示</div><div class=\"line\">PID：进程的ID[参数解释](http://www.cnblogs.com/gaojun/p/3406096.html)</div><div class=\"line\">　　USER：进程所有者</div><div class=\"line\">　　PR：进程的优先级别，越小越优先被执行</div><div class=\"line\">　　NInice：值</div><div class=\"line\">　　VIRT：进程占用的虚拟内存</div><div class=\"line\">　　RES：进程占用的物理内存</div><div class=\"line\">　　SHR：进程使用的共享内存</div><div class=\"line\">　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</div><div class=\"line\">　　%CPU：进程占用CPU的使用率</div><div class=\"line\">　　%MEM：进程使用的物理内存和总内存的百分比</div><div class=\"line\">　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</div><div class=\"line\">　　COMMAND：进程启动命令名称</div><div class=\"line\"></div><div class=\"line\">ps a 显示现行终端机下的所有程序，包括其他用户的程序。</div><div class=\"line\"></div><div class=\"line\">**看下某个进程跑在哪个端口**</div><div class=\"line\"> netstat -anp | grep sshd</div><div class=\"line\"></div><div class=\"line\">ps | grep 类似于 pgrep XXX //查找某个进程</div><div class=\"line\"></div><div class=\"line\">进程命令</div><div class=\"line\">*实时监控，1秒刷新一次*</div><div class=\"line\">watch -n 1 ps -aux --sort=-pmem,-pcpu</div></pre></td></tr></table></figure>\n<p>查看端口占用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#列出所有端口的占用情况</div><div class=\"line\">netstat -anp</div><div class=\"line\">lsof -i # 这个也行</div><div class=\"line\">#查看哪个进程占了http端口(其实就是80了)</div><div class=\"line\">lsof -i:80</div><div class=\"line\">#查看某个进程占了哪些端口</div><div class=\"line\">netstat -anp|grep pid</div></pre></td></tr></table></figure></p>\n<p>//杀进程（如果进程不属于当前用户，要sudo）</p>\n<blockquote>\n<p>杀进程，慎用。<br>kill -9 进程id // 9直接干掉进程，慎用。。。<br>kill pid // 这个和kill 15是一样的 //15表示terminate,请求进程停下来  </p>\n</blockquote>\n<p>kill -l //列出进程及id</p>\n<p>killall nginx -&gt;&gt; 干掉nginx的所有进程</p>\n<p>pkill -u username //干掉所有属于某一个用户的ps</p>\n<p>Signal (信号)  man signal</p>\n<p>进程状态<br>runnable、sleeping、zombie、stop</p>\n<p>//更改友善度,数字越小越不友好<br>nice -n 15 /…..   命令path。启动的时候确定nice<br>renice -s pid //更改友善度</p>\n<p>df -ah  // 查看mounted文件系统<br>proc</p>\n<h3 id=\"11-常用配置\"><a href=\"#11-常用配置\" class=\"headerlink\" title=\"11 .常用配置\"></a>11 .常用配置</h3><blockquote>\n<p>查看登陆失败日志<br>grep “Failed password for root” /var/log/auth.log | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more</p>\n</blockquote>\n<p>防范措施<br>修改登陆端口号<br>sudo vi /etc/ssh/sshd_config<br>Port 4484<br>PermitRootLogin no</p>\n<p>修改完成后重启ssh<br>/etc/init.d/ssh restart</p>\n<p><a href=\"https://perlgeek.de/en/article/set-up-a-clean-utf8-environment\">编码的修改</a><br>更改locale为utf-8(ubuntu)<br>&gt;<br>vi ~/.bashrc</p>\n<h1 id=\"add-these-lines\"><a href=\"#add-these-lines\" class=\"headerlink\" title=\"add these lines\"></a>add these lines</h1><p>export LC_ALL=en_US.UTF-8<br>export LANG=en_US.UTF-8<br>export LANGUAGE=en_US.UTF-8</p>\n<p>sudo locale-gen “en_US.UTF-8”<br>sudo dpkg-reconfigure locales</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><img src=\"http://odzl05jxx.bkt.clouddn.com/fork_you_git.jpg\" alt=\"\"></li>\n<li><a href=\"https://my.oschina.net/liting/blog/392051\">文件大小查看命令</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_7479f7990100zwkp.html\">文件压缩命令</a></li>\n<li><a href=\"https://my.oschina.net/hunterli/blog/140783\">硬件查询</a></li>\n<li><a href=\"http://www.jianshu.com/p/3d80c7cb7b17\">Python源码编译安装ss</a></li>\n<li><a href=\"http://blog.csdn.net/program_thinker/article/details/45787395\">源码编译安装ss</a></li>\n<li><a href=\"https://askubuntu.com/questions/162391/how-do-i-fix-my-locale-issue\">修改系统编码为utf-8</a></li>\n</ul>\n","excerpt":"<p>一些常用的linux基本命令,仅作为参考。</br><br><img src=\"http://odzl05jxx.bkt.clouddn.com/849c18412f8e7a0b18df09f6f87e6516.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<p>首先是连接vps的ssh(Secure Shell)工具，putty或者xshell都可以。</p>\n<h2 id=\"速查手册\"><a href=\"#速查手册\" class=\"headerlink\" title=\"速查手册\"></a>速查手册</h2><ol>\n<li><a href=\"#1-文件操作常用命令\">文件操作</a></li>\n<li><a href=\"#2-Vi文本编辑器\">Vi文本编辑器</a></li>\n<li><a href=\"#3-linux下shell脚本语句的语法\">bash脚本怎么写</a></li>\n<li><a href=\"#4-用户和用户组的问题\">用户和用户组的问题</a></li>\n<li><a href=\"#5-文件权限的问题\">文件权限</a></li>\n<li><a href=\"#6-管道\">管道</a></li>\n<li><a href=\"#7-硬件相关的命令\">硬件相关的命令</a></li>\n<li><a href=\"#8-SS相关的命令\">SS相关的命令</a></li>\n<li><a href=\"#9-网络监控\">网络监控</a></li>\n<li><a href=\"#10-查看进程\">查看进程</a><br>11.<a href=\"#11-常用配置\">通用配置</a></li>\n</ol>\n<p><a href=\"#参考\">参考</a></p>\n<h3 id=\"1-文件操作常用命令\"><a href=\"#1-文件操作常用命令\" class=\"headerlink\" title=\"1. 文件操作常用命令\"></a>1. 文件操作常用命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; cd //进入目录</div><div class=\"line\">- &gt; cd /  返回根目录</div><div class=\"line\">- &gt; pwd // 显示当前目录</div><div class=\"line\">- &gt; ls // 显示当前目录下内容</div><div class=\"line\"></div><div class=\"line\">- &gt; mkdir //新建目录</div><div class=\"line\">- &gt; rmdir //删除目录,如果目录不为空，</div><div class=\"line\">- &gt;使用 rm -r //递归删除</div><div class=\"line\">- &gt; rm -rf //强制删除</div><div class=\"line\"></div><div class=\"line\">文件名一般不支持空格，如果真有的话得用单引号括起来，像这样:</div><div class=\"line\">-&gt; rm -f &apos;my file&apos;</div><div class=\"line\">-&gt; mv a.mp4 b.mp4 //mv虽然是移动（Windows中的剪切）操作，但这种情况下就等同于重命名了，亲测有效</div><div class=\"line\"></div><div class=\"line\"># 重命名</div><div class=\"line\">rename是实际意义上的重命名命令，但rename接受三个参数</div><div class=\"line\"></div><div class=\"line\">- &gt; touch filename //创建文件，后缀在linux下没意义</div></pre></td></tr></table></figure>\n<p>复制粘贴：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; cp a b //把a复制一份，命名为b</div><div class=\"line\"></div><div class=\"line\">- &gt; cp d1 d2 // 这样是不行的，复制目录需要加上-r ，即</div><div class=\"line\">- &gt; cp -r d1 d2</div><div class=\"line\"></div><div class=\"line\">移动(左边是被移动的文件或目录，右边是目标路径)：</div><div class=\"line\"></div><div class=\"line\">- &gt; mv d1 /  把d1移动到相对路径，也就是根目录下</div><div class=\"line\">- &gt; mv d1 ../把d1往上移动一层</div><div class=\"line\">- &gt; mv d1 ../../</div></pre></td></tr></table></figure></p>\n<p>###重定向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">重定向输出 &gt;</div><div class=\"line\">ls  &gt; lsoutput.txt #用于将输出的结果写入一个新的文本文件中</div><div class=\"line\">echo &apos;hey man&apos; # 类似于print</div><div class=\"line\">echo &apos;hello&apos; &gt; log.txt #把这句话写入到文本中 ，覆盖其原有内容</div><div class=\"line\"></div><div class=\"line\">重定向输入 &lt;</div><div class=\"line\">wall &lt; aa.txt # wall是向所有用户发广播， 即从aa.txt中读取内容，然后广播发出去</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#service命令</div><div class=\"line\">service XXX start/stop/status #原理是将这些程序注册成为系统服务，这样调用这些程序的时候就不需要写一大堆绝对路径了，具体用法help已经很详细了。</div><div class=\"line\"></div><div class=\"line\">zip –q –r video.zip /home/video</div><div class=\"line\">zip –q –r video.zip .  # .代表当前目录</div></pre></td></tr></table></figure>\n<h3 id=\"2-Vi文本编辑器\"><a href=\"#2-Vi文本编辑器\" class=\"headerlink\" title=\"2. Vi文本编辑器\"></a>2. Vi文本编辑器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; vi 3.txt // 如果有则编辑，没有则直接创建</div><div class=\"line\"></div><div class=\"line\">Vi分为命令模式和编辑模式，一进来是命令模式，输入&apos;a&apos;进入编辑模式</div><div class=\"line\">切换回命令模式按&apos;esc&apos;</div><div class=\"line\">命令模式下 :w 表示存盘</div><div class=\"line\">- :q 退出</div><div class=\"line\"></div><div class=\"line\">- :wq 保存并退出</div><div class=\"line\">- :q! 不保存退出（无内容变化）</div></pre></td></tr></table></figure>\n<p>在编辑模式下,输入 ‘dd’删除一行 ，输入’dw’删除一个词<br>输入’o’插入一行。。。。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- &gt; more filename//查看文件内容</div><div class=\"line\"></div><div class=\"line\">- &gt; cat filename //正序查看文件内容</div><div class=\"line\"></div><div class=\"line\">- &gt; tac filename //逆序查看文件内容</div><div class=\"line\"></div><div class=\"line\">- &gt; head - 3 filename //只查看文件前面三行</div><div class=\"line\">- &gt; tail - 3 filename //只查看倒数后三行</div></pre></td></tr></table></figure>\n<p>更多命令如 find 、 whereis 、 Li(Link)<br>查找：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">find / -name filename  //在根目录下查找文件</div><div class=\"line\">find /etc -name filename //在etc目录下查找文件</div><div class=\"line\"></div><div class=\"line\">grep stringtofind filename //在指定的文本文件中查找指定的字符串</div><div class=\"line\"></div><div class=\"line\">whereis ls //查看ls命令所执行的是哪个文件及其位置(查看系统文件所在路径)</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-linux下shell脚本语句的语法\"><a href=\"#3-linux下shell脚本语句的语法\" class=\"headerlink\" title=\"3. linux下shell脚本语句的语法\"></a>3. linux下shell脚本语句的语法</h3><p>linux大小写敏感<br>eg:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">myPath=&quot;/var/log/httpd/&quot;</div><div class=\"line\">myFile=&quot;/var /log/httpd/access.log&quot;</div><div class=\"line\">#这里的-x 参数判断$myPath是否存在并且是否具有可执行权限</div><div class=\"line\">if [ ! -x &quot;$myPath&quot;]; then</div><div class=\"line\">mkdir &quot;$myPath&quot;</div><div class=\"line\">fi</div><div class=\"line\">#这里的-d 参数判断$myPath是否存在</div><div class=\"line\">if [ ! -d &quot;$myPath&quot;]; then</div><div class=\"line\">mkdir &quot;$myPath&quot;</div><div class=\"line\">fi</div><div class=\"line\">#这里的-f参数判断$myFile是否存在</div><div class=\"line\">if [ ! -f &quot;$myFile&quot; ]; then</div><div class=\"line\">touch &quot;$myFile&quot;</div><div class=\"line\">fi</div><div class=\"line\">#其他参数还有-n,-n是判断一个变量是否是否有值</div><div class=\"line\">if [ ! -n &quot;$myVar&quot; ]; then</div><div class=\"line\">echo &quot;$myVar is empty&quot;</div><div class=\"line\">exit 0</div><div class=\"line\">fi</div><div class=\"line\">#两个变量判断是否相等</div><div class=\"line\">if [ &quot;$var1&quot; == &quot;$var2&quot; ]; then  //if 后面必须加then</div><div class=\"line\">echo &apos;$var1 eq $var2&apos;</div><div class=\"line\">else</div><div class=\"line\">echo &apos;$var1 not eq $var2&apos;</div><div class=\"line\">fi //else后面必须加fi</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">       if list then</div><div class=\"line\">           do something here</div><div class=\"line\">       elif list then</div><div class=\"line\">           do another thing here</div><div class=\"line\">       else</div><div class=\"line\">         do something else here</div><div class=\"line\">       fi</div></pre></td></tr></table></figure></p>\n<p>eg: echo类似于print<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">例：myvar=“Hi there！”</div><div class=\"line\"></div><div class=\"line\">    echo $myvar</div><div class=\"line\"></div><div class=\"line\">    echo &quot;$myvar&quot;</div><div class=\"line\"></div><div class=\"line\">    echo &apos; $myvar&apos;</div><div class=\"line\"></div><div class=\"line\">    echo \\$myvar</div><div class=\"line\"></div><div class=\"line\">将会输出如下：Hi there！</div><div class=\"line\"></div><div class=\"line\">              Hi there!</div><div class=\"line\"></div><div class=\"line\">              $myvar</div><div class=\"line\"></div><div class=\"line\">              $myvar</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-用户和用户组的问题\"><a href=\"#4-用户和用户组的问题\" class=\"headerlink\" title=\"4. 用户和用户组的问题\"></a>4. 用户和用户组的问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd user //添加用户，(-g 指定用户所在用户组)/home目录下会多一个user的目录，作为该用户的主目录</div><div class=\"line\"></div><div class=\"line\">passwd user //设置user的密码，会提示输入密码，密码不会显示在窗口中</div><div class=\"line\"></div><div class=\"line\">cd /etc &gt;&gt;&gt; more passwd  ，这里面会显示所有的用户</div><div class=\"line\">more group ,显示用户组的信息</div><div class=\"line\">groupadd groupname //添加一个用户组</div><div class=\"line\"></div><div class=\"line\">//删除用户</div><div class=\"line\">userdel user //删除一个用户</div><div class=\"line\">还需要删除该用户的主目录(rm -rf user)</div><div class=\"line\"></div><div class=\"line\">重启机器，登录页面选择新用户即可完成用户切换</div><div class=\"line\"></div><div class=\"line\">或者使用 su testuser 切换到testuser身份</div><div class=\"line\">exit就回到root用户的身份</div><div class=\"line\"></div><div class=\"line\">新用户登录时，默认的pwd是该用户的主目录</div></pre></td></tr></table></figure>\n<h3 id=\"5-文件权限的问题\"><a href=\"#5-文件权限的问题\" class=\"headerlink\" title=\"5. 文件权限的问题\"></a>5. 文件权限的问题</h3><p>ls命令执行显示的文件前一般带有一串信息<br>第一位：</p>\n<ul>\n<li>代表文件<br>l代表链接<br>d代表目录</li>\n</ul>\n<p>后面九位划分为三块，可能的权限有这么几种<br>r(read权限)w(写权限)-(无权限)x(执行权限)</p>\n<p>第一组代表所有者(u)权限，第二组代表与所有者一个用户组的用户(g)的权限，第三组代表其他用户(0)的权限</p>\n<p>更改文件权限命令: chmod<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x filename //加上可执行权限，所有用户都加上了</div><div class=\"line\">chmod u+x filename //给当前用户加上可执行权限</div><div class=\"line\">//其他命令不一一列举</div><div class=\"line\"></div><div class=\"line\">&gt; u ：目录或者文件的当前的用户</div><div class=\"line\">  g ：目录或者文件的当前的群组</div><div class=\"line\">  o ：除了目录或者文件的当前用户或群组之外的用户或者群组</div><div class=\"line\">  a ：所有的用户及群组</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&gt; r ：读权限，用数字4表示</div><div class=\"line\">  w ：写权限，用数字2表示</div><div class=\"line\">  x ：执行权限，用数字1表示</div><div class=\"line\">  - ：删除权限，用数字0表示</div><div class=\"line\"></div><div class=\"line\">所以给所有用户增加a.txt文件的可执行权限就像这样</div><div class=\"line\">chmod a+x a.txt</div><div class=\"line\">#其余自行发挥</div><div class=\"line\">chmod a-x a.txt  #删除所有用户的可执行权限</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">chmod 755 filename  </div><div class=\"line\">751应该是读/写/执行</div><div class=\"line\">chomod 444 filename# 为所有用户分配读权限</div><div class=\"line\">chmod 777 filename //全部权限都有了，其实上面的9位就是这三位数每一位的二进制拼起来的</div><div class=\"line\">755 就是 111101101,也就对应上面的权限九位字母</div><div class=\"line\"></div><div class=\"line\">chown -R Jane /foldername # 把flodername文件夹的所有者改为Jane， -R 表示递归，会保证所有子文件夹的所有者也被更改</div></pre></td></tr></table></figure></p>\n<p>更改文件所有者</p>\n<ul>\n<li><blockquote>\n<p>chown username filename</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"6-管道\"><a href=\"#6-管道\" class=\"headerlink\" title=\"6. 管道\"></a>6. 管道</h3><p>将一个命令的输出传送给另一个命令，作为另一个命令的输入<br>eg: 中间那条竖线叫做管道连接符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cat /etc/passwd | grep usernametofind</div><div class=\"line\">$ ls -l | grep &quot;^d&quot;</div><div class=\"line\">$ ls -l * | grep &quot;^-&quot; | wc -|   //&quot;^-&quot;表示不列出目录或链接，只展示目录；wc是数行数</div><div class=\"line\">$ ls -l | grep &quot;^d&quot; //只列出目录</div></pre></td></tr></table></figure></p>\n<h3 id=\"7-硬件相关的命令\"><a href=\"#7-硬件相关的命令\" class=\"headerlink\" title=\"7. 硬件相关的命令\"></a>7. 硬件相关的命令</h3><p><a href=\"https://github.com/Teddysun/across\">VPS跑分软件</a></p>\n<blockquote>\n<p>git clone下来<br>cd across<br>wget -qO- bench.sh | bash （亲测可用，也可以自己看Readme）<br>或者 &gt; curl -Lso- bench.sh | bash</p>\n</blockquote>\n<h3 id=\"BandWagon\"><a href=\"#BandWagon\" class=\"headerlink\" title=\"BandWagon\"></a>BandWagon</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU E3-1275 v5 @ 3.60GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 3600.041 MHz</div><div class=\"line\">Total size of Disk   : 12.0 GB (10.0 GB Used)</div><div class=\"line\">Total amount of Mem  : 256 MB (217 MB Used)</div><div class=\"line\">Total amount of Swap : 128 MB (122 MB Used)</div><div class=\"line\">System uptime        : 2 days, 4 hour 20 min</div><div class=\"line\">Load average         : 0.06, 0.05, 0.01</div><div class=\"line\">OS                   : Ubuntu 14.04.1 LTS</div><div class=\"line\">Arch                 : i686 (32 Bit)</div><div class=\"line\">Kernel               : 2.6.32-042stab123.3</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 855 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 1.0 GB/s</div><div class=\"line\">I/O speed(3rd run)   : 1.0 GB/s</div><div class=\"line\">Average I/O speed    : 967.7 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         76.5MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          17.6MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            8.18MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           8.67MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           12.8MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             9.40MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           62.3MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          66.0MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            12.2MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           11.8MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          13.2MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<h3 id=\"BuyVm\"><a href=\"#BuyVm\" class=\"headerlink\" title=\"BuyVm\"></a>BuyVm</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU           L5639  @ 2.13GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 2000.070 MHz</div><div class=\"line\">Total size of Disk   : 15.0 GB (1.3 GB Used)</div><div class=\"line\">Total amount of Mem  : 128 MB (80 MB Used)</div><div class=\"line\">Total amount of Swap : 128 MB (32 MB Used)</div><div class=\"line\">System uptime        : 0 days, 22 hour 28 min</div><div class=\"line\">Load average         : 0.10, 0.04, 0.05</div><div class=\"line\">OS                   : Ubuntu 14.04.2 LTS</div><div class=\"line\">Arch                 : i686 (32 Bit)</div><div class=\"line\">Kernel               : 2.6.32-openvz-042stab116.2-amd64</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 102 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 97.1 MB/s</div><div class=\"line\">I/O speed(3rd run)   : 147 MB/s</div><div class=\"line\">Average I/O speed    : 115.4 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         14.7MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          6.15MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            2.54MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           2.99MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           2.96MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             4.27MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           11.7MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          13.0MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            1.89MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           3.26MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          3.72MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<h3 id=\"DigitalOcean-Los-Angeles\"><a href=\"#DigitalOcean-Los-Angeles\" class=\"headerlink\" title=\"DigitalOcean Los Angeles\"></a>DigitalOcean Los Angeles</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU E5-2650L v3 @ 1.80GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 1799.998 MHz</div><div class=\"line\">Total size of Disk   : 20.2 GB (1.0 GB Used)</div><div class=\"line\">Total amount of Mem  : 488 MB (33 MB Used)</div><div class=\"line\">Total amount of Swap : 0 MB (0 MB Used)</div><div class=\"line\">System uptime        : 0 days, 0 hour 3 min</div><div class=\"line\">Load average         : 0.16, 0.10, 0.03</div><div class=\"line\">OS                   : Ubuntu 16.04.2 LTS</div><div class=\"line\">Arch                 : x86_64 (64 Bit)</div><div class=\"line\">Kernel               : 4.4.0-78-generic</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 581 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 711 MB/s</div><div class=\"line\">I/O speed(3rd run)   : 777 MB/s</div><div class=\"line\">Average I/O speed    : 689.7 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         161MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          15.7MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            5.96MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           5.71MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           6.45MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             30.4MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           29.9MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          57.7MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            3.64MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           7.59MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          8.84MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<h3 id=\"DigitalOcean-Sinapore-ip-adress-lokks-like-Russian\"><a href=\"#DigitalOcean-Sinapore-ip-adress-lokks-like-Russian\" class=\"headerlink\" title=\"DigitalOcean Sinapore (ip adress lokks like Russian)\"></a>DigitalOcean Sinapore (ip adress lokks like Russian)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">CPU model            : Intel(R) Xeon(R) CPU E5-2630L 0 @ 2.00GHz</div><div class=\"line\">Number of cores      : 1</div><div class=\"line\">CPU frequency        : 1999.999 MHz</div><div class=\"line\">Total size of Disk   : 20.2 GB (1.0 GB Used)</div><div class=\"line\">Total amount of Mem  : 488 MB (36 MB Used)</div><div class=\"line\">Total amount of Swap : 0 MB (0 MB Used)</div><div class=\"line\">System uptime        : 0 days, 0 hour 2 min</div><div class=\"line\">Load average         : 0.17, 0.20, 0.09</div><div class=\"line\">OS                   : Ubuntu 16.04.2 LTS</div><div class=\"line\">Arch                 : x86_64 (64 Bit)</div><div class=\"line\">Kernel               : 4.4.0-78-generic</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">I/O speed(1st run)   : 662 MB/s</div><div class=\"line\">I/O speed(2nd run)   : 741 MB/s</div><div class=\"line\">I/O speed(3rd run)   : 728 MB/s</div><div class=\"line\">Average I/O speed    : 710.3 MB/s</div><div class=\"line\">----------------------------------------------------------------------</div><div class=\"line\">Node Name                       IPv4 address            Download Speed</div><div class=\"line\">CacheFly                        205.234.175.175         20.8MB/s</div><div class=\"line\">Linode, Tokyo, JP               106.187.96.148          18.6MB/s</div><div class=\"line\">Linode, Singapore, SG           139.162.23.4            83.8MB/s</div><div class=\"line\">Linode, London, UK              176.58.107.39           5.71MB/s</div><div class=\"line\">Linode, Frankfurt, DE           139.162.130.8           8.13MB/s</div><div class=\"line\">Linode, Fremont, CA             50.116.14.9             2.82MB/s</div><div class=\"line\">Softlayer, Dallas, TX           173.192.68.18           6.18MB/s</div><div class=\"line\">Softlayer, Seattle, WA          67.228.112.250          8.47MB/s</div><div class=\"line\">Softlayer, Frankfurt, DE        159.122.69.4            6.77MB/s</div><div class=\"line\">Softlayer, Singapore, SG        119.81.28.170           97.9MB/s</div><div class=\"line\">Softlayer, HongKong, CN         119.81.130.170          35.2MB/s</div><div class=\"line\">----------------------------------------------------------------------</div></pre></td></tr></table></figure>\n<p>查看硬盘存储空间:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">df -h //h的意思是human-readable</div><div class=\"line\">du -sh //查看当前directory的大小</div><div class=\"line\">du -h //查看当前目录下各个子目录分别的大小</div><div class=\"line\">dh -h img// 查看img目录下文件及文件夹的大小</div><div class=\"line\">dh -h img/1.jpg //查看指定文件的大小</div></pre></td></tr></table></figure></p>\n<p>查看cpu信息</p>\n<blockquote>\n<p>cat /proc/cpuinfo</p>\n</blockquote>\n<p>查看内存</p>\n<blockquote>\n<p>free -m<br>free -h # human readable</p>\n</blockquote>\n<p>修改默认安全设置</p>\n<blockquote>\n<p>vi /etc/ssh/ssd_config</p>\n</blockquote>\n<p>添加或修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Port 22 (ssh默认端口修改)</div><div class=\"line\">PermitRootLogin without-Password no</div><div class=\"line\">AllowUsers userName</div></pre></td></tr></table></figure>\n<p>压缩文件命令<br>将/home/video/ 这个目录下所有文件和文件夹打包为当前目录下的video.zip</p>\n<p>zip –q –r -v video.zip . #加上一个-v主要是为了能够实时查看输出</p>\n<p>文件传输（linux -&gt;windows）： 一般使用putty ssh到Linux主机，想要把Linux上的文件弄到Windows中，需要使用pscp工具。下载好pscp.exe后，放到c:/windows/system32下面。打开cmd。输入命令<br>pscp -r root@202.123.123.123:”/root/fileonServer.mp4” d:/whateveriwantonmyPc.mp4  ，确认后输入root密码就好了。我主要是用来下载视频的。<br>有时候会出现Connection Refused Error。</p>\n<blockquote>\n<p>netstat -anp | grep sshd</p>\n</blockquote>\n<p>看下跑在哪个端口<br>然后</p>\n<blockquote>\n<p>pscp -P 12345-r root@202.123.123.123:”/root/fileonServer.mp4” d:/whateveriwantonmyPc.mp4  -p要大写</p>\n</blockquote>\n<h3 id=\"8-SS相关的命令\"><a href=\"#8-SS相关的命令\" class=\"headerlink\" title=\"8. SS相关的命令\"></a>8. SS相关的命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">  1. 刚装好的ubuntu需要执行以下步骤</div><div class=\"line\">  安装git &gt; apt-get install git</div><div class=\"line\">  安装python &gt; apt-get install python-2.7</div><div class=\"line\">  安装python-setuptools &gt; apt-get install python-setuptools</div><div class=\"line\">  检查是否安装好： python --version</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  2. 下载shadowsocks源码编译</div><div class=\"line\"> &gt; git clone https://github.com/shadowsocks/shadowsocks</div><div class=\"line\">  # 记得切换到master分支</div><div class=\"line\">  python setup.py build</div><div class=\"line\">  python setup.py install</div><div class=\"line\"></div><div class=\"line\">  检查下版本 ssserver --version</div><div class=\"line\"></div><div class=\"line\">  3. 编辑配置文件</div><div class=\"line\">  vim config.json</div><div class=\"line\">  &#123;</div><div class=\"line\">   &quot;server&quot;:&quot;my_server_ip&quot;,</div><div class=\"line\">   &quot;server_port&quot;:8388,</div><div class=\"line\">   &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">   &quot;local_port&quot;:1080,</div><div class=\"line\">   &quot;password&quot;:&quot;mypassword&quot;,</div><div class=\"line\">   &quot;timeout&quot;:300,</div><div class=\"line\">   &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">   &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ssserver -c config.json -d start #启动完成</div><div class=\"line\"></div><div class=\"line\">检查下是否启动了</div><div class=\"line\">ps -ef |grep sss</div><div class=\"line\"></div><div class=\"line\">ss 命令</div><div class=\"line\">ssserver -c /etc/shadowsocks/config.json # 前台运行</div><div class=\"line\"></div><div class=\"line\">- 后台运行和停止</div><div class=\"line\">ssserver -c /etc/shadowsocks.json -d start</div><div class=\"line\">ssserver -c /etc/shadowsocks.json -d stop</div><div class=\"line\"></div><div class=\"line\">- 加入开机启动</div><div class=\"line\"></div><div class=\"line\">在/etc/rc.local中加入</div><div class=\"line\">sudo ssserver -c /etc/shadowsocks.json --user username -d start - 不要总是用root用户做事，adduser来做，给sudo权限即可</div><div class=\"line\"></div><div class=\"line\">[ShadowsocksR](https://github.com/breakwa11/shadowsocks-rss/wiki)启动后台运行命令</div><div class=\"line\">&gt; python server.py -p 443 -k password -m aes-256-cfb -O auth_sha1_v4 -o http_simple -d start</div><div class=\"line\"></div><div class=\"line\">[net-speeder](https://zhgcao.github.io/2016/05/26/ubuntu-install-net-speeder/)</div><div class=\"line\">venetX，OpenVZ架构</div><div class=\"line\"></div><div class=\"line\">cd net-speeder-master/</div><div class=\"line\">sh build.sh -DCOOKED</div><div class=\"line\"></div><div class=\"line\">Xen，KVM，物理机</div><div class=\"line\">cd net-speeder-master/</div><div class=\"line\">sh build.sh</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">加速所有ip协议数据</div><div class=\"line\"></div><div class=\"line\">&gt; ./net_speeder venet0 &quot;ip&quot;</div><div class=\"line\"></div><div class=\"line\">只加速指定端口，例如只加速TCP协议的 8989端口</div><div class=\"line\">前提是切换到net-speeder的目录下</div><div class=\"line\">&gt; ./net_speeder venet0:0 &quot;tcp src port 8989&quot;</div><div class=\"line\"></div><div class=\"line\">./net_speeder venet0 &quot;ip&quot;</div><div class=\"line\"></div><div class=\"line\">只加速指定端口，例如只加速TCP协议的 8989端口</div><div class=\"line\">前提是切换到net-speeder的目录下</div><div class=\"line\"> ./net_speeder venet0:0 &quot;tcp src port 8989&quot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> [KVM架构升级内核开启BBR](https://qiujunya.com/linodebbr.html)</div></pre></td></tr></table></figure>\n<h3 id=\"9-网络监控\"><a href=\"#9-网络监控\" class=\"headerlink\" title=\"9. 网络监控\"></a>9. 网络监控</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">tcpdump -i &quot;venet0:0&quot;  //抓包的</div><div class=\"line\">tcpdump -c 10 //count</div><div class=\"line\">tcpdump -c -A  //Asicii码形式展示出来每个package</div><div class=\"line\">tcpdump -c 5 -i wlo1 // 监听某一个网卡</div><div class=\"line\">tcpdump -c 5 -i wlo1 port 22// 监听某一个网卡某一个端口</div><div class=\"line\"></div><div class=\"line\">tcpdump version 4.5.1</div><div class=\"line\">libpcap version 1.5.3</div><div class=\"line\">Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ]</div><div class=\"line\">                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]</div><div class=\"line\">                [ -i interface ] [ -j tstamptype ] [ -M secret ]</div><div class=\"line\">                [ -P in|out|inout ]</div><div class=\"line\">                [ -r file ] [ -s snaplen ] [ -T type ] [ -V file ] [ -w file ]</div><div class=\"line\">                [ -W filecount ] [ -y datalinktype ] [ -z command ]</div><div class=\"line\">                [ -Z user ] [ expression ]</div></pre></td></tr></table></figure>\n<p>tcpdump结合wireshark可实现完整的网络抓包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">netstat</div><div class=\"line\">netstat -i // 查看某个网络接口发出和接收了多少byte的数据</div><div class=\"line\">netstat -ta //当前active的网络连接</div><div class=\"line\">netstat -tan //以ip地址的方式展示出来</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ifconfig // 查看机器上的网卡</div><div class=\"line\">en01 //Ethernet</div><div class=\"line\">注意 RX bytes(接收到的数据)和TX bytes(发送出去的数据)后面的数字</div></pre></td></tr></table></figure>\n<h3 id=\"10-查看进程\"><a href=\"#10-查看进程\" class=\"headerlink\" title=\"10.查看进程\"></a>10.查看进程</h3><p><a href=\"https://stackoverflow.com/questions/4797050/how-to-run-process-as-background-and-never-die\">起一个进程，后台运行，关掉终端照样跑的那种</a></p>\n<blockquote>\n<p> nohup node server.js &gt; /dev/null 2&gt;&amp;1 &amp;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup node server.js &gt; /dev/null 2&gt;&amp;1 &amp;</div><div class=\"line\"></div><div class=\"line\">1. nohup means: Do not terminate this process even when the stty is cut off.</div><div class=\"line\">2. &gt; /dev/null means: stdout goes to /dev/null (which is a dummy device that does not record any output).</div><div class=\"line\">3. 2&gt;&amp;1 means: stderr also goes to the stdout (which is already redirected to /dev/null). You may replace &amp;1 with a file path to keep a log of errors, e.g.: 2&gt;/tmp/myLog</div><div class=\"line\">4. &amp; at the end means: run this command as a background task.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">top 动态显示</div><div class=\"line\">PID：进程的ID[参数解释](http://www.cnblogs.com/gaojun/p/3406096.html)</div><div class=\"line\">　　USER：进程所有者</div><div class=\"line\">　　PR：进程的优先级别，越小越优先被执行</div><div class=\"line\">　　NInice：值</div><div class=\"line\">　　VIRT：进程占用的虚拟内存</div><div class=\"line\">　　RES：进程占用的物理内存</div><div class=\"line\">　　SHR：进程使用的共享内存</div><div class=\"line\">　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</div><div class=\"line\">　　%CPU：进程占用CPU的使用率</div><div class=\"line\">　　%MEM：进程使用的物理内存和总内存的百分比</div><div class=\"line\">　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</div><div class=\"line\">　　COMMAND：进程启动命令名称</div><div class=\"line\"></div><div class=\"line\">ps a 显示现行终端机下的所有程序，包括其他用户的程序。</div><div class=\"line\"></div><div class=\"line\">**看下某个进程跑在哪个端口**</div><div class=\"line\"> netstat -anp | grep sshd</div><div class=\"line\"></div><div class=\"line\">ps | grep 类似于 pgrep XXX //查找某个进程</div><div class=\"line\"></div><div class=\"line\">进程命令</div><div class=\"line\">*实时监控，1秒刷新一次*</div><div class=\"line\">watch -n 1 ps -aux --sort=-pmem,-pcpu</div></pre></td></tr></table></figure>\n<p>查看端口占用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#列出所有端口的占用情况</div><div class=\"line\">netstat -anp</div><div class=\"line\">lsof -i # 这个也行</div><div class=\"line\">#查看哪个进程占了http端口(其实就是80了)</div><div class=\"line\">lsof -i:80</div><div class=\"line\">#查看某个进程占了哪些端口</div><div class=\"line\">netstat -anp|grep pid</div></pre></td></tr></table></figure></p>\n<p>//杀进程（如果进程不属于当前用户，要sudo）</p>\n<blockquote>\n<p>杀进程，慎用。<br>kill -9 进程id // 9直接干掉进程，慎用。。。<br>kill pid // 这个和kill 15是一样的 //15表示terminate,请求进程停下来  </p>\n</blockquote>\n<p>kill -l //列出进程及id</p>\n<p>killall nginx -&gt;&gt; 干掉nginx的所有进程</p>\n<p>pkill -u username //干掉所有属于某一个用户的ps</p>\n<p>Signal (信号)  man signal</p>\n<p>进程状态<br>runnable、sleeping、zombie、stop</p>\n<p>//更改友善度,数字越小越不友好<br>nice -n 15 /…..   命令path。启动的时候确定nice<br>renice -s pid //更改友善度</p>\n<p>df -ah  // 查看mounted文件系统<br>proc</p>\n<h3 id=\"11-常用配置\"><a href=\"#11-常用配置\" class=\"headerlink\" title=\"11 .常用配置\"></a>11 .常用配置</h3><blockquote>\n<p>查看登陆失败日志<br>grep “Failed password for root” /var/log/auth.log | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more</p>\n</blockquote>\n<p>防范措施<br>修改登陆端口号<br>sudo vi /etc/ssh/sshd_config<br>Port 4484<br>PermitRootLogin no</p>\n<p>修改完成后重启ssh<br>/etc/init.d/ssh restart</p>\n<p><a href=\"https://perlgeek.de/en/article/set-up-a-clean-utf8-environment\">编码的修改</a><br>更改locale为utf-8(ubuntu)<br>&gt;<br>vi ~/.bashrc</p>\n<h1 id=\"add-these-lines\"><a href=\"#add-these-lines\" class=\"headerlink\" title=\"add these lines\"></a>add these lines</h1><p>export LC_ALL=en_US.UTF-8<br>export LANG=en_US.UTF-8<br>export LANGUAGE=en_US.UTF-8</p>\n<p>sudo locale-gen “en_US.UTF-8”<br>sudo dpkg-reconfigure locales</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><img src=\"http://odzl05jxx.bkt.clouddn.com/fork_you_git.jpg\" alt=\"\"></li>\n<li><a href=\"https://my.oschina.net/liting/blog/392051\">文件大小查看命令</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_7479f7990100zwkp.html\">文件压缩命令</a></li>\n<li><a href=\"https://my.oschina.net/hunterli/blog/140783\">硬件查询</a></li>\n<li><a href=\"http://www.jianshu.com/p/3d80c7cb7b17\">Python源码编译安装ss</a></li>\n<li><a href=\"http://blog.csdn.net/program_thinker/article/details/45787395\">源码编译安装ss</a></li>\n<li><a href=\"https://askubuntu.com/questions/162391/how-do-i-fix-my-locale-issue\">修改系统编码为utf-8</a></li>\n</ul>"},{"title":"Hexo部署个人博客记录","date":"2017-01-08T10:01:01.000Z","top":2,"_content":"\n使用hexo写博客以来，记录下来的问题越来越多。只希望下次再碰到同样的问题时，不要再去浪费时间去查找。如果想要给自己的blog一个值得置顶的文章的话，我觉得一篇记录使用hexo过程中的一些解决问题的方法的文章是再合适不过的了。</br>\n![](http://odzl05jxx.bkt.clouddn.com/79a65f1911c81d736be0704904de8ea1.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n### 1. 经常更新yilia的theme\n[yilia](https://github.com/litten/hexo-theme-yilia)主题经常会更新，及时更新theme会发现很多新的特性及bug fix\n\n### 2. 部署相关\n- 部署到github\n```javascript\nhexo clean //清除缓存\nhexo g -d //一步到位 = hexo g + hexo d\nhexo s //localost:4000本地预览\n```\n\n- 部署过程中出现的一些错误\n\n```javascript\n$ hexo g -d\nINFO  Start processing\nERROR Process failed: _posts/2016-12-10-adb-command.md\nYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 3, column 11:\n    categories:  [技术]\n              ^\n    at generateError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:162:10)\n    at throwError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:168:9)\n    at readBlockMapping (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1040:9)\n    at composeNode (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1326:12)\n    at readDocument (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1488:3)\n    at loadDocuments (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1544:5)\n    at Object.load (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1561:19)\n    at parseYAML (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:80:21)\n    at parse (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:56:12)\n    at D:\\Blog\\github\\node_modules\\hexo\\lib\\plugins\\processor\\post.js:52:18\n    at tryCatcher (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\util.js:16:23)\n    at Promise._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:507:35)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:567:18)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:125:19)\n    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:143:14)\n    at PromiseArray._iterate (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:113:31)\n    at PromiseArray.init [as _init] (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:77:10)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:564:21)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:125:19)\n    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:143:14)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:572:26)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at Promise._resolveCallback (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:431:57)\n    at Promise._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:522:17)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:567:18)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\nodeback.js:42:21\n    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-fs\\node_modules\\graceful-fs\\graceful-fs.js:78:16\n    at tryToString (fs.js:455:3)\n    at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:442:12)\nINFO  Files loaded in 1.48 s\nINFO  Generated: sitemap.xml\nINFO  Generated: atom.xml\nINFO  Generated: 2017/01/08/2017-01-08-trouble-shooting-with-my-blog/index.html\nINFO  Generated: index.html\nINFO  4 files generated in 2.26 s\nINFO  Deploying: git\n\n```\n找了好久，有说 _config.xml有空格的，有说title被乱改的，试了好长时间，改成这样就不再报错了。所以，**冒号后面一定要加空格，英文半角的**\n```\n---\ntitle: adb常用命令手册\ndate: 2016-12-10 21:14:14\ntags:\n - android\n - adb\n---\n```\ntags有两种写法，一种是上面这样前面加横杠\n另一种长这样，写成数组形式\n```\n---\ntitle: my awesometitle\ndate: 2017-05-07 16:48:01\ncategories: blog\ntags: [linux,python]\n---\n```\n\n\n### 3. 一些功能的实现\n\n- 置顶功能\n    将node_modules/hexo-generator-index/lib/generator.js的文件内容替换成以下内容\n\n```javascript\n'use strict';\nvar pagination = require('hexo-pagination');\nmodule.exports = function(locals){\n  var config = this.config;\n  var posts = locals.posts;\n    posts.data = posts.data.sort(function(a, b) {\n        if(a.top && b.top) { // 两篇文章top都有定义\n            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排\n            else return b.top - a.top; // 否则按照top值降序排\n        }\n        else if(a.top && !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）\n            return -1;\n        }\n        else if(!a.top && b.top) {\n            return 1;\n        }\n        else return b.date - a.date; // 都没定义按照文章日期降序排\n    });\n  var paginationDir = config.pagination_dir || 'page';\n  return pagination('', posts, {\n    perPage: config.index_generator.per_page,\n    layout: ['index', 'archive'],\n    format: paginationDir + '/%d/',\n    data: {\n    __index: true\n    }\n  });\n};\n\n```\n\n- 同时在文章开头添加top : 1即可 ，实际排序按照这个数字从大到小排序\n```java\n title: Hexo置顶文章\ndate: 2016-11-11 23:26:22\ntags:[置顶]\ncategories: Hexo\ntop: 0 # 0或者1\n```\n\n### 4. SublimeText的一些快捷键\n由于文章大部分都是使用SublimeText写的，Typroa这种所见即所得的编辑器也不错，但对于掌握MardkDown语法没有帮助。这里摘录一些SubLimeText的快捷键。\n\n> **Ctrl+Shift+P：打开命令面板**\nCtrl+P：搜索项目中的文件\nCtrl+G：跳转到第几行\nCtrl+W：关闭当前打开文件 CTRL+F4也可以\nCtrl+Shift+W：关闭所有打开文件\nCtrl+Shift+V：粘贴并格式化\nCtrl+D：选择单词，重复可增加选择下一个相同的单词\n**Ctrl+L：选择行，重复可依次增加选择下一行**\n**Alt+Shift+数字：分屏显示**\n**Ctrl+Shift+L：选择多行**\n**Ctrl+Shift+D：复制粘贴当前行**\n**Ctrl+X：删除当前行**\n**Ctrl+Shift+左箭头 往左边选择内容**\n**Shift+向左箭头 向左选择文本**\n**Ctrl+B 编译，markDown生成html文件**\n**Alt+2 切换到第二个Tab（打开的文件，记得chrome是ctrl+2）**\n**Ctrl+R：前往 对应的方法的实现***\n**快速加上[] 选中单词按 [ 即可**\n**批量更改当前页面相同的单词 alt+F3 **\n**Ctrl+Enter 在下一行插入新的一行**\n**Ctrl+Shift+Enter 在上一行插入新的一行**\n**Shift+ 向上箭头 向上选中多行**\n\n\n\nCtrl+Shift+D：复制粘贴当前行Ctrl+Shift+Enter：在当前行前插入新行\nCtrl+M：跳转到对应括号\nCtrl+U：软撤销，撤销光标位置\nCtrl+J：选择标签内容\nCtrl+F：查找内容\nCtrl+Shift+F：查找并替换\nCtrl+H：替换\nCtrl+N：新建窗口\nCtrl+K+B：开关侧栏\nCtrl+Shift+M：选中当前括号内容，重复可选着括号本身\nCtrl+F2：设置/删除标记\nCtrl+/：注释当前行\nCtrl+Shift+/：当前位置插入注释\nCtrl+Alt+/：块注释，并Focus到首行，写注释说明用的\nCtrl+Shift+A：选择当前标签前后，修改标签用的\nF11：全屏\nShift+F11：全屏免打扰模式，只编辑当前文件\nAlt+F3：选择所有相同的词\nAlt+.：闭合标签\nShift+右键拖动：光标多不，用来更改或插入列内容\nAlt+数字：切换打开第N个文件\n鼠标的前进后退键可切换Tab文件\n按Ctrl，依次点击或选取，可需要编辑的多个位置\n按Ctrl+Shift+上下键，可替换行\n\n\n\n### 5. title不能以[]开头\n前面加上###确实能够让字号变大，但不要写4个#，后面的字母会大小写不分的\n\n\n### 6. markdown语法\nMarkDown页面内部跳转\n[MarkDown技巧：两种方式实现页内跳转](http://www.cnblogs.com/JohnTsai/p/4027229.html)\n\n### 7.github提交commit的时候显示Emoji\n链接[在此](https://www.webpagefx.com/tools/emoji-cheat-sheet/)\n\n\n\n### ref\n- [Hexo博文置顶技巧](http://yanhuili.github.io/2016/11/21/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%8A%80%E5%B7%A7/)\n- [SublimeText快捷键](http://www.daqianduan.com/4820.html)","source":"_posts/2017-01-08-trouble-shooting-with-my-blog.md","raw":"---\ntitle: Hexo部署个人博客记录\ndate: 2017-01-08 18:01:01\ncategories: blog\ntags: [hexo,置顶]\ntop : 2\n---\n\n使用hexo写博客以来，记录下来的问题越来越多。只希望下次再碰到同样的问题时，不要再去浪费时间去查找。如果想要给自己的blog一个值得置顶的文章的话，我觉得一篇记录使用hexo过程中的一些解决问题的方法的文章是再合适不过的了。</br>\n![](http://odzl05jxx.bkt.clouddn.com/79a65f1911c81d736be0704904de8ea1.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n### 1. 经常更新yilia的theme\n[yilia](https://github.com/litten/hexo-theme-yilia)主题经常会更新，及时更新theme会发现很多新的特性及bug fix\n\n### 2. 部署相关\n- 部署到github\n```javascript\nhexo clean //清除缓存\nhexo g -d //一步到位 = hexo g + hexo d\nhexo s //localost:4000本地预览\n```\n\n- 部署过程中出现的一些错误\n\n```javascript\n$ hexo g -d\nINFO  Start processing\nERROR Process failed: _posts/2016-12-10-adb-command.md\nYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 3, column 11:\n    categories:  [技术]\n              ^\n    at generateError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:162:10)\n    at throwError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:168:9)\n    at readBlockMapping (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1040:9)\n    at composeNode (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1326:12)\n    at readDocument (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1488:3)\n    at loadDocuments (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1544:5)\n    at Object.load (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:1561:19)\n    at parseYAML (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:80:21)\n    at parse (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:56:12)\n    at D:\\Blog\\github\\node_modules\\hexo\\lib\\plugins\\processor\\post.js:52:18\n    at tryCatcher (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\util.js:16:23)\n    at Promise._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:507:35)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:567:18)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:125:19)\n    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:143:14)\n    at PromiseArray._iterate (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:113:31)\n    at PromiseArray.init [as _init] (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:77:10)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:564:21)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:125:19)\n    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:143:14)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:572:26)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at Promise._resolveCallback (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:431:57)\n    at Promise._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:522:17)\n    at Promise._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:567:18)\n    at Promise._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:612:10)\n    at Promise._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:691:18)\n    at Promise._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:636:18)\n    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\nodeback.js:42:21\n    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-fs\\node_modules\\graceful-fs\\graceful-fs.js:78:16\n    at tryToString (fs.js:455:3)\n    at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:442:12)\nINFO  Files loaded in 1.48 s\nINFO  Generated: sitemap.xml\nINFO  Generated: atom.xml\nINFO  Generated: 2017/01/08/2017-01-08-trouble-shooting-with-my-blog/index.html\nINFO  Generated: index.html\nINFO  4 files generated in 2.26 s\nINFO  Deploying: git\n\n```\n找了好久，有说 _config.xml有空格的，有说title被乱改的，试了好长时间，改成这样就不再报错了。所以，**冒号后面一定要加空格，英文半角的**\n```\n---\ntitle: adb常用命令手册\ndate: 2016-12-10 21:14:14\ntags:\n - android\n - adb\n---\n```\ntags有两种写法，一种是上面这样前面加横杠\n另一种长这样，写成数组形式\n```\n---\ntitle: my awesometitle\ndate: 2017-05-07 16:48:01\ncategories: blog\ntags: [linux,python]\n---\n```\n\n\n### 3. 一些功能的实现\n\n- 置顶功能\n    将node_modules/hexo-generator-index/lib/generator.js的文件内容替换成以下内容\n\n```javascript\n'use strict';\nvar pagination = require('hexo-pagination');\nmodule.exports = function(locals){\n  var config = this.config;\n  var posts = locals.posts;\n    posts.data = posts.data.sort(function(a, b) {\n        if(a.top && b.top) { // 两篇文章top都有定义\n            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排\n            else return b.top - a.top; // 否则按照top值降序排\n        }\n        else if(a.top && !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）\n            return -1;\n        }\n        else if(!a.top && b.top) {\n            return 1;\n        }\n        else return b.date - a.date; // 都没定义按照文章日期降序排\n    });\n  var paginationDir = config.pagination_dir || 'page';\n  return pagination('', posts, {\n    perPage: config.index_generator.per_page,\n    layout: ['index', 'archive'],\n    format: paginationDir + '/%d/',\n    data: {\n    __index: true\n    }\n  });\n};\n\n```\n\n- 同时在文章开头添加top : 1即可 ，实际排序按照这个数字从大到小排序\n```java\n title: Hexo置顶文章\ndate: 2016-11-11 23:26:22\ntags:[置顶]\ncategories: Hexo\ntop: 0 # 0或者1\n```\n\n### 4. SublimeText的一些快捷键\n由于文章大部分都是使用SublimeText写的，Typroa这种所见即所得的编辑器也不错，但对于掌握MardkDown语法没有帮助。这里摘录一些SubLimeText的快捷键。\n\n> **Ctrl+Shift+P：打开命令面板**\nCtrl+P：搜索项目中的文件\nCtrl+G：跳转到第几行\nCtrl+W：关闭当前打开文件 CTRL+F4也可以\nCtrl+Shift+W：关闭所有打开文件\nCtrl+Shift+V：粘贴并格式化\nCtrl+D：选择单词，重复可增加选择下一个相同的单词\n**Ctrl+L：选择行，重复可依次增加选择下一行**\n**Alt+Shift+数字：分屏显示**\n**Ctrl+Shift+L：选择多行**\n**Ctrl+Shift+D：复制粘贴当前行**\n**Ctrl+X：删除当前行**\n**Ctrl+Shift+左箭头 往左边选择内容**\n**Shift+向左箭头 向左选择文本**\n**Ctrl+B 编译，markDown生成html文件**\n**Alt+2 切换到第二个Tab（打开的文件，记得chrome是ctrl+2）**\n**Ctrl+R：前往 对应的方法的实现***\n**快速加上[] 选中单词按 [ 即可**\n**批量更改当前页面相同的单词 alt+F3 **\n**Ctrl+Enter 在下一行插入新的一行**\n**Ctrl+Shift+Enter 在上一行插入新的一行**\n**Shift+ 向上箭头 向上选中多行**\n\n\n\nCtrl+Shift+D：复制粘贴当前行Ctrl+Shift+Enter：在当前行前插入新行\nCtrl+M：跳转到对应括号\nCtrl+U：软撤销，撤销光标位置\nCtrl+J：选择标签内容\nCtrl+F：查找内容\nCtrl+Shift+F：查找并替换\nCtrl+H：替换\nCtrl+N：新建窗口\nCtrl+K+B：开关侧栏\nCtrl+Shift+M：选中当前括号内容，重复可选着括号本身\nCtrl+F2：设置/删除标记\nCtrl+/：注释当前行\nCtrl+Shift+/：当前位置插入注释\nCtrl+Alt+/：块注释，并Focus到首行，写注释说明用的\nCtrl+Shift+A：选择当前标签前后，修改标签用的\nF11：全屏\nShift+F11：全屏免打扰模式，只编辑当前文件\nAlt+F3：选择所有相同的词\nAlt+.：闭合标签\nShift+右键拖动：光标多不，用来更改或插入列内容\nAlt+数字：切换打开第N个文件\n鼠标的前进后退键可切换Tab文件\n按Ctrl，依次点击或选取，可需要编辑的多个位置\n按Ctrl+Shift+上下键，可替换行\n\n\n\n### 5. title不能以[]开头\n前面加上###确实能够让字号变大，但不要写4个#，后面的字母会大小写不分的\n\n\n### 6. markdown语法\nMarkDown页面内部跳转\n[MarkDown技巧：两种方式实现页内跳转](http://www.cnblogs.com/JohnTsai/p/4027229.html)\n\n### 7.github提交commit的时候显示Emoji\n链接[在此](https://www.webpagefx.com/tools/emoji-cheat-sheet/)\n\n\n\n### ref\n- [Hexo博文置顶技巧](http://yanhuili.github.io/2016/11/21/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%8A%80%E5%B7%A7/)\n- [SublimeText快捷键](http://www.daqianduan.com/4820.html)","slug":"2017-01-08-trouble-shooting-with-my-blog","published":1,"updated":"2017-07-20T15:58:38.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnhb0012bovry5kxogrt","content":"<p>使用hexo写博客以来，记录下来的问题越来越多。只希望下次再碰到同样的问题时，不要再去浪费时间去查找。如果想要给自己的blog一个值得置顶的文章的话，我觉得一篇记录使用hexo过程中的一些解决问题的方法的文章是再合适不过的了。</br><br><img src=\"http://odzl05jxx.bkt.clouddn.com/79a65f1911c81d736be0704904de8ea1.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-经常更新yilia的theme\"><a href=\"#1-经常更新yilia的theme\" class=\"headerlink\" title=\"1. 经常更新yilia的theme\"></a>1. 经常更新yilia的theme</h3><p><a href=\"https://github.com/litten/hexo-theme-yilia\">yilia</a>主题经常会更新，及时更新theme会发现很多新的特性及bug fix</p>\n<h3 id=\"2-部署相关\"><a href=\"#2-部署相关\" class=\"headerlink\" title=\"2. 部署相关\"></a>2. 部署相关</h3><ul>\n<li><p>部署到github</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean <span class=\"comment\">//清除缓存</span></div><div class=\"line\">hexo g -d <span class=\"comment\">//一步到位 = hexo g + hexo d</span></div><div class=\"line\">hexo s <span class=\"comment\">//localost:4000本地预览</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>部署过程中出现的一些错误</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g -d</div><div class=\"line\">INFO  Start processing</div><div class=\"line\">ERROR Process failed: _posts/<span class=\"number\">2016</span><span class=\"number\">-12</span><span class=\"number\">-10</span>-adb-command.md</div><div class=\"line\">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line <span class=\"number\">3</span>, column <span class=\"number\">11</span>:</div><div class=\"line\">    categories:  [技术]</div><div class=\"line\">              ^</div><div class=\"line\">    at generateError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">162</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at throwError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">168</span>:<span class=\"number\">9</span>)</div><div class=\"line\">    at readBlockMapping (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1040</span>:<span class=\"number\">9</span>)</div><div class=\"line\">    at composeNode (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1326</span>:<span class=\"number\">12</span>)</div><div class=\"line\">    at readDocument (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1488</span>:<span class=\"number\">3</span>)</div><div class=\"line\">    at loadDocuments (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1544</span>:<span class=\"number\">5</span>)</div><div class=\"line\">    at <span class=\"built_in\">Object</span>.load (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1561</span>:<span class=\"number\">19</span>)</div><div class=\"line\">    at parseYAML (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:<span class=\"number\">80</span>:<span class=\"number\">21</span>)</div><div class=\"line\">    at parse (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:<span class=\"number\">56</span>:<span class=\"number\">12</span>)</div><div class=\"line\">    at D:\\Blog\\github\\node_modules\\hexo\\lib\\plugins\\processor\\post.js:<span class=\"number\">52</span>:<span class=\"number\">18</span></div><div class=\"line\">    at tryCatcher (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\util.js:<span class=\"number\">16</span>:<span class=\"number\">23</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">507</span>:<span class=\"number\">35</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">567</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">125</span>:<span class=\"number\">19</span>)</div><div class=\"line\">    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">143</span>:<span class=\"number\">14</span>)</div><div class=\"line\">    at PromiseArray._iterate (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">113</span>:<span class=\"number\">31</span>)</div><div class=\"line\">    at PromiseArray.init [<span class=\"keyword\">as</span> _init] (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">77</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">564</span>:<span class=\"number\">21</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">125</span>:<span class=\"number\">19</span>)</div><div class=\"line\">    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">143</span>:<span class=\"number\">14</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">572</span>:<span class=\"number\">26</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._resolveCallback (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">431</span>:<span class=\"number\">57</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">522</span>:<span class=\"number\">17</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">567</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\nodeback.js:<span class=\"number\">42</span>:<span class=\"number\">21</span></div><div class=\"line\">    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-fs\\node_modules\\graceful-fs\\graceful-fs.js:<span class=\"number\">78</span>:<span class=\"number\">16</span></div><div class=\"line\">    at tryToString (fs.js:<span class=\"number\">455</span>:<span class=\"number\">3</span>)</div><div class=\"line\">    at FSReqWrap.readFileAfterClose [<span class=\"keyword\">as</span> oncomplete] (fs.js:<span class=\"number\">442</span>:<span class=\"number\">12</span>)</div><div class=\"line\">INFO  Files loaded <span class=\"keyword\">in</span> <span class=\"number\">1.48</span> s</div><div class=\"line\">INFO  Generated: sitemap.xml</div><div class=\"line\">INFO  Generated: atom.xml</div><div class=\"line\">INFO  Generated: <span class=\"number\">2017</span>/<span class=\"number\">01</span>/<span class=\"number\">08</span>/<span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-08</span>-trouble-shooting-<span class=\"keyword\">with</span>-my-blog/index.html</div><div class=\"line\">INFO  Generated: index.html</div><div class=\"line\">INFO  <span class=\"number\">4</span> files generated <span class=\"keyword\">in</span> <span class=\"number\">2.26</span> s</div><div class=\"line\">INFO  Deploying: git</div></pre></td></tr></table></figure>\n<p>找了好久，有说 _config.xml有空格的，有说title被乱改的，试了好长时间，改成这样就不再报错了。所以，<strong>冒号后面一定要加空格，英文半角的</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: adb常用命令手册</div><div class=\"line\">date: 2016-12-10 21:14:14</div><div class=\"line\">tags:</div><div class=\"line\"> - android</div><div class=\"line\"> - adb</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>tags有两种写法，一种是上面这样前面加横杠<br>另一种长这样，写成数组形式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: my awesometitle</div><div class=\"line\">date: 2017-05-07 16:48:01</div><div class=\"line\">categories: blog</div><div class=\"line\">tags: [linux,python]</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-一些功能的实现\"><a href=\"#3-一些功能的实现\" class=\"headerlink\" title=\"3. 一些功能的实现\"></a>3. 一些功能的实现</h3><ul>\n<li>置顶功能<br>  将node_modules/hexo-generator-index/lib/generator.js的文件内容替换成以下内容</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> pagination = <span class=\"built_in\">require</span>(<span class=\"string\">'hexo-pagination'</span>);</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> config = <span class=\"keyword\">this</span>.config;</div><div class=\"line\">  <span class=\"keyword\">var</span> posts = locals.posts;</div><div class=\"line\">    posts.data = posts.data.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(a.top &amp;&amp; b.top) &#123; <span class=\"comment\">// 两篇文章top都有定义</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(a.top == b.top) <span class=\"keyword\">return</span> b.date - a.date; <span class=\"comment\">// 若top值一样则按照文章日期降序排</span></div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> b.top - a.top; <span class=\"comment\">// 否则按照top值降序排</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a.top &amp;&amp; !b.top) &#123; <span class=\"comment\">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!a.top &amp;&amp; b.top) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> b.date - a.date; <span class=\"comment\">// 都没定义按照文章日期降序排</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">  <span class=\"keyword\">var</span> paginationDir = config.pagination_dir || <span class=\"string\">'page'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> pagination(<span class=\"string\">''</span>, posts, &#123;</div><div class=\"line\">    perPage: config.index_generator.per_page,</div><div class=\"line\">    layout: [<span class=\"string\">'index'</span>, <span class=\"string\">'archive'</span>],</div><div class=\"line\">    format: paginationDir + <span class=\"string\">'/%d/'</span>,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">    __index: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>同时在文章开头添加top : 1即可 ，实际排序按照这个数字从大到小排序<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> title: Hexo置顶文章</div><div class=\"line\">date: 2016-11-11 23:26:22</div><div class=\"line\">tags:[置顶]</div><div class=\"line\">categories: Hexo</div><div class=\"line\">top: 0 # 0或者1</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"4-SublimeText的一些快捷键\"><a href=\"#4-SublimeText的一些快捷键\" class=\"headerlink\" title=\"4. SublimeText的一些快捷键\"></a>4. SublimeText的一些快捷键</h3><p>由于文章大部分都是使用SublimeText写的，Typroa这种所见即所得的编辑器也不错，但对于掌握MardkDown语法没有帮助。这里摘录一些SubLimeText的快捷键。</p>\n<blockquote>\n<p><strong>Ctrl+Shift+P：打开命令面板</strong><br>Ctrl+P：搜索项目中的文件<br>Ctrl+G：跳转到第几行<br>Ctrl+W：关闭当前打开文件 CTRL+F4也可以<br>Ctrl+Shift+W：关闭所有打开文件<br>Ctrl+Shift+V：粘贴并格式化<br>Ctrl+D：选择单词，重复可增加选择下一个相同的单词<br><strong>Ctrl+L：选择行，重复可依次增加选择下一行</strong><br><strong>Alt+Shift+数字：分屏显示</strong><br><strong>Ctrl+Shift+L：选择多行</strong><br><strong>Ctrl+Shift+D：复制粘贴当前行</strong><br><strong>Ctrl+X：删除当前行</strong><br><strong>Ctrl+Shift+左箭头 往左边选择内容</strong><br><strong>Shift+向左箭头 向左选择文本</strong><br><strong>Ctrl+B 编译，markDown生成html文件</strong><br><strong>Alt+2 切换到第二个Tab（打开的文件，记得chrome是ctrl+2）</strong><br><strong>Ctrl+R：前往 对应的方法的实现*</strong><br><strong>快速加上[] 选中单词按 [ 即可</strong><br><strong>批量更改当前页面相同的单词 alt+F3 </strong><br><strong>Ctrl+Enter 在下一行插入新的一行</strong><br><strong>Ctrl+Shift+Enter 在上一行插入新的一行</strong><br><strong>Shift+ 向上箭头 向上选中多行</strong></p>\n</blockquote>\n<p>Ctrl+Shift+D：复制粘贴当前行Ctrl+Shift+Enter：在当前行前插入新行<br>Ctrl+M：跳转到对应括号<br>Ctrl+U：软撤销，撤销光标位置<br>Ctrl+J：选择标签内容<br>Ctrl+F：查找内容<br>Ctrl+Shift+F：查找并替换<br>Ctrl+H：替换<br>Ctrl+N：新建窗口<br>Ctrl+K+B：开关侧栏<br>Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身<br>Ctrl+F2：设置/删除标记<br>Ctrl+/：注释当前行<br>Ctrl+Shift+/：当前位置插入注释<br>Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的<br>Ctrl+Shift+A：选择当前标签前后，修改标签用的<br>F11：全屏<br>Shift+F11：全屏免打扰模式，只编辑当前文件<br>Alt+F3：选择所有相同的词<br>Alt+.：闭合标签<br>Shift+右键拖动：光标多不，用来更改或插入列内容<br>Alt+数字：切换打开第N个文件<br>鼠标的前进后退键可切换Tab文件<br>按Ctrl，依次点击或选取，可需要编辑的多个位置<br>按Ctrl+Shift+上下键，可替换行</p>\n<h3 id=\"5-title不能以-开头\"><a href=\"#5-title不能以-开头\" class=\"headerlink\" title=\"5. title不能以[]开头\"></a>5. title不能以[]开头</h3><p>前面加上###确实能够让字号变大，但不要写4个#，后面的字母会大小写不分的</p>\n<h3 id=\"6-markdown语法\"><a href=\"#6-markdown语法\" class=\"headerlink\" title=\"6. markdown语法\"></a>6. markdown语法</h3><p>MarkDown页面内部跳转<br><a href=\"http://www.cnblogs.com/JohnTsai/p/4027229.html\">MarkDown技巧：两种方式实现页内跳转</a></p>\n<h3 id=\"7-github提交commit的时候显示Emoji\"><a href=\"#7-github提交commit的时候显示Emoji\" class=\"headerlink\" title=\"7.github提交commit的时候显示Emoji\"></a>7.github提交commit的时候显示Emoji</h3><p>链接<a href=\"https://www.webpagefx.com/tools/emoji-cheat-sheet/\">在此</a></p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"http://yanhuili.github.io/2016/11/21/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%8A%80%E5%B7%A7/\">Hexo博文置顶技巧</a></li>\n<li><a href=\"http://www.daqianduan.com/4820.html\">SublimeText快捷键</a></li>\n</ul>\n","excerpt":"<p>使用hexo写博客以来，记录下来的问题越来越多。只希望下次再碰到同样的问题时，不要再去浪费时间去查找。如果想要给自己的blog一个值得置顶的文章的话，我觉得一篇记录使用hexo过程中的一些解决问题的方法的文章是再合适不过的了。</br><br><img src=\"http://odzl05jxx.bkt.clouddn.com/79a65f1911c81d736be0704904de8ea1.jpg?imageView2/2/w/600\" alt=\"\"></p>","more":"<h3 id=\"1-经常更新yilia的theme\"><a href=\"#1-经常更新yilia的theme\" class=\"headerlink\" title=\"1. 经常更新yilia的theme\"></a>1. 经常更新yilia的theme</h3><p><a href=\"https://github.com/litten/hexo-theme-yilia\">yilia</a>主题经常会更新，及时更新theme会发现很多新的特性及bug fix</p>\n<h3 id=\"2-部署相关\"><a href=\"#2-部署相关\" class=\"headerlink\" title=\"2. 部署相关\"></a>2. 部署相关</h3><ul>\n<li><p>部署到github</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean <span class=\"comment\">//清除缓存</span></div><div class=\"line\">hexo g -d <span class=\"comment\">//一步到位 = hexo g + hexo d</span></div><div class=\"line\">hexo s <span class=\"comment\">//localost:4000本地预览</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>部署过程中出现的一些错误</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g -d</div><div class=\"line\">INFO  Start processing</div><div class=\"line\">ERROR Process failed: _posts/<span class=\"number\">2016</span><span class=\"number\">-12</span><span class=\"number\">-10</span>-adb-command.md</div><div class=\"line\">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line <span class=\"number\">3</span>, column <span class=\"number\">11</span>:</div><div class=\"line\">    categories:  [技术]</div><div class=\"line\">              ^</div><div class=\"line\">    at generateError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">162</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at throwError (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">168</span>:<span class=\"number\">9</span>)</div><div class=\"line\">    at readBlockMapping (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1040</span>:<span class=\"number\">9</span>)</div><div class=\"line\">    at composeNode (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1326</span>:<span class=\"number\">12</span>)</div><div class=\"line\">    at readDocument (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1488</span>:<span class=\"number\">3</span>)</div><div class=\"line\">    at loadDocuments (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1544</span>:<span class=\"number\">5</span>)</div><div class=\"line\">    at <span class=\"built_in\">Object</span>.load (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js:<span class=\"number\">1561</span>:<span class=\"number\">19</span>)</div><div class=\"line\">    at parseYAML (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:<span class=\"number\">80</span>:<span class=\"number\">21</span>)</div><div class=\"line\">    at parse (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-front-matter\\lib\\front_matter.js:<span class=\"number\">56</span>:<span class=\"number\">12</span>)</div><div class=\"line\">    at D:\\Blog\\github\\node_modules\\hexo\\lib\\plugins\\processor\\post.js:<span class=\"number\">52</span>:<span class=\"number\">18</span></div><div class=\"line\">    at tryCatcher (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\util.js:<span class=\"number\">16</span>:<span class=\"number\">23</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">507</span>:<span class=\"number\">35</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">567</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">125</span>:<span class=\"number\">19</span>)</div><div class=\"line\">    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">143</span>:<span class=\"number\">14</span>)</div><div class=\"line\">    at PromiseArray._iterate (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">113</span>:<span class=\"number\">31</span>)</div><div class=\"line\">    at PromiseArray.init [<span class=\"keyword\">as</span> _init] (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">77</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">564</span>:<span class=\"number\">21</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at PromiseArray._resolve (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">125</span>:<span class=\"number\">19</span>)</div><div class=\"line\">    at PromiseArray._promiseFulfilled (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise_array.js:<span class=\"number\">143</span>:<span class=\"number\">14</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">572</span>:<span class=\"number\">26</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._resolveCallback (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">431</span>:<span class=\"number\">57</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromiseFromHandler (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">522</span>:<span class=\"number\">17</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">567</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromise0 (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">612</span>:<span class=\"number\">10</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._settlePromises (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">691</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at <span class=\"built_in\">Promise</span>._fulfill (D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">636</span>:<span class=\"number\">18</span>)</div><div class=\"line\">    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\nodeback.js:<span class=\"number\">42</span>:<span class=\"number\">21</span></div><div class=\"line\">    at D:\\Blog\\github\\node_modules\\hexo\\node_modules\\hexo-fs\\node_modules\\graceful-fs\\graceful-fs.js:<span class=\"number\">78</span>:<span class=\"number\">16</span></div><div class=\"line\">    at tryToString (fs.js:<span class=\"number\">455</span>:<span class=\"number\">3</span>)</div><div class=\"line\">    at FSReqWrap.readFileAfterClose [<span class=\"keyword\">as</span> oncomplete] (fs.js:<span class=\"number\">442</span>:<span class=\"number\">12</span>)</div><div class=\"line\">INFO  Files loaded <span class=\"keyword\">in</span> <span class=\"number\">1.48</span> s</div><div class=\"line\">INFO  Generated: sitemap.xml</div><div class=\"line\">INFO  Generated: atom.xml</div><div class=\"line\">INFO  Generated: <span class=\"number\">2017</span>/<span class=\"number\">01</span>/<span class=\"number\">08</span>/<span class=\"number\">2017</span><span class=\"number\">-01</span><span class=\"number\">-08</span>-trouble-shooting-<span class=\"keyword\">with</span>-my-blog/index.html</div><div class=\"line\">INFO  Generated: index.html</div><div class=\"line\">INFO  <span class=\"number\">4</span> files generated <span class=\"keyword\">in</span> <span class=\"number\">2.26</span> s</div><div class=\"line\">INFO  Deploying: git</div></pre></td></tr></table></figure>\n<p>找了好久，有说 _config.xml有空格的，有说title被乱改的，试了好长时间，改成这样就不再报错了。所以，<strong>冒号后面一定要加空格，英文半角的</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: adb常用命令手册</div><div class=\"line\">date: 2016-12-10 21:14:14</div><div class=\"line\">tags:</div><div class=\"line\"> - android</div><div class=\"line\"> - adb</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>tags有两种写法，一种是上面这样前面加横杠<br>另一种长这样，写成数组形式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: my awesometitle</div><div class=\"line\">date: 2017-05-07 16:48:01</div><div class=\"line\">categories: blog</div><div class=\"line\">tags: [linux,python]</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-一些功能的实现\"><a href=\"#3-一些功能的实现\" class=\"headerlink\" title=\"3. 一些功能的实现\"></a>3. 一些功能的实现</h3><ul>\n<li>置顶功能<br>  将node_modules/hexo-generator-index/lib/generator.js的文件内容替换成以下内容</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> pagination = <span class=\"built_in\">require</span>(<span class=\"string\">'hexo-pagination'</span>);</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> config = <span class=\"keyword\">this</span>.config;</div><div class=\"line\">  <span class=\"keyword\">var</span> posts = locals.posts;</div><div class=\"line\">    posts.data = posts.data.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(a.top &amp;&amp; b.top) &#123; <span class=\"comment\">// 两篇文章top都有定义</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(a.top == b.top) <span class=\"keyword\">return</span> b.date - a.date; <span class=\"comment\">// 若top值一样则按照文章日期降序排</span></div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> b.top - a.top; <span class=\"comment\">// 否则按照top值降序排</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a.top &amp;&amp; !b.top) &#123; <span class=\"comment\">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!a.top &amp;&amp; b.top) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> b.date - a.date; <span class=\"comment\">// 都没定义按照文章日期降序排</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">  <span class=\"keyword\">var</span> paginationDir = config.pagination_dir || <span class=\"string\">'page'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> pagination(<span class=\"string\">''</span>, posts, &#123;</div><div class=\"line\">    perPage: config.index_generator.per_page,</div><div class=\"line\">    layout: [<span class=\"string\">'index'</span>, <span class=\"string\">'archive'</span>],</div><div class=\"line\">    format: paginationDir + <span class=\"string\">'/%d/'</span>,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">    __index: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>同时在文章开头添加top : 1即可 ，实际排序按照这个数字从大到小排序<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> title: Hexo置顶文章</div><div class=\"line\">date: 2016-11-11 23:26:22</div><div class=\"line\">tags:[置顶]</div><div class=\"line\">categories: Hexo</div><div class=\"line\">top: 0 # 0或者1</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"4-SublimeText的一些快捷键\"><a href=\"#4-SublimeText的一些快捷键\" class=\"headerlink\" title=\"4. SublimeText的一些快捷键\"></a>4. SublimeText的一些快捷键</h3><p>由于文章大部分都是使用SublimeText写的，Typroa这种所见即所得的编辑器也不错，但对于掌握MardkDown语法没有帮助。这里摘录一些SubLimeText的快捷键。</p>\n<blockquote>\n<p><strong>Ctrl+Shift+P：打开命令面板</strong><br>Ctrl+P：搜索项目中的文件<br>Ctrl+G：跳转到第几行<br>Ctrl+W：关闭当前打开文件 CTRL+F4也可以<br>Ctrl+Shift+W：关闭所有打开文件<br>Ctrl+Shift+V：粘贴并格式化<br>Ctrl+D：选择单词，重复可增加选择下一个相同的单词<br><strong>Ctrl+L：选择行，重复可依次增加选择下一行</strong><br><strong>Alt+Shift+数字：分屏显示</strong><br><strong>Ctrl+Shift+L：选择多行</strong><br><strong>Ctrl+Shift+D：复制粘贴当前行</strong><br><strong>Ctrl+X：删除当前行</strong><br><strong>Ctrl+Shift+左箭头 往左边选择内容</strong><br><strong>Shift+向左箭头 向左选择文本</strong><br><strong>Ctrl+B 编译，markDown生成html文件</strong><br><strong>Alt+2 切换到第二个Tab（打开的文件，记得chrome是ctrl+2）</strong><br><strong>Ctrl+R：前往 对应的方法的实现*</strong><br><strong>快速加上[] 选中单词按 [ 即可</strong><br><strong>批量更改当前页面相同的单词 alt+F3 </strong><br><strong>Ctrl+Enter 在下一行插入新的一行</strong><br><strong>Ctrl+Shift+Enter 在上一行插入新的一行</strong><br><strong>Shift+ 向上箭头 向上选中多行</strong></p>\n</blockquote>\n<p>Ctrl+Shift+D：复制粘贴当前行Ctrl+Shift+Enter：在当前行前插入新行<br>Ctrl+M：跳转到对应括号<br>Ctrl+U：软撤销，撤销光标位置<br>Ctrl+J：选择标签内容<br>Ctrl+F：查找内容<br>Ctrl+Shift+F：查找并替换<br>Ctrl+H：替换<br>Ctrl+N：新建窗口<br>Ctrl+K+B：开关侧栏<br>Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身<br>Ctrl+F2：设置/删除标记<br>Ctrl+/：注释当前行<br>Ctrl+Shift+/：当前位置插入注释<br>Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的<br>Ctrl+Shift+A：选择当前标签前后，修改标签用的<br>F11：全屏<br>Shift+F11：全屏免打扰模式，只编辑当前文件<br>Alt+F3：选择所有相同的词<br>Alt+.：闭合标签<br>Shift+右键拖动：光标多不，用来更改或插入列内容<br>Alt+数字：切换打开第N个文件<br>鼠标的前进后退键可切换Tab文件<br>按Ctrl，依次点击或选取，可需要编辑的多个位置<br>按Ctrl+Shift+上下键，可替换行</p>\n<h3 id=\"5-title不能以-开头\"><a href=\"#5-title不能以-开头\" class=\"headerlink\" title=\"5. title不能以[]开头\"></a>5. title不能以[]开头</h3><p>前面加上###确实能够让字号变大，但不要写4个#，后面的字母会大小写不分的</p>\n<h3 id=\"6-markdown语法\"><a href=\"#6-markdown语法\" class=\"headerlink\" title=\"6. markdown语法\"></a>6. markdown语法</h3><p>MarkDown页面内部跳转<br><a href=\"http://www.cnblogs.com/JohnTsai/p/4027229.html\">MarkDown技巧：两种方式实现页内跳转</a></p>\n<h3 id=\"7-github提交commit的时候显示Emoji\"><a href=\"#7-github提交commit的时候显示Emoji\" class=\"headerlink\" title=\"7.github提交commit的时候显示Emoji\"></a>7.github提交commit的时候显示Emoji</h3><p>链接<a href=\"https://www.webpagefx.com/tools/emoji-cheat-sheet/\">在此</a></p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><a href=\"http://yanhuili.github.io/2016/11/21/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%8A%80%E5%B7%A7/\">Hexo博文置顶技巧</a></li>\n<li><a href=\"http://www.daqianduan.com/4820.html\">SublimeText快捷键</a></li>\n</ul>"},{"title":"使用Kotlin进行java开发","date":"2017-01-13T15:06:13.000Z","_content":"\nKotlin是Jetbrain公司推出的面向jvm的语言，编译后的bytecode和java编写的代码并没有什么区别。\n\n<!--more-->\n\n### 1. 基本语法\n\n 没有new关键字\n ```\n 主函数\n fun main(args : Array<String>) {\n    for (i in args.indices) {\n       print(args[i])\n    }\n}\n\n\n自定义函数\n\n ```\n fun getStringLength(obj: Any) :Int?{ //问号代表有可能返回空值\n    if (obj is String) {\n        return obj.length\n    }\n    return 0\n}\n\n ```\n\n 支持lambda\n fun maps(list: List<String>) {\n    list.filter { it.startsWith(\"a\") }\n            .sortedBy { it }\n            .map(String::toUpperCase)\n            .forEach(::print)\n}\n ```\n\n\n \n\n### 2. 集合迭代\n\n ```\n//带index的方式\n  val quoteParts = \" YOU JUST TALKED TO MUCH !\".split(\" \")\n            for ((index, value) in quoteParts.withIndex()) {\n                print(\"reading index $index: $value \")\n            }\n ```\n\n\n\n\n### ref\n\n1. [Kotlin in production](https://www.youtube.com/watch?v=mDpnc45WwlI&index=10&list=PLnVy79PaFHMXJha06t6pWfkYcATV4oPvC)\n2. [10 Kotlin Tricks in 10 ish minutes by Jake Wharton](https://www.youtube.com/watch?v=YKzUbeUtTak)​\n3. [Try Kotlin](https://try.kotlinlang.org/#/Examples/Basic%20syntax%20walk-through/Null-checks/Null-checks.kt)\n\n","source":"_posts/2017-01-13-embracing-kotlin.md","raw":"---\ntitle: 使用Kotlin进行java开发\ndate: 2017-01-13 23:06:13\ncategories: blog \ntags: [kotlin]\n---\n\nKotlin是Jetbrain公司推出的面向jvm的语言，编译后的bytecode和java编写的代码并没有什么区别。\n\n<!--more-->\n\n### 1. 基本语法\n\n 没有new关键字\n ```\n 主函数\n fun main(args : Array<String>) {\n    for (i in args.indices) {\n       print(args[i])\n    }\n}\n\n\n自定义函数\n\n ```\n fun getStringLength(obj: Any) :Int?{ //问号代表有可能返回空值\n    if (obj is String) {\n        return obj.length\n    }\n    return 0\n}\n\n ```\n\n 支持lambda\n fun maps(list: List<String>) {\n    list.filter { it.startsWith(\"a\") }\n            .sortedBy { it }\n            .map(String::toUpperCase)\n            .forEach(::print)\n}\n ```\n\n\n \n\n### 2. 集合迭代\n\n ```\n//带index的方式\n  val quoteParts = \" YOU JUST TALKED TO MUCH !\".split(\" \")\n            for ((index, value) in quoteParts.withIndex()) {\n                print(\"reading index $index: $value \")\n            }\n ```\n\n\n\n\n### ref\n\n1. [Kotlin in production](https://www.youtube.com/watch?v=mDpnc45WwlI&index=10&list=PLnVy79PaFHMXJha06t6pWfkYcATV4oPvC)\n2. [10 Kotlin Tricks in 10 ish minutes by Jake Wharton](https://www.youtube.com/watch?v=YKzUbeUtTak)​\n3. [Try Kotlin](https://try.kotlinlang.org/#/Examples/Basic%20syntax%20walk-through/Null-checks/Null-checks.kt)\n\n","slug":"2017-01-13-embracing-kotlin","published":1,"updated":"2017-06-25T15:01:31.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnhe0014bovrmpflooe5","content":"<p>Kotlin是Jetbrain公司推出的面向jvm的语言，编译后的bytecode和java编写的代码并没有什么区别。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-基本语法\"><a href=\"#1-基本语法\" class=\"headerlink\" title=\"1. 基本语法\"></a>1. 基本语法</h3><p> 没有new关键字<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 主函数</div><div class=\"line\"> fun main(args : Array&lt;String&gt;) &#123;</div><div class=\"line\">    for (i in args.indices) &#123;</div><div class=\"line\">       print(args[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">自定义函数</div></pre></td></tr></table></figure></p>\n<p> fun getStringLength(obj: Any) :Int?{ //问号代表有可能返回空值<br>    if (obj is String) {<br>        return obj.length<br>    }<br>    return 0<br>}</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> 支持lambda</div><div class=\"line\"> fun maps(list: List&lt;String&gt;) &#123;</div><div class=\"line\">    list.filter &#123; it.startsWith(&quot;a&quot;) &#125;</div><div class=\"line\">            .sortedBy &#123; it &#125;</div><div class=\"line\">            .map(String::toUpperCase)</div><div class=\"line\">            .forEach(::print)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-集合迭代\"><a href=\"#2-集合迭代\" class=\"headerlink\" title=\"2. 集合迭代\"></a>2. 集合迭代</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//带index的方式</div><div class=\"line\">  val quoteParts = &quot; YOU JUST TALKED TO MUCH !&quot;.split(&quot; &quot;)</div><div class=\"line\">            for ((index, value) in quoteParts.withIndex()) &#123;</div><div class=\"line\">                print(&quot;reading index $index: $value &quot;)</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ol>\n<li><a href=\"https://www.youtube.com/watch?v=mDpnc45WwlI&amp;index=10&amp;list=PLnVy79PaFHMXJha06t6pWfkYcATV4oPvC\">Kotlin in production</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=YKzUbeUtTak\">10 Kotlin Tricks in 10 ish minutes by Jake Wharton</a>​</li>\n<li><a href=\"https://try.kotlinlang.org/#/Examples/Basic%20syntax%20walk-through/Null-checks/Null-checks.kt\">Try Kotlin</a></li>\n</ol>\n","excerpt":"<p>Kotlin是Jetbrain公司推出的面向jvm的语言，编译后的bytecode和java编写的代码并没有什么区别。</p>","more":"<h3 id=\"1-基本语法\"><a href=\"#1-基本语法\" class=\"headerlink\" title=\"1. 基本语法\"></a>1. 基本语法</h3><p> 没有new关键字<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 主函数</div><div class=\"line\"> fun main(args : Array&lt;String&gt;) &#123;</div><div class=\"line\">    for (i in args.indices) &#123;</div><div class=\"line\">       print(args[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">自定义函数</div></pre></td></tr></table></figure></p>\n<p> fun getStringLength(obj: Any) :Int?{ //问号代表有可能返回空值<br>    if (obj is String) {<br>        return obj.length<br>    }<br>    return 0<br>}</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> 支持lambda</div><div class=\"line\"> fun maps(list: List&lt;String&gt;) &#123;</div><div class=\"line\">    list.filter &#123; it.startsWith(&quot;a&quot;) &#125;</div><div class=\"line\">            .sortedBy &#123; it &#125;</div><div class=\"line\">            .map(String::toUpperCase)</div><div class=\"line\">            .forEach(::print)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-集合迭代\"><a href=\"#2-集合迭代\" class=\"headerlink\" title=\"2. 集合迭代\"></a>2. 集合迭代</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//带index的方式</div><div class=\"line\">  val quoteParts = &quot; YOU JUST TALKED TO MUCH !&quot;.split(&quot; &quot;)</div><div class=\"line\">            for ((index, value) in quoteParts.withIndex()) &#123;</div><div class=\"line\">                print(&quot;reading index $index: $value &quot;)</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ol>\n<li><a href=\"https://www.youtube.com/watch?v=mDpnc45WwlI&amp;index=10&amp;list=PLnVy79PaFHMXJha06t6pWfkYcATV4oPvC\">Kotlin in production</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=YKzUbeUtTak\">10 Kotlin Tricks in 10 ish minutes by Jake Wharton</a>​</li>\n<li><a href=\"https://try.kotlinlang.org/#/Examples/Basic%20syntax%20walk-through/Null-checks/Null-checks.kt\">Try Kotlin</a></li>\n</ol>"},{"title":"使用IDE内置的Terminal","date":"2017-03-11T14:28:51.000Z","_content":"\n![io](http://odzl05jxx.bkt.clouddn.com/device-2017-03-11-222239.png?imageView2/2/w/600)\n这周终于把Google I/O 2016的Android App在Device上跑起来了，顺便尝试多多使用命令行进行编译或者安装。\n\n<!-- more -->\n\n### 1. 编译Android client并安装到本地设备 \n官方提供了比较完善的Build Instructions，对于习惯于shift+F10的我来说，还是有点麻烦。\n\nclone下来[iosched](https://github.com/google/iosched)，修改gradle.properities里面的supportLib等值，参考Build Instruction ，\n\n> gradlew clean assembleDebug\n\n\n往往这一步会开始下载gradle，非常耗时。参考了stackOverFlow，自己去下载gradle 3.3 -all.zip，放到/gradle/wrapper文件夹下，修改gradle-wrapper.properities，将其中的distributionUrl改成\n\n\n> distributionUrl=gradle-3.3-all.zip\n\n等于直接省去上述下载步骤。Build完成后，敲入命令行\n\n>gradlew installNormalDebug\n\n不出意外的话，即可进入主页面。\n\n### 2. Server端配置\nGoogle io 2016 Android Client提供了Map Intergation和Youtube video display以及GCM等服务。这些全部集成在Google Cloud Platform上配置。\n","source":"_posts/2017-03-11-utilizing-the-terminal-in-android-studio.md","raw":"---\ntitle: 使用IDE内置的Terminal\ndate: 2017-03-11 22:28:51\ncategories: blog \ntags: [android]\n---\n\n![io](http://odzl05jxx.bkt.clouddn.com/device-2017-03-11-222239.png?imageView2/2/w/600)\n这周终于把Google I/O 2016的Android App在Device上跑起来了，顺便尝试多多使用命令行进行编译或者安装。\n\n<!-- more -->\n\n### 1. 编译Android client并安装到本地设备 \n官方提供了比较完善的Build Instructions，对于习惯于shift+F10的我来说，还是有点麻烦。\n\nclone下来[iosched](https://github.com/google/iosched)，修改gradle.properities里面的supportLib等值，参考Build Instruction ，\n\n> gradlew clean assembleDebug\n\n\n往往这一步会开始下载gradle，非常耗时。参考了stackOverFlow，自己去下载gradle 3.3 -all.zip，放到/gradle/wrapper文件夹下，修改gradle-wrapper.properities，将其中的distributionUrl改成\n\n\n> distributionUrl=gradle-3.3-all.zip\n\n等于直接省去上述下载步骤。Build完成后，敲入命令行\n\n>gradlew installNormalDebug\n\n不出意外的话，即可进入主页面。\n\n### 2. Server端配置\nGoogle io 2016 Android Client提供了Map Intergation和Youtube video display以及GCM等服务。这些全部集成在Google Cloud Platform上配置。\n","slug":"2017-03-11-utilizing-the-terminal-in-android-studio","published":1,"updated":"2017-04-23T10:51:46.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnhm0018bovrou42i4yn","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/device-2017-03-11-222239.png?imageView2/2/w/600\" alt=\"io\"><br>这周终于把Google I/O 2016的Android App在Device上跑起来了，顺便尝试多多使用命令行进行编译或者安装。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-编译Android-client并安装到本地设备\"><a href=\"#1-编译Android-client并安装到本地设备\" class=\"headerlink\" title=\"1. 编译Android client并安装到本地设备\"></a>1. 编译Android client并安装到本地设备</h3><p>官方提供了比较完善的Build Instructions，对于习惯于shift+F10的我来说，还是有点麻烦。</p>\n<p>clone下来<a href=\"https://github.com/google/iosched\">iosched</a>，修改gradle.properities里面的supportLib等值，参考Build Instruction ，</p>\n<blockquote>\n<p>gradlew clean assembleDebug</p>\n</blockquote>\n<p>往往这一步会开始下载gradle，非常耗时。参考了stackOverFlow，自己去下载gradle 3.3 -all.zip，放到/gradle/wrapper文件夹下，修改gradle-wrapper.properities，将其中的distributionUrl改成</p>\n<blockquote>\n<p>distributionUrl=gradle-3.3-all.zip</p>\n</blockquote>\n<p>等于直接省去上述下载步骤。Build完成后，敲入命令行</p>\n<blockquote>\n<p>gradlew installNormalDebug</p>\n</blockquote>\n<p>不出意外的话，即可进入主页面。</p>\n<h3 id=\"2-Server端配置\"><a href=\"#2-Server端配置\" class=\"headerlink\" title=\"2. Server端配置\"></a>2. Server端配置</h3><p>Google io 2016 Android Client提供了Map Intergation和Youtube video display以及GCM等服务。这些全部集成在Google Cloud Platform上配置。</p>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/device-2017-03-11-222239.png?imageView2/2/w/600\" alt=\"io\"><br>这周终于把Google I/O 2016的Android App在Device上跑起来了，顺便尝试多多使用命令行进行编译或者安装。</p>","more":"<h3 id=\"1-编译Android-client并安装到本地设备\"><a href=\"#1-编译Android-client并安装到本地设备\" class=\"headerlink\" title=\"1. 编译Android client并安装到本地设备\"></a>1. 编译Android client并安装到本地设备</h3><p>官方提供了比较完善的Build Instructions，对于习惯于shift+F10的我来说，还是有点麻烦。</p>\n<p>clone下来<a href=\"https://github.com/google/iosched\">iosched</a>，修改gradle.properities里面的supportLib等值，参考Build Instruction ，</p>\n<blockquote>\n<p>gradlew clean assembleDebug</p>\n</blockquote>\n<p>往往这一步会开始下载gradle，非常耗时。参考了stackOverFlow，自己去下载gradle 3.3 -all.zip，放到/gradle/wrapper文件夹下，修改gradle-wrapper.properities，将其中的distributionUrl改成</p>\n<blockquote>\n<p>distributionUrl=gradle-3.3-all.zip</p>\n</blockquote>\n<p>等于直接省去上述下载步骤。Build完成后，敲入命令行</p>\n<blockquote>\n<p>gradlew installNormalDebug</p>\n</blockquote>\n<p>不出意外的话，即可进入主页面。</p>\n<h3 id=\"2-Server端配置\"><a href=\"#2-Server端配置\" class=\"headerlink\" title=\"2. Server端配置\"></a>2. Server端配置</h3><p>Google io 2016 Android Client提供了Map Intergation和Youtube video display以及GCM等服务。这些全部集成在Google Cloud Platform上配置。</p>"},{"title":"Rxjava2 的一些点","date":"2017-04-23T05:56:07.000Z","_content":"\n本文多数内容来自Jake Wharton的演讲，配合一些个人的感受，作为今后使用Rxjava2的一些参考。\n![](http://odzl05jxx.bkt.clouddn.com/f21a6a245edfe0b19804be5b3df24a3d.jpg?imageView2/2/w/600)\n<!--more-->\n\n\n## 1. Why Reactive?\n最早使用Rxjava的初衷在于方便地实现线程切换，使用链式语法轻松地将异步任务分发到子线程并省去了主动实现回调的麻烦。\n我们生活在一个事件异步分发的环境中，网络，文件、甚至用户输入本身也是异步事件，除此之外，安卓系统本身的许多操作也是异步的，例如startActivity，Fragment的transaction，这就要求开发者不得不考虑各种事件状态，并在各种事件之间进行协调。Rxjava将各种事件的处理、完成以及异常在事件定义之初定义好处理方式。事件的开始，进行，完成以及异常，都被抽象到Observable的载体中。值得注意的是，这种链式调用很像Builder Pattern，但本质上每一步都生成了一个新的对象。这个在Rxjava的Wiki上有所说明，即每一步都生成一个新的immutable object（GC表示压力大）。\n\n\n## 2. 数据源\nStream基本包括这三部分\n```\nsource of data\nlistener of data\nmethods for modifying data\n```\n![](http://odzl05jxx.bkt.clouddn.com/stream_compose.jpg?imageView2/2/w/600)\n\n### 2.1 数据源的种类\nObservable<T> 和Flowable<T>，区别在于后者支持BackPressure，后者不支持BackPressure.\n接收Observable和Flowable的类型分别为Observer和Subscriber\n\n```java\ninterface Observer<T>{\n  void onNext(T t);\n  void onComplete();\n  void onError(Throwable t);\n  void onSubscribe(Disposable d);\n}\n\ninterface Disposable{\n  void dispose();\n}\n\n\ninterface Subscriber<T>{\n  void onNext(T t)\n  void onComplete();;\n  void onError(Throwable t);\n  void onSubscribe(Subscription s);\n}\n\ninterface Subscription{\n  void cancel() //用于取消订阅，释放资源\n  void request(long r) //请求更多的数据，即BackPressure开始体现的地方\n}\n```\n两者的区别在于最后一个方法，以Disposable为例，当你开始subscribe一个数据源的时，就类似于创建了一个Resurce，而Resource是往往需要在用完之后及时释放。无论是Observable还是Flowable,这个onSubscribe方法会在订阅后立即被调用，这个方法里的Disposable可以保留下来，在必要时候用于释放资源。如Activity的onDestroy中cancel network request.\n\n\n### 2.2 数据源的对应类\n1. Single(订阅一个Single，要么获得仅一个返回值，要么出现异常返回Error)\n```java\npublic abstract class Single<T> implements SingleSource<T> {}\n\n```\n\n2. Completeable(订阅一个completeable，要么成功，不返回值，要么出现异常返回error，就像一个reactive runnale，一个可以执行的command，并不返回结果)\n```java\npublic abstract class Completable implements CompletableSource {}\n```\n例如，异步写一个文件，要么成功，要么出现error，并不需要返回什么。\n```java\npublic void writeFile(Stirng data){}\n// 就可以model成\nCompleteable writeFile(Stirng data){}\n```\n\n\n3. Maybe(有可能返回值，有可能不返回，也有可能异常，即optional)\n```java\npublic abstract class Maybe<T> implements MaybeSource<T> {}\n```\n以上三种数据源都有static方法生成：\n例如\n![from iterable](http://odzl05jxx.bkt.clouddn.com/creating_source_from_iterable.jpg?imageView2/2/w/600)\n\n\n![fromjust](http://odzl05jxx.bkt.clouddn.com/creating_source_from_just.jpg?imageView2/2/w/600)\n\n比较推荐的方法有两种\n\n### 1. fromCallable\n```java\nObservable.fromCallable(new Callable<String>(){\n\n  @override\n  public String call() throw Exception{\n      return getName() //  之前是synchronious的get，现在这一步可以asynchnous执行,比如放一个OkHttpClient.newCall(request).execute(); //因为是异步执行的，也不存在性能问题\n}\n})\n```\n上面这段中的call方法会在被订阅后执行，成功的话会走到observer的onNext，失败的话会走到onError。\nfromCallable可用于各种数据源，包括Flowable\n```java\nFlowable.fromCallable(() -> \"Hello Flowable\");\nObservable.fromCallable(() -> \"Hello Observable\");\nMaybe.fromCallable(() -> \"Hello Maybe\");\nSingle.fromCallable(() -> \"Hello Single\");\nCompleteable.fromCallable(() -> \"Hello Completeable\");\n```\n> fromCallable are for modeling synchronous sourse of a single source of data.\n\n很多需要返回值的方法都可以抽象成这种方法。\nMaybe和Completeable还有两个方法,用于表示不返回数据的方法\n```java\nMaybe.fromAction(() -> \"Hey jude\")\nMaybe.fromRunnable(() -> \"ignore\")\n\nCompleteable.fromAction(() -> \"Hey jude\")\nCompleteable.fromRunnable(() -> \"ignore\")\n\n```\n\n### 2. create(Rxjava 1中不推荐使用该方法，Rxjava2中建议使用)\n```java\nObservable.create(new ObservableOnSubscribe<String>()){\n      @override\n      public void subscribe (ObservableEmitter<String> e) throws Exception{ //subscribe get called whenever there's a new subscriber, emitter is the person that's listening.\n      //\n         e.onNext(\"Hello\");\n         e.onComplete();\n      }\n}\n```\n\n//一个Observable可以有多个subscriber。一个被观察者可以有多个观察者，被观察者的onNext调用，观察者的onNext也会被调用\n\nlambda更简洁\n```java\nObservable.create(e ->{\n    e.onNext(\"Hello\");\n    e.onNext(\"Hello\");\n    e.onComplete();\n})\n\nOkhttp的异步网络请求也可以model成一种被观察的流\nObservable.create(e ->{\n   Call call = client.newCall(request);\n   call.enqueue(new Callback()){\n\n    @Override\n    public void   onResponse(Response r) throws IOException{\n      e.onNext(r.body().toString());\n      e.onComplete();\n    }\n\n    @Override\n    public void onFailure(IOException e){\n      e.onError(e);\n    }\n\n  }\n})\n\n//重点了来了，\npublic interface ObservableEmitter<T> extends Emitter<T> {\n    /**\n     * Sets a Cancellable on this emitter; any previous Disposable\n     * or Cancellation will be unsubscribed/cancelled.\n     * @param c the cancellable resource, null is allowed\n     */\n    void setCancellable(Cancellable c);\n}\n\n// emitter可以设置cancel的动作\n\nObservable.create(e ->{\n    e.setCacelation(() -view.setOnClickListener(null));\n    view.setOnClickListener(v -> e.onNext());\n})\n\n// 点击按钮发送事件，取消订阅时避免leak View\n\n和fromCallable一样，create方法也适用于所有五种data source\n\n```\n\n\n\n## 3. 如何订阅（接收）这些数据\n\n### 3.1 observer<T>和Subscriber<T>\n\n接收Observable和Flowable的类型分别为Observer和Subscriber\n\n```java\ninterface Observer<T>{\n  void onNext(T t);\n  void onComplete();\n  void onError(Throwable t);\n  void onSubscribe(Disposable d);\n}\n\ninterface Disposable{\n  void dispose();\n}\n\n\ninterface Subscriber<T>{\n  void onNext(T t);\n  void onComplete();\n  void onError(Throwable t);\n  void onSubscribe(Subscription s);\n}\n\ninterface Subscription{\n  void cancel(); //用于取消订阅，释放资源\n  void request(long r) ;//请求更多的数据，即BackPressure开始体现的地方\n}\n```\n## 所以整体来看，数据的流向就这么两种，左边发送数据(可能只有一个，可能间歇性的，可能一直不停)，事件通过数据流传输到右边，右边根据协议作出相应(Reactive)\nObservable -> subscribe -> Observer\n\nFlowable -> subscribe -> Subscription\n\n### 3.2 onSubscribe怎么用\n通常不直接用这两种base class，因为第四个方法不知道怎么用嘛。\n![](http://odzl05jxx.bkt.clouddn.com/4dab298b9f7ce29c43f9d8eaf686e02f.jpg?imageView2/2/w/600)\n```java\nObservable.just(\"Hello\").subscribe(new DisposableObserver<String>() {\n                    @Override\n                    public void onNext(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onComplete() {\n                    }\n                });\n\n\n  可以持有DisposableObserver，在停止订阅的时候调用observer.dispose方法，切断流。\n  或者这样\n  Disposable disposable =   Observable.just(\"Hello\").subscribeWith(new DisposableObserver<String>() {\n                    @Override\n                    public void onNext(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onComplete() {\n                    }\n                });\n\n   subscribeWith返回一个Disposable，subscribe是一个没有返回值的函数    \n\n  偷懒一点的话，通常把这些返回的订阅加入到一个CompositeDisposable,在onDestroy的时候统一取消订阅即可  \n\n  Observable、Single、Completeable、Maybe以及Flowable都支持subscribewith。\n\n\n```\n\n\n\n\n## 4. 数据源和接受者建立联系\n\n> Observable.subscribe  \n或者\n> Flowable.subscribe\n或者使用之前提到的sbscribeWith\n我尝试写了一个比较复杂的调用顺序\n```java\nObservable.fromCallable(new Callable<List<String>>() {\n            @Override\n            public List<String> call() throws Exception {\n                LogUtil.p(\"call do on thread any\");\n                blockThread(2000); // block 2s\n                return Arrays.asList(array);\n            }\n        }).subscribeOn(Schedulers.computation())\n                .observeOn(AndroidSchedulers.mainThread())\n                .doOnSubscribe(new Consumer<Disposable>() {\n                    @Override\n                    public void accept(Disposable disposable) throws Exception {\n                        LogUtil.p(\"\");\n                    }\n                }).doOnComplete(new Action() {\n            @Override\n            public void run() throws Exception {\n                LogUtil.p(\"\");\n            }\n        }).doOnNext(new Consumer<List<String>>() {\n            @Override\n            public void accept(List<String> strings) throws Exception {\n                LogUtil.p(\"\" + strings.get(0));\n            }\n        }).doAfterNext(new Consumer<List<String>>() {\n            @Override\n            public void accept(List<String> strings) throws Exception {\n                LogUtil.p(\"\"+strings.get(0));\n            }\n        }).subscribe(new Observer<List<String>>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                LogUtil.p(\"onSubscribe \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(List<String> value) {\n                LogUtil.p(\" get Response \" + value.size());\n                value.set(0, \"change first element!\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onComplete() {\n                LogUtil.p(\"\");\n            }\n        });\n\n执行顺序：（括号内数字表示线程id）\ndoOnsubscribe(1) -> onSubscribe(1) -> call(276) ->doOnNext(1)->onNext(1) -> doAfterNext(1) ->doOnComplete(1)->onComplete(1)\n所以基本上可以认为doOnXXX= doBeforeXXX,线程都是一样的。估计是为了打日志用的，或者说用于切片。\n像极了OkHttp的interecpter或是gradle的task。\n\n```\n\n\n\n\n## 5. Operator and Threading\n```java\nObservable<String> greeting  = Observable.just(\"Hello\");\nObservable<String> yelling = greeting.map(s ->s.toUppercase())\n\nObservable.subscribeOn(Schedulers.io()) //\n```\nsubscribeOn决定了task在哪条线程上运行，操作符的顺序很重要\n![Wrong](http://odzl05jxx.bkt.clouddn.com/reading%20network%20response%20on%20main%20thread.jpg?imageView2/2/w/600)\n![Ok](http://odzl05jxx.bkt.clouddn.com/observing%20on%20ui%20thred.jpg?imageView2/2/w/600)\n\n\n流之间的转换\n\n>Observable -> first() -> single\nObservable -> firsetElement -> Maybe\nObservable -> ignoreElements() ->Completable\n\n>Flowable -> first() -> single\nFlowable -> firsetElement -> Maybe\nFlowable -> ignoreElements() ->Completable\n\n- [Combining Observables](https://github.com/ReactiveX/RxJava/wiki/Combining-Observables) 多个数据来源的加工\n\n\n\n\n\n## 链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\n## quote:\n### RxJava 2 is not something new. Reactive programming is not new by any stretch, but Android itself is a highly reactive world that we’ve been taught to model in a very imperative, stateful fashion.\nReactive programming allow us to model it in the proper way: asynchronously. Embrace the asynchronicity of the sources, and instead of trying to manage all the state ourselves, compose them together such that our apps become truly reactive.\n\n\n\n\n### Reference\n\n-- [GOTO 2016 • Exploring RxJava 2 for Android • Jake Wharton - YouTube](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=6&cad=rja&uact=8&ved=0ahUKEwjlvrfg8bnTAhUI0mMKHcXZC1MQtwIITDAF&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DhtIXKI5gOQU&usg=AFQjCNEYczqXGkjYXOUbovtP1CxDPARcXA&sig2=gmLYEd2cVOhI7C2WjOHr9g)\n","source":"_posts/2017-04-23-rxjava2-for-android.md","raw":"---\ntitle: Rxjava2 的一些点\ndate: 2017-04-23 13:56:07\ncategories: blog\ntags: [rxjava2,android]\n---\n\n本文多数内容来自Jake Wharton的演讲，配合一些个人的感受，作为今后使用Rxjava2的一些参考。\n![](http://odzl05jxx.bkt.clouddn.com/f21a6a245edfe0b19804be5b3df24a3d.jpg?imageView2/2/w/600)\n<!--more-->\n\n\n## 1. Why Reactive?\n最早使用Rxjava的初衷在于方便地实现线程切换，使用链式语法轻松地将异步任务分发到子线程并省去了主动实现回调的麻烦。\n我们生活在一个事件异步分发的环境中，网络，文件、甚至用户输入本身也是异步事件，除此之外，安卓系统本身的许多操作也是异步的，例如startActivity，Fragment的transaction，这就要求开发者不得不考虑各种事件状态，并在各种事件之间进行协调。Rxjava将各种事件的处理、完成以及异常在事件定义之初定义好处理方式。事件的开始，进行，完成以及异常，都被抽象到Observable的载体中。值得注意的是，这种链式调用很像Builder Pattern，但本质上每一步都生成了一个新的对象。这个在Rxjava的Wiki上有所说明，即每一步都生成一个新的immutable object（GC表示压力大）。\n\n\n## 2. 数据源\nStream基本包括这三部分\n```\nsource of data\nlistener of data\nmethods for modifying data\n```\n![](http://odzl05jxx.bkt.clouddn.com/stream_compose.jpg?imageView2/2/w/600)\n\n### 2.1 数据源的种类\nObservable<T> 和Flowable<T>，区别在于后者支持BackPressure，后者不支持BackPressure.\n接收Observable和Flowable的类型分别为Observer和Subscriber\n\n```java\ninterface Observer<T>{\n  void onNext(T t);\n  void onComplete();\n  void onError(Throwable t);\n  void onSubscribe(Disposable d);\n}\n\ninterface Disposable{\n  void dispose();\n}\n\n\ninterface Subscriber<T>{\n  void onNext(T t)\n  void onComplete();;\n  void onError(Throwable t);\n  void onSubscribe(Subscription s);\n}\n\ninterface Subscription{\n  void cancel() //用于取消订阅，释放资源\n  void request(long r) //请求更多的数据，即BackPressure开始体现的地方\n}\n```\n两者的区别在于最后一个方法，以Disposable为例，当你开始subscribe一个数据源的时，就类似于创建了一个Resurce，而Resource是往往需要在用完之后及时释放。无论是Observable还是Flowable,这个onSubscribe方法会在订阅后立即被调用，这个方法里的Disposable可以保留下来，在必要时候用于释放资源。如Activity的onDestroy中cancel network request.\n\n\n### 2.2 数据源的对应类\n1. Single(订阅一个Single，要么获得仅一个返回值，要么出现异常返回Error)\n```java\npublic abstract class Single<T> implements SingleSource<T> {}\n\n```\n\n2. Completeable(订阅一个completeable，要么成功，不返回值，要么出现异常返回error，就像一个reactive runnale，一个可以执行的command，并不返回结果)\n```java\npublic abstract class Completable implements CompletableSource {}\n```\n例如，异步写一个文件，要么成功，要么出现error，并不需要返回什么。\n```java\npublic void writeFile(Stirng data){}\n// 就可以model成\nCompleteable writeFile(Stirng data){}\n```\n\n\n3. Maybe(有可能返回值，有可能不返回，也有可能异常，即optional)\n```java\npublic abstract class Maybe<T> implements MaybeSource<T> {}\n```\n以上三种数据源都有static方法生成：\n例如\n![from iterable](http://odzl05jxx.bkt.clouddn.com/creating_source_from_iterable.jpg?imageView2/2/w/600)\n\n\n![fromjust](http://odzl05jxx.bkt.clouddn.com/creating_source_from_just.jpg?imageView2/2/w/600)\n\n比较推荐的方法有两种\n\n### 1. fromCallable\n```java\nObservable.fromCallable(new Callable<String>(){\n\n  @override\n  public String call() throw Exception{\n      return getName() //  之前是synchronious的get，现在这一步可以asynchnous执行,比如放一个OkHttpClient.newCall(request).execute(); //因为是异步执行的，也不存在性能问题\n}\n})\n```\n上面这段中的call方法会在被订阅后执行，成功的话会走到observer的onNext，失败的话会走到onError。\nfromCallable可用于各种数据源，包括Flowable\n```java\nFlowable.fromCallable(() -> \"Hello Flowable\");\nObservable.fromCallable(() -> \"Hello Observable\");\nMaybe.fromCallable(() -> \"Hello Maybe\");\nSingle.fromCallable(() -> \"Hello Single\");\nCompleteable.fromCallable(() -> \"Hello Completeable\");\n```\n> fromCallable are for modeling synchronous sourse of a single source of data.\n\n很多需要返回值的方法都可以抽象成这种方法。\nMaybe和Completeable还有两个方法,用于表示不返回数据的方法\n```java\nMaybe.fromAction(() -> \"Hey jude\")\nMaybe.fromRunnable(() -> \"ignore\")\n\nCompleteable.fromAction(() -> \"Hey jude\")\nCompleteable.fromRunnable(() -> \"ignore\")\n\n```\n\n### 2. create(Rxjava 1中不推荐使用该方法，Rxjava2中建议使用)\n```java\nObservable.create(new ObservableOnSubscribe<String>()){\n      @override\n      public void subscribe (ObservableEmitter<String> e) throws Exception{ //subscribe get called whenever there's a new subscriber, emitter is the person that's listening.\n      //\n         e.onNext(\"Hello\");\n         e.onComplete();\n      }\n}\n```\n\n//一个Observable可以有多个subscriber。一个被观察者可以有多个观察者，被观察者的onNext调用，观察者的onNext也会被调用\n\nlambda更简洁\n```java\nObservable.create(e ->{\n    e.onNext(\"Hello\");\n    e.onNext(\"Hello\");\n    e.onComplete();\n})\n\nOkhttp的异步网络请求也可以model成一种被观察的流\nObservable.create(e ->{\n   Call call = client.newCall(request);\n   call.enqueue(new Callback()){\n\n    @Override\n    public void   onResponse(Response r) throws IOException{\n      e.onNext(r.body().toString());\n      e.onComplete();\n    }\n\n    @Override\n    public void onFailure(IOException e){\n      e.onError(e);\n    }\n\n  }\n})\n\n//重点了来了，\npublic interface ObservableEmitter<T> extends Emitter<T> {\n    /**\n     * Sets a Cancellable on this emitter; any previous Disposable\n     * or Cancellation will be unsubscribed/cancelled.\n     * @param c the cancellable resource, null is allowed\n     */\n    void setCancellable(Cancellable c);\n}\n\n// emitter可以设置cancel的动作\n\nObservable.create(e ->{\n    e.setCacelation(() -view.setOnClickListener(null));\n    view.setOnClickListener(v -> e.onNext());\n})\n\n// 点击按钮发送事件，取消订阅时避免leak View\n\n和fromCallable一样，create方法也适用于所有五种data source\n\n```\n\n\n\n## 3. 如何订阅（接收）这些数据\n\n### 3.1 observer<T>和Subscriber<T>\n\n接收Observable和Flowable的类型分别为Observer和Subscriber\n\n```java\ninterface Observer<T>{\n  void onNext(T t);\n  void onComplete();\n  void onError(Throwable t);\n  void onSubscribe(Disposable d);\n}\n\ninterface Disposable{\n  void dispose();\n}\n\n\ninterface Subscriber<T>{\n  void onNext(T t);\n  void onComplete();\n  void onError(Throwable t);\n  void onSubscribe(Subscription s);\n}\n\ninterface Subscription{\n  void cancel(); //用于取消订阅，释放资源\n  void request(long r) ;//请求更多的数据，即BackPressure开始体现的地方\n}\n```\n## 所以整体来看，数据的流向就这么两种，左边发送数据(可能只有一个，可能间歇性的，可能一直不停)，事件通过数据流传输到右边，右边根据协议作出相应(Reactive)\nObservable -> subscribe -> Observer\n\nFlowable -> subscribe -> Subscription\n\n### 3.2 onSubscribe怎么用\n通常不直接用这两种base class，因为第四个方法不知道怎么用嘛。\n![](http://odzl05jxx.bkt.clouddn.com/4dab298b9f7ce29c43f9d8eaf686e02f.jpg?imageView2/2/w/600)\n```java\nObservable.just(\"Hello\").subscribe(new DisposableObserver<String>() {\n                    @Override\n                    public void onNext(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onComplete() {\n                    }\n                });\n\n\n  可以持有DisposableObserver，在停止订阅的时候调用observer.dispose方法，切断流。\n  或者这样\n  Disposable disposable =   Observable.just(\"Hello\").subscribeWith(new DisposableObserver<String>() {\n                    @Override\n                    public void onNext(String value) {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onComplete() {\n                    }\n                });\n\n   subscribeWith返回一个Disposable，subscribe是一个没有返回值的函数    \n\n  偷懒一点的话，通常把这些返回的订阅加入到一个CompositeDisposable,在onDestroy的时候统一取消订阅即可  \n\n  Observable、Single、Completeable、Maybe以及Flowable都支持subscribewith。\n\n\n```\n\n\n\n\n## 4. 数据源和接受者建立联系\n\n> Observable.subscribe  \n或者\n> Flowable.subscribe\n或者使用之前提到的sbscribeWith\n我尝试写了一个比较复杂的调用顺序\n```java\nObservable.fromCallable(new Callable<List<String>>() {\n            @Override\n            public List<String> call() throws Exception {\n                LogUtil.p(\"call do on thread any\");\n                blockThread(2000); // block 2s\n                return Arrays.asList(array);\n            }\n        }).subscribeOn(Schedulers.computation())\n                .observeOn(AndroidSchedulers.mainThread())\n                .doOnSubscribe(new Consumer<Disposable>() {\n                    @Override\n                    public void accept(Disposable disposable) throws Exception {\n                        LogUtil.p(\"\");\n                    }\n                }).doOnComplete(new Action() {\n            @Override\n            public void run() throws Exception {\n                LogUtil.p(\"\");\n            }\n        }).doOnNext(new Consumer<List<String>>() {\n            @Override\n            public void accept(List<String> strings) throws Exception {\n                LogUtil.p(\"\" + strings.get(0));\n            }\n        }).doAfterNext(new Consumer<List<String>>() {\n            @Override\n            public void accept(List<String> strings) throws Exception {\n                LogUtil.p(\"\"+strings.get(0));\n            }\n        }).subscribe(new Observer<List<String>>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                LogUtil.p(\"onSubscribe \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(List<String> value) {\n                LogUtil.p(\" get Response \" + value.size());\n                value.set(0, \"change first element!\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onComplete() {\n                LogUtil.p(\"\");\n            }\n        });\n\n执行顺序：（括号内数字表示线程id）\ndoOnsubscribe(1) -> onSubscribe(1) -> call(276) ->doOnNext(1)->onNext(1) -> doAfterNext(1) ->doOnComplete(1)->onComplete(1)\n所以基本上可以认为doOnXXX= doBeforeXXX,线程都是一样的。估计是为了打日志用的，或者说用于切片。\n像极了OkHttp的interecpter或是gradle的task。\n\n```\n\n\n\n\n## 5. Operator and Threading\n```java\nObservable<String> greeting  = Observable.just(\"Hello\");\nObservable<String> yelling = greeting.map(s ->s.toUppercase())\n\nObservable.subscribeOn(Schedulers.io()) //\n```\nsubscribeOn决定了task在哪条线程上运行，操作符的顺序很重要\n![Wrong](http://odzl05jxx.bkt.clouddn.com/reading%20network%20response%20on%20main%20thread.jpg?imageView2/2/w/600)\n![Ok](http://odzl05jxx.bkt.clouddn.com/observing%20on%20ui%20thred.jpg?imageView2/2/w/600)\n\n\n流之间的转换\n\n>Observable -> first() -> single\nObservable -> firsetElement -> Maybe\nObservable -> ignoreElements() ->Completable\n\n>Flowable -> first() -> single\nFlowable -> firsetElement -> Maybe\nFlowable -> ignoreElements() ->Completable\n\n- [Combining Observables](https://github.com/ReactiveX/RxJava/wiki/Combining-Observables) 多个数据来源的加工\n\n\n\n\n\n## 链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\n## quote:\n### RxJava 2 is not something new. Reactive programming is not new by any stretch, but Android itself is a highly reactive world that we’ve been taught to model in a very imperative, stateful fashion.\nReactive programming allow us to model it in the proper way: asynchronously. Embrace the asynchronicity of the sources, and instead of trying to manage all the state ourselves, compose them together such that our apps become truly reactive.\n\n\n\n\n### Reference\n\n-- [GOTO 2016 • Exploring RxJava 2 for Android • Jake Wharton - YouTube](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=6&cad=rja&uact=8&ved=0ahUKEwjlvrfg8bnTAhUI0mMKHcXZC1MQtwIITDAF&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DhtIXKI5gOQU&usg=AFQjCNEYczqXGkjYXOUbovtP1CxDPARcXA&sig2=gmLYEd2cVOhI7C2WjOHr9g)\n","slug":"2017-04-23-rxjava2-for-android","published":1,"updated":"2017-07-23T10:43:10.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnhs001bbovri4b6e8d2","content":"<p>本文多数内容来自Jake Wharton的演讲，配合一些个人的感受，作为今后使用Rxjava2的一些参考。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/f21a6a245edfe0b19804be5b3df24a3d.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"1-Why-Reactive\"><a href=\"#1-Why-Reactive\" class=\"headerlink\" title=\"1. Why Reactive?\"></a>1. Why Reactive?</h2><p>最早使用Rxjava的初衷在于方便地实现线程切换，使用链式语法轻松地将异步任务分发到子线程并省去了主动实现回调的麻烦。<br>我们生活在一个事件异步分发的环境中，网络，文件、甚至用户输入本身也是异步事件，除此之外，安卓系统本身的许多操作也是异步的，例如startActivity，Fragment的transaction，这就要求开发者不得不考虑各种事件状态，并在各种事件之间进行协调。Rxjava将各种事件的处理、完成以及异常在事件定义之初定义好处理方式。事件的开始，进行，完成以及异常，都被抽象到Observable的载体中。值得注意的是，这种链式调用很像Builder Pattern，但本质上每一步都生成了一个新的对象。这个在Rxjava的Wiki上有所说明，即每一步都生成一个新的immutable object（GC表示压力大）。</p>\n<h2 id=\"2-数据源\"><a href=\"#2-数据源\" class=\"headerlink\" title=\"2. 数据源\"></a>2. 数据源</h2><p>Stream基本包括这三部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">source of data</div><div class=\"line\">listener of data</div><div class=\"line\">methods for modifying data</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/stream_compose.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<h3 id=\"2-1-数据源的种类\"><a href=\"#2-1-数据源的种类\" class=\"headerlink\" title=\"2.1 数据源的种类\"></a>2.1 数据源的种类</h3><p>Observable<T> 和Flowable<T>，区别在于后者支持BackPressure，后者不支持BackPressure.<br>接收Observable和Flowable的类型分别为Observer和Subscriber</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Disposable</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></div><div class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Subscription s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscription</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> <span class=\"comment\">//用于取消订阅，释放资源</span></div><div class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">long</span> r)</span> <span class=\"comment\">//请求更多的数据，即BackPressure开始体现的地方</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>两者的区别在于最后一个方法，以Disposable为例，当你开始subscribe一个数据源的时，就类似于创建了一个Resurce，而Resource是往往需要在用完之后及时释放。无论是Observable还是Flowable,这个onSubscribe方法会在订阅后立即被调用，这个方法里的Disposable可以保留下来，在必要时候用于释放资源。如Activity的onDestroy中cancel network request.</p>\n<h3 id=\"2-2-数据源的对应类\"><a href=\"#2-2-数据源的对应类\" class=\"headerlink\" title=\"2.2 数据源的对应类\"></a>2.2 数据源的对应类</h3><ol>\n<li><p>Single(订阅一个Single，要么获得仅一个返回值，要么出现异常返回Error)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">SingleSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Completeable(订阅一个completeable，要么成功，不返回值，要么出现异常返回error，就像一个reactive runnale，一个可以执行的command，并不返回结果)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Completable</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompletableSource</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>例如，异步写一个文件，要么成功，要么出现error，并不需要返回什么。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(Stirng data)</span></span>&#123;&#125;</div><div class=\"line\"><span class=\"comment\">// 就可以model成</span></div><div class=\"line\"><span class=\"function\">Completeable <span class=\"title\">writeFile</span><span class=\"params\">(Stirng data)</span></span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>Maybe(有可能返回值，有可能不返回，也有可能异常，即optional)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maybe</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MaybeSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以上三种数据源都有static方法生成：<br>例如<br><img src=\"http://odzl05jxx.bkt.clouddn.com/creating_source_from_iterable.jpg?imageView2/2/w/600\" alt=\"from iterable\"></p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/creating_source_from_just.jpg?imageView2/2/w/600\" alt=\"fromjust\"></p>\n<p>比较推荐的方法有两种</p>\n<h3 id=\"1-fromCallable\"><a href=\"#1-fromCallable\" class=\"headerlink\" title=\"1. fromCallable\"></a>1. fromCallable</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.fromCallable(<span class=\"keyword\">new</span> Callable&lt;String&gt;()&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> throw Exception</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> getName() <span class=\"comment\">//  之前是synchronious的get，现在这一步可以asynchnous执行,比如放一个OkHttpClient.newCall(request).execute(); //因为是异步执行的，也不存在性能问题</span></div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面这段中的call方法会在被订阅后执行，成功的话会走到observer的onNext，失败的话会走到onError。<br>fromCallable可用于各种数据源，包括Flowable<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Flowable.fromCallable(() -&gt; <span class=\"string\">\"Hello Flowable\"</span>);</div><div class=\"line\">Observable.fromCallable(() -&gt; <span class=\"string\">\"Hello Observable\"</span>);</div><div class=\"line\">Maybe.fromCallable(() -&gt; <span class=\"string\">\"Hello Maybe\"</span>);</div><div class=\"line\">Single.fromCallable(() -&gt; <span class=\"string\">\"Hello Single\"</span>);</div><div class=\"line\">Completeable.fromCallable(() -&gt; <span class=\"string\">\"Hello Completeable\"</span>);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>fromCallable are for modeling synchronous sourse of a single source of data.</p>\n</blockquote>\n<p>很多需要返回值的方法都可以抽象成这种方法。<br>Maybe和Completeable还有两个方法,用于表示不返回数据的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Maybe.fromAction(() -&gt; <span class=\"string\">\"Hey jude\"</span>)</div><div class=\"line\">Maybe.fromRunnable(() -&gt; <span class=\"string\">\"ignore\"</span>)</div><div class=\"line\"></div><div class=\"line\">Completeable.fromAction(() -&gt; <span class=\"string\">\"Hey jude\"</span>)</div><div class=\"line\">Completeable.fromRunnable(() -&gt; <span class=\"string\">\"ignore\"</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-create-Rxjava-1中不推荐使用该方法，Rxjava2中建议使用\"><a href=\"#2-create-Rxjava-1中不推荐使用该方法，Rxjava2中建议使用\" class=\"headerlink\" title=\"2. create(Rxjava 1中不推荐使用该方法，Rxjava2中建议使用)\"></a>2. create(Rxjava 1中不推荐使用该方法，Rxjava2中建议使用)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;String&gt;())&#123;</div><div class=\"line\">      <span class=\"meta\">@override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span> <span class=\"params\">(ObservableEmitter&lt;String&gt; e)</span> <span class=\"keyword\">throws</span> Exception</span>&#123; <span class=\"comment\">//subscribe get called whenever there's a new subscriber, emitter is the person that's listening.</span></div><div class=\"line\">      <span class=\"comment\">//</span></div><div class=\"line\">         e.onNext(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">         e.onComplete();</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>//一个Observable可以有多个subscriber。一个被观察者可以有多个观察者，被观察者的onNext调用，观察者的onNext也会被调用</p>\n<p>lambda更简洁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(e -&gt;&#123;</div><div class=\"line\">    e.onNext(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    e.onNext(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    e.onComplete();</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">Okhttp的异步网络请求也可以model成一种被观察的流</div><div class=\"line\">Observable.create(e -&gt;&#123;</div><div class=\"line\">   Call call = client.newCall(request);</div><div class=\"line\">   call.enqueue(<span class=\"keyword\">new</span> Callback())&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>   <span class=\"title\">onResponse</span><span class=\"params\">(Response r)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</div><div class=\"line\">      e.onNext(r.body().toString());</div><div class=\"line\">      e.onComplete();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(IOException e)</span></span>&#123;</div><div class=\"line\">      e.onError(e);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//重点了来了，</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ObservableEmitter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Emitter</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Sets a Cancellable on this emitter; any previous Disposable</div><div class=\"line\">     * or Cancellation will be unsubscribed/cancelled.</div><div class=\"line\">     * <span class=\"doctag\">@param</span> c the cancellable resource, null is allowed</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setCancellable</span><span class=\"params\">(Cancellable c)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// emitter可以设置cancel的动作</span></div><div class=\"line\"></div><div class=\"line\">Observable.create(e -&gt;&#123;</div><div class=\"line\">    e.setCacelation(() -view.setOnClickListener(<span class=\"keyword\">null</span>));</div><div class=\"line\">    view.setOnClickListener(v -&gt; e.onNext());</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 点击按钮发送事件，取消订阅时避免leak View</span></div><div class=\"line\"></div><div class=\"line\">和fromCallable一样，create方法也适用于所有五种data source</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-如何订阅（接收）这些数据\"><a href=\"#3-如何订阅（接收）这些数据\" class=\"headerlink\" title=\"3. 如何订阅（接收）这些数据\"></a>3. 如何订阅（接收）这些数据</h2><h3 id=\"3-1-observer和Subscriber\"><a href=\"#3-1-observer和Subscriber\" class=\"headerlink\" title=\"3.1 observer和Subscriber\"></a>3.1 observer<T>和Subscriber<T></h3><p>接收Observable和Flowable的类型分别为Observer和Subscriber</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Disposable</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Subscription s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscription</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>; <span class=\"comment\">//用于取消订阅，释放资源</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">long</span> r)</span> </span>;<span class=\"comment\">//请求更多的数据，即BackPressure开始体现的地方</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"所以整体来看，数据的流向就这么两种，左边发送数据-可能只有一个，可能间歇性的，可能一直不停-，事件通过数据流传输到右边，右边根据协议作出相应-Reactive\"><a href=\"#所以整体来看，数据的流向就这么两种，左边发送数据-可能只有一个，可能间歇性的，可能一直不停-，事件通过数据流传输到右边，右边根据协议作出相应-Reactive\" class=\"headerlink\" title=\"所以整体来看，数据的流向就这么两种，左边发送数据(可能只有一个，可能间歇性的，可能一直不停)，事件通过数据流传输到右边，右边根据协议作出相应(Reactive)\"></a>所以整体来看，数据的流向就这么两种，左边发送数据(可能只有一个，可能间歇性的，可能一直不停)，事件通过数据流传输到右边，右边根据协议作出相应(Reactive)</h2><p>Observable -&gt; subscribe -&gt; Observer</p>\n<p>Flowable -&gt; subscribe -&gt; Subscription</p>\n<h3 id=\"3-2-onSubscribe怎么用\"><a href=\"#3-2-onSubscribe怎么用\" class=\"headerlink\" title=\"3.2 onSubscribe怎么用\"></a>3.2 onSubscribe怎么用</h3><p>通常不直接用这两种base class，因为第四个方法不知道怎么用嘛。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/4dab298b9f7ce29c43f9d8eaf686e02f.jpg?imageView2/2/w/600\" alt=\"\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"string\">\"Hello\"</span>).subscribe(<span class=\"keyword\">new</span> DisposableObserver&lt;String&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String value)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  可以持有DisposableObserver，在停止订阅的时候调用observer.dispose方法，切断流。</div><div class=\"line\">  或者这样</div><div class=\"line\">  Disposable disposable =   Observable.just(<span class=\"string\">\"Hello\"</span>).subscribeWith(<span class=\"keyword\">new</span> DisposableObserver&lt;String&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String value)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\"></div><div class=\"line\">   subscribeWith返回一个Disposable，subscribe是一个没有返回值的函数    </div><div class=\"line\"></div><div class=\"line\">  偷懒一点的话，通常把这些返回的订阅加入到一个CompositeDisposable,在onDestroy的时候统一取消订阅即可  </div><div class=\"line\"></div><div class=\"line\">  Observable、Single、Completeable、Maybe以及Flowable都支持subscribewith。</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-数据源和接受者建立联系\"><a href=\"#4-数据源和接受者建立联系\" class=\"headerlink\" title=\"4. 数据源和接受者建立联系\"></a>4. 数据源和接受者建立联系</h2><blockquote>\n<p>Observable.subscribe<br>或者<br>Flowable.subscribe<br>或者使用之前提到的sbscribeWith<br>我尝试写了一个比较复杂的调用顺序<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.fromCallable(<span class=\"keyword\">new</span> Callable&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"call do on thread any\"</span>);</div><div class=\"line\">                blockThread(<span class=\"number\">2000</span>); <span class=\"comment\">// block 2s</span></div><div class=\"line\">                <span class=\"keyword\">return</span> Arrays.asList(array);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribeOn(Schedulers.computation())</div><div class=\"line\">                .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">                .doOnSubscribe(<span class=\"keyword\">new</span> Consumer&lt;Disposable&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Disposable disposable)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                        LogUtil.p(<span class=\"string\">\"\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;).doOnComplete(<span class=\"keyword\">new</span> Action() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).doOnNext(<span class=\"keyword\">new</span> Consumer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(List&lt;String&gt; strings)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span> + strings.get(<span class=\"number\">0</span>));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).doAfterNext(<span class=\"keyword\">new</span> Consumer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(List&lt;String&gt; strings)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span>+strings.get(<span class=\"number\">0</span>));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span> </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"onSubscribe \"</span> + d.isDisposed());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(List&lt;String&gt; value)</span> </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\" get Response \"</span> + value.size());</div><div class=\"line\">                value.set(<span class=\"number\">0</span>, <span class=\"string\">\"change first element!\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">执行顺序：（括号内数字表示线程id）</div><div class=\"line\">doOnsubscribe(<span class=\"number\">1</span>) -&gt; onSubscribe(<span class=\"number\">1</span>) -&gt; call(<span class=\"number\">276</span>) -&gt;doOnNext(<span class=\"number\">1</span>)-&gt;onNext(<span class=\"number\">1</span>) -&gt; doAfterNext(<span class=\"number\">1</span>) -&gt;doOnComplete(<span class=\"number\">1</span>)-&gt;onComplete(<span class=\"number\">1</span>)</div><div class=\"line\">所以基本上可以认为doOnXXX= doBeforeXXX,线程都是一样的。估计是为了打日志用的，或者说用于切片。</div><div class=\"line\">像极了OkHttp的interecpter或是gradle的task。</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"5-Operator-and-Threading\"><a href=\"#5-Operator-and-Threading\" class=\"headerlink\" title=\"5. Operator and Threading\"></a>5. Operator and Threading</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;String&gt; greeting  = Observable.just(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">Observable&lt;String&gt; yelling = greeting.map(s -&gt;s.toUppercase())</div><div class=\"line\"></div><div class=\"line\">Observable.subscribeOn(Schedulers.io()) <span class=\"comment\">//</span></div></pre></td></tr></table></figure>\n<p>subscribeOn决定了task在哪条线程上运行，操作符的顺序很重要<br><img src=\"http://odzl05jxx.bkt.clouddn.com/reading%20network%20response%20on%20main%20thread.jpg?imageView2/2/w/600\" alt=\"Wrong\"><br><img src=\"http://odzl05jxx.bkt.clouddn.com/observing%20on%20ui%20thred.jpg?imageView2/2/w/600\" alt=\"Ok\"></p>\n<p>流之间的转换</p>\n<blockquote>\n<p>Observable -&gt; first() -&gt; single<br>Observable -&gt; firsetElement -&gt; Maybe<br>Observable -&gt; ignoreElements() -&gt;Completable</p>\n<p>Flowable -&gt; first() -&gt; single<br>Flowable -&gt; firsetElement -&gt; Maybe<br>Flowable -&gt; ignoreElements() -&gt;Completable</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ReactiveX/RxJava/wiki/Combining-Observables\">Combining Observables</a> 多个数据来源的加工</li>\n</ul>\n<h2 id=\"链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\"><a href=\"#链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\" class=\"headerlink\" title=\"链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\"></a>链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。</h2><h2 id=\"quote\"><a href=\"#quote\" class=\"headerlink\" title=\"quote:\"></a>quote:</h2><h3 id=\"RxJava-2-is-not-something-new-Reactive-programming-is-not-new-by-any-stretch-but-Android-itself-is-a-highly-reactive-world-that-we’ve-been-taught-to-model-in-a-very-imperative-stateful-fashion\"><a href=\"#RxJava-2-is-not-something-new-Reactive-programming-is-not-new-by-any-stretch-but-Android-itself-is-a-highly-reactive-world-that-we’ve-been-taught-to-model-in-a-very-imperative-stateful-fashion\" class=\"headerlink\" title=\"RxJava 2 is not something new. Reactive programming is not new by any stretch, but Android itself is a highly reactive world that we’ve been taught to model in a very imperative, stateful fashion.\"></a>RxJava 2 is not something new. Reactive programming is not new by any stretch, but Android itself is a highly reactive world that we’ve been taught to model in a very imperative, stateful fashion.</h3><p>Reactive programming allow us to model it in the proper way: asynchronously. Embrace the asynchronicity of the sources, and instead of trying to manage all the state ourselves, compose them together such that our apps become truly reactive.</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>– <a href=\"https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=6&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjlvrfg8bnTAhUI0mMKHcXZC1MQtwIITDAF&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DhtIXKI5gOQU&amp;usg=AFQjCNEYczqXGkjYXOUbovtP1CxDPARcXA&amp;sig2=gmLYEd2cVOhI7C2WjOHr9g\">GOTO 2016 • Exploring RxJava 2 for Android • Jake Wharton - YouTube</a></p>\n","excerpt":"<p>本文多数内容来自Jake Wharton的演讲，配合一些个人的感受，作为今后使用Rxjava2的一些参考。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/f21a6a245edfe0b19804be5b3df24a3d.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<h2 id=\"1-Why-Reactive\"><a href=\"#1-Why-Reactive\" class=\"headerlink\" title=\"1. Why Reactive?\"></a>1. Why Reactive?</h2><p>最早使用Rxjava的初衷在于方便地实现线程切换，使用链式语法轻松地将异步任务分发到子线程并省去了主动实现回调的麻烦。<br>我们生活在一个事件异步分发的环境中，网络，文件、甚至用户输入本身也是异步事件，除此之外，安卓系统本身的许多操作也是异步的，例如startActivity，Fragment的transaction，这就要求开发者不得不考虑各种事件状态，并在各种事件之间进行协调。Rxjava将各种事件的处理、完成以及异常在事件定义之初定义好处理方式。事件的开始，进行，完成以及异常，都被抽象到Observable的载体中。值得注意的是，这种链式调用很像Builder Pattern，但本质上每一步都生成了一个新的对象。这个在Rxjava的Wiki上有所说明，即每一步都生成一个新的immutable object（GC表示压力大）。</p>\n<h2 id=\"2-数据源\"><a href=\"#2-数据源\" class=\"headerlink\" title=\"2. 数据源\"></a>2. 数据源</h2><p>Stream基本包括这三部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">source of data</div><div class=\"line\">listener of data</div><div class=\"line\">methods for modifying data</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/stream_compose.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<h3 id=\"2-1-数据源的种类\"><a href=\"#2-1-数据源的种类\" class=\"headerlink\" title=\"2.1 数据源的种类\"></a>2.1 数据源的种类</h3><p>Observable<T> 和Flowable<T>，区别在于后者支持BackPressure，后者不支持BackPressure.<br>接收Observable和Flowable的类型分别为Observer和Subscriber</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Disposable</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></div><div class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Subscription s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscription</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> <span class=\"comment\">//用于取消订阅，释放资源</span></div><div class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">long</span> r)</span> <span class=\"comment\">//请求更多的数据，即BackPressure开始体现的地方</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>两者的区别在于最后一个方法，以Disposable为例，当你开始subscribe一个数据源的时，就类似于创建了一个Resurce，而Resource是往往需要在用完之后及时释放。无论是Observable还是Flowable,这个onSubscribe方法会在订阅后立即被调用，这个方法里的Disposable可以保留下来，在必要时候用于释放资源。如Activity的onDestroy中cancel network request.</p>\n<h3 id=\"2-2-数据源的对应类\"><a href=\"#2-2-数据源的对应类\" class=\"headerlink\" title=\"2.2 数据源的对应类\"></a>2.2 数据源的对应类</h3><ol>\n<li><p>Single(订阅一个Single，要么获得仅一个返回值，要么出现异常返回Error)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">SingleSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Completeable(订阅一个completeable，要么成功，不返回值，要么出现异常返回error，就像一个reactive runnale，一个可以执行的command，并不返回结果)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Completable</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompletableSource</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>例如，异步写一个文件，要么成功，要么出现error，并不需要返回什么。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(Stirng data)</span></span>&#123;&#125;</div><div class=\"line\"><span class=\"comment\">// 就可以model成</span></div><div class=\"line\"><span class=\"function\">Completeable <span class=\"title\">writeFile</span><span class=\"params\">(Stirng data)</span></span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>Maybe(有可能返回值，有可能不返回，也有可能异常，即optional)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maybe</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MaybeSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以上三种数据源都有static方法生成：<br>例如<br><img src=\"http://odzl05jxx.bkt.clouddn.com/creating_source_from_iterable.jpg?imageView2/2/w/600\" alt=\"from iterable\"></p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/creating_source_from_just.jpg?imageView2/2/w/600\" alt=\"fromjust\"></p>\n<p>比较推荐的方法有两种</p>\n<h3 id=\"1-fromCallable\"><a href=\"#1-fromCallable\" class=\"headerlink\" title=\"1. fromCallable\"></a>1. fromCallable</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.fromCallable(<span class=\"keyword\">new</span> Callable&lt;String&gt;()&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> throw Exception</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> getName() <span class=\"comment\">//  之前是synchronious的get，现在这一步可以asynchnous执行,比如放一个OkHttpClient.newCall(request).execute(); //因为是异步执行的，也不存在性能问题</span></div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面这段中的call方法会在被订阅后执行，成功的话会走到observer的onNext，失败的话会走到onError。<br>fromCallable可用于各种数据源，包括Flowable<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Flowable.fromCallable(() -&gt; <span class=\"string\">\"Hello Flowable\"</span>);</div><div class=\"line\">Observable.fromCallable(() -&gt; <span class=\"string\">\"Hello Observable\"</span>);</div><div class=\"line\">Maybe.fromCallable(() -&gt; <span class=\"string\">\"Hello Maybe\"</span>);</div><div class=\"line\">Single.fromCallable(() -&gt; <span class=\"string\">\"Hello Single\"</span>);</div><div class=\"line\">Completeable.fromCallable(() -&gt; <span class=\"string\">\"Hello Completeable\"</span>);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>fromCallable are for modeling synchronous sourse of a single source of data.</p>\n</blockquote>\n<p>很多需要返回值的方法都可以抽象成这种方法。<br>Maybe和Completeable还有两个方法,用于表示不返回数据的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Maybe.fromAction(() -&gt; <span class=\"string\">\"Hey jude\"</span>)</div><div class=\"line\">Maybe.fromRunnable(() -&gt; <span class=\"string\">\"ignore\"</span>)</div><div class=\"line\"></div><div class=\"line\">Completeable.fromAction(() -&gt; <span class=\"string\">\"Hey jude\"</span>)</div><div class=\"line\">Completeable.fromRunnable(() -&gt; <span class=\"string\">\"ignore\"</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-create-Rxjava-1中不推荐使用该方法，Rxjava2中建议使用\"><a href=\"#2-create-Rxjava-1中不推荐使用该方法，Rxjava2中建议使用\" class=\"headerlink\" title=\"2. create(Rxjava 1中不推荐使用该方法，Rxjava2中建议使用)\"></a>2. create(Rxjava 1中不推荐使用该方法，Rxjava2中建议使用)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;String&gt;())&#123;</div><div class=\"line\">      <span class=\"meta\">@override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span> <span class=\"params\">(ObservableEmitter&lt;String&gt; e)</span> <span class=\"keyword\">throws</span> Exception</span>&#123; <span class=\"comment\">//subscribe get called whenever there's a new subscriber, emitter is the person that's listening.</span></div><div class=\"line\">      <span class=\"comment\">//</span></div><div class=\"line\">         e.onNext(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">         e.onComplete();</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>//一个Observable可以有多个subscriber。一个被观察者可以有多个观察者，被观察者的onNext调用，观察者的onNext也会被调用</p>\n<p>lambda更简洁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(e -&gt;&#123;</div><div class=\"line\">    e.onNext(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    e.onNext(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    e.onComplete();</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">Okhttp的异步网络请求也可以model成一种被观察的流</div><div class=\"line\">Observable.create(e -&gt;&#123;</div><div class=\"line\">   Call call = client.newCall(request);</div><div class=\"line\">   call.enqueue(<span class=\"keyword\">new</span> Callback())&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>   <span class=\"title\">onResponse</span><span class=\"params\">(Response r)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</div><div class=\"line\">      e.onNext(r.body().toString());</div><div class=\"line\">      e.onComplete();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(IOException e)</span></span>&#123;</div><div class=\"line\">      e.onError(e);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//重点了来了，</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ObservableEmitter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Emitter</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Sets a Cancellable on this emitter; any previous Disposable</div><div class=\"line\">     * or Cancellation will be unsubscribed/cancelled.</div><div class=\"line\">     * <span class=\"doctag\">@param</span> c the cancellable resource, null is allowed</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setCancellable</span><span class=\"params\">(Cancellable c)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// emitter可以设置cancel的动作</span></div><div class=\"line\"></div><div class=\"line\">Observable.create(e -&gt;&#123;</div><div class=\"line\">    e.setCacelation(() -view.setOnClickListener(<span class=\"keyword\">null</span>));</div><div class=\"line\">    view.setOnClickListener(v -&gt; e.onNext());</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 点击按钮发送事件，取消订阅时避免leak View</span></div><div class=\"line\"></div><div class=\"line\">和fromCallable一样，create方法也适用于所有五种data source</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-如何订阅（接收）这些数据\"><a href=\"#3-如何订阅（接收）这些数据\" class=\"headerlink\" title=\"3. 如何订阅（接收）这些数据\"></a>3. 如何订阅（接收）这些数据</h2><h3 id=\"3-1-observer和Subscriber\"><a href=\"#3-1-observer和Subscriber\" class=\"headerlink\" title=\"3.1 observer和Subscriber\"></a>3.1 observer<T>和Subscriber<T></h3><p>接收Observable和Flowable的类型分别为Observer和Subscriber</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Disposable</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Subscription s)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscription</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>; <span class=\"comment\">//用于取消订阅，释放资源</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">long</span> r)</span> </span>;<span class=\"comment\">//请求更多的数据，即BackPressure开始体现的地方</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"所以整体来看，数据的流向就这么两种，左边发送数据-可能只有一个，可能间歇性的，可能一直不停-，事件通过数据流传输到右边，右边根据协议作出相应-Reactive\"><a href=\"#所以整体来看，数据的流向就这么两种，左边发送数据-可能只有一个，可能间歇性的，可能一直不停-，事件通过数据流传输到右边，右边根据协议作出相应-Reactive\" class=\"headerlink\" title=\"所以整体来看，数据的流向就这么两种，左边发送数据(可能只有一个，可能间歇性的，可能一直不停)，事件通过数据流传输到右边，右边根据协议作出相应(Reactive)\"></a>所以整体来看，数据的流向就这么两种，左边发送数据(可能只有一个，可能间歇性的，可能一直不停)，事件通过数据流传输到右边，右边根据协议作出相应(Reactive)</h2><p>Observable -&gt; subscribe -&gt; Observer</p>\n<p>Flowable -&gt; subscribe -&gt; Subscription</p>\n<h3 id=\"3-2-onSubscribe怎么用\"><a href=\"#3-2-onSubscribe怎么用\" class=\"headerlink\" title=\"3.2 onSubscribe怎么用\"></a>3.2 onSubscribe怎么用</h3><p>通常不直接用这两种base class，因为第四个方法不知道怎么用嘛。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/4dab298b9f7ce29c43f9d8eaf686e02f.jpg?imageView2/2/w/600\" alt=\"\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"string\">\"Hello\"</span>).subscribe(<span class=\"keyword\">new</span> DisposableObserver&lt;String&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String value)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  可以持有DisposableObserver，在停止订阅的时候调用observer.dispose方法，切断流。</div><div class=\"line\">  或者这样</div><div class=\"line\">  Disposable disposable =   Observable.just(<span class=\"string\">\"Hello\"</span>).subscribeWith(<span class=\"keyword\">new</span> DisposableObserver&lt;String&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String value)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\"></div><div class=\"line\">   subscribeWith返回一个Disposable，subscribe是一个没有返回值的函数    </div><div class=\"line\"></div><div class=\"line\">  偷懒一点的话，通常把这些返回的订阅加入到一个CompositeDisposable,在onDestroy的时候统一取消订阅即可  </div><div class=\"line\"></div><div class=\"line\">  Observable、Single、Completeable、Maybe以及Flowable都支持subscribewith。</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-数据源和接受者建立联系\"><a href=\"#4-数据源和接受者建立联系\" class=\"headerlink\" title=\"4. 数据源和接受者建立联系\"></a>4. 数据源和接受者建立联系</h2><blockquote>\n<p>Observable.subscribe<br>或者<br>Flowable.subscribe<br>或者使用之前提到的sbscribeWith<br>我尝试写了一个比较复杂的调用顺序<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.fromCallable(<span class=\"keyword\">new</span> Callable&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"call do on thread any\"</span>);</div><div class=\"line\">                blockThread(<span class=\"number\">2000</span>); <span class=\"comment\">// block 2s</span></div><div class=\"line\">                <span class=\"keyword\">return</span> Arrays.asList(array);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribeOn(Schedulers.computation())</div><div class=\"line\">                .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">                .doOnSubscribe(<span class=\"keyword\">new</span> Consumer&lt;Disposable&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Disposable disposable)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                        LogUtil.p(<span class=\"string\">\"\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;).doOnComplete(<span class=\"keyword\">new</span> Action() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).doOnNext(<span class=\"keyword\">new</span> Consumer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(List&lt;String&gt; strings)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span> + strings.get(<span class=\"number\">0</span>));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).doAfterNext(<span class=\"keyword\">new</span> Consumer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(List&lt;String&gt; strings)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span>+strings.get(<span class=\"number\">0</span>));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span> </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"onSubscribe \"</span> + d.isDisposed());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(List&lt;String&gt; value)</span> </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\" get Response \"</span> + value.size());</div><div class=\"line\">                value.set(<span class=\"number\">0</span>, <span class=\"string\">\"change first element!\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                LogUtil.p(<span class=\"string\">\"\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">执行顺序：（括号内数字表示线程id）</div><div class=\"line\">doOnsubscribe(<span class=\"number\">1</span>) -&gt; onSubscribe(<span class=\"number\">1</span>) -&gt; call(<span class=\"number\">276</span>) -&gt;doOnNext(<span class=\"number\">1</span>)-&gt;onNext(<span class=\"number\">1</span>) -&gt; doAfterNext(<span class=\"number\">1</span>) -&gt;doOnComplete(<span class=\"number\">1</span>)-&gt;onComplete(<span class=\"number\">1</span>)</div><div class=\"line\">所以基本上可以认为doOnXXX= doBeforeXXX,线程都是一样的。估计是为了打日志用的，或者说用于切片。</div><div class=\"line\">像极了OkHttp的interecpter或是gradle的task。</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"5-Operator-and-Threading\"><a href=\"#5-Operator-and-Threading\" class=\"headerlink\" title=\"5. Operator and Threading\"></a>5. Operator and Threading</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;String&gt; greeting  = Observable.just(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">Observable&lt;String&gt; yelling = greeting.map(s -&gt;s.toUppercase())</div><div class=\"line\"></div><div class=\"line\">Observable.subscribeOn(Schedulers.io()) <span class=\"comment\">//</span></div></pre></td></tr></table></figure>\n<p>subscribeOn决定了task在哪条线程上运行，操作符的顺序很重要<br><img src=\"http://odzl05jxx.bkt.clouddn.com/reading%20network%20response%20on%20main%20thread.jpg?imageView2/2/w/600\" alt=\"Wrong\"><br><img src=\"http://odzl05jxx.bkt.clouddn.com/observing%20on%20ui%20thred.jpg?imageView2/2/w/600\" alt=\"Ok\"></p>\n<p>流之间的转换</p>\n<blockquote>\n<p>Observable -&gt; first() -&gt; single<br>Observable -&gt; firsetElement -&gt; Maybe<br>Observable -&gt; ignoreElements() -&gt;Completable</p>\n<p>Flowable -&gt; first() -&gt; single<br>Flowable -&gt; firsetElement -&gt; Maybe<br>Flowable -&gt; ignoreElements() -&gt;Completable</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ReactiveX/RxJava/wiki/Combining-Observables\">Combining Observables</a> 多个数据来源的加工</li>\n</ul>\n<h2 id=\"链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\"><a href=\"#链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\" class=\"headerlink\" title=\"链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。\"></a>链式调用每一步都生成了新的object，Rxjava2和Rxjava1相比，对GC更加友好。</h2><h2 id=\"quote\"><a href=\"#quote\" class=\"headerlink\" title=\"quote:\"></a>quote:</h2><h3 id=\"RxJava-2-is-not-something-new-Reactive-programming-is-not-new-by-any-stretch-but-Android-itself-is-a-highly-reactive-world-that-we’ve-been-taught-to-model-in-a-very-imperative-stateful-fashion\"><a href=\"#RxJava-2-is-not-something-new-Reactive-programming-is-not-new-by-any-stretch-but-Android-itself-is-a-highly-reactive-world-that-we’ve-been-taught-to-model-in-a-very-imperative-stateful-fashion\" class=\"headerlink\" title=\"RxJava 2 is not something new. Reactive programming is not new by any stretch, but Android itself is a highly reactive world that we’ve been taught to model in a very imperative, stateful fashion.\"></a>RxJava 2 is not something new. Reactive programming is not new by any stretch, but Android itself is a highly reactive world that we’ve been taught to model in a very imperative, stateful fashion.</h3><p>Reactive programming allow us to model it in the proper way: asynchronously. Embrace the asynchronicity of the sources, and instead of trying to manage all the state ourselves, compose them together such that our apps become truly reactive.</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>– <a href=\"https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=6&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjlvrfg8bnTAhUI0mMKHcXZC1MQtwIITDAF&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DhtIXKI5gOQU&amp;usg=AFQjCNEYczqXGkjYXOUbovtP1CxDPARcXA&amp;sig2=gmLYEd2cVOhI7C2WjOHr9g\">GOTO 2016 • Exploring RxJava 2 for Android • Jake Wharton - YouTube</a></p>"},{"title":"View的属性大全[转载]","date":"2017-04-03T03:38:10.000Z","_content":"\n转自[Android属性大全](http://www.codexiu.cn/android/blog/40141/)\n\n<!-- more -->\n\n```java\nandroid:alpha \nsetAlpha(float) 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。\nandroid:background \nsetBackgroundResource(int) 属性说明: 视图背景\nandroid:clickable \nsetClickable(boolean) 属性说明: 视图是否可点击\nandroid:contentDescription \nsetContentDescription(CharSequence) 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明\nandroid:drawingCacheQuality \nsetDrawingCacheQuality(int) 属性说明: \"设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存\"\nandroid:duplicateParentState \n属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）\nandroid:fadeScrollbars \nsetScrollbarFadingEnabled(boolean) 属性说明: 定义在ScrollBar没有使用时，是否褪色。\nandroid:fadingEdgeLength \ngetVerticalFadingEdgeLength() 属性说明: 设置边框渐变的长度。\nandroid:filterTouchesWhenObscured \nsetFilterTouchesWhenObscured(boolean) 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。\nandroid:fitsSystemWindows \nsetFitsSystemWindows(boolean) 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）\nandroid:focusable \nsetFocusable(boolean) 属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。\nandroid:focusableInTouchMode \nsetFocusableInTouchMode(boolean) 属性说明: 设置在Touch模式下View是否能取得焦点。\nandroid:hapticFeedbackEnabled \nsetHapticFeedbackEnabled(boolean) 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果\nandroid:id \nsetId(int) 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用View.findViewById() 或Activity.findViewById()根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。\nandroid:importantForAccessibility \nsetImportantForAccessibility(int) 属性说明: 设置可达性的重要性\nandroid:isScrollContainer \nsetScrollContainer(boolean) 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条\nandroid:keepScreenOn \nsetKeepScreenOn(boolean) 属性说明: 视图在可见的情况下是否保持唤醒状态。\nandroid:layerType \nsetLayerType(int,Paint) 属性说明: \"设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。\"\nandroid:layoutDirection \nsetLayoutDirection(int) 属性说明: 定义布局图纸的方向\nandroid:longClickable \nsetLongClickable(boolean) 属性说明: 是否响应长点击事件\nandroid:minHeight \nsetMinimumHeight(int) 属性说明: 设置视图最小高度\nandroid:minWidth \nsetMinimumWidth(int) 属性说明: 设置视图最小宽度\nandroid:nextFocusDown \nsetNextFocusDownId(int) 属性说明: 向下移动焦点时，下一个获取焦点的view的id\nandroid:nextFocusForward \nsetNextFocusForwardId(int) 属性说明: 下一个获取焦点的view的id\nandroid:nextFocusLeft \nsetNextFocusLeftId(int) 属性说明: 向左移动焦点时，下一个获取焦点的view的id\nandroid:nextFocusRight \nsetNextFocusRightId(int) 属性说明: 向右移动焦点时，下一个获取焦点的view的id\nandroid:nextFocusUp \nsetNextFocusUpId(int) 属性说明: 向上移动焦点时，下一个获取焦点的view的id\nandroid:onClick \nsetOnClick()或 onClick(View view)属性说明: 点击时，要调用的方法的名称。\nandroid:padding \nsetPaddingRelative(int,int,int,int) 属性说明: 设置上下左右的边距\nandroid:paddingBottom \nsetPaddingRelative(int,int,int,int) 属性说明: 下边距\nandroid:paddingEnd \nsetPaddingRelative(int,int,int,int) 属性说明: 与android:paddingRight相同\nandroid:paddingLeft \nsetPadding(int,int,int,int) 属性说明: 左边距\nandroid:paddingRight \nsetPadding(int,int,int,int) 属性说明: 右边距\nandroid:paddingStart \nsetPaddingRelative(int,int,int,int) 属性说明: android:paddingLeft相同\nandroid:paddingTop \nsetPaddingRelative(int,int,int,int) 属性说明: 上边距\nandroid:requiresFadingEdge \nsetVerticalFadingEdgeEnabled(boolean) 属性说明: 定义滚动时边缘是否褪色\nandroid:rotation \nsetRotation(float) 属性说明: 旋转度数\nandroid:rotationX \nsetRotationX(float) 属性说明: 水平旋转度数\nandroid:rotationY \nsetRotationY(float) 属性说明: 竖直旋转度数\nandroid:saveEnabled \nsetSaveEnabled(boolean) 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。\nandroid:scaleX \nsetScaleX(float) 属性说明: 水平方向缩放比例\nandroid:scaleY \nsetScaleY(float) 属性说明: 竖直方向缩放比例\nandroid:scrollX \n属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离\nandroid:scrollY \n属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离\nandroid:scrollbarAlwaysDrawHorizontalTrack \n属性说明: 是否总是绘制水平滚动条的滚动轨道\nandroid:scrollbarAlwaysDrawVerticalTrack \n属性说明: 是否总是绘制竖直滚动条的滚动轨道\nandroid:scrollbarDefaultDelayBeforeFade \nsetScrollBarDefaultDelayBeforeFade(int) 属性说明: 滚动条在n毫秒后开始淡出。\nandroid:scrollbarFadeDuration \nsetScrollBarFadeDuration(int) 属性说明: 滚动条用多长时间淡出完毕。\nandroid:scrollbarSize \nsetScrollBarSize(int) 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度\nandroid:scrollbarStyle \nsetScrollBarStyle(int) 属性说明: \"滚动条的风格。共4组值： insideOverlay——内贴图 insideInset——内插图 outsideOverlay——外贴图 outsideInset——外插图。 inside就是滚动条在绘制在padding以内；outside就是不需要绘制在padding内（即view的边界处）；Overlay是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；Inset是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。\"\nandroid:scrollbarThumbHorizontal \n属性说明: 水平滚动块的drawable对象\nandroid:scrollbarThumbVertical \n属性说明: 竖直滚动块的drawable对象\nandroid:scrollbarTrackHorizontal \n属性说明: 水平滚动条滚动轨道的drawable对象\nandroid:scrollbarTrackVertical \n属性说明: 竖直滚动条滚动轨道的drawable对象\nandroid:scrollbars \n属性说明: \"设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条\"\nandroid:soundEffectsEnabled \nsetSoundEffectsEnabled(boolean) 属性说明: 点击或触摸该view时，是否需要有声音效果\nandroid:tag \n属性说明: string标识。类似id，id是整数标识。\nandroid:textAlignment \nsetTextAlignment(int) 属性说明: 设置文本的显示方式。\nandroid:textDirection \nsetTextDirection(int) 属性说明: 设置文本的显示方向。\nandroid:transformPivotX \nsetPivotX(float) 属性说明: 水平方向偏转量\nandroid:transformPivotY \nsetPivotY(float) 属性说明: 竖直方向偏转量\nandroid:translationX \nsetTranslationX(float) 属性说明: 水平方向的移动距离\nandroid:translationY \nsetTranslationY(float) 属性说明: 竖直方向的移动距离\nandroid:visibility \nsetVisibility(int) 属性说明: \"view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见\"\nTextView属性说明\n下面对TextView的属性进行说明 android:autoLink \nsetAutoLinkMask(int) 属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all)\nandroid:autoText \nsetKeyListener(KeyListener) 属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。\nandroid:bufferType \nsetText(CharSequence,TextView.BufferType) 属性说明: 指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。\nandroid:capitalize \nsetKeyListener(KeyListener) 属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。\nandroid:cursorVisible \nsetCursorVisible(boolean) 属性说明: 设定光标为显示/隐藏，默认显示。\nandroid:digits \nsetKeyListener(KeyListener) 属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\\n()”\nandroid:drawableBottom \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。\nandroid:drawableEnd \nsetCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int) 属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][package:]type:name\"或者\"?[package:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。\nandroid:drawableLeft \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的左边输出一个drawable。\nandroid:drawablePadding \nsetCompoundDrawablePadding(int) 属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。\nandroid:drawableRight \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的右边输出一个drawable。\nandroid:drawableStart \nsetCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int) 属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][package:]type:name\"或者\"?[package:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。\nandroid:drawableTop \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的正上方输出一个drawable。\nandroid:editable \n属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。\nandroid:editorExtras \nsetInputExtras(int) 属性说明: 设置文本的额外的输入数据。在EditView中才有效果。\nandroid:ellipsize \nsetEllipsize(TextUtils.TruncateAt) 属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)\nandroid:ems \nsetEms(int) 属性说明: 设置TextView的宽度为N个字符的宽度。\nandroid:fontFamily \nsetTypeface(Typeface) 属性说明: 文本的字形体系。\nandroid:freezesText \nsetFreezesText(boolean) 属性说明: 设置保存文本的内容以及光标的位置。\nandroid:gravity \nsetGravity(int) 属性说明: 设置文本位置，如设置成“center”，文本将居中显示。\nandroid:height \nsetHeight(int) 属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)\nandroid:hint \nsetHint(int) 属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。\nandroid:imeActionId \nsetImeActionLabel(CharSequence,int) 属性说明: 设置IME动作ID。\nandroid:imeActionLabel \nsetImeActionLabel(CharSequence,int) 属性说明: 设置IME动作标签。在EditView再做说明。\nandroid:imeOptions \nsetImeOptions(int) 属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。\nandroid:includeFontPadding \nsetIncludeFontPadding(boolean) 属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。\nandroid:inputMethod \nsetKeyListener(KeyListener) 属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。\nandroid:inputType \nsetRawInputType(int) 属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。\nandroid:lineSpacingExtra \nsetLineSpacing(float,float) 属性说明: 设置行间距。\nandroid:lineSpacingMultiplier \nsetLineSpacing(float,float) 属性说明: 设置行间距的倍数。如”1.2”\nandroid:lines \nsetLines(int) 属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。\nandroid:linksClickable \nsetLinksClickable(boolean) 属性说明: 设置链接是否点击连接，即使设置了autoLink。\nandroid:marqueeRepeatLimit \nsetMarqueeRepeatLimit(int) 属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。\nandroid:maxEms \nsetMaxEms(int) 属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。\nandroid:maxHeight \nsetMaxHeight(int) 属性说明: 设置文本区域的最大高度\nandroid:maxLength \nsetFilters(InputFilter) 属性说明: 限制显示的文本长度，超出部分不显示。\nandroid:maxLines \nsetMaxLines(int) 属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。\nandroid:maxWidth \nsetMaxWidth(int) 属性说明: 设置文本区域的最大宽度\nandroid:minEms \nsetMinEms(int) 属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。\nandroid:minHeight \nsetMinHeight(int) 属性说明: 设置文本区域的最小高度\nandroid:minLines \nsetMinLines(int) 属性说明: 设置文本的最小行数，与lines类似。\nandroid:minWidth \nsetMinWidth(int) 属性说明: 设置文本区域的最小宽度\nandroid:numeric \nsetKeyListener(KeyListener) 属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。\nandroid:password \nsetTransformationMethod(TransformationMethod) 属性说明: 以小点”.”显示文本\nandroid:phoneNumber \nsetKeyListener(KeyListener) 属性说明: 设置为电话号码的输入方式。\nandroid:privateImeOptions \nsetPrivateImeOptions(String) 属性说明: 设置输入法选项，在EditText中才有作用。\nandroid:scrollHorizontally \nsetHorizontallyScrolling(boolean) 属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。\nandroid:selectAllOnFocus \nsetSelectAllOnFocus(boolean) 属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。\nandroid:shadowColor \nsetShadowLayer(float,float,float,int) 属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。\nandroid:shadowDx \nsetShadowLayer(float,float,float,int) 属性说明: 设置阴影横向坐标开始位置。\nandroid:shadowDy \nsetShadowLayer(float,float,float,int) 属性说明: 设置阴影纵向坐标开始位置。\nandroid:shadowRadius \nsetShadowLayer(float,float,float,int) 属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。\nandroid:singleLine \nsetTransformationMethod(TransformationMethod) 属性说明: 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=\"test_ singleLine \" android:singleLine=\"true\" android:layout_width=\"20dp\"将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行\nandroid:text \nsetText(CharSequence,TextView.BufferType) 属性说明: 设置显示文本.\nandroid:textAllCaps \nsetAllCaps(boolean) 属性说明: 设置文本全为大写。值为\"true\"或\"false\"。\nandroid:textAppearance \n属性说明: 设置文字外观。如“?android:attr/textAppearanceLargeInverse\nandroid:textColor \nsetTextColor(int) 属性说明: 设置文本颜色\nandroid:textColorHighlight \nsetHighlightColor(int) 属性说明: 被选中文字的底色，默认为蓝色\nandroid:textColorHint \nsetHintTextColor(int) 属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。\nandroid:textColorLink \nsetLinkTextColor(int) 属性说明: 文字链接的颜色.\nandroid:textIsSelectable \nisTextSelectable() 属性说明: 设置非编辑文本可否被选择。值为\"true\"或\"false\"。\nandroid:textScaleX \nsetTextScaleX(float) 属性说明: 设置文字之间间隔，默认为1.0f。\nandroid:textSize \nsetTextSize(int,float) 属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”\nandroid:textStyle \nsetTypeface(Typeface) 属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开\nandroid:typeface \nsetTypeface(Typeface) 属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3]\nandroid:width \nsetWidth(int) 属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。\nandroid:fadingEdgeLength\n设置淡入淡出边缘的长度，可以接受大小值的单位是：px、dp、sp、in、mm，也可以参考大小值资源\nandroid:fitsSystemWindows\n是否适合系统窗体，取值为true或false。该属性只对不是子组件的组件有效\nandroid:focusable\n是否可以获取焦点，取值true或false\nandroid:focusableInTouchMode\n是否可以在触摸模式下获取焦点，true或false\nandroid:hapticFeedbackEnabled\n是否允许触摸反馈效果，true或false\nandroid:id\n提供该组件的标识名，可以借助Activity或View实例的findViewById方法通过id获取对应的组件实例对象，其属性值的形式为：android:id=”@+id/id”\nandroid:isScrollContainer\n设置该组件是否设置为滚动条容器，true或false\nandroid:keepScreenOn\n控制该组件在显示的时候保持在屏幕显示，true或false\nandroid:longClickable\n是否响应长时间点击事件，true或false\nandroid:minHeight\n组件的最小高度，取值同android:fadingEdgeLength\nandroid:minWidth\n组件的最小宽度，取值同android:fadingEdgeLength\nandroid:nextFocusDown\n设置下一个向下获取焦点的组件，取值为id\nandroid:nextFocusLeft\n设置下一个向左获取焦点的组件，取值为id\nandroid:nextFocusRight\n设置下一个向右获取焦点的组件，取值为id\nandroid:nextFocusUp\n设置下一个向上获取焦点的组件，取值为id\nandroid:padding\n设置上、下、左、右4个边缘的填充距离，必须是一个大小值，取值同android:fadingEdgeLength\nandroid:paddingBottom\n设置下端边缘的填充距离，取值同android:padding\nandroid:paddingLeft\n设置左端边缘的填充距离，取值同android:padding\nandroid:paddingRight\n设置右端边缘的填充距离，取值同android:padding\nandroid:paddingTop\n设置上端边缘的填充距离，取值同android:padding\nandroid:saveEnabled\n是否允许保存状态，取值为true或false\nandroid:scrollX\n设置垂直滚动条的位移量，必须是一个大小值，取值同android:padding\nandroid:scrollY\n设置水平滚动条的位移量，必须是一个大小值，取值同android:padding\nandroid:scrollbarAlwaysDrawHorizontalTrack\n是否总是设置水平滚动条滑块，true或false\nandroid:scrollbarAlwaysDrawVerticalTrack\n是否总是设置垂直滚动条滑块，true或false\nandroid:scrollbarSize\n设置垂直滚动条的宽度和水平滚动条的长度，必须是一个大小值，取值同android:padding\nandroid:scrollbarStyle\n设置滚动条的样式，取值为下列之一：\ninsideOverlay在填充区域内，覆盖形式\ninsideInset在填充区域内，插进形式（凹进）\noutsideOverly在绑定组件边缘，覆盖形式\noutsideInset在绑定组件边缘，插进形似\nandroid:scrollbarThumbHorizontal\n设置水平滚动条按钮的绘制资源，必须引用可绘制资源\nandroid:scrollbarThumbVertical\n设置垂直滚动条按钮的绘制资源，必须引用可绘制资源\nandroid:scrollbarTrackHorizontal\n设置水平滚动条轨道的绘制资源，必须引用可绘制资源\nandroid:scrollbarTrackVertical\n设置水平滚动条轨道的绘制资源，必须引用可绘制资源\nandroid:scrollbars\n设置滚动显示，可以为一下一个或多个值：\nnone不显示滚动条\nhorizontal只显示水平滚动条\nvertical只显示垂直滚动条\nandroid:soundEffectsEnabled\n是否允许音效，取值为true或false\nandroid:tag\n设置标记内容，可以通过View类实例的getTag方法获取该组件的标记内容，或者使用findViewByTag通过标记来查找相应的子组件\nandroid:visibility\n设置初始化可见状态，取值为以下之一：\nvisible可见（默认值）\ninvisible不可见（其所占空间将留出）\ngone完全不可见（其所占空间都不会留出）\n线性布局LinearLayout组件属性列表\n属性说明\nandroid:baselineAligned\n基线对齐\nandroid:baselineAlignedChildIndex\n以指定子组件作为基线对齐\nandroid:gravity\n指定该物体放入其容器的重心位置，取值为下列之一：\ntop上方，物体大小不变\nbottom下方，物体大小不变\nleft左方，物体大小不变\nright右方，物体大小不变\ncenter_vertical垂直方向的中间，物体大小不变\nfill_vertical填满垂直方向，自动进行大小调整\ncenter_horizontal水平方向的中间，大小不变\nfill_horizontal填满水平方向，自动进行大小调整\ncenter居中（既是水平也是垂直方向的中间）\nfill填满整个容器\nclip_vertical\nclip_horizontal\nandroid:orientation\n布局方向，取值为下列之一：\nhorizontal水平的\nvertical垂直的（默认值）\nandroid:weightSum\n组件的比重和\n\nLinearLayout_Layout属性说明\n\nandroid:layout_gravity\n当前子组件的心位置\nandroid:layout_height\n当前子组件的高度\nandroid:layout_weight\n当前子组件的空间比重，取值为浮点数\nandroid:layout_width\n当前子组件的宽度\n\nRalativeLayout属性说明\n\nandroid:gravity\n设置添加组件的重心\nandroid:ignoreGravity\n忽略布局重心的影响\n\nRalativeLayout_Layout属性说明\n\nandroid:layout_above\n将当前组件的下边缘放置于参照组件之上，该属性为参照组件的ID\nandroid:layout_alignBaseline\n当前组件与参照组件的基线对齐，该属性为参照组件的ID\nandroid:layout_alignBottom\n当前组件与参照组件的下边界对齐，该属性为参照组件的ID\nandroid:layout_alignLeft\n当前组件与参照组件的左边界对齐，该属性为参照组件的ID\nandroid:layout_alignParenBottom\n当前组件与父组件的下边界对齐，true或false\nandroid:layout_alignParentLeft\n当前组件与父组件的左边界对齐，true或false\nandroid:layout_alignParentRight\n当前组件与父组件的右边界对齐，true或false\nandroid:layout_alignParentTop\n当前组件与父组件的上边界对齐，true或false\nandroid:layout_alignRight\n当前组件与参照组件的右边界对齐，该属性为参照组件的ID\nandroid:layout_alignTop\n当前组件与参照组件的上边界对齐，该属性为参照组件的ID\nandroid:layout_alignWithParentIfMissing\n如果对应的兄弟元素找不到的话就以父元素做参照物 true或false\nandroid:layout_below\n将当前组件的上边缘放置于参照组件之下，该属性为参照组件的ID\nandroid:layout_centerHorizontal\n当前组件放置到父组件的水平居中的位置\nandroid:layout_centerInParent\n当前组件放置到父组件的重心位置\nandroid:layout_centerVertical\n当前组件放置到父组件垂直居中的位置\nandroid:layout_toLeftOf\n将当前组件的右边缘放置于参照组件之下，该属性为参照组件的ID\nandroid:layout_toRightOf\n将当前组件的左边缘放置于参照组件之下，该属性为参照组件的ID\n\nAbsoluteLayout_Layout属性说明\n\nandroid:layout_x\n当前组件的x坐标位置（从左到右方向）\nandroid:layout_y\n当前组件的y坐标位置（从上到下方向）\n\nFrameLayout属性说明\n\nandroid:foreground\n前置图片\nandroid:foregroundGravity\n前置图片重心\nandroid:measureAllChildren\n在切换显示时是否侧重所有子组件的大小\nandroid:layout_gravity\n添加组件的重心\n\nFrameLayout_Layout属性说明\n\nandroid:layout_gravity\n当前子组件所添加的重心位置\n\nTableLayout属性说明\n\nandroid:collapseColumns\n设置允许折叠的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔\nandroid:shrinkColumns\n设置允许收缩的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔\nandroid:stretchColumns\n设置允许伸展的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔\nTableRow_Cell属性说明\n\nandroid:layout_column\n设置该单元格的列编号（基于0）\nandroid:layout_span\n指明该单元格可以跨越的列数\n\nAbsListView属性说明\n\nandroid:cacheColorHint\n设置缓冲颜色\nandroid:drawSelectorOnTop\n是否将选择器绘制在备选条目上方，取值为true或false\nandroid:fastScrollEnabled\n允许快速滚动\nandroid:listSelector\n指示选择器的内容\nandroid:scrollingCache\n滚动时是否使用绘制缓冲，true或false\nandroid:smoothScrollbar\n平滑滚动条\nandroid:stackFromBottom\n从下方堆叠条目\nandroid:textFilterEnbled\n是否允许过滤\nandroid:transcriptMode设置抄本模式\n\nListView属性说明\n\nandroid:choiceMode\n选择模式\nandroid:divider\n分割线颜色或组件的参考\nandroid:dividerHeight\n分割线高度\nandroid:entries\n指定绑定到当前列表视图的一个数组资源\nandroid:footerDividersEnabled\n是否允许页脚分割线\nandroid:headerDividersEnabled\n是否允许页眉分割线\n\nGridView属性说明\n\nandroid:columnWidth\n指定列宽\nandroid:gravity\n添加组件的重心位置\nandroid:horizontalSpacing\n水平空间\nandroid:numColumns\n指定列数\nandroid:strechMode\n伸展模式\nandroid:verticalSpacing\n垂直空间\n\nGallery属性说明\n\nandroid:animationDuration\n动画持续时间\nandroid:gravity\n添加组件的重心位置\nandroid:spacing\n间隔空间\nandroid:unselectedAlpha\n非选择条目的透明度\n\nTextView属性说明\n\nandroid:autoLink\n是否自动链接（内容是网址或是电子邮件时）\nandroid:autoText\n自动更新拼音错误\nandroid:bufferType\n设置缓冲区类型\nandroid:capitalize\n自动大写\nandroid:cursorVisible\n光标是否可见，true或false\nandroid:digits\n所接受的数字字符\nandroid:drawableBottom\n在文本下方绘制\nandroid:drawableLeft\n在文本左方绘制\nandroid: drawablePadding\n绘制填充区\nandroid: drawableRight\n在文本右方绘制\nandroid: drawableTop\n在文本上方绘制\nandroid:editable\n是否可编辑，true或false\nandroid:editorExtras\n设置文本的额外的输入数据。在EditView中才有效果\nandroid:ellipsize\n当内容过长时会自动打断单词内容\nandroid:ems\n设置TextView的宽度为N个字符的宽度\nandroid:enabled\n是否可用，true或false\nandroid:freezesText\n是否冻结文本\nandroid:gravity\n指明文本的重心位置\nandroid:height\n高度值\nandroid:hint\n指示内容\nandroid:imeActionId\n设置IME动作ID\nandroid:imeActionLabel\n设置IME动作标签\nandroid:imeOptions\n输入法选项\nandroid:includeFontPadding\n设置文本是否包含顶部和底部额外空白，默认为true\nandroid:inputMethod\n指定输入法\nandroid:inputType\n输入类型，取值为下列之一：\nnone\ntext普通文本\ntextCapCharacters大写字符\ntextCapWords单词首字母大写\ntextCapSentences句子首字母大写\ntextAutoCorret自动更正\ntextAutoComplete自动完成\ntextMultiLine多行内容\ntextUri，Uri\ntextEmailAddress电子邮件地址\ntextEmailSubject电子邮件主题\ntextShortMessage短消息\ntextLongMessage长消息\ntextPersonName个人姓名\ntextPostalAddress邮政地址\ntextPassword密码\ntextVIsiblePassword可见的密码\ntextWebEditText网页格式\ntextFilter过滤字符串\ntextPhonetic语言发音\nnumber数字\nnumberSigned有符号数字\nnumberDecimal十进制数字\nphone电话号码\ndatetime日期时间\ndate日期\ntime时间\nandroid:lineSpacingExtra\n设置行间距 \nandroid:lineSpacingMultiplier\n设置行间距的倍数\nandroid:lines\n设置文本行数\nandroid:linksClickable\n设置链接是否点击连接，即使设置了autoLick\nandroid:marqueeRepeatLimit\n来回移动的动画次数\nandroid:maxEms\n设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项 \nandroid:maxHeight\n物体的最大高度\nandroid:maxLength\n最大文本长度\nandroid:maxLines\n最大行数\nandroid:minWidth\n物体的最大宽度\nandroid:minEms\n设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项\n \nandroid:minHeight\n物体的最小高度\nandroid:minLines\n最小文本行数\nandroid:minWidth\n物体的最小宽度\nandroid:numeric\n是否使用数字输入方式\nandroid:password\n是否使用密码输入方式\nandroid:phonenumber\n是否使用电话号码输入方式\nandroid:privateImeOptions\n设置输入法选项 \nandroid:scrollHorizontally\n设置文本超出TextView的宽度的情况下，是否出现横拉条 \nandroid:selectAllOnFocus\n如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。\nandroid:shadowColor\n文本阴影颜色\nandroid:shadowDx\n阴影的水平偏移\nandroid:shadowDy\n阴影的垂直偏移\nandroid:shadowRadius\n阴影的半径\nandroid:singleLine\n是否单行（不自动换行）\nandroid:text\n显示的文本内容\nandroid:textApperance\n基本字体颜色、字样、大小和样式\nandroid:textColor\n文本颜色\nandroid: textColorHighlight\n文本高亮颜色\nandroid: textColorHint\n文本提示颜色\nandroid:textColorLink\n文本链接颜色\nandroid:textScaleX\n文本缩放因数\nandroid:textSize\n文本大小\nandroid:textStyle\n文本样式，取值为下列之一：\nbold粗体\nitalic斜体\nbolditalic粗斜体\nandroid:typeface\n字样\nandroid:width\n物体的高度\n\nAutoCompleteTextView属性说明\n\nandroid:completionHint\n显示提示\nandroid:completionHintView\n提示视图\nandroid:completionThreshold\n设置开始提示的字符数\nandroid:dropDownAnchor\n下拉框链接视图\nandroid:dropDownSelector\n下拉框选择器\nandroid:dropDownWIdth\n下拉框宽度\n\nImageView属性说明\n\nandroid:adjustViewBounds\n是否调整视图范围\nandroid:baselineAlignBottom\n是否按照下端基线对齐\nandroid:cropToPadding\n是否按照填充进行裁剪\nandroid:maxHeight\n设置最大高度\nandroid:maxWidth\n设置最大宽度\nandroid:scaleType\n缩放类型，取值为下列之一：\nmatrix图片真实大小\nfitXY适合图片大小\nfitStart\nfitCenter\nfitEnd\ncenter居中显示\ncenterCrop\ncenterInside\nandroid:src\n设置绘制用内容\nandroid:tint\n设置染色颜色值\nandroid:layout_above=\"@id/xxx\" \n将控件置于给定ID控件之上 \nandroid:layout_below=\"@id/xxx\"\n将控件置于给定ID控件之下\nandroid:layout_toLeftOf=\"@id/xxx\" \n将控件的右边缘和给定ID控件的左边缘对齐 \nandroid:layout_toRightOf=\"@id/xxx\" \n将控件的左边缘和给定ID控件的右边缘对齐\nandroid:layout_alignLeft=\"@id/xxx\" \n将控件的左边缘和给定ID控件的左边缘对齐\nandroid:layout_alignTop=\"@id/xxx\" \n将控件的上边缘和给定ID控件的上边缘对齐\n \nandroid:layout_alignRight=\"@id/xxx\"\n将控件的右边缘和给定ID控件的右边缘对齐\nandroid:layout_alignBottom=\"@id/xxx\" \n将控件的底边缘和给定ID控件的底边缘对齐 \nandroid:layout_alignParentLeft=\"true\" \n将控件的左边缘和父控件的左边缘对齐 \nandroid:layout_alignParentTop=\"true\" \n将控件的上边缘和父控件的上边缘对齐 \nandroid:layout_alignParentRight=\"true\" \n将控件的右边缘和父控件的右边缘对齐 \nandroid:layout_alignParentBottom=\"true\" \n将控件的底边缘和父控件的底边缘对齐\n android:layout_centerInParent=\"true\" \n 将控件置于父控件的中心位置 \n \n android:layout_centerHorizontal=\"true\" \n 将控件置于水平方向的中心位置 \n \n android:layout_centerVertical=\"true\" \n 将控件置于垂直方向的中心位置\n ```\n","source":"_posts/2017-04-03-properties-of-view.md","raw":"---\ntitle: View的属性大全[转载]\ndate: 2017-04-03 11:38:10\ncategories: blog \ntags: [android,tools]\n---\n\n转自[Android属性大全](http://www.codexiu.cn/android/blog/40141/)\n\n<!-- more -->\n\n```java\nandroid:alpha \nsetAlpha(float) 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。\nandroid:background \nsetBackgroundResource(int) 属性说明: 视图背景\nandroid:clickable \nsetClickable(boolean) 属性说明: 视图是否可点击\nandroid:contentDescription \nsetContentDescription(CharSequence) 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明\nandroid:drawingCacheQuality \nsetDrawingCacheQuality(int) 属性说明: \"设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存\"\nandroid:duplicateParentState \n属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）\nandroid:fadeScrollbars \nsetScrollbarFadingEnabled(boolean) 属性说明: 定义在ScrollBar没有使用时，是否褪色。\nandroid:fadingEdgeLength \ngetVerticalFadingEdgeLength() 属性说明: 设置边框渐变的长度。\nandroid:filterTouchesWhenObscured \nsetFilterTouchesWhenObscured(boolean) 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。\nandroid:fitsSystemWindows \nsetFitsSystemWindows(boolean) 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）\nandroid:focusable \nsetFocusable(boolean) 属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。\nandroid:focusableInTouchMode \nsetFocusableInTouchMode(boolean) 属性说明: 设置在Touch模式下View是否能取得焦点。\nandroid:hapticFeedbackEnabled \nsetHapticFeedbackEnabled(boolean) 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果\nandroid:id \nsetId(int) 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用View.findViewById() 或Activity.findViewById()根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。\nandroid:importantForAccessibility \nsetImportantForAccessibility(int) 属性说明: 设置可达性的重要性\nandroid:isScrollContainer \nsetScrollContainer(boolean) 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条\nandroid:keepScreenOn \nsetKeepScreenOn(boolean) 属性说明: 视图在可见的情况下是否保持唤醒状态。\nandroid:layerType \nsetLayerType(int,Paint) 属性说明: \"设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。\"\nandroid:layoutDirection \nsetLayoutDirection(int) 属性说明: 定义布局图纸的方向\nandroid:longClickable \nsetLongClickable(boolean) 属性说明: 是否响应长点击事件\nandroid:minHeight \nsetMinimumHeight(int) 属性说明: 设置视图最小高度\nandroid:minWidth \nsetMinimumWidth(int) 属性说明: 设置视图最小宽度\nandroid:nextFocusDown \nsetNextFocusDownId(int) 属性说明: 向下移动焦点时，下一个获取焦点的view的id\nandroid:nextFocusForward \nsetNextFocusForwardId(int) 属性说明: 下一个获取焦点的view的id\nandroid:nextFocusLeft \nsetNextFocusLeftId(int) 属性说明: 向左移动焦点时，下一个获取焦点的view的id\nandroid:nextFocusRight \nsetNextFocusRightId(int) 属性说明: 向右移动焦点时，下一个获取焦点的view的id\nandroid:nextFocusUp \nsetNextFocusUpId(int) 属性说明: 向上移动焦点时，下一个获取焦点的view的id\nandroid:onClick \nsetOnClick()或 onClick(View view)属性说明: 点击时，要调用的方法的名称。\nandroid:padding \nsetPaddingRelative(int,int,int,int) 属性说明: 设置上下左右的边距\nandroid:paddingBottom \nsetPaddingRelative(int,int,int,int) 属性说明: 下边距\nandroid:paddingEnd \nsetPaddingRelative(int,int,int,int) 属性说明: 与android:paddingRight相同\nandroid:paddingLeft \nsetPadding(int,int,int,int) 属性说明: 左边距\nandroid:paddingRight \nsetPadding(int,int,int,int) 属性说明: 右边距\nandroid:paddingStart \nsetPaddingRelative(int,int,int,int) 属性说明: android:paddingLeft相同\nandroid:paddingTop \nsetPaddingRelative(int,int,int,int) 属性说明: 上边距\nandroid:requiresFadingEdge \nsetVerticalFadingEdgeEnabled(boolean) 属性说明: 定义滚动时边缘是否褪色\nandroid:rotation \nsetRotation(float) 属性说明: 旋转度数\nandroid:rotationX \nsetRotationX(float) 属性说明: 水平旋转度数\nandroid:rotationY \nsetRotationY(float) 属性说明: 竖直旋转度数\nandroid:saveEnabled \nsetSaveEnabled(boolean) 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。\nandroid:scaleX \nsetScaleX(float) 属性说明: 水平方向缩放比例\nandroid:scaleY \nsetScaleY(float) 属性说明: 竖直方向缩放比例\nandroid:scrollX \n属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离\nandroid:scrollY \n属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离\nandroid:scrollbarAlwaysDrawHorizontalTrack \n属性说明: 是否总是绘制水平滚动条的滚动轨道\nandroid:scrollbarAlwaysDrawVerticalTrack \n属性说明: 是否总是绘制竖直滚动条的滚动轨道\nandroid:scrollbarDefaultDelayBeforeFade \nsetScrollBarDefaultDelayBeforeFade(int) 属性说明: 滚动条在n毫秒后开始淡出。\nandroid:scrollbarFadeDuration \nsetScrollBarFadeDuration(int) 属性说明: 滚动条用多长时间淡出完毕。\nandroid:scrollbarSize \nsetScrollBarSize(int) 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度\nandroid:scrollbarStyle \nsetScrollBarStyle(int) 属性说明: \"滚动条的风格。共4组值： insideOverlay——内贴图 insideInset——内插图 outsideOverlay——外贴图 outsideInset——外插图。 inside就是滚动条在绘制在padding以内；outside就是不需要绘制在padding内（即view的边界处）；Overlay是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；Inset是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。\"\nandroid:scrollbarThumbHorizontal \n属性说明: 水平滚动块的drawable对象\nandroid:scrollbarThumbVertical \n属性说明: 竖直滚动块的drawable对象\nandroid:scrollbarTrackHorizontal \n属性说明: 水平滚动条滚动轨道的drawable对象\nandroid:scrollbarTrackVertical \n属性说明: 竖直滚动条滚动轨道的drawable对象\nandroid:scrollbars \n属性说明: \"设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条\"\nandroid:soundEffectsEnabled \nsetSoundEffectsEnabled(boolean) 属性说明: 点击或触摸该view时，是否需要有声音效果\nandroid:tag \n属性说明: string标识。类似id，id是整数标识。\nandroid:textAlignment \nsetTextAlignment(int) 属性说明: 设置文本的显示方式。\nandroid:textDirection \nsetTextDirection(int) 属性说明: 设置文本的显示方向。\nandroid:transformPivotX \nsetPivotX(float) 属性说明: 水平方向偏转量\nandroid:transformPivotY \nsetPivotY(float) 属性说明: 竖直方向偏转量\nandroid:translationX \nsetTranslationX(float) 属性说明: 水平方向的移动距离\nandroid:translationY \nsetTranslationY(float) 属性说明: 竖直方向的移动距离\nandroid:visibility \nsetVisibility(int) 属性说明: \"view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见\"\nTextView属性说明\n下面对TextView的属性进行说明 android:autoLink \nsetAutoLinkMask(int) 属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all)\nandroid:autoText \nsetKeyListener(KeyListener) 属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。\nandroid:bufferType \nsetText(CharSequence,TextView.BufferType) 属性说明: 指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。\nandroid:capitalize \nsetKeyListener(KeyListener) 属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。\nandroid:cursorVisible \nsetCursorVisible(boolean) 属性说明: 设定光标为显示/隐藏，默认显示。\nandroid:digits \nsetKeyListener(KeyListener) 属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\\n()”\nandroid:drawableBottom \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。\nandroid:drawableEnd \nsetCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int) 属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][package:]type:name\"或者\"?[package:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。\nandroid:drawableLeft \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的左边输出一个drawable。\nandroid:drawablePadding \nsetCompoundDrawablePadding(int) 属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。\nandroid:drawableRight \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的右边输出一个drawable。\nandroid:drawableStart \nsetCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int) 属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][package:]type:name\"或者\"?[package:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。\nandroid:drawableTop \nsetCompoundDrawablesWithIntrinsicBounds(int,int,int,int) 属性说明: 在text的正上方输出一个drawable。\nandroid:editable \n属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。\nandroid:editorExtras \nsetInputExtras(int) 属性说明: 设置文本的额外的输入数据。在EditView中才有效果。\nandroid:ellipsize \nsetEllipsize(TextUtils.TruncateAt) 属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)\nandroid:ems \nsetEms(int) 属性说明: 设置TextView的宽度为N个字符的宽度。\nandroid:fontFamily \nsetTypeface(Typeface) 属性说明: 文本的字形体系。\nandroid:freezesText \nsetFreezesText(boolean) 属性说明: 设置保存文本的内容以及光标的位置。\nandroid:gravity \nsetGravity(int) 属性说明: 设置文本位置，如设置成“center”，文本将居中显示。\nandroid:height \nsetHeight(int) 属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)\nandroid:hint \nsetHint(int) 属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。\nandroid:imeActionId \nsetImeActionLabel(CharSequence,int) 属性说明: 设置IME动作ID。\nandroid:imeActionLabel \nsetImeActionLabel(CharSequence,int) 属性说明: 设置IME动作标签。在EditView再做说明。\nandroid:imeOptions \nsetImeOptions(int) 属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。\nandroid:includeFontPadding \nsetIncludeFontPadding(boolean) 属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。\nandroid:inputMethod \nsetKeyListener(KeyListener) 属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。\nandroid:inputType \nsetRawInputType(int) 属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。\nandroid:lineSpacingExtra \nsetLineSpacing(float,float) 属性说明: 设置行间距。\nandroid:lineSpacingMultiplier \nsetLineSpacing(float,float) 属性说明: 设置行间距的倍数。如”1.2”\nandroid:lines \nsetLines(int) 属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。\nandroid:linksClickable \nsetLinksClickable(boolean) 属性说明: 设置链接是否点击连接，即使设置了autoLink。\nandroid:marqueeRepeatLimit \nsetMarqueeRepeatLimit(int) 属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。\nandroid:maxEms \nsetMaxEms(int) 属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。\nandroid:maxHeight \nsetMaxHeight(int) 属性说明: 设置文本区域的最大高度\nandroid:maxLength \nsetFilters(InputFilter) 属性说明: 限制显示的文本长度，超出部分不显示。\nandroid:maxLines \nsetMaxLines(int) 属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。\nandroid:maxWidth \nsetMaxWidth(int) 属性说明: 设置文本区域的最大宽度\nandroid:minEms \nsetMinEms(int) 属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。\nandroid:minHeight \nsetMinHeight(int) 属性说明: 设置文本区域的最小高度\nandroid:minLines \nsetMinLines(int) 属性说明: 设置文本的最小行数，与lines类似。\nandroid:minWidth \nsetMinWidth(int) 属性说明: 设置文本区域的最小宽度\nandroid:numeric \nsetKeyListener(KeyListener) 属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。\nandroid:password \nsetTransformationMethod(TransformationMethod) 属性说明: 以小点”.”显示文本\nandroid:phoneNumber \nsetKeyListener(KeyListener) 属性说明: 设置为电话号码的输入方式。\nandroid:privateImeOptions \nsetPrivateImeOptions(String) 属性说明: 设置输入法选项，在EditText中才有作用。\nandroid:scrollHorizontally \nsetHorizontallyScrolling(boolean) 属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。\nandroid:selectAllOnFocus \nsetSelectAllOnFocus(boolean) 属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。\nandroid:shadowColor \nsetShadowLayer(float,float,float,int) 属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。\nandroid:shadowDx \nsetShadowLayer(float,float,float,int) 属性说明: 设置阴影横向坐标开始位置。\nandroid:shadowDy \nsetShadowLayer(float,float,float,int) 属性说明: 设置阴影纵向坐标开始位置。\nandroid:shadowRadius \nsetShadowLayer(float,float,float,int) 属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。\nandroid:singleLine \nsetTransformationMethod(TransformationMethod) 属性说明: 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=\"test_ singleLine \" android:singleLine=\"true\" android:layout_width=\"20dp\"将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行\nandroid:text \nsetText(CharSequence,TextView.BufferType) 属性说明: 设置显示文本.\nandroid:textAllCaps \nsetAllCaps(boolean) 属性说明: 设置文本全为大写。值为\"true\"或\"false\"。\nandroid:textAppearance \n属性说明: 设置文字外观。如“?android:attr/textAppearanceLargeInverse\nandroid:textColor \nsetTextColor(int) 属性说明: 设置文本颜色\nandroid:textColorHighlight \nsetHighlightColor(int) 属性说明: 被选中文字的底色，默认为蓝色\nandroid:textColorHint \nsetHintTextColor(int) 属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。\nandroid:textColorLink \nsetLinkTextColor(int) 属性说明: 文字链接的颜色.\nandroid:textIsSelectable \nisTextSelectable() 属性说明: 设置非编辑文本可否被选择。值为\"true\"或\"false\"。\nandroid:textScaleX \nsetTextScaleX(float) 属性说明: 设置文字之间间隔，默认为1.0f。\nandroid:textSize \nsetTextSize(int,float) 属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”\nandroid:textStyle \nsetTypeface(Typeface) 属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开\nandroid:typeface \nsetTypeface(Typeface) 属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3]\nandroid:width \nsetWidth(int) 属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。\nandroid:fadingEdgeLength\n设置淡入淡出边缘的长度，可以接受大小值的单位是：px、dp、sp、in、mm，也可以参考大小值资源\nandroid:fitsSystemWindows\n是否适合系统窗体，取值为true或false。该属性只对不是子组件的组件有效\nandroid:focusable\n是否可以获取焦点，取值true或false\nandroid:focusableInTouchMode\n是否可以在触摸模式下获取焦点，true或false\nandroid:hapticFeedbackEnabled\n是否允许触摸反馈效果，true或false\nandroid:id\n提供该组件的标识名，可以借助Activity或View实例的findViewById方法通过id获取对应的组件实例对象，其属性值的形式为：android:id=”@+id/id”\nandroid:isScrollContainer\n设置该组件是否设置为滚动条容器，true或false\nandroid:keepScreenOn\n控制该组件在显示的时候保持在屏幕显示，true或false\nandroid:longClickable\n是否响应长时间点击事件，true或false\nandroid:minHeight\n组件的最小高度，取值同android:fadingEdgeLength\nandroid:minWidth\n组件的最小宽度，取值同android:fadingEdgeLength\nandroid:nextFocusDown\n设置下一个向下获取焦点的组件，取值为id\nandroid:nextFocusLeft\n设置下一个向左获取焦点的组件，取值为id\nandroid:nextFocusRight\n设置下一个向右获取焦点的组件，取值为id\nandroid:nextFocusUp\n设置下一个向上获取焦点的组件，取值为id\nandroid:padding\n设置上、下、左、右4个边缘的填充距离，必须是一个大小值，取值同android:fadingEdgeLength\nandroid:paddingBottom\n设置下端边缘的填充距离，取值同android:padding\nandroid:paddingLeft\n设置左端边缘的填充距离，取值同android:padding\nandroid:paddingRight\n设置右端边缘的填充距离，取值同android:padding\nandroid:paddingTop\n设置上端边缘的填充距离，取值同android:padding\nandroid:saveEnabled\n是否允许保存状态，取值为true或false\nandroid:scrollX\n设置垂直滚动条的位移量，必须是一个大小值，取值同android:padding\nandroid:scrollY\n设置水平滚动条的位移量，必须是一个大小值，取值同android:padding\nandroid:scrollbarAlwaysDrawHorizontalTrack\n是否总是设置水平滚动条滑块，true或false\nandroid:scrollbarAlwaysDrawVerticalTrack\n是否总是设置垂直滚动条滑块，true或false\nandroid:scrollbarSize\n设置垂直滚动条的宽度和水平滚动条的长度，必须是一个大小值，取值同android:padding\nandroid:scrollbarStyle\n设置滚动条的样式，取值为下列之一：\ninsideOverlay在填充区域内，覆盖形式\ninsideInset在填充区域内，插进形式（凹进）\noutsideOverly在绑定组件边缘，覆盖形式\noutsideInset在绑定组件边缘，插进形似\nandroid:scrollbarThumbHorizontal\n设置水平滚动条按钮的绘制资源，必须引用可绘制资源\nandroid:scrollbarThumbVertical\n设置垂直滚动条按钮的绘制资源，必须引用可绘制资源\nandroid:scrollbarTrackHorizontal\n设置水平滚动条轨道的绘制资源，必须引用可绘制资源\nandroid:scrollbarTrackVertical\n设置水平滚动条轨道的绘制资源，必须引用可绘制资源\nandroid:scrollbars\n设置滚动显示，可以为一下一个或多个值：\nnone不显示滚动条\nhorizontal只显示水平滚动条\nvertical只显示垂直滚动条\nandroid:soundEffectsEnabled\n是否允许音效，取值为true或false\nandroid:tag\n设置标记内容，可以通过View类实例的getTag方法获取该组件的标记内容，或者使用findViewByTag通过标记来查找相应的子组件\nandroid:visibility\n设置初始化可见状态，取值为以下之一：\nvisible可见（默认值）\ninvisible不可见（其所占空间将留出）\ngone完全不可见（其所占空间都不会留出）\n线性布局LinearLayout组件属性列表\n属性说明\nandroid:baselineAligned\n基线对齐\nandroid:baselineAlignedChildIndex\n以指定子组件作为基线对齐\nandroid:gravity\n指定该物体放入其容器的重心位置，取值为下列之一：\ntop上方，物体大小不变\nbottom下方，物体大小不变\nleft左方，物体大小不变\nright右方，物体大小不变\ncenter_vertical垂直方向的中间，物体大小不变\nfill_vertical填满垂直方向，自动进行大小调整\ncenter_horizontal水平方向的中间，大小不变\nfill_horizontal填满水平方向，自动进行大小调整\ncenter居中（既是水平也是垂直方向的中间）\nfill填满整个容器\nclip_vertical\nclip_horizontal\nandroid:orientation\n布局方向，取值为下列之一：\nhorizontal水平的\nvertical垂直的（默认值）\nandroid:weightSum\n组件的比重和\n\nLinearLayout_Layout属性说明\n\nandroid:layout_gravity\n当前子组件的心位置\nandroid:layout_height\n当前子组件的高度\nandroid:layout_weight\n当前子组件的空间比重，取值为浮点数\nandroid:layout_width\n当前子组件的宽度\n\nRalativeLayout属性说明\n\nandroid:gravity\n设置添加组件的重心\nandroid:ignoreGravity\n忽略布局重心的影响\n\nRalativeLayout_Layout属性说明\n\nandroid:layout_above\n将当前组件的下边缘放置于参照组件之上，该属性为参照组件的ID\nandroid:layout_alignBaseline\n当前组件与参照组件的基线对齐，该属性为参照组件的ID\nandroid:layout_alignBottom\n当前组件与参照组件的下边界对齐，该属性为参照组件的ID\nandroid:layout_alignLeft\n当前组件与参照组件的左边界对齐，该属性为参照组件的ID\nandroid:layout_alignParenBottom\n当前组件与父组件的下边界对齐，true或false\nandroid:layout_alignParentLeft\n当前组件与父组件的左边界对齐，true或false\nandroid:layout_alignParentRight\n当前组件与父组件的右边界对齐，true或false\nandroid:layout_alignParentTop\n当前组件与父组件的上边界对齐，true或false\nandroid:layout_alignRight\n当前组件与参照组件的右边界对齐，该属性为参照组件的ID\nandroid:layout_alignTop\n当前组件与参照组件的上边界对齐，该属性为参照组件的ID\nandroid:layout_alignWithParentIfMissing\n如果对应的兄弟元素找不到的话就以父元素做参照物 true或false\nandroid:layout_below\n将当前组件的上边缘放置于参照组件之下，该属性为参照组件的ID\nandroid:layout_centerHorizontal\n当前组件放置到父组件的水平居中的位置\nandroid:layout_centerInParent\n当前组件放置到父组件的重心位置\nandroid:layout_centerVertical\n当前组件放置到父组件垂直居中的位置\nandroid:layout_toLeftOf\n将当前组件的右边缘放置于参照组件之下，该属性为参照组件的ID\nandroid:layout_toRightOf\n将当前组件的左边缘放置于参照组件之下，该属性为参照组件的ID\n\nAbsoluteLayout_Layout属性说明\n\nandroid:layout_x\n当前组件的x坐标位置（从左到右方向）\nandroid:layout_y\n当前组件的y坐标位置（从上到下方向）\n\nFrameLayout属性说明\n\nandroid:foreground\n前置图片\nandroid:foregroundGravity\n前置图片重心\nandroid:measureAllChildren\n在切换显示时是否侧重所有子组件的大小\nandroid:layout_gravity\n添加组件的重心\n\nFrameLayout_Layout属性说明\n\nandroid:layout_gravity\n当前子组件所添加的重心位置\n\nTableLayout属性说明\n\nandroid:collapseColumns\n设置允许折叠的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔\nandroid:shrinkColumns\n设置允许收缩的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔\nandroid:stretchColumns\n设置允许伸展的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔\nTableRow_Cell属性说明\n\nandroid:layout_column\n设置该单元格的列编号（基于0）\nandroid:layout_span\n指明该单元格可以跨越的列数\n\nAbsListView属性说明\n\nandroid:cacheColorHint\n设置缓冲颜色\nandroid:drawSelectorOnTop\n是否将选择器绘制在备选条目上方，取值为true或false\nandroid:fastScrollEnabled\n允许快速滚动\nandroid:listSelector\n指示选择器的内容\nandroid:scrollingCache\n滚动时是否使用绘制缓冲，true或false\nandroid:smoothScrollbar\n平滑滚动条\nandroid:stackFromBottom\n从下方堆叠条目\nandroid:textFilterEnbled\n是否允许过滤\nandroid:transcriptMode设置抄本模式\n\nListView属性说明\n\nandroid:choiceMode\n选择模式\nandroid:divider\n分割线颜色或组件的参考\nandroid:dividerHeight\n分割线高度\nandroid:entries\n指定绑定到当前列表视图的一个数组资源\nandroid:footerDividersEnabled\n是否允许页脚分割线\nandroid:headerDividersEnabled\n是否允许页眉分割线\n\nGridView属性说明\n\nandroid:columnWidth\n指定列宽\nandroid:gravity\n添加组件的重心位置\nandroid:horizontalSpacing\n水平空间\nandroid:numColumns\n指定列数\nandroid:strechMode\n伸展模式\nandroid:verticalSpacing\n垂直空间\n\nGallery属性说明\n\nandroid:animationDuration\n动画持续时间\nandroid:gravity\n添加组件的重心位置\nandroid:spacing\n间隔空间\nandroid:unselectedAlpha\n非选择条目的透明度\n\nTextView属性说明\n\nandroid:autoLink\n是否自动链接（内容是网址或是电子邮件时）\nandroid:autoText\n自动更新拼音错误\nandroid:bufferType\n设置缓冲区类型\nandroid:capitalize\n自动大写\nandroid:cursorVisible\n光标是否可见，true或false\nandroid:digits\n所接受的数字字符\nandroid:drawableBottom\n在文本下方绘制\nandroid:drawableLeft\n在文本左方绘制\nandroid: drawablePadding\n绘制填充区\nandroid: drawableRight\n在文本右方绘制\nandroid: drawableTop\n在文本上方绘制\nandroid:editable\n是否可编辑，true或false\nandroid:editorExtras\n设置文本的额外的输入数据。在EditView中才有效果\nandroid:ellipsize\n当内容过长时会自动打断单词内容\nandroid:ems\n设置TextView的宽度为N个字符的宽度\nandroid:enabled\n是否可用，true或false\nandroid:freezesText\n是否冻结文本\nandroid:gravity\n指明文本的重心位置\nandroid:height\n高度值\nandroid:hint\n指示内容\nandroid:imeActionId\n设置IME动作ID\nandroid:imeActionLabel\n设置IME动作标签\nandroid:imeOptions\n输入法选项\nandroid:includeFontPadding\n设置文本是否包含顶部和底部额外空白，默认为true\nandroid:inputMethod\n指定输入法\nandroid:inputType\n输入类型，取值为下列之一：\nnone\ntext普通文本\ntextCapCharacters大写字符\ntextCapWords单词首字母大写\ntextCapSentences句子首字母大写\ntextAutoCorret自动更正\ntextAutoComplete自动完成\ntextMultiLine多行内容\ntextUri，Uri\ntextEmailAddress电子邮件地址\ntextEmailSubject电子邮件主题\ntextShortMessage短消息\ntextLongMessage长消息\ntextPersonName个人姓名\ntextPostalAddress邮政地址\ntextPassword密码\ntextVIsiblePassword可见的密码\ntextWebEditText网页格式\ntextFilter过滤字符串\ntextPhonetic语言发音\nnumber数字\nnumberSigned有符号数字\nnumberDecimal十进制数字\nphone电话号码\ndatetime日期时间\ndate日期\ntime时间\nandroid:lineSpacingExtra\n设置行间距 \nandroid:lineSpacingMultiplier\n设置行间距的倍数\nandroid:lines\n设置文本行数\nandroid:linksClickable\n设置链接是否点击连接，即使设置了autoLick\nandroid:marqueeRepeatLimit\n来回移动的动画次数\nandroid:maxEms\n设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项 \nandroid:maxHeight\n物体的最大高度\nandroid:maxLength\n最大文本长度\nandroid:maxLines\n最大行数\nandroid:minWidth\n物体的最大宽度\nandroid:minEms\n设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项\n \nandroid:minHeight\n物体的最小高度\nandroid:minLines\n最小文本行数\nandroid:minWidth\n物体的最小宽度\nandroid:numeric\n是否使用数字输入方式\nandroid:password\n是否使用密码输入方式\nandroid:phonenumber\n是否使用电话号码输入方式\nandroid:privateImeOptions\n设置输入法选项 \nandroid:scrollHorizontally\n设置文本超出TextView的宽度的情况下，是否出现横拉条 \nandroid:selectAllOnFocus\n如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。\nandroid:shadowColor\n文本阴影颜色\nandroid:shadowDx\n阴影的水平偏移\nandroid:shadowDy\n阴影的垂直偏移\nandroid:shadowRadius\n阴影的半径\nandroid:singleLine\n是否单行（不自动换行）\nandroid:text\n显示的文本内容\nandroid:textApperance\n基本字体颜色、字样、大小和样式\nandroid:textColor\n文本颜色\nandroid: textColorHighlight\n文本高亮颜色\nandroid: textColorHint\n文本提示颜色\nandroid:textColorLink\n文本链接颜色\nandroid:textScaleX\n文本缩放因数\nandroid:textSize\n文本大小\nandroid:textStyle\n文本样式，取值为下列之一：\nbold粗体\nitalic斜体\nbolditalic粗斜体\nandroid:typeface\n字样\nandroid:width\n物体的高度\n\nAutoCompleteTextView属性说明\n\nandroid:completionHint\n显示提示\nandroid:completionHintView\n提示视图\nandroid:completionThreshold\n设置开始提示的字符数\nandroid:dropDownAnchor\n下拉框链接视图\nandroid:dropDownSelector\n下拉框选择器\nandroid:dropDownWIdth\n下拉框宽度\n\nImageView属性说明\n\nandroid:adjustViewBounds\n是否调整视图范围\nandroid:baselineAlignBottom\n是否按照下端基线对齐\nandroid:cropToPadding\n是否按照填充进行裁剪\nandroid:maxHeight\n设置最大高度\nandroid:maxWidth\n设置最大宽度\nandroid:scaleType\n缩放类型，取值为下列之一：\nmatrix图片真实大小\nfitXY适合图片大小\nfitStart\nfitCenter\nfitEnd\ncenter居中显示\ncenterCrop\ncenterInside\nandroid:src\n设置绘制用内容\nandroid:tint\n设置染色颜色值\nandroid:layout_above=\"@id/xxx\" \n将控件置于给定ID控件之上 \nandroid:layout_below=\"@id/xxx\"\n将控件置于给定ID控件之下\nandroid:layout_toLeftOf=\"@id/xxx\" \n将控件的右边缘和给定ID控件的左边缘对齐 \nandroid:layout_toRightOf=\"@id/xxx\" \n将控件的左边缘和给定ID控件的右边缘对齐\nandroid:layout_alignLeft=\"@id/xxx\" \n将控件的左边缘和给定ID控件的左边缘对齐\nandroid:layout_alignTop=\"@id/xxx\" \n将控件的上边缘和给定ID控件的上边缘对齐\n \nandroid:layout_alignRight=\"@id/xxx\"\n将控件的右边缘和给定ID控件的右边缘对齐\nandroid:layout_alignBottom=\"@id/xxx\" \n将控件的底边缘和给定ID控件的底边缘对齐 \nandroid:layout_alignParentLeft=\"true\" \n将控件的左边缘和父控件的左边缘对齐 \nandroid:layout_alignParentTop=\"true\" \n将控件的上边缘和父控件的上边缘对齐 \nandroid:layout_alignParentRight=\"true\" \n将控件的右边缘和父控件的右边缘对齐 \nandroid:layout_alignParentBottom=\"true\" \n将控件的底边缘和父控件的底边缘对齐\n android:layout_centerInParent=\"true\" \n 将控件置于父控件的中心位置 \n \n android:layout_centerHorizontal=\"true\" \n 将控件置于水平方向的中心位置 \n \n android:layout_centerVertical=\"true\" \n 将控件置于垂直方向的中心位置\n ```\n","slug":"2017-04-03-properties-of-view","published":1,"updated":"2017-07-23T11:23:12.376Z","_id":"cj5gmdnhz001fbovriuud50uy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转自<a href=\"http://www.codexiu.cn/android/blog/40141/\">Android属性大全</a></p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div><div class=\"line\">663</div><div class=\"line\">664</div><div class=\"line\">665</div><div class=\"line\">666</div><div class=\"line\">667</div><div class=\"line\">668</div><div class=\"line\">669</div><div class=\"line\">670</div><div class=\"line\">671</div><div class=\"line\">672</div><div class=\"line\">673</div><div class=\"line\">674</div><div class=\"line\">675</div><div class=\"line\">676</div><div class=\"line\">677</div><div class=\"line\">678</div><div class=\"line\">679</div><div class=\"line\">680</div><div class=\"line\">681</div><div class=\"line\">682</div><div class=\"line\">683</div><div class=\"line\">684</div><div class=\"line\">685</div><div class=\"line\">686</div><div class=\"line\">687</div><div class=\"line\">688</div><div class=\"line\">689</div><div class=\"line\">690</div><div class=\"line\">691</div><div class=\"line\">692</div><div class=\"line\">693</div><div class=\"line\">694</div><div class=\"line\">695</div><div class=\"line\">696</div><div class=\"line\">697</div><div class=\"line\">698</div><div class=\"line\">699</div><div class=\"line\">700</div><div class=\"line\">701</div><div class=\"line\">702</div><div class=\"line\">703</div><div class=\"line\">704</div><div class=\"line\">705</div><div class=\"line\">706</div><div class=\"line\">707</div><div class=\"line\">708</div><div class=\"line\">709</div><div class=\"line\">710</div><div class=\"line\">711</div><div class=\"line\">712</div><div class=\"line\">713</div><div class=\"line\">714</div><div class=\"line\">715</div><div class=\"line\">716</div><div class=\"line\">717</div><div class=\"line\">718</div><div class=\"line\">719</div><div class=\"line\">720</div><div class=\"line\">721</div><div class=\"line\">722</div><div class=\"line\">723</div><div class=\"line\">724</div><div class=\"line\">725</div><div class=\"line\">726</div><div class=\"line\">727</div><div class=\"line\">728</div><div class=\"line\">729</div><div class=\"line\">730</div><div class=\"line\">731</div><div class=\"line\">732</div><div class=\"line\">733</div><div class=\"line\">734</div><div class=\"line\">735</div><div class=\"line\">736</div><div class=\"line\">737</div><div class=\"line\">738</div><div class=\"line\">739</div><div class=\"line\">740</div><div class=\"line\">741</div><div class=\"line\">742</div><div class=\"line\">743</div><div class=\"line\">744</div><div class=\"line\">745</div><div class=\"line\">746</div><div class=\"line\">747</div><div class=\"line\">748</div><div class=\"line\">749</div><div class=\"line\">750</div><div class=\"line\">751</div><div class=\"line\">752</div><div class=\"line\">753</div><div class=\"line\">754</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:<span class=\"function\">alpha </div><div class=\"line\"><span class=\"title\">setAlpha</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。</div><div class=\"line\">android:background </div><div class=\"line\"><span class=\"title\">setBackgroundResource</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 视图背景</div><div class=\"line\">android:clickable </div><div class=\"line\"><span class=\"title\">setClickable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 视图是否可点击</div><div class=\"line\">android:contentDescription </div><div class=\"line\"><span class=\"title\">setContentDescription</span><span class=\"params\">(CharSequence)</span> 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明</div><div class=\"line\">android:drawingCacheQuality </div><div class=\"line\"><span class=\"title\">setDrawingCacheQuality</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: \"设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存\"</div><div class=\"line\">android:duplicateParentState </div><div class=\"line\">属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）</div><div class=\"line\">android:fadeScrollbars </div><div class=\"line\"><span class=\"title\">setScrollbarFadingEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 定义在ScrollBar没有使用时，是否褪色。</div><div class=\"line\">android:fadingEdgeLength </div><div class=\"line\"><span class=\"title\">getVerticalFadingEdgeLength</span><span class=\"params\">()</span> 属性说明: 设置边框渐变的长度。</div><div class=\"line\">android:filterTouchesWhenObscured </div><div class=\"line\"><span class=\"title\">setFilterTouchesWhenObscured</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。</div><div class=\"line\">android:fitsSystemWindows </div><div class=\"line\"><span class=\"title\">setFitsSystemWindows</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）</div><div class=\"line\">android:focusable </div><div class=\"line\"><span class=\"title\">setFocusable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置是否获得焦点。若有<span class=\"title\">requestFocus</span><span class=\"params\">()</span>被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为<span class=\"keyword\">false</span>才行。在Touch模式下获取焦点需要设置focusableInTouchMode为<span class=\"keyword\">true</span>。</div><div class=\"line\">android:focusableInTouchMode </div><div class=\"line\"><span class=\"title\">setFocusableInTouchMode</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置在Touch模式下View是否能取得焦点。</div><div class=\"line\">android:hapticFeedbackEnabled </div><div class=\"line\"><span class=\"title\">setHapticFeedbackEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果</div><div class=\"line\">android:id </div><div class=\"line\"><span class=\"title\">setId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用View.<span class=\"title\">findViewById</span><span class=\"params\">()</span> 或Activity.<span class=\"title\">findViewById</span><span class=\"params\">()</span>根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。</div><div class=\"line\">android:importantForAccessibility </div><div class=\"line\"><span class=\"title\">setImportantForAccessibility</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置可达性的重要性</div><div class=\"line\">android:isScrollContainer </div><div class=\"line\"><span class=\"title\">setScrollContainer</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条</div><div class=\"line\">android:keepScreenOn </div><div class=\"line\"><span class=\"title\">setKeepScreenOn</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 视图在可见的情况下是否保持唤醒状态。</div><div class=\"line\">android:layerType </div><div class=\"line\"><span class=\"title\">setLayerType</span><span class=\"params\">(<span class=\"keyword\">int</span>,Paint)</span> 属性说明: \"设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。\"</div><div class=\"line\">android:layoutDirection </div><div class=\"line\"><span class=\"title\">setLayoutDirection</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 定义布局图纸的方向</div><div class=\"line\">android:longClickable </div><div class=\"line\"><span class=\"title\">setLongClickable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 是否响应长点击事件</div><div class=\"line\">android:minHeight </div><div class=\"line\"><span class=\"title\">setMinimumHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置视图最小高度</div><div class=\"line\">android:minWidth </div><div class=\"line\"><span class=\"title\">setMinimumWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置视图最小宽度</div><div class=\"line\">android:nextFocusDown </div><div class=\"line\"><span class=\"title\">setNextFocusDownId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向下移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusForward </div><div class=\"line\"><span class=\"title\">setNextFocusForwardId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusLeft </div><div class=\"line\"><span class=\"title\">setNextFocusLeftId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向左移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusRight </div><div class=\"line\"><span class=\"title\">setNextFocusRightId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向右移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusUp </div><div class=\"line\"><span class=\"title\">setNextFocusUpId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向上移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:onClick </div><div class=\"line\"><span class=\"title\">setOnClick</span><span class=\"params\">()</span>或 <span class=\"title\">onClick</span><span class=\"params\">(View view)</span>属性说明: 点击时，要调用的方法的名称。</div><div class=\"line\">android:padding </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置上下左右的边距</div><div class=\"line\">android:paddingBottom </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 下边距</div><div class=\"line\">android:paddingEnd </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 与android:paddingRight相同</div><div class=\"line\">android:paddingLeft </div><div class=\"line\"><span class=\"title\">setPadding</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 左边距</div><div class=\"line\">android:paddingRight </div><div class=\"line\"><span class=\"title\">setPadding</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 右边距</div><div class=\"line\">android:paddingStart </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: android:paddingLeft相同</div><div class=\"line\">android:paddingTop </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 上边距</div><div class=\"line\">android:requiresFadingEdge </div><div class=\"line\"><span class=\"title\">setVerticalFadingEdgeEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 定义滚动时边缘是否褪色</div><div class=\"line\">android:rotation </div><div class=\"line\"><span class=\"title\">setRotation</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 旋转度数</div><div class=\"line\">android:rotationX </div><div class=\"line\"><span class=\"title\">setRotationX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平旋转度数</div><div class=\"line\">android:rotationY </div><div class=\"line\"><span class=\"title\">setRotationY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直旋转度数</div><div class=\"line\">android:saveEnabled </div><div class=\"line\"><span class=\"title\">setSaveEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。</div><div class=\"line\">android:scaleX </div><div class=\"line\"><span class=\"title\">setScaleX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平方向缩放比例</div><div class=\"line\">android:scaleY </div><div class=\"line\"><span class=\"title\">setScaleY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直方向缩放比例</div><div class=\"line\">android:scrollX </div><div class=\"line\">属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离</div><div class=\"line\">android:scrollY </div><div class=\"line\">属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离</div><div class=\"line\">android:scrollbarAlwaysDrawHorizontalTrack </div><div class=\"line\">属性说明: 是否总是绘制水平滚动条的滚动轨道</div><div class=\"line\">android:scrollbarAlwaysDrawVerticalTrack </div><div class=\"line\">属性说明: 是否总是绘制竖直滚动条的滚动轨道</div><div class=\"line\">android:scrollbarDefaultDelayBeforeFade </div><div class=\"line\"><span class=\"title\">setScrollBarDefaultDelayBeforeFade</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 滚动条在n毫秒后开始淡出。</div><div class=\"line\">android:scrollbarFadeDuration </div><div class=\"line\"><span class=\"title\">setScrollBarFadeDuration</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 滚动条用多长时间淡出完毕。</div><div class=\"line\">android:scrollbarSize </div><div class=\"line\"><span class=\"title\">setScrollBarSize</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度</div><div class=\"line\">android:scrollbarStyle </div><div class=\"line\"><span class=\"title\">setScrollBarStyle</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: \"滚动条的风格。共4组值： insideOverlay——内贴图 insideInset——内插图 outsideOverlay——外贴图 outsideInset——外插图。 inside就是滚动条在绘制在padding以内；outside就是不需要绘制在padding内（即view的边界处）；Overlay是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；Inset是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。\"</div><div class=\"line\">android:scrollbarThumbHorizontal </div><div class=\"line\">属性说明: 水平滚动块的drawable对象</div><div class=\"line\">android:scrollbarThumbVertical </div><div class=\"line\">属性说明: 竖直滚动块的drawable对象</div><div class=\"line\">android:scrollbarTrackHorizontal </div><div class=\"line\">属性说明: 水平滚动条滚动轨道的drawable对象</div><div class=\"line\">android:scrollbarTrackVertical </div><div class=\"line\">属性说明: 竖直滚动条滚动轨道的drawable对象</div><div class=\"line\">android:scrollbars </div><div class=\"line\">属性说明: \"设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条\"</div><div class=\"line\">android:soundEffectsEnabled </div><div class=\"line\"><span class=\"title\">setSoundEffectsEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 点击或触摸该view时，是否需要有声音效果</div><div class=\"line\">android:tag </div><div class=\"line\">属性说明: string标识。类似id，id是整数标识。</div><div class=\"line\">android:textAlignment </div><div class=\"line\"><span class=\"title\">setTextAlignment</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的显示方式。</div><div class=\"line\">android:textDirection </div><div class=\"line\"><span class=\"title\">setTextDirection</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的显示方向。</div><div class=\"line\">android:transformPivotX </div><div class=\"line\"><span class=\"title\">setPivotX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平方向偏转量</div><div class=\"line\">android:transformPivotY </div><div class=\"line\"><span class=\"title\">setPivotY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直方向偏转量</div><div class=\"line\">android:translationX </div><div class=\"line\"><span class=\"title\">setTranslationX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平方向的移动距离</div><div class=\"line\">android:translationY </div><div class=\"line\"><span class=\"title\">setTranslationY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直方向的移动距离</div><div class=\"line\">android:visibility </div><div class=\"line\"><span class=\"title\">setVisibility</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: \"view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见\"</div><div class=\"line\">TextView属性说明</div><div class=\"line\">下面对TextView的属性进行说明 android:autoLink </div><div class=\"line\"><span class=\"title\">setAutoLinkMask</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值<span class=\"params\">(none/web/email/phone/map/all)</span></div><div class=\"line\">android:autoText </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</div><div class=\"line\">android:bufferType </div><div class=\"line\"><span class=\"title\">setText</span><span class=\"params\">(CharSequence,TextView.BufferType)</span> 属性说明: 指定<span class=\"title\">getText</span><span class=\"params\">()</span>方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。</div><div class=\"line\">android:capitalize </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。</div><div class=\"line\">android:cursorVisible </div><div class=\"line\"><span class=\"title\">setCursorVisible</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设定光标为显示/隐藏，默认显示。</div><div class=\"line\">android:digits </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\\<span class=\"title\">n</span><span class=\"params\">()</span>”</div><div class=\"line\">android:drawableBottom </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。</div><div class=\"line\">android:drawableEnd </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesRelativeWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][<span class=\"keyword\">package</span>:]type:name\"或者\"?[<span class=\"keyword\">package</span>:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。</div><div class=\"line\">android:drawableLeft </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的左边输出一个drawable。</div><div class=\"line\">android:drawablePadding </div><div class=\"line\"><span class=\"title\">setCompoundDrawablePadding</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。</div><div class=\"line\">android:drawableRight </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的右边输出一个drawable。</div><div class=\"line\">android:drawableStart </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesRelativeWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][<span class=\"keyword\">package</span>:]type:name\"或者\"?[<span class=\"keyword\">package</span>:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。</div><div class=\"line\">android:drawableTop </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的正上方输出一个drawable。</div><div class=\"line\">android:editable </div><div class=\"line\">属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。</div><div class=\"line\">android:editorExtras </div><div class=\"line\"><span class=\"title\">setInputExtras</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的额外的输入数据。在EditView中才有效果。</div><div class=\"line\">android:ellipsize </div><div class=\"line\"><span class=\"title\">setEllipsize</span><span class=\"params\">(TextUtils.TruncateAt)</span> 属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示<span class=\"params\">(动画横向移动)</span></div><div class=\"line\">android:ems </div><div class=\"line\"><span class=\"title\">setEms</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置TextView的宽度为N个字符的宽度。</div><div class=\"line\">android:fontFamily </div><div class=\"line\"><span class=\"title\">setTypeface</span><span class=\"params\">(Typeface)</span> 属性说明: 文本的字形体系。</div><div class=\"line\">android:freezesText </div><div class=\"line\"><span class=\"title\">setFreezesText</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置保存文本的内容以及光标的位置。</div><div class=\"line\">android:gravity </div><div class=\"line\"><span class=\"title\">setGravity</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本位置，如设置成“center”，文本将居中显示。</div><div class=\"line\">android:height </div><div class=\"line\"><span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的高度，支持度量单位：<span class=\"title\">px</span><span class=\"params\">(像素)</span>/dp/sp/in/<span class=\"title\">mm</span><span class=\"params\">(毫米)</span></div><div class=\"line\">android:hint </div><div class=\"line\"><span class=\"title\">setHint</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。</div><div class=\"line\">android:imeActionId </div><div class=\"line\"><span class=\"title\">setImeActionLabel</span><span class=\"params\">(CharSequence,<span class=\"keyword\">int</span>)</span> 属性说明: 设置IME动作ID。</div><div class=\"line\">android:imeActionLabel </div><div class=\"line\"><span class=\"title\">setImeActionLabel</span><span class=\"params\">(CharSequence,<span class=\"keyword\">int</span>)</span> 属性说明: 设置IME动作标签。在EditView再做说明。</div><div class=\"line\">android:imeOptions </div><div class=\"line\"><span class=\"title\">setImeOptions</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。</div><div class=\"line\">android:includeFontPadding </div><div class=\"line\"><span class=\"title\">setIncludeFontPadding</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置文本是否包含顶部和底部额外空白，默认为<span class=\"keyword\">true</span>。</div><div class=\"line\">android:inputMethod </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。</div><div class=\"line\">android:inputType </div><div class=\"line\"><span class=\"title\">setRawInputType</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。</div><div class=\"line\">android:lineSpacingExtra </div><div class=\"line\"><span class=\"title\">setLineSpacing</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>)</span> 属性说明: 设置行间距。</div><div class=\"line\">android:lineSpacingMultiplier </div><div class=\"line\"><span class=\"title\">setLineSpacing</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>)</span> 属性说明: 设置行间距的倍数。如”1.2”</div><div class=\"line\">android:lines </div><div class=\"line\"><span class=\"title\">setLines</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。</div><div class=\"line\">android:linksClickable </div><div class=\"line\"><span class=\"title\">setLinksClickable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置链接是否点击连接，即使设置了autoLink。</div><div class=\"line\">android:marqueeRepeatLimit </div><div class=\"line\"><span class=\"title\">setMarqueeRepeatLimit</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。</div><div class=\"line\">android:maxEms </div><div class=\"line\"><span class=\"title\">setMaxEms</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。</div><div class=\"line\">android:maxHeight </div><div class=\"line\"><span class=\"title\">setMaxHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最大高度</div><div class=\"line\">android:maxLength </div><div class=\"line\"><span class=\"title\">setFilters</span><span class=\"params\">(InputFilter)</span> 属性说明: 限制显示的文本长度，超出部分不显示。</div><div class=\"line\">android:maxLines </div><div class=\"line\"><span class=\"title\">setMaxLines</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</div><div class=\"line\">android:maxWidth </div><div class=\"line\"><span class=\"title\">setMaxWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最大宽度</div><div class=\"line\">android:minEms </div><div class=\"line\"><span class=\"title\">setMinEms</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。</div><div class=\"line\">android:minHeight </div><div class=\"line\"><span class=\"title\">setMinHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最小高度</div><div class=\"line\">android:minLines </div><div class=\"line\"><span class=\"title\">setMinLines</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的最小行数，与lines类似。</div><div class=\"line\">android:minWidth </div><div class=\"line\"><span class=\"title\">setMinWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最小宽度</div><div class=\"line\">android:numeric </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。</div><div class=\"line\">android:password </div><div class=\"line\"><span class=\"title\">setTransformationMethod</span><span class=\"params\">(TransformationMethod)</span> 属性说明: 以小点”.”显示文本</div><div class=\"line\">android:phoneNumber </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 设置为电话号码的输入方式。</div><div class=\"line\">android:privateImeOptions </div><div class=\"line\"><span class=\"title\">setPrivateImeOptions</span><span class=\"params\">(String)</span> 属性说明: 设置输入法选项，在EditText中才有作用。</div><div class=\"line\">android:scrollHorizontally </div><div class=\"line\"><span class=\"title\">setHorizontallyScrolling</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。</div><div class=\"line\">android:selectAllOnFocus </div><div class=\"line\"><span class=\"title\">setSelectAllOnFocus</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</div><div class=\"line\">android:shadowColor </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。</div><div class=\"line\">android:shadowDx </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置阴影横向坐标开始位置。</div><div class=\"line\">android:shadowDy </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置阴影纵向坐标开始位置。</div><div class=\"line\">android:shadowRadius </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。</div><div class=\"line\">android:singleLine </div><div class=\"line\"><span class=\"title\">setTransformationMethod</span><span class=\"params\">(TransformationMethod)</span> 属性说明: 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text</span>=<span class=\"string\">\"test_ singleLine \"</span> android:singleLine=<span class=\"string\">\"true\"</span> android:layout_width=<span class=\"string\">\"20dp\"</span>将只显示“t…”。如果不设置singleLine或者设置为<span class=\"keyword\">false</span>，文本将自动换行</div><div class=\"line\">android:<span class=\"function\">text </div><div class=\"line\"><span class=\"title\">setText</span><span class=\"params\">(CharSequence,TextView.BufferType)</span> 属性说明: 设置显示文本.</div><div class=\"line\">android:textAllCaps </div><div class=\"line\"><span class=\"title\">setAllCaps</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置文本全为大写。值为\"<span class=\"keyword\">true</span>\"或\"<span class=\"keyword\">false</span>\"。</div><div class=\"line\">android:textAppearance </div><div class=\"line\">属性说明: 设置文字外观。如“?android:attr/textAppearanceLargeInverse</div><div class=\"line\">android:textColor </div><div class=\"line\"><span class=\"title\">setTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本颜色</div><div class=\"line\">android:textColorHighlight </div><div class=\"line\"><span class=\"title\">setHighlightColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 被选中文字的底色，默认为蓝色</div><div class=\"line\">android:textColorHint </div><div class=\"line\"><span class=\"title\">setHintTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。</div><div class=\"line\">android:textColorLink </div><div class=\"line\"><span class=\"title\">setLinkTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 文字链接的颜色.</div><div class=\"line\">android:textIsSelectable </div><div class=\"line\"><span class=\"title\">isTextSelectable</span><span class=\"params\">()</span> 属性说明: 设置非编辑文本可否被选择。值为\"<span class=\"keyword\">true</span>\"或\"<span class=\"keyword\">false</span>\"。</div><div class=\"line\">android:textScaleX </div><div class=\"line\"><span class=\"title\">setTextScaleX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 设置文字之间间隔，默认为1.0f。</div><div class=\"line\">android:textSize </div><div class=\"line\"><span class=\"title\">setTextSize</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">float</span>)</span> 属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”</div><div class=\"line\">android:textStyle </div><div class=\"line\"><span class=\"title\">setTypeface</span><span class=\"params\">(Typeface)</span> 属性说明: 设置字形[<span class=\"title\">bold</span><span class=\"params\">(粗体)</span> 0, <span class=\"title\">italic</span><span class=\"params\">(斜体)</span> 1, <span class=\"title\">bolditalic</span><span class=\"params\">(又粗又斜)</span> 2] 可以设置一个或多个，用“|”隔开</div><div class=\"line\">android:typeface </div><div class=\"line\"><span class=\"title\">setTypeface</span><span class=\"params\">(Typeface)</span> 属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, <span class=\"title\">monospace</span><span class=\"params\">(等宽字体)</span> 3]</div><div class=\"line\">android:width </div><div class=\"line\"><span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的宽度，支持度量单位：<span class=\"title\">px</span><span class=\"params\">(像素)</span>/dp/sp/in/<span class=\"title\">mm</span><span class=\"params\">(毫米)</span>。</div><div class=\"line\">android:fadingEdgeLength</div><div class=\"line\">设置淡入淡出边缘的长度，可以接受大小值的单位是：px、dp、sp、in、mm，也可以参考大小值资源</div><div class=\"line\">android:fitsSystemWindows</div><div class=\"line\">是否适合系统窗体，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span>。该属性只对不是子组件的组件有效</div><div class=\"line\">android:focusable</div><div class=\"line\">是否可以获取焦点，取值<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:focusableInTouchMode</div><div class=\"line\">是否可以在触摸模式下获取焦点，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:hapticFeedbackEnabled</div><div class=\"line\">是否允许触摸反馈效果，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:id</div><div class=\"line\">提供该组件的标识名，可以借助Activity或View实例的findViewById方法通过id获取对应的组件实例对象，其属性值的形式为：android:id</span>=”@+id/id”</div><div class=\"line\">android:isScrollContainer</div><div class=\"line\">设置该组件是否设置为滚动条容器，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:keepScreenOn</div><div class=\"line\">控制该组件在显示的时候保持在屏幕显示，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:longClickable</div><div class=\"line\">是否响应长时间点击事件，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:minHeight</div><div class=\"line\">组件的最小高度，取值同android:fadingEdgeLength</div><div class=\"line\">android:minWidth</div><div class=\"line\">组件的最小宽度，取值同android:fadingEdgeLength</div><div class=\"line\">android:nextFocusDown</div><div class=\"line\">设置下一个向下获取焦点的组件，取值为id</div><div class=\"line\">android:nextFocusLeft</div><div class=\"line\">设置下一个向左获取焦点的组件，取值为id</div><div class=\"line\">android:nextFocusRight</div><div class=\"line\">设置下一个向右获取焦点的组件，取值为id</div><div class=\"line\">android:nextFocusUp</div><div class=\"line\">设置下一个向上获取焦点的组件，取值为id</div><div class=\"line\">android:padding</div><div class=\"line\">设置上、下、左、右<span class=\"number\">4</span>个边缘的填充距离，必须是一个大小值，取值同android:fadingEdgeLength</div><div class=\"line\">android:paddingBottom</div><div class=\"line\">设置下端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:paddingLeft</div><div class=\"line\">设置左端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:paddingRight</div><div class=\"line\">设置右端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:paddingTop</div><div class=\"line\">设置上端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:saveEnabled</div><div class=\"line\">是否允许保存状态，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:scrollX</div><div class=\"line\">设置垂直滚动条的位移量，必须是一个大小值，取值同android:padding</div><div class=\"line\">android:scrollY</div><div class=\"line\">设置水平滚动条的位移量，必须是一个大小值，取值同android:padding</div><div class=\"line\">android:scrollbarAlwaysDrawHorizontalTrack</div><div class=\"line\">是否总是设置水平滚动条滑块，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:scrollbarAlwaysDrawVerticalTrack</div><div class=\"line\">是否总是设置垂直滚动条滑块，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:scrollbarSize</div><div class=\"line\">设置垂直滚动条的宽度和水平滚动条的长度，必须是一个大小值，取值同android:padding</div><div class=\"line\">android:scrollbarStyle</div><div class=\"line\">设置滚动条的样式，取值为下列之一：</div><div class=\"line\">insideOverlay在填充区域内，覆盖形式</div><div class=\"line\">insideInset在填充区域内，插进形式（凹进）</div><div class=\"line\">outsideOverly在绑定组件边缘，覆盖形式</div><div class=\"line\">outsideInset在绑定组件边缘，插进形似</div><div class=\"line\">android:scrollbarThumbHorizontal</div><div class=\"line\">设置水平滚动条按钮的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbarThumbVertical</div><div class=\"line\">设置垂直滚动条按钮的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbarTrackHorizontal</div><div class=\"line\">设置水平滚动条轨道的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbarTrackVertical</div><div class=\"line\">设置水平滚动条轨道的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbars</div><div class=\"line\">设置滚动显示，可以为一下一个或多个值：</div><div class=\"line\">none不显示滚动条</div><div class=\"line\">horizontal只显示水平滚动条</div><div class=\"line\">vertical只显示垂直滚动条</div><div class=\"line\">android:soundEffectsEnabled</div><div class=\"line\">是否允许音效，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:tag</div><div class=\"line\">设置标记内容，可以通过View类实例的getTag方法获取该组件的标记内容，或者使用findViewByTag通过标记来查找相应的子组件</div><div class=\"line\">android:visibility</div><div class=\"line\">设置初始化可见状态，取值为以下之一：</div><div class=\"line\">visible可见（默认值）</div><div class=\"line\">invisible不可见（其所占空间将留出）</div><div class=\"line\">gone完全不可见（其所占空间都不会留出）</div><div class=\"line\">线性布局LinearLayout组件属性列表</div><div class=\"line\">属性说明</div><div class=\"line\">android:baselineAligned</div><div class=\"line\">基线对齐</div><div class=\"line\">android:baselineAlignedChildIndex</div><div class=\"line\">以指定子组件作为基线对齐</div><div class=\"line\">android:gravity</div><div class=\"line\">指定该物体放入其容器的重心位置，取值为下列之一：</div><div class=\"line\">top上方，物体大小不变</div><div class=\"line\">bottom下方，物体大小不变</div><div class=\"line\">left左方，物体大小不变</div><div class=\"line\">right右方，物体大小不变</div><div class=\"line\">center_vertical垂直方向的中间，物体大小不变</div><div class=\"line\">fill_vertical填满垂直方向，自动进行大小调整</div><div class=\"line\">center_horizontal水平方向的中间，大小不变</div><div class=\"line\">fill_horizontal填满水平方向，自动进行大小调整</div><div class=\"line\">center居中（既是水平也是垂直方向的中间）</div><div class=\"line\">fill填满整个容器</div><div class=\"line\">clip_vertical</div><div class=\"line\">clip_horizontal</div><div class=\"line\">android:orientation</div><div class=\"line\">布局方向，取值为下列之一：</div><div class=\"line\">horizontal水平的</div><div class=\"line\">vertical垂直的（默认值）</div><div class=\"line\">android:weightSum</div><div class=\"line\">组件的比重和</div><div class=\"line\"></div><div class=\"line\">LinearLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_gravity</div><div class=\"line\">当前子组件的心位置</div><div class=\"line\">android:layout_height</div><div class=\"line\">当前子组件的高度</div><div class=\"line\">android:layout_weight</div><div class=\"line\">当前子组件的空间比重，取值为浮点数</div><div class=\"line\">android:layout_width</div><div class=\"line\">当前子组件的宽度</div><div class=\"line\"></div><div class=\"line\">RalativeLayout属性说明</div><div class=\"line\"></div><div class=\"line\">android:gravity</div><div class=\"line\">设置添加组件的重心</div><div class=\"line\">android:ignoreGravity</div><div class=\"line\">忽略布局重心的影响</div><div class=\"line\"></div><div class=\"line\">RalativeLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_above</div><div class=\"line\">将当前组件的下边缘放置于参照组件之上，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignBaseline</div><div class=\"line\">当前组件与参照组件的基线对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignBottom</div><div class=\"line\">当前组件与参照组件的下边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignLeft</div><div class=\"line\">当前组件与参照组件的左边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignParenBottom</div><div class=\"line\">当前组件与父组件的下边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignParentLeft</div><div class=\"line\">当前组件与父组件的左边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignParentRight</div><div class=\"line\">当前组件与父组件的右边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignParentTop</div><div class=\"line\">当前组件与父组件的上边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignRight</div><div class=\"line\">当前组件与参照组件的右边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignTop</div><div class=\"line\">当前组件与参照组件的上边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignWithParentIfMissing</div><div class=\"line\">如果对应的兄弟元素找不到的话就以父元素做参照物 <span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_below</div><div class=\"line\">将当前组件的上边缘放置于参照组件之下，该属性为参照组件的ID</div><div class=\"line\">android:layout_centerHorizontal</div><div class=\"line\">当前组件放置到父组件的水平居中的位置</div><div class=\"line\">android:layout_centerInParent</div><div class=\"line\">当前组件放置到父组件的重心位置</div><div class=\"line\">android:layout_centerVertical</div><div class=\"line\">当前组件放置到父组件垂直居中的位置</div><div class=\"line\">android:layout_toLeftOf</div><div class=\"line\">将当前组件的右边缘放置于参照组件之下，该属性为参照组件的ID</div><div class=\"line\">android:layout_toRightOf</div><div class=\"line\">将当前组件的左边缘放置于参照组件之下，该属性为参照组件的ID</div><div class=\"line\"></div><div class=\"line\">AbsoluteLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_x</div><div class=\"line\">当前组件的x坐标位置（从左到右方向）</div><div class=\"line\">android:layout_y</div><div class=\"line\">当前组件的y坐标位置（从上到下方向）</div><div class=\"line\"></div><div class=\"line\">FrameLayout属性说明</div><div class=\"line\"></div><div class=\"line\">android:foreground</div><div class=\"line\">前置图片</div><div class=\"line\">android:foregroundGravity</div><div class=\"line\">前置图片重心</div><div class=\"line\">android:measureAllChildren</div><div class=\"line\">在切换显示时是否侧重所有子组件的大小</div><div class=\"line\">android:layout_gravity</div><div class=\"line\">添加组件的重心</div><div class=\"line\"></div><div class=\"line\">FrameLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_gravity</div><div class=\"line\">当前子组件所添加的重心位置</div><div class=\"line\"></div><div class=\"line\">TableLayout属性说明</div><div class=\"line\"></div><div class=\"line\">android:collapseColumns</div><div class=\"line\">设置允许折叠的列编号，列编号基于<span class=\"number\">0</span>，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</div><div class=\"line\">android:shrinkColumns</div><div class=\"line\">设置允许收缩的列编号，列编号基于<span class=\"number\">0</span>，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</div><div class=\"line\">android:stretchColumns</div><div class=\"line\">设置允许伸展的列编号，列编号基于<span class=\"number\">0</span>，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</div><div class=\"line\">TableRow_Cell属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_column</div><div class=\"line\">设置该单元格的列编号（基于<span class=\"number\">0</span>）</div><div class=\"line\">android:layout_span</div><div class=\"line\">指明该单元格可以跨越的列数</div><div class=\"line\"></div><div class=\"line\">AbsListView属性说明</div><div class=\"line\"></div><div class=\"line\">android:cacheColorHint</div><div class=\"line\">设置缓冲颜色</div><div class=\"line\">android:drawSelectorOnTop</div><div class=\"line\">是否将选择器绘制在备选条目上方，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:fastScrollEnabled</div><div class=\"line\">允许快速滚动</div><div class=\"line\">android:listSelector</div><div class=\"line\">指示选择器的内容</div><div class=\"line\">android:scrollingCache</div><div class=\"line\">滚动时是否使用绘制缓冲，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:smoothScrollbar</div><div class=\"line\">平滑滚动条</div><div class=\"line\">android:stackFromBottom</div><div class=\"line\">从下方堆叠条目</div><div class=\"line\">android:textFilterEnbled</div><div class=\"line\">是否允许过滤</div><div class=\"line\">android:transcriptMode设置抄本模式</div><div class=\"line\"></div><div class=\"line\">ListView属性说明</div><div class=\"line\"></div><div class=\"line\">android:choiceMode</div><div class=\"line\">选择模式</div><div class=\"line\">android:divider</div><div class=\"line\">分割线颜色或组件的参考</div><div class=\"line\">android:dividerHeight</div><div class=\"line\">分割线高度</div><div class=\"line\">android:entries</div><div class=\"line\">指定绑定到当前列表视图的一个数组资源</div><div class=\"line\">android:footerDividersEnabled</div><div class=\"line\">是否允许页脚分割线</div><div class=\"line\">android:headerDividersEnabled</div><div class=\"line\">是否允许页眉分割线</div><div class=\"line\"></div><div class=\"line\">GridView属性说明</div><div class=\"line\"></div><div class=\"line\">android:columnWidth</div><div class=\"line\">指定列宽</div><div class=\"line\">android:gravity</div><div class=\"line\">添加组件的重心位置</div><div class=\"line\">android:horizontalSpacing</div><div class=\"line\">水平空间</div><div class=\"line\">android:numColumns</div><div class=\"line\">指定列数</div><div class=\"line\">android:strechMode</div><div class=\"line\">伸展模式</div><div class=\"line\">android:verticalSpacing</div><div class=\"line\">垂直空间</div><div class=\"line\"></div><div class=\"line\">Gallery属性说明</div><div class=\"line\"></div><div class=\"line\">android:animationDuration</div><div class=\"line\">动画持续时间</div><div class=\"line\">android:gravity</div><div class=\"line\">添加组件的重心位置</div><div class=\"line\">android:spacing</div><div class=\"line\">间隔空间</div><div class=\"line\">android:unselectedAlpha</div><div class=\"line\">非选择条目的透明度</div><div class=\"line\"></div><div class=\"line\">TextView属性说明</div><div class=\"line\"></div><div class=\"line\">android:autoLink</div><div class=\"line\">是否自动链接（内容是网址或是电子邮件时）</div><div class=\"line\">android:autoText</div><div class=\"line\">自动更新拼音错误</div><div class=\"line\">android:bufferType</div><div class=\"line\">设置缓冲区类型</div><div class=\"line\">android:capitalize</div><div class=\"line\">自动大写</div><div class=\"line\">android:cursorVisible</div><div class=\"line\">光标是否可见，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:digits</div><div class=\"line\">所接受的数字字符</div><div class=\"line\">android:drawableBottom</div><div class=\"line\">在文本下方绘制</div><div class=\"line\">android:drawableLeft</div><div class=\"line\">在文本左方绘制</div><div class=\"line\">android: drawablePadding</div><div class=\"line\">绘制填充区</div><div class=\"line\">android: drawableRight</div><div class=\"line\">在文本右方绘制</div><div class=\"line\">android: drawableTop</div><div class=\"line\">在文本上方绘制</div><div class=\"line\">android:editable</div><div class=\"line\">是否可编辑，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:editorExtras</div><div class=\"line\">设置文本的额外的输入数据。在EditView中才有效果</div><div class=\"line\">android:ellipsize</div><div class=\"line\">当内容过长时会自动打断单词内容</div><div class=\"line\">android:ems</div><div class=\"line\">设置TextView的宽度为N个字符的宽度</div><div class=\"line\">android:enabled</div><div class=\"line\">是否可用，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:freezesText</div><div class=\"line\">是否冻结文本</div><div class=\"line\">android:gravity</div><div class=\"line\">指明文本的重心位置</div><div class=\"line\">android:height</div><div class=\"line\">高度值</div><div class=\"line\">android:hint</div><div class=\"line\">指示内容</div><div class=\"line\">android:imeActionId</div><div class=\"line\">设置IME动作ID</div><div class=\"line\">android:imeActionLabel</div><div class=\"line\">设置IME动作标签</div><div class=\"line\">android:imeOptions</div><div class=\"line\">输入法选项</div><div class=\"line\">android:includeFontPadding</div><div class=\"line\">设置文本是否包含顶部和底部额外空白，默认为<span class=\"keyword\">true</span></div><div class=\"line\">android:inputMethod</div><div class=\"line\">指定输入法</div><div class=\"line\">android:inputType</div><div class=\"line\">输入类型，取值为下列之一：</div><div class=\"line\">none</div><div class=\"line\">text普通文本</div><div class=\"line\">textCapCharacters大写字符</div><div class=\"line\">textCapWords单词首字母大写</div><div class=\"line\">textCapSentences句子首字母大写</div><div class=\"line\">textAutoCorret自动更正</div><div class=\"line\">textAutoComplete自动完成</div><div class=\"line\">textMultiLine多行内容</div><div class=\"line\">textUri，Uri</div><div class=\"line\">textEmailAddress电子邮件地址</div><div class=\"line\">textEmailSubject电子邮件主题</div><div class=\"line\">textShortMessage短消息</div><div class=\"line\">textLongMessage长消息</div><div class=\"line\">textPersonName个人姓名</div><div class=\"line\">textPostalAddress邮政地址</div><div class=\"line\">textPassword密码</div><div class=\"line\">textVIsiblePassword可见的密码</div><div class=\"line\">textWebEditText网页格式</div><div class=\"line\">textFilter过滤字符串</div><div class=\"line\">textPhonetic语言发音</div><div class=\"line\">number数字</div><div class=\"line\">numberSigned有符号数字</div><div class=\"line\">numberDecimal十进制数字</div><div class=\"line\">phone电话号码</div><div class=\"line\">datetime日期时间</div><div class=\"line\">date日期</div><div class=\"line\">time时间</div><div class=\"line\">android:lineSpacingExtra</div><div class=\"line\">设置行间距 </div><div class=\"line\">android:lineSpacingMultiplier</div><div class=\"line\">设置行间距的倍数</div><div class=\"line\">android:lines</div><div class=\"line\">设置文本行数</div><div class=\"line\">android:linksClickable</div><div class=\"line\">设置链接是否点击连接，即使设置了autoLick</div><div class=\"line\">android:marqueeRepeatLimit</div><div class=\"line\">来回移动的动画次数</div><div class=\"line\">android:maxEms</div><div class=\"line\">设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项 </div><div class=\"line\">android:maxHeight</div><div class=\"line\">物体的最大高度</div><div class=\"line\">android:maxLength</div><div class=\"line\">最大文本长度</div><div class=\"line\">android:maxLines</div><div class=\"line\">最大行数</div><div class=\"line\">android:minWidth</div><div class=\"line\">物体的最大宽度</div><div class=\"line\">android:minEms</div><div class=\"line\">设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项</div><div class=\"line\"> </div><div class=\"line\">android:minHeight</div><div class=\"line\">物体的最小高度</div><div class=\"line\">android:minLines</div><div class=\"line\">最小文本行数</div><div class=\"line\">android:minWidth</div><div class=\"line\">物体的最小宽度</div><div class=\"line\">android:numeric</div><div class=\"line\">是否使用数字输入方式</div><div class=\"line\">android:password</div><div class=\"line\">是否使用密码输入方式</div><div class=\"line\">android:phonenumber</div><div class=\"line\">是否使用电话号码输入方式</div><div class=\"line\">android:privateImeOptions</div><div class=\"line\">设置输入法选项 </div><div class=\"line\">android:scrollHorizontally</div><div class=\"line\">设置文本超出TextView的宽度的情况下，是否出现横拉条 </div><div class=\"line\">android:selectAllOnFocus</div><div class=\"line\">如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</div><div class=\"line\">android:shadowColor</div><div class=\"line\">文本阴影颜色</div><div class=\"line\">android:shadowDx</div><div class=\"line\">阴影的水平偏移</div><div class=\"line\">android:shadowDy</div><div class=\"line\">阴影的垂直偏移</div><div class=\"line\">android:shadowRadius</div><div class=\"line\">阴影的半径</div><div class=\"line\">android:singleLine</div><div class=\"line\">是否单行（不自动换行）</div><div class=\"line\">android:text</div><div class=\"line\">显示的文本内容</div><div class=\"line\">android:textApperance</div><div class=\"line\">基本字体颜色、字样、大小和样式</div><div class=\"line\">android:textColor</div><div class=\"line\">文本颜色</div><div class=\"line\">android: textColorHighlight</div><div class=\"line\">文本高亮颜色</div><div class=\"line\">android: textColorHint</div><div class=\"line\">文本提示颜色</div><div class=\"line\">android:textColorLink</div><div class=\"line\">文本链接颜色</div><div class=\"line\">android:textScaleX</div><div class=\"line\">文本缩放因数</div><div class=\"line\">android:textSize</div><div class=\"line\">文本大小</div><div class=\"line\">android:textStyle</div><div class=\"line\">文本样式，取值为下列之一：</div><div class=\"line\">bold粗体</div><div class=\"line\">italic斜体</div><div class=\"line\">bolditalic粗斜体</div><div class=\"line\">android:typeface</div><div class=\"line\">字样</div><div class=\"line\">android:width</div><div class=\"line\">物体的高度</div><div class=\"line\"></div><div class=\"line\">AutoCompleteTextView属性说明</div><div class=\"line\"></div><div class=\"line\">android:completionHint</div><div class=\"line\">显示提示</div><div class=\"line\">android:completionHintView</div><div class=\"line\">提示视图</div><div class=\"line\">android:completionThreshold</div><div class=\"line\">设置开始提示的字符数</div><div class=\"line\">android:dropDownAnchor</div><div class=\"line\">下拉框链接视图</div><div class=\"line\">android:dropDownSelector</div><div class=\"line\">下拉框选择器</div><div class=\"line\">android:dropDownWIdth</div><div class=\"line\">下拉框宽度</div><div class=\"line\"></div><div class=\"line\">ImageView属性说明</div><div class=\"line\"></div><div class=\"line\">android:adjustViewBounds</div><div class=\"line\">是否调整视图范围</div><div class=\"line\">android:baselineAlignBottom</div><div class=\"line\">是否按照下端基线对齐</div><div class=\"line\">android:cropToPadding</div><div class=\"line\">是否按照填充进行裁剪</div><div class=\"line\">android:maxHeight</div><div class=\"line\">设置最大高度</div><div class=\"line\">android:maxWidth</div><div class=\"line\">设置最大宽度</div><div class=\"line\">android:scaleType</div><div class=\"line\">缩放类型，取值为下列之一：</div><div class=\"line\">matrix图片真实大小</div><div class=\"line\">fitXY适合图片大小</div><div class=\"line\">fitStart</div><div class=\"line\">fitCenter</div><div class=\"line\">fitEnd</div><div class=\"line\">center居中显示</div><div class=\"line\">centerCrop</div><div class=\"line\">centerInside</div><div class=\"line\">android:src</div><div class=\"line\">设置绘制用内容</div><div class=\"line\">android:tint</div><div class=\"line\">设置染色颜色值</div><div class=\"line\">android:layout_above=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件置于给定ID控件之上 </div><div class=\"line\">android:layout_below=<span class=\"string\">\"@id/xxx\"</span></div><div class=\"line\">将控件置于给定ID控件之下</div><div class=\"line\">android:layout_toLeftOf=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的右边缘和给定ID控件的左边缘对齐 </div><div class=\"line\">android:layout_toRightOf=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的左边缘和给定ID控件的右边缘对齐</div><div class=\"line\">android:layout_alignLeft=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的左边缘和给定ID控件的左边缘对齐</div><div class=\"line\">android:layout_alignTop=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的上边缘和给定ID控件的上边缘对齐</div><div class=\"line\"> </div><div class=\"line\">android:layout_alignRight=<span class=\"string\">\"@id/xxx\"</span></div><div class=\"line\">将控件的右边缘和给定ID控件的右边缘对齐</div><div class=\"line\">android:layout_alignBottom=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的底边缘和给定ID控件的底边缘对齐 </div><div class=\"line\">android:layout_alignParentLeft=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的左边缘和父控件的左边缘对齐 </div><div class=\"line\">android:layout_alignParentTop=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的上边缘和父控件的上边缘对齐 </div><div class=\"line\">android:layout_alignParentRight=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的右边缘和父控件的右边缘对齐 </div><div class=\"line\">android:layout_alignParentBottom=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的底边缘和父控件的底边缘对齐</div><div class=\"line\"> android:layout_centerInParent=<span class=\"string\">\"true\"</span> </div><div class=\"line\"> 将控件置于父控件的中心位置 </div><div class=\"line\"> </div><div class=\"line\"> android:layout_centerHorizontal=<span class=\"string\">\"true\"</span> </div><div class=\"line\"> 将控件置于水平方向的中心位置 </div><div class=\"line\"> </div><div class=\"line\"> android:layout_centerVertical=<span class=\"string\">\"true\"</span> </div><div class=\"line\"> 将控件置于垂直方向的中心位置</div></pre></td></tr></table></figure>\n","excerpt":"<p>转自<a href=\"http://www.codexiu.cn/android/blog/40141/\">Android属性大全</a></p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div><div class=\"line\">663</div><div class=\"line\">664</div><div class=\"line\">665</div><div class=\"line\">666</div><div class=\"line\">667</div><div class=\"line\">668</div><div class=\"line\">669</div><div class=\"line\">670</div><div class=\"line\">671</div><div class=\"line\">672</div><div class=\"line\">673</div><div class=\"line\">674</div><div class=\"line\">675</div><div class=\"line\">676</div><div class=\"line\">677</div><div class=\"line\">678</div><div class=\"line\">679</div><div class=\"line\">680</div><div class=\"line\">681</div><div class=\"line\">682</div><div class=\"line\">683</div><div class=\"line\">684</div><div class=\"line\">685</div><div class=\"line\">686</div><div class=\"line\">687</div><div class=\"line\">688</div><div class=\"line\">689</div><div class=\"line\">690</div><div class=\"line\">691</div><div class=\"line\">692</div><div class=\"line\">693</div><div class=\"line\">694</div><div class=\"line\">695</div><div class=\"line\">696</div><div class=\"line\">697</div><div class=\"line\">698</div><div class=\"line\">699</div><div class=\"line\">700</div><div class=\"line\">701</div><div class=\"line\">702</div><div class=\"line\">703</div><div class=\"line\">704</div><div class=\"line\">705</div><div class=\"line\">706</div><div class=\"line\">707</div><div class=\"line\">708</div><div class=\"line\">709</div><div class=\"line\">710</div><div class=\"line\">711</div><div class=\"line\">712</div><div class=\"line\">713</div><div class=\"line\">714</div><div class=\"line\">715</div><div class=\"line\">716</div><div class=\"line\">717</div><div class=\"line\">718</div><div class=\"line\">719</div><div class=\"line\">720</div><div class=\"line\">721</div><div class=\"line\">722</div><div class=\"line\">723</div><div class=\"line\">724</div><div class=\"line\">725</div><div class=\"line\">726</div><div class=\"line\">727</div><div class=\"line\">728</div><div class=\"line\">729</div><div class=\"line\">730</div><div class=\"line\">731</div><div class=\"line\">732</div><div class=\"line\">733</div><div class=\"line\">734</div><div class=\"line\">735</div><div class=\"line\">736</div><div class=\"line\">737</div><div class=\"line\">738</div><div class=\"line\">739</div><div class=\"line\">740</div><div class=\"line\">741</div><div class=\"line\">742</div><div class=\"line\">743</div><div class=\"line\">744</div><div class=\"line\">745</div><div class=\"line\">746</div><div class=\"line\">747</div><div class=\"line\">748</div><div class=\"line\">749</div><div class=\"line\">750</div><div class=\"line\">751</div><div class=\"line\">752</div><div class=\"line\">753</div><div class=\"line\">754</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:<span class=\"function\">alpha </div><div class=\"line\"><span class=\"title\">setAlpha</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。</div><div class=\"line\">android:background </div><div class=\"line\"><span class=\"title\">setBackgroundResource</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 视图背景</div><div class=\"line\">android:clickable </div><div class=\"line\"><span class=\"title\">setClickable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 视图是否可点击</div><div class=\"line\">android:contentDescription </div><div class=\"line\"><span class=\"title\">setContentDescription</span><span class=\"params\">(CharSequence)</span> 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明</div><div class=\"line\">android:drawingCacheQuality </div><div class=\"line\"><span class=\"title\">setDrawingCacheQuality</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: \"设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存\"</div><div class=\"line\">android:duplicateParentState </div><div class=\"line\">属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）</div><div class=\"line\">android:fadeScrollbars </div><div class=\"line\"><span class=\"title\">setScrollbarFadingEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 定义在ScrollBar没有使用时，是否褪色。</div><div class=\"line\">android:fadingEdgeLength </div><div class=\"line\"><span class=\"title\">getVerticalFadingEdgeLength</span><span class=\"params\">()</span> 属性说明: 设置边框渐变的长度。</div><div class=\"line\">android:filterTouchesWhenObscured </div><div class=\"line\"><span class=\"title\">setFilterTouchesWhenObscured</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。</div><div class=\"line\">android:fitsSystemWindows </div><div class=\"line\"><span class=\"title\">setFitsSystemWindows</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）</div><div class=\"line\">android:focusable </div><div class=\"line\"><span class=\"title\">setFocusable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置是否获得焦点。若有<span class=\"title\">requestFocus</span><span class=\"params\">()</span>被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为<span class=\"keyword\">false</span>才行。在Touch模式下获取焦点需要设置focusableInTouchMode为<span class=\"keyword\">true</span>。</div><div class=\"line\">android:focusableInTouchMode </div><div class=\"line\"><span class=\"title\">setFocusableInTouchMode</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置在Touch模式下View是否能取得焦点。</div><div class=\"line\">android:hapticFeedbackEnabled </div><div class=\"line\"><span class=\"title\">setHapticFeedbackEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果</div><div class=\"line\">android:id </div><div class=\"line\"><span class=\"title\">setId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用View.<span class=\"title\">findViewById</span><span class=\"params\">()</span> 或Activity.<span class=\"title\">findViewById</span><span class=\"params\">()</span>根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。</div><div class=\"line\">android:importantForAccessibility </div><div class=\"line\"><span class=\"title\">setImportantForAccessibility</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置可达性的重要性</div><div class=\"line\">android:isScrollContainer </div><div class=\"line\"><span class=\"title\">setScrollContainer</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条</div><div class=\"line\">android:keepScreenOn </div><div class=\"line\"><span class=\"title\">setKeepScreenOn</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 视图在可见的情况下是否保持唤醒状态。</div><div class=\"line\">android:layerType </div><div class=\"line\"><span class=\"title\">setLayerType</span><span class=\"params\">(<span class=\"keyword\">int</span>,Paint)</span> 属性说明: \"设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。\"</div><div class=\"line\">android:layoutDirection </div><div class=\"line\"><span class=\"title\">setLayoutDirection</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 定义布局图纸的方向</div><div class=\"line\">android:longClickable </div><div class=\"line\"><span class=\"title\">setLongClickable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 是否响应长点击事件</div><div class=\"line\">android:minHeight </div><div class=\"line\"><span class=\"title\">setMinimumHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置视图最小高度</div><div class=\"line\">android:minWidth </div><div class=\"line\"><span class=\"title\">setMinimumWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置视图最小宽度</div><div class=\"line\">android:nextFocusDown </div><div class=\"line\"><span class=\"title\">setNextFocusDownId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向下移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusForward </div><div class=\"line\"><span class=\"title\">setNextFocusForwardId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusLeft </div><div class=\"line\"><span class=\"title\">setNextFocusLeftId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向左移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusRight </div><div class=\"line\"><span class=\"title\">setNextFocusRightId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向右移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:nextFocusUp </div><div class=\"line\"><span class=\"title\">setNextFocusUpId</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 向上移动焦点时，下一个获取焦点的view的id</div><div class=\"line\">android:onClick </div><div class=\"line\"><span class=\"title\">setOnClick</span><span class=\"params\">()</span>或 <span class=\"title\">onClick</span><span class=\"params\">(View view)</span>属性说明: 点击时，要调用的方法的名称。</div><div class=\"line\">android:padding </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置上下左右的边距</div><div class=\"line\">android:paddingBottom </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 下边距</div><div class=\"line\">android:paddingEnd </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 与android:paddingRight相同</div><div class=\"line\">android:paddingLeft </div><div class=\"line\"><span class=\"title\">setPadding</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 左边距</div><div class=\"line\">android:paddingRight </div><div class=\"line\"><span class=\"title\">setPadding</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 右边距</div><div class=\"line\">android:paddingStart </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: android:paddingLeft相同</div><div class=\"line\">android:paddingTop </div><div class=\"line\"><span class=\"title\">setPaddingRelative</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 上边距</div><div class=\"line\">android:requiresFadingEdge </div><div class=\"line\"><span class=\"title\">setVerticalFadingEdgeEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 定义滚动时边缘是否褪色</div><div class=\"line\">android:rotation </div><div class=\"line\"><span class=\"title\">setRotation</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 旋转度数</div><div class=\"line\">android:rotationX </div><div class=\"line\"><span class=\"title\">setRotationX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平旋转度数</div><div class=\"line\">android:rotationY </div><div class=\"line\"><span class=\"title\">setRotationY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直旋转度数</div><div class=\"line\">android:saveEnabled </div><div class=\"line\"><span class=\"title\">setSaveEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。</div><div class=\"line\">android:scaleX </div><div class=\"line\"><span class=\"title\">setScaleX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平方向缩放比例</div><div class=\"line\">android:scaleY </div><div class=\"line\"><span class=\"title\">setScaleY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直方向缩放比例</div><div class=\"line\">android:scrollX </div><div class=\"line\">属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离</div><div class=\"line\">android:scrollY </div><div class=\"line\">属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离</div><div class=\"line\">android:scrollbarAlwaysDrawHorizontalTrack </div><div class=\"line\">属性说明: 是否总是绘制水平滚动条的滚动轨道</div><div class=\"line\">android:scrollbarAlwaysDrawVerticalTrack </div><div class=\"line\">属性说明: 是否总是绘制竖直滚动条的滚动轨道</div><div class=\"line\">android:scrollbarDefaultDelayBeforeFade </div><div class=\"line\"><span class=\"title\">setScrollBarDefaultDelayBeforeFade</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 滚动条在n毫秒后开始淡出。</div><div class=\"line\">android:scrollbarFadeDuration </div><div class=\"line\"><span class=\"title\">setScrollBarFadeDuration</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 滚动条用多长时间淡出完毕。</div><div class=\"line\">android:scrollbarSize </div><div class=\"line\"><span class=\"title\">setScrollBarSize</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度</div><div class=\"line\">android:scrollbarStyle </div><div class=\"line\"><span class=\"title\">setScrollBarStyle</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: \"滚动条的风格。共4组值： insideOverlay——内贴图 insideInset——内插图 outsideOverlay——外贴图 outsideInset——外插图。 inside就是滚动条在绘制在padding以内；outside就是不需要绘制在padding内（即view的边界处）；Overlay是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；Inset是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。\"</div><div class=\"line\">android:scrollbarThumbHorizontal </div><div class=\"line\">属性说明: 水平滚动块的drawable对象</div><div class=\"line\">android:scrollbarThumbVertical </div><div class=\"line\">属性说明: 竖直滚动块的drawable对象</div><div class=\"line\">android:scrollbarTrackHorizontal </div><div class=\"line\">属性说明: 水平滚动条滚动轨道的drawable对象</div><div class=\"line\">android:scrollbarTrackVertical </div><div class=\"line\">属性说明: 竖直滚动条滚动轨道的drawable对象</div><div class=\"line\">android:scrollbars </div><div class=\"line\">属性说明: \"设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条\"</div><div class=\"line\">android:soundEffectsEnabled </div><div class=\"line\"><span class=\"title\">setSoundEffectsEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 点击或触摸该view时，是否需要有声音效果</div><div class=\"line\">android:tag </div><div class=\"line\">属性说明: string标识。类似id，id是整数标识。</div><div class=\"line\">android:textAlignment </div><div class=\"line\"><span class=\"title\">setTextAlignment</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的显示方式。</div><div class=\"line\">android:textDirection </div><div class=\"line\"><span class=\"title\">setTextDirection</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的显示方向。</div><div class=\"line\">android:transformPivotX </div><div class=\"line\"><span class=\"title\">setPivotX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平方向偏转量</div><div class=\"line\">android:transformPivotY </div><div class=\"line\"><span class=\"title\">setPivotY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直方向偏转量</div><div class=\"line\">android:translationX </div><div class=\"line\"><span class=\"title\">setTranslationX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 水平方向的移动距离</div><div class=\"line\">android:translationY </div><div class=\"line\"><span class=\"title\">setTranslationY</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 竖直方向的移动距离</div><div class=\"line\">android:visibility </div><div class=\"line\"><span class=\"title\">setVisibility</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: \"view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见\"</div><div class=\"line\">TextView属性说明</div><div class=\"line\">下面对TextView的属性进行说明 android:autoLink </div><div class=\"line\"><span class=\"title\">setAutoLinkMask</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值<span class=\"params\">(none/web/email/phone/map/all)</span></div><div class=\"line\">android:autoText </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</div><div class=\"line\">android:bufferType </div><div class=\"line\"><span class=\"title\">setText</span><span class=\"params\">(CharSequence,TextView.BufferType)</span> 属性说明: 指定<span class=\"title\">getText</span><span class=\"params\">()</span>方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。</div><div class=\"line\">android:capitalize </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。</div><div class=\"line\">android:cursorVisible </div><div class=\"line\"><span class=\"title\">setCursorVisible</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设定光标为显示/隐藏，默认显示。</div><div class=\"line\">android:digits </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\\<span class=\"title\">n</span><span class=\"params\">()</span>”</div><div class=\"line\">android:drawableBottom </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。</div><div class=\"line\">android:drawableEnd </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesRelativeWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][<span class=\"keyword\">package</span>:]type:name\"或者\"?[<span class=\"keyword\">package</span>:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。</div><div class=\"line\">android:drawableLeft </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的左边输出一个drawable。</div><div class=\"line\">android:drawablePadding </div><div class=\"line\"><span class=\"title\">setCompoundDrawablePadding</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。</div><div class=\"line\">android:drawableRight </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的右边输出一个drawable。</div><div class=\"line\">android:drawableStart </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesRelativeWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，\"@[+][<span class=\"keyword\">package</span>:]type:name\"或者\"?[<span class=\"keyword\">package</span>:][type:]name\"；也可以是颜色值，如\"#rgb\", \"#argb\", \"#rrggbb\", or \"#aarrggbb\"。</div><div class=\"line\">android:drawableTop </div><div class=\"line\"><span class=\"title\">setCompoundDrawablesWithIntrinsicBounds</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 在text的正上方输出一个drawable。</div><div class=\"line\">android:editable </div><div class=\"line\">属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。</div><div class=\"line\">android:editorExtras </div><div class=\"line\"><span class=\"title\">setInputExtras</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的额外的输入数据。在EditView中才有效果。</div><div class=\"line\">android:ellipsize </div><div class=\"line\"><span class=\"title\">setEllipsize</span><span class=\"params\">(TextUtils.TruncateAt)</span> 属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示<span class=\"params\">(动画横向移动)</span></div><div class=\"line\">android:ems </div><div class=\"line\"><span class=\"title\">setEms</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置TextView的宽度为N个字符的宽度。</div><div class=\"line\">android:fontFamily </div><div class=\"line\"><span class=\"title\">setTypeface</span><span class=\"params\">(Typeface)</span> 属性说明: 文本的字形体系。</div><div class=\"line\">android:freezesText </div><div class=\"line\"><span class=\"title\">setFreezesText</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置保存文本的内容以及光标的位置。</div><div class=\"line\">android:gravity </div><div class=\"line\"><span class=\"title\">setGravity</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本位置，如设置成“center”，文本将居中显示。</div><div class=\"line\">android:height </div><div class=\"line\"><span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的高度，支持度量单位：<span class=\"title\">px</span><span class=\"params\">(像素)</span>/dp/sp/in/<span class=\"title\">mm</span><span class=\"params\">(毫米)</span></div><div class=\"line\">android:hint </div><div class=\"line\"><span class=\"title\">setHint</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。</div><div class=\"line\">android:imeActionId </div><div class=\"line\"><span class=\"title\">setImeActionLabel</span><span class=\"params\">(CharSequence,<span class=\"keyword\">int</span>)</span> 属性说明: 设置IME动作ID。</div><div class=\"line\">android:imeActionLabel </div><div class=\"line\"><span class=\"title\">setImeActionLabel</span><span class=\"params\">(CharSequence,<span class=\"keyword\">int</span>)</span> 属性说明: 设置IME动作标签。在EditView再做说明。</div><div class=\"line\">android:imeOptions </div><div class=\"line\"><span class=\"title\">setImeOptions</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。</div><div class=\"line\">android:includeFontPadding </div><div class=\"line\"><span class=\"title\">setIncludeFontPadding</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置文本是否包含顶部和底部额外空白，默认为<span class=\"keyword\">true</span>。</div><div class=\"line\">android:inputMethod </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。</div><div class=\"line\">android:inputType </div><div class=\"line\"><span class=\"title\">setRawInputType</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。</div><div class=\"line\">android:lineSpacingExtra </div><div class=\"line\"><span class=\"title\">setLineSpacing</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>)</span> 属性说明: 设置行间距。</div><div class=\"line\">android:lineSpacingMultiplier </div><div class=\"line\"><span class=\"title\">setLineSpacing</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>)</span> 属性说明: 设置行间距的倍数。如”1.2”</div><div class=\"line\">android:lines </div><div class=\"line\"><span class=\"title\">setLines</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。</div><div class=\"line\">android:linksClickable </div><div class=\"line\"><span class=\"title\">setLinksClickable</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置链接是否点击连接，即使设置了autoLink。</div><div class=\"line\">android:marqueeRepeatLimit </div><div class=\"line\"><span class=\"title\">setMarqueeRepeatLimit</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。</div><div class=\"line\">android:maxEms </div><div class=\"line\"><span class=\"title\">setMaxEms</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。</div><div class=\"line\">android:maxHeight </div><div class=\"line\"><span class=\"title\">setMaxHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最大高度</div><div class=\"line\">android:maxLength </div><div class=\"line\"><span class=\"title\">setFilters</span><span class=\"params\">(InputFilter)</span> 属性说明: 限制显示的文本长度，超出部分不显示。</div><div class=\"line\">android:maxLines </div><div class=\"line\"><span class=\"title\">setMaxLines</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</div><div class=\"line\">android:maxWidth </div><div class=\"line\"><span class=\"title\">setMaxWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最大宽度</div><div class=\"line\">android:minEms </div><div class=\"line\"><span class=\"title\">setMinEms</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。</div><div class=\"line\">android:minHeight </div><div class=\"line\"><span class=\"title\">setMinHeight</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最小高度</div><div class=\"line\">android:minLines </div><div class=\"line\"><span class=\"title\">setMinLines</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本的最小行数，与lines类似。</div><div class=\"line\">android:minWidth </div><div class=\"line\"><span class=\"title\">setMinWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的最小宽度</div><div class=\"line\">android:numeric </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。</div><div class=\"line\">android:password </div><div class=\"line\"><span class=\"title\">setTransformationMethod</span><span class=\"params\">(TransformationMethod)</span> 属性说明: 以小点”.”显示文本</div><div class=\"line\">android:phoneNumber </div><div class=\"line\"><span class=\"title\">setKeyListener</span><span class=\"params\">(KeyListener)</span> 属性说明: 设置为电话号码的输入方式。</div><div class=\"line\">android:privateImeOptions </div><div class=\"line\"><span class=\"title\">setPrivateImeOptions</span><span class=\"params\">(String)</span> 属性说明: 设置输入法选项，在EditText中才有作用。</div><div class=\"line\">android:scrollHorizontally </div><div class=\"line\"><span class=\"title\">setHorizontallyScrolling</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。</div><div class=\"line\">android:selectAllOnFocus </div><div class=\"line\"><span class=\"title\">setSelectAllOnFocus</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</div><div class=\"line\">android:shadowColor </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。</div><div class=\"line\">android:shadowDx </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置阴影横向坐标开始位置。</div><div class=\"line\">android:shadowDy </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置阴影纵向坐标开始位置。</div><div class=\"line\">android:shadowRadius </div><div class=\"line\"><span class=\"title\">setShadowLayer</span><span class=\"params\">(<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">float</span>,<span class=\"keyword\">int</span>)</span> 属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。</div><div class=\"line\">android:singleLine </div><div class=\"line\"><span class=\"title\">setTransformationMethod</span><span class=\"params\">(TransformationMethod)</span> 属性说明: 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text</span>=<span class=\"string\">\"test_ singleLine \"</span> android:singleLine=<span class=\"string\">\"true\"</span> android:layout_width=<span class=\"string\">\"20dp\"</span>将只显示“t…”。如果不设置singleLine或者设置为<span class=\"keyword\">false</span>，文本将自动换行</div><div class=\"line\">android:<span class=\"function\">text </div><div class=\"line\"><span class=\"title\">setText</span><span class=\"params\">(CharSequence,TextView.BufferType)</span> 属性说明: 设置显示文本.</div><div class=\"line\">android:textAllCaps </div><div class=\"line\"><span class=\"title\">setAllCaps</span><span class=\"params\">(<span class=\"keyword\">boolean</span>)</span> 属性说明: 设置文本全为大写。值为\"<span class=\"keyword\">true</span>\"或\"<span class=\"keyword\">false</span>\"。</div><div class=\"line\">android:textAppearance </div><div class=\"line\">属性说明: 设置文字外观。如“?android:attr/textAppearanceLargeInverse</div><div class=\"line\">android:textColor </div><div class=\"line\"><span class=\"title\">setTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本颜色</div><div class=\"line\">android:textColorHighlight </div><div class=\"line\"><span class=\"title\">setHighlightColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 被选中文字的底色，默认为蓝色</div><div class=\"line\">android:textColorHint </div><div class=\"line\"><span class=\"title\">setHintTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。</div><div class=\"line\">android:textColorLink </div><div class=\"line\"><span class=\"title\">setLinkTextColor</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 文字链接的颜色.</div><div class=\"line\">android:textIsSelectable </div><div class=\"line\"><span class=\"title\">isTextSelectable</span><span class=\"params\">()</span> 属性说明: 设置非编辑文本可否被选择。值为\"<span class=\"keyword\">true</span>\"或\"<span class=\"keyword\">false</span>\"。</div><div class=\"line\">android:textScaleX </div><div class=\"line\"><span class=\"title\">setTextScaleX</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> 属性说明: 设置文字之间间隔，默认为1.0f。</div><div class=\"line\">android:textSize </div><div class=\"line\"><span class=\"title\">setTextSize</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">float</span>)</span> 属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”</div><div class=\"line\">android:textStyle </div><div class=\"line\"><span class=\"title\">setTypeface</span><span class=\"params\">(Typeface)</span> 属性说明: 设置字形[<span class=\"title\">bold</span><span class=\"params\">(粗体)</span> 0, <span class=\"title\">italic</span><span class=\"params\">(斜体)</span> 1, <span class=\"title\">bolditalic</span><span class=\"params\">(又粗又斜)</span> 2] 可以设置一个或多个，用“|”隔开</div><div class=\"line\">android:typeface </div><div class=\"line\"><span class=\"title\">setTypeface</span><span class=\"params\">(Typeface)</span> 属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, <span class=\"title\">monospace</span><span class=\"params\">(等宽字体)</span> 3]</div><div class=\"line\">android:width </div><div class=\"line\"><span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> 属性说明: 设置文本区域的宽度，支持度量单位：<span class=\"title\">px</span><span class=\"params\">(像素)</span>/dp/sp/in/<span class=\"title\">mm</span><span class=\"params\">(毫米)</span>。</div><div class=\"line\">android:fadingEdgeLength</div><div class=\"line\">设置淡入淡出边缘的长度，可以接受大小值的单位是：px、dp、sp、in、mm，也可以参考大小值资源</div><div class=\"line\">android:fitsSystemWindows</div><div class=\"line\">是否适合系统窗体，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span>。该属性只对不是子组件的组件有效</div><div class=\"line\">android:focusable</div><div class=\"line\">是否可以获取焦点，取值<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:focusableInTouchMode</div><div class=\"line\">是否可以在触摸模式下获取焦点，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:hapticFeedbackEnabled</div><div class=\"line\">是否允许触摸反馈效果，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:id</div><div class=\"line\">提供该组件的标识名，可以借助Activity或View实例的findViewById方法通过id获取对应的组件实例对象，其属性值的形式为：android:id</span>=”@+id/id”</div><div class=\"line\">android:isScrollContainer</div><div class=\"line\">设置该组件是否设置为滚动条容器，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:keepScreenOn</div><div class=\"line\">控制该组件在显示的时候保持在屏幕显示，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:longClickable</div><div class=\"line\">是否响应长时间点击事件，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:minHeight</div><div class=\"line\">组件的最小高度，取值同android:fadingEdgeLength</div><div class=\"line\">android:minWidth</div><div class=\"line\">组件的最小宽度，取值同android:fadingEdgeLength</div><div class=\"line\">android:nextFocusDown</div><div class=\"line\">设置下一个向下获取焦点的组件，取值为id</div><div class=\"line\">android:nextFocusLeft</div><div class=\"line\">设置下一个向左获取焦点的组件，取值为id</div><div class=\"line\">android:nextFocusRight</div><div class=\"line\">设置下一个向右获取焦点的组件，取值为id</div><div class=\"line\">android:nextFocusUp</div><div class=\"line\">设置下一个向上获取焦点的组件，取值为id</div><div class=\"line\">android:padding</div><div class=\"line\">设置上、下、左、右<span class=\"number\">4</span>个边缘的填充距离，必须是一个大小值，取值同android:fadingEdgeLength</div><div class=\"line\">android:paddingBottom</div><div class=\"line\">设置下端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:paddingLeft</div><div class=\"line\">设置左端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:paddingRight</div><div class=\"line\">设置右端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:paddingTop</div><div class=\"line\">设置上端边缘的填充距离，取值同android:padding</div><div class=\"line\">android:saveEnabled</div><div class=\"line\">是否允许保存状态，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:scrollX</div><div class=\"line\">设置垂直滚动条的位移量，必须是一个大小值，取值同android:padding</div><div class=\"line\">android:scrollY</div><div class=\"line\">设置水平滚动条的位移量，必须是一个大小值，取值同android:padding</div><div class=\"line\">android:scrollbarAlwaysDrawHorizontalTrack</div><div class=\"line\">是否总是设置水平滚动条滑块，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:scrollbarAlwaysDrawVerticalTrack</div><div class=\"line\">是否总是设置垂直滚动条滑块，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:scrollbarSize</div><div class=\"line\">设置垂直滚动条的宽度和水平滚动条的长度，必须是一个大小值，取值同android:padding</div><div class=\"line\">android:scrollbarStyle</div><div class=\"line\">设置滚动条的样式，取值为下列之一：</div><div class=\"line\">insideOverlay在填充区域内，覆盖形式</div><div class=\"line\">insideInset在填充区域内，插进形式（凹进）</div><div class=\"line\">outsideOverly在绑定组件边缘，覆盖形式</div><div class=\"line\">outsideInset在绑定组件边缘，插进形似</div><div class=\"line\">android:scrollbarThumbHorizontal</div><div class=\"line\">设置水平滚动条按钮的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbarThumbVertical</div><div class=\"line\">设置垂直滚动条按钮的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbarTrackHorizontal</div><div class=\"line\">设置水平滚动条轨道的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbarTrackVertical</div><div class=\"line\">设置水平滚动条轨道的绘制资源，必须引用可绘制资源</div><div class=\"line\">android:scrollbars</div><div class=\"line\">设置滚动显示，可以为一下一个或多个值：</div><div class=\"line\">none不显示滚动条</div><div class=\"line\">horizontal只显示水平滚动条</div><div class=\"line\">vertical只显示垂直滚动条</div><div class=\"line\">android:soundEffectsEnabled</div><div class=\"line\">是否允许音效，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:tag</div><div class=\"line\">设置标记内容，可以通过View类实例的getTag方法获取该组件的标记内容，或者使用findViewByTag通过标记来查找相应的子组件</div><div class=\"line\">android:visibility</div><div class=\"line\">设置初始化可见状态，取值为以下之一：</div><div class=\"line\">visible可见（默认值）</div><div class=\"line\">invisible不可见（其所占空间将留出）</div><div class=\"line\">gone完全不可见（其所占空间都不会留出）</div><div class=\"line\">线性布局LinearLayout组件属性列表</div><div class=\"line\">属性说明</div><div class=\"line\">android:baselineAligned</div><div class=\"line\">基线对齐</div><div class=\"line\">android:baselineAlignedChildIndex</div><div class=\"line\">以指定子组件作为基线对齐</div><div class=\"line\">android:gravity</div><div class=\"line\">指定该物体放入其容器的重心位置，取值为下列之一：</div><div class=\"line\">top上方，物体大小不变</div><div class=\"line\">bottom下方，物体大小不变</div><div class=\"line\">left左方，物体大小不变</div><div class=\"line\">right右方，物体大小不变</div><div class=\"line\">center_vertical垂直方向的中间，物体大小不变</div><div class=\"line\">fill_vertical填满垂直方向，自动进行大小调整</div><div class=\"line\">center_horizontal水平方向的中间，大小不变</div><div class=\"line\">fill_horizontal填满水平方向，自动进行大小调整</div><div class=\"line\">center居中（既是水平也是垂直方向的中间）</div><div class=\"line\">fill填满整个容器</div><div class=\"line\">clip_vertical</div><div class=\"line\">clip_horizontal</div><div class=\"line\">android:orientation</div><div class=\"line\">布局方向，取值为下列之一：</div><div class=\"line\">horizontal水平的</div><div class=\"line\">vertical垂直的（默认值）</div><div class=\"line\">android:weightSum</div><div class=\"line\">组件的比重和</div><div class=\"line\"></div><div class=\"line\">LinearLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_gravity</div><div class=\"line\">当前子组件的心位置</div><div class=\"line\">android:layout_height</div><div class=\"line\">当前子组件的高度</div><div class=\"line\">android:layout_weight</div><div class=\"line\">当前子组件的空间比重，取值为浮点数</div><div class=\"line\">android:layout_width</div><div class=\"line\">当前子组件的宽度</div><div class=\"line\"></div><div class=\"line\">RalativeLayout属性说明</div><div class=\"line\"></div><div class=\"line\">android:gravity</div><div class=\"line\">设置添加组件的重心</div><div class=\"line\">android:ignoreGravity</div><div class=\"line\">忽略布局重心的影响</div><div class=\"line\"></div><div class=\"line\">RalativeLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_above</div><div class=\"line\">将当前组件的下边缘放置于参照组件之上，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignBaseline</div><div class=\"line\">当前组件与参照组件的基线对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignBottom</div><div class=\"line\">当前组件与参照组件的下边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignLeft</div><div class=\"line\">当前组件与参照组件的左边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignParenBottom</div><div class=\"line\">当前组件与父组件的下边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignParentLeft</div><div class=\"line\">当前组件与父组件的左边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignParentRight</div><div class=\"line\">当前组件与父组件的右边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignParentTop</div><div class=\"line\">当前组件与父组件的上边界对齐，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_alignRight</div><div class=\"line\">当前组件与参照组件的右边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignTop</div><div class=\"line\">当前组件与参照组件的上边界对齐，该属性为参照组件的ID</div><div class=\"line\">android:layout_alignWithParentIfMissing</div><div class=\"line\">如果对应的兄弟元素找不到的话就以父元素做参照物 <span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:layout_below</div><div class=\"line\">将当前组件的上边缘放置于参照组件之下，该属性为参照组件的ID</div><div class=\"line\">android:layout_centerHorizontal</div><div class=\"line\">当前组件放置到父组件的水平居中的位置</div><div class=\"line\">android:layout_centerInParent</div><div class=\"line\">当前组件放置到父组件的重心位置</div><div class=\"line\">android:layout_centerVertical</div><div class=\"line\">当前组件放置到父组件垂直居中的位置</div><div class=\"line\">android:layout_toLeftOf</div><div class=\"line\">将当前组件的右边缘放置于参照组件之下，该属性为参照组件的ID</div><div class=\"line\">android:layout_toRightOf</div><div class=\"line\">将当前组件的左边缘放置于参照组件之下，该属性为参照组件的ID</div><div class=\"line\"></div><div class=\"line\">AbsoluteLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_x</div><div class=\"line\">当前组件的x坐标位置（从左到右方向）</div><div class=\"line\">android:layout_y</div><div class=\"line\">当前组件的y坐标位置（从上到下方向）</div><div class=\"line\"></div><div class=\"line\">FrameLayout属性说明</div><div class=\"line\"></div><div class=\"line\">android:foreground</div><div class=\"line\">前置图片</div><div class=\"line\">android:foregroundGravity</div><div class=\"line\">前置图片重心</div><div class=\"line\">android:measureAllChildren</div><div class=\"line\">在切换显示时是否侧重所有子组件的大小</div><div class=\"line\">android:layout_gravity</div><div class=\"line\">添加组件的重心</div><div class=\"line\"></div><div class=\"line\">FrameLayout_Layout属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_gravity</div><div class=\"line\">当前子组件所添加的重心位置</div><div class=\"line\"></div><div class=\"line\">TableLayout属性说明</div><div class=\"line\"></div><div class=\"line\">android:collapseColumns</div><div class=\"line\">设置允许折叠的列编号，列编号基于<span class=\"number\">0</span>，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</div><div class=\"line\">android:shrinkColumns</div><div class=\"line\">设置允许收缩的列编号，列编号基于<span class=\"number\">0</span>，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</div><div class=\"line\">android:stretchColumns</div><div class=\"line\">设置允许伸展的列编号，列编号基于<span class=\"number\">0</span>，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</div><div class=\"line\">TableRow_Cell属性说明</div><div class=\"line\"></div><div class=\"line\">android:layout_column</div><div class=\"line\">设置该单元格的列编号（基于<span class=\"number\">0</span>）</div><div class=\"line\">android:layout_span</div><div class=\"line\">指明该单元格可以跨越的列数</div><div class=\"line\"></div><div class=\"line\">AbsListView属性说明</div><div class=\"line\"></div><div class=\"line\">android:cacheColorHint</div><div class=\"line\">设置缓冲颜色</div><div class=\"line\">android:drawSelectorOnTop</div><div class=\"line\">是否将选择器绘制在备选条目上方，取值为<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:fastScrollEnabled</div><div class=\"line\">允许快速滚动</div><div class=\"line\">android:listSelector</div><div class=\"line\">指示选择器的内容</div><div class=\"line\">android:scrollingCache</div><div class=\"line\">滚动时是否使用绘制缓冲，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:smoothScrollbar</div><div class=\"line\">平滑滚动条</div><div class=\"line\">android:stackFromBottom</div><div class=\"line\">从下方堆叠条目</div><div class=\"line\">android:textFilterEnbled</div><div class=\"line\">是否允许过滤</div><div class=\"line\">android:transcriptMode设置抄本模式</div><div class=\"line\"></div><div class=\"line\">ListView属性说明</div><div class=\"line\"></div><div class=\"line\">android:choiceMode</div><div class=\"line\">选择模式</div><div class=\"line\">android:divider</div><div class=\"line\">分割线颜色或组件的参考</div><div class=\"line\">android:dividerHeight</div><div class=\"line\">分割线高度</div><div class=\"line\">android:entries</div><div class=\"line\">指定绑定到当前列表视图的一个数组资源</div><div class=\"line\">android:footerDividersEnabled</div><div class=\"line\">是否允许页脚分割线</div><div class=\"line\">android:headerDividersEnabled</div><div class=\"line\">是否允许页眉分割线</div><div class=\"line\"></div><div class=\"line\">GridView属性说明</div><div class=\"line\"></div><div class=\"line\">android:columnWidth</div><div class=\"line\">指定列宽</div><div class=\"line\">android:gravity</div><div class=\"line\">添加组件的重心位置</div><div class=\"line\">android:horizontalSpacing</div><div class=\"line\">水平空间</div><div class=\"line\">android:numColumns</div><div class=\"line\">指定列数</div><div class=\"line\">android:strechMode</div><div class=\"line\">伸展模式</div><div class=\"line\">android:verticalSpacing</div><div class=\"line\">垂直空间</div><div class=\"line\"></div><div class=\"line\">Gallery属性说明</div><div class=\"line\"></div><div class=\"line\">android:animationDuration</div><div class=\"line\">动画持续时间</div><div class=\"line\">android:gravity</div><div class=\"line\">添加组件的重心位置</div><div class=\"line\">android:spacing</div><div class=\"line\">间隔空间</div><div class=\"line\">android:unselectedAlpha</div><div class=\"line\">非选择条目的透明度</div><div class=\"line\"></div><div class=\"line\">TextView属性说明</div><div class=\"line\"></div><div class=\"line\">android:autoLink</div><div class=\"line\">是否自动链接（内容是网址或是电子邮件时）</div><div class=\"line\">android:autoText</div><div class=\"line\">自动更新拼音错误</div><div class=\"line\">android:bufferType</div><div class=\"line\">设置缓冲区类型</div><div class=\"line\">android:capitalize</div><div class=\"line\">自动大写</div><div class=\"line\">android:cursorVisible</div><div class=\"line\">光标是否可见，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:digits</div><div class=\"line\">所接受的数字字符</div><div class=\"line\">android:drawableBottom</div><div class=\"line\">在文本下方绘制</div><div class=\"line\">android:drawableLeft</div><div class=\"line\">在文本左方绘制</div><div class=\"line\">android: drawablePadding</div><div class=\"line\">绘制填充区</div><div class=\"line\">android: drawableRight</div><div class=\"line\">在文本右方绘制</div><div class=\"line\">android: drawableTop</div><div class=\"line\">在文本上方绘制</div><div class=\"line\">android:editable</div><div class=\"line\">是否可编辑，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:editorExtras</div><div class=\"line\">设置文本的额外的输入数据。在EditView中才有效果</div><div class=\"line\">android:ellipsize</div><div class=\"line\">当内容过长时会自动打断单词内容</div><div class=\"line\">android:ems</div><div class=\"line\">设置TextView的宽度为N个字符的宽度</div><div class=\"line\">android:enabled</div><div class=\"line\">是否可用，<span class=\"keyword\">true</span>或<span class=\"keyword\">false</span></div><div class=\"line\">android:freezesText</div><div class=\"line\">是否冻结文本</div><div class=\"line\">android:gravity</div><div class=\"line\">指明文本的重心位置</div><div class=\"line\">android:height</div><div class=\"line\">高度值</div><div class=\"line\">android:hint</div><div class=\"line\">指示内容</div><div class=\"line\">android:imeActionId</div><div class=\"line\">设置IME动作ID</div><div class=\"line\">android:imeActionLabel</div><div class=\"line\">设置IME动作标签</div><div class=\"line\">android:imeOptions</div><div class=\"line\">输入法选项</div><div class=\"line\">android:includeFontPadding</div><div class=\"line\">设置文本是否包含顶部和底部额外空白，默认为<span class=\"keyword\">true</span></div><div class=\"line\">android:inputMethod</div><div class=\"line\">指定输入法</div><div class=\"line\">android:inputType</div><div class=\"line\">输入类型，取值为下列之一：</div><div class=\"line\">none</div><div class=\"line\">text普通文本</div><div class=\"line\">textCapCharacters大写字符</div><div class=\"line\">textCapWords单词首字母大写</div><div class=\"line\">textCapSentences句子首字母大写</div><div class=\"line\">textAutoCorret自动更正</div><div class=\"line\">textAutoComplete自动完成</div><div class=\"line\">textMultiLine多行内容</div><div class=\"line\">textUri，Uri</div><div class=\"line\">textEmailAddress电子邮件地址</div><div class=\"line\">textEmailSubject电子邮件主题</div><div class=\"line\">textShortMessage短消息</div><div class=\"line\">textLongMessage长消息</div><div class=\"line\">textPersonName个人姓名</div><div class=\"line\">textPostalAddress邮政地址</div><div class=\"line\">textPassword密码</div><div class=\"line\">textVIsiblePassword可见的密码</div><div class=\"line\">textWebEditText网页格式</div><div class=\"line\">textFilter过滤字符串</div><div class=\"line\">textPhonetic语言发音</div><div class=\"line\">number数字</div><div class=\"line\">numberSigned有符号数字</div><div class=\"line\">numberDecimal十进制数字</div><div class=\"line\">phone电话号码</div><div class=\"line\">datetime日期时间</div><div class=\"line\">date日期</div><div class=\"line\">time时间</div><div class=\"line\">android:lineSpacingExtra</div><div class=\"line\">设置行间距 </div><div class=\"line\">android:lineSpacingMultiplier</div><div class=\"line\">设置行间距的倍数</div><div class=\"line\">android:lines</div><div class=\"line\">设置文本行数</div><div class=\"line\">android:linksClickable</div><div class=\"line\">设置链接是否点击连接，即使设置了autoLick</div><div class=\"line\">android:marqueeRepeatLimit</div><div class=\"line\">来回移动的动画次数</div><div class=\"line\">android:maxEms</div><div class=\"line\">设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项 </div><div class=\"line\">android:maxHeight</div><div class=\"line\">物体的最大高度</div><div class=\"line\">android:maxLength</div><div class=\"line\">最大文本长度</div><div class=\"line\">android:maxLines</div><div class=\"line\">最大行数</div><div class=\"line\">android:minWidth</div><div class=\"line\">物体的最大宽度</div><div class=\"line\">android:minEms</div><div class=\"line\">设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项</div><div class=\"line\"> </div><div class=\"line\">android:minHeight</div><div class=\"line\">物体的最小高度</div><div class=\"line\">android:minLines</div><div class=\"line\">最小文本行数</div><div class=\"line\">android:minWidth</div><div class=\"line\">物体的最小宽度</div><div class=\"line\">android:numeric</div><div class=\"line\">是否使用数字输入方式</div><div class=\"line\">android:password</div><div class=\"line\">是否使用密码输入方式</div><div class=\"line\">android:phonenumber</div><div class=\"line\">是否使用电话号码输入方式</div><div class=\"line\">android:privateImeOptions</div><div class=\"line\">设置输入法选项 </div><div class=\"line\">android:scrollHorizontally</div><div class=\"line\">设置文本超出TextView的宽度的情况下，是否出现横拉条 </div><div class=\"line\">android:selectAllOnFocus</div><div class=\"line\">如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</div><div class=\"line\">android:shadowColor</div><div class=\"line\">文本阴影颜色</div><div class=\"line\">android:shadowDx</div><div class=\"line\">阴影的水平偏移</div><div class=\"line\">android:shadowDy</div><div class=\"line\">阴影的垂直偏移</div><div class=\"line\">android:shadowRadius</div><div class=\"line\">阴影的半径</div><div class=\"line\">android:singleLine</div><div class=\"line\">是否单行（不自动换行）</div><div class=\"line\">android:text</div><div class=\"line\">显示的文本内容</div><div class=\"line\">android:textApperance</div><div class=\"line\">基本字体颜色、字样、大小和样式</div><div class=\"line\">android:textColor</div><div class=\"line\">文本颜色</div><div class=\"line\">android: textColorHighlight</div><div class=\"line\">文本高亮颜色</div><div class=\"line\">android: textColorHint</div><div class=\"line\">文本提示颜色</div><div class=\"line\">android:textColorLink</div><div class=\"line\">文本链接颜色</div><div class=\"line\">android:textScaleX</div><div class=\"line\">文本缩放因数</div><div class=\"line\">android:textSize</div><div class=\"line\">文本大小</div><div class=\"line\">android:textStyle</div><div class=\"line\">文本样式，取值为下列之一：</div><div class=\"line\">bold粗体</div><div class=\"line\">italic斜体</div><div class=\"line\">bolditalic粗斜体</div><div class=\"line\">android:typeface</div><div class=\"line\">字样</div><div class=\"line\">android:width</div><div class=\"line\">物体的高度</div><div class=\"line\"></div><div class=\"line\">AutoCompleteTextView属性说明</div><div class=\"line\"></div><div class=\"line\">android:completionHint</div><div class=\"line\">显示提示</div><div class=\"line\">android:completionHintView</div><div class=\"line\">提示视图</div><div class=\"line\">android:completionThreshold</div><div class=\"line\">设置开始提示的字符数</div><div class=\"line\">android:dropDownAnchor</div><div class=\"line\">下拉框链接视图</div><div class=\"line\">android:dropDownSelector</div><div class=\"line\">下拉框选择器</div><div class=\"line\">android:dropDownWIdth</div><div class=\"line\">下拉框宽度</div><div class=\"line\"></div><div class=\"line\">ImageView属性说明</div><div class=\"line\"></div><div class=\"line\">android:adjustViewBounds</div><div class=\"line\">是否调整视图范围</div><div class=\"line\">android:baselineAlignBottom</div><div class=\"line\">是否按照下端基线对齐</div><div class=\"line\">android:cropToPadding</div><div class=\"line\">是否按照填充进行裁剪</div><div class=\"line\">android:maxHeight</div><div class=\"line\">设置最大高度</div><div class=\"line\">android:maxWidth</div><div class=\"line\">设置最大宽度</div><div class=\"line\">android:scaleType</div><div class=\"line\">缩放类型，取值为下列之一：</div><div class=\"line\">matrix图片真实大小</div><div class=\"line\">fitXY适合图片大小</div><div class=\"line\">fitStart</div><div class=\"line\">fitCenter</div><div class=\"line\">fitEnd</div><div class=\"line\">center居中显示</div><div class=\"line\">centerCrop</div><div class=\"line\">centerInside</div><div class=\"line\">android:src</div><div class=\"line\">设置绘制用内容</div><div class=\"line\">android:tint</div><div class=\"line\">设置染色颜色值</div><div class=\"line\">android:layout_above=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件置于给定ID控件之上 </div><div class=\"line\">android:layout_below=<span class=\"string\">\"@id/xxx\"</span></div><div class=\"line\">将控件置于给定ID控件之下</div><div class=\"line\">android:layout_toLeftOf=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的右边缘和给定ID控件的左边缘对齐 </div><div class=\"line\">android:layout_toRightOf=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的左边缘和给定ID控件的右边缘对齐</div><div class=\"line\">android:layout_alignLeft=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的左边缘和给定ID控件的左边缘对齐</div><div class=\"line\">android:layout_alignTop=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的上边缘和给定ID控件的上边缘对齐</div><div class=\"line\"> </div><div class=\"line\">android:layout_alignRight=<span class=\"string\">\"@id/xxx\"</span></div><div class=\"line\">将控件的右边缘和给定ID控件的右边缘对齐</div><div class=\"line\">android:layout_alignBottom=<span class=\"string\">\"@id/xxx\"</span> </div><div class=\"line\">将控件的底边缘和给定ID控件的底边缘对齐 </div><div class=\"line\">android:layout_alignParentLeft=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的左边缘和父控件的左边缘对齐 </div><div class=\"line\">android:layout_alignParentTop=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的上边缘和父控件的上边缘对齐 </div><div class=\"line\">android:layout_alignParentRight=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的右边缘和父控件的右边缘对齐 </div><div class=\"line\">android:layout_alignParentBottom=<span class=\"string\">\"true\"</span> </div><div class=\"line\">将控件的底边缘和父控件的底边缘对齐</div><div class=\"line\"> android:layout_centerInParent=<span class=\"string\">\"true\"</span> </div><div class=\"line\"> 将控件置于父控件的中心位置 </div><div class=\"line\"> </div><div class=\"line\"> android:layout_centerHorizontal=<span class=\"string\">\"true\"</span> </div><div class=\"line\"> 将控件置于水平方向的中心位置 </div><div class=\"line\"> </div><div class=\"line\"> android:layout_centerVertical=<span class=\"string\">\"true\"</span> </div><div class=\"line\"> 将控件置于垂直方向的中心位置</div></pre></td></tr></table></figure>"},{"title":"java线程池的实现原理","date":"2017-04-30T11:17:45.000Z","_content":"\n原本只打算写一点关于线程池的实现原理，后来发现坑越挖越大。不得不写到一半停下来，所以，这算是一篇不那么完善的关于原理的解析吧。\n![](http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600)\n<!--more-->\n\n1. 线程池的常规使用方式\n通常说的线程池对外表现为具有一系列操作功能的接口，Executor提供了execute一个runnable的功能，而其子类ExecutorService则对外提供了更多的实用功能，所以平时用的都是ExecutorService的实现类。\n```java\n\npublic interface Executor {\n\n    /**\n     * Executes the given command at some time in the future.  The command\n     * may execute in a new thread, in a pooled thread, or in the calling\n     * thread, at the discretion of the {@code Executor} implementation.\n     *\n     * @param command the runnable task\n     * @throws RejectedExecutionException if this task cannot be\n     * accepted for execution\n     * @throws NullPointerException if command is null\n     */\n    void execute(Runnable command);\n}\n\n\npublic interface ExecutorService extends Executor{\n\t\n}\n\n\npublic abstract class AbstractExecutorService implements ExecutorService {\n\t\n}\npublic class ThreadPoolExecutor extends AbstractExecutorService {\n\t\n}\n```\n更具体一点来说，java.util.concurrent.ThreadPoolExecutor这个类提供了上述接口的具体实现，同时对外提供了一些hook(beforeExecute、afterExecute等)，当然开发者也可以继承这个方法，实现更多自定义功能。\n它的构造函数如下：\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), defaultHandler);\n    }\n```\n但实际上，java不建议这样直接弄一个线程池出来，而是使用java.util.concurrent.Executors中的一些现成的工厂方法来创建一个线程池实例，具体的方法名很好理解，newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool等等。关于线程池构造函数各个参数的意义以及Executors提供的各种线程方法的适用场合，网上有很多详尽的文章。\n\n\n```java\nThread有这些状态\n    */\n    public enum State {\n        NEW,\n        RUNNABLE,\n        BLOCKED,\n        WAITING,\n        TIMED_WAITING,\n        TERMINATED;\n    }\n```\n\n这里针对execute方法具体的实现来展开，即，如何做到自动扩容，如何做到线程缓存，如何实现终止，以及资源同步问题。\n```java\n public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        /*\n         * Proceed in 3 steps:\n         *\n         * 1. If fewer than corePoolSize threads are running, try to\n         * start a new thread with the given command as its first\n         * task.  The call to addWorker atomically checks runState and\n         * workerCount, and so prevents false alarms that would add\n         * threads when it shouldn't, by returning false.\n         *\n         * 2. If a task can be successfully queued, then we still need\n         * to double-check whether we should have added a thread\n         * (because existing ones died since last checking，上一次检查之后可能有线程挂掉了) or that\n         * the pool shut down since entry into this method. So we\n         * recheck state and if necessary roll back the enqueuing if\n         * stopped, or start a new thread if there are none.\n         *\n         * 3. If we cannot queue task, then we try to add a new\n         * thread.  If it fails, we know we are shut down or saturated\n         * and so reject the task.\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) { //\n       // Core pool size is the minimum number of workers to keep alive (and not allow to time out etc)\n        unless allowCoreThreadTimeOut is set, in which case the minimum is zero.\n            if (addWorker(command, true))//true表示创建新的Worker时的上限是coolPoolSize,false表示上限是maximunPoolSize\n            一般前者都小于等于后者，成功创建新的Worker并执行任务的话,直接在这里就return掉了\n                return;\n            c = ctl.get(); //当前pool的state,ctl是一个AtomicInteger\n        }\n        if (isRunning(c) && workQueue.offer(command)) {//addworker就是创建一个新的Worker并立即执行command，没能成功就得暂时放进queue了。offer就是往这里面加一个runnable\n            int recheck = ctl.get();//recheck的原因源码中也说明了\n           //走到这一步，说明已经成功加入到队列中了。\n            if (! isRunning(recheck) && remove(command))\n                reject(command);//pool随时可能会被关掉\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n\n        }\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n来看addWorker的实现\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        、、、省略代码\n        try {\n            w = new Worker(firstTask);\n            //每一个不为null的command都会创建一个新的worker\n            final Thread t = w.thread;\n            if (t != null) {\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();//加锁\n                try {\n                        workers.add(w); //workers就是一个普通的HashSet,同步的问题通过ReentrantLock解决\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    t.start(); //这里就是真正执行command的方法了\n                    workerStarted = true;\n                }\n            }\n        } \n        return workerStarted; //这里可以看出来,addWorker返回值表示这个command有没有被执行\n    }\n\n\n\n final void runWorker(Worker w) { //每一条线程运行起来的时候都会走这个方法\n        try {\n            while (task != null || (task = getTask()) != null) {\n                w.lock();//task可能是第一个runnable，也可能是从queue中取出来的\n                //getTask方法就是不断的从队列中获取任务。注意之前addTask的方法入参说明,command是该worker执行的第一个任务。也就是说，一个worker之后还有可能从queue中获取新的任务。线程能够一直有任务执行，就不会进入死亡状态(Thread有几个状态)\n                try {\n                    beforeExecute(wt, task);//钩子\n                    Throwable thrown = null;\n                    try {\n                        task.run(); \n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);//钩子\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }    \n```\naddWorker会创建一个新的Worker(线程)，并将command作为这个线程要执行的第一个任务，而Worker的run方法是线程跑起来执行的方法。至于如何实现从queue中获取任务交给线程去完成，看getTask方法\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n\n        for (;;) { //轮询\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : //从queue中提取任务\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                \n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n整体来说，executor.execute方法就是通过new出Woker，而Worker则会在run方法中不停的从queue中获取新的任务，从而确保线程不会挂掉。也就是所谓的线程池缓存了线程，避免了频繁创建线程的开销。\n\n\n2. Worker这个类继承自AbstractQueuedSynchronizer\nAbstractQueuedSynchronizer即大名鼎鼎的AQS。\n\n\n3. Reetranlock的使用\n这其中有\n注意上面使用了重入锁 ReentrantLock，后来发现ThreadPoolExecutor中多处使用了这个类。\n\n4. Future,Callable,FutureTask等等\n\n最后，今天下午看到很多jdk里源码的注释，作者都是 Doug Lea ，实在佩服前人的功力。之前也看过一些自定义线程池的实现，现在看起来确实差很多，不要重复造轮子不意味着不需要去了解轮子是怎么造出来的。\n\nReference \n1. [Java 多线程：线程池实现原理](https://github.com/pzxwhc/MineKnowContainer/issues/9)","source":"_posts/2017-04-30-concurrency-and-beyond.md","raw":"---\ntitle: java线程池的实现原理\ndate: 2017-04-30 19:17:45\ntags: [concurrency]\n---\n\n原本只打算写一点关于线程池的实现原理，后来发现坑越挖越大。不得不写到一半停下来，所以，这算是一篇不那么完善的关于原理的解析吧。\n![](http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600)\n<!--more-->\n\n1. 线程池的常规使用方式\n通常说的线程池对外表现为具有一系列操作功能的接口，Executor提供了execute一个runnable的功能，而其子类ExecutorService则对外提供了更多的实用功能，所以平时用的都是ExecutorService的实现类。\n```java\n\npublic interface Executor {\n\n    /**\n     * Executes the given command at some time in the future.  The command\n     * may execute in a new thread, in a pooled thread, or in the calling\n     * thread, at the discretion of the {@code Executor} implementation.\n     *\n     * @param command the runnable task\n     * @throws RejectedExecutionException if this task cannot be\n     * accepted for execution\n     * @throws NullPointerException if command is null\n     */\n    void execute(Runnable command);\n}\n\n\npublic interface ExecutorService extends Executor{\n\t\n}\n\n\npublic abstract class AbstractExecutorService implements ExecutorService {\n\t\n}\npublic class ThreadPoolExecutor extends AbstractExecutorService {\n\t\n}\n```\n更具体一点来说，java.util.concurrent.ThreadPoolExecutor这个类提供了上述接口的具体实现，同时对外提供了一些hook(beforeExecute、afterExecute等)，当然开发者也可以继承这个方法，实现更多自定义功能。\n它的构造函数如下：\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), defaultHandler);\n    }\n```\n但实际上，java不建议这样直接弄一个线程池出来，而是使用java.util.concurrent.Executors中的一些现成的工厂方法来创建一个线程池实例，具体的方法名很好理解，newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool等等。关于线程池构造函数各个参数的意义以及Executors提供的各种线程方法的适用场合，网上有很多详尽的文章。\n\n\n```java\nThread有这些状态\n    */\n    public enum State {\n        NEW,\n        RUNNABLE,\n        BLOCKED,\n        WAITING,\n        TIMED_WAITING,\n        TERMINATED;\n    }\n```\n\n这里针对execute方法具体的实现来展开，即，如何做到自动扩容，如何做到线程缓存，如何实现终止，以及资源同步问题。\n```java\n public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        /*\n         * Proceed in 3 steps:\n         *\n         * 1. If fewer than corePoolSize threads are running, try to\n         * start a new thread with the given command as its first\n         * task.  The call to addWorker atomically checks runState and\n         * workerCount, and so prevents false alarms that would add\n         * threads when it shouldn't, by returning false.\n         *\n         * 2. If a task can be successfully queued, then we still need\n         * to double-check whether we should have added a thread\n         * (because existing ones died since last checking，上一次检查之后可能有线程挂掉了) or that\n         * the pool shut down since entry into this method. So we\n         * recheck state and if necessary roll back the enqueuing if\n         * stopped, or start a new thread if there are none.\n         *\n         * 3. If we cannot queue task, then we try to add a new\n         * thread.  If it fails, we know we are shut down or saturated\n         * and so reject the task.\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) { //\n       // Core pool size is the minimum number of workers to keep alive (and not allow to time out etc)\n        unless allowCoreThreadTimeOut is set, in which case the minimum is zero.\n            if (addWorker(command, true))//true表示创建新的Worker时的上限是coolPoolSize,false表示上限是maximunPoolSize\n            一般前者都小于等于后者，成功创建新的Worker并执行任务的话,直接在这里就return掉了\n                return;\n            c = ctl.get(); //当前pool的state,ctl是一个AtomicInteger\n        }\n        if (isRunning(c) && workQueue.offer(command)) {//addworker就是创建一个新的Worker并立即执行command，没能成功就得暂时放进queue了。offer就是往这里面加一个runnable\n            int recheck = ctl.get();//recheck的原因源码中也说明了\n           //走到这一步，说明已经成功加入到队列中了。\n            if (! isRunning(recheck) && remove(command))\n                reject(command);//pool随时可能会被关掉\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n\n        }\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n来看addWorker的实现\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        、、、省略代码\n        try {\n            w = new Worker(firstTask);\n            //每一个不为null的command都会创建一个新的worker\n            final Thread t = w.thread;\n            if (t != null) {\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();//加锁\n                try {\n                        workers.add(w); //workers就是一个普通的HashSet,同步的问题通过ReentrantLock解决\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    t.start(); //这里就是真正执行command的方法了\n                    workerStarted = true;\n                }\n            }\n        } \n        return workerStarted; //这里可以看出来,addWorker返回值表示这个command有没有被执行\n    }\n\n\n\n final void runWorker(Worker w) { //每一条线程运行起来的时候都会走这个方法\n        try {\n            while (task != null || (task = getTask()) != null) {\n                w.lock();//task可能是第一个runnable，也可能是从queue中取出来的\n                //getTask方法就是不断的从队列中获取任务。注意之前addTask的方法入参说明,command是该worker执行的第一个任务。也就是说，一个worker之后还有可能从queue中获取新的任务。线程能够一直有任务执行，就不会进入死亡状态(Thread有几个状态)\n                try {\n                    beforeExecute(wt, task);//钩子\n                    Throwable thrown = null;\n                    try {\n                        task.run(); \n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);//钩子\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }    \n```\naddWorker会创建一个新的Worker(线程)，并将command作为这个线程要执行的第一个任务，而Worker的run方法是线程跑起来执行的方法。至于如何实现从queue中获取任务交给线程去完成，看getTask方法\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n\n        for (;;) { //轮询\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : //从queue中提取任务\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                \n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n整体来说，executor.execute方法就是通过new出Woker，而Worker则会在run方法中不停的从queue中获取新的任务，从而确保线程不会挂掉。也就是所谓的线程池缓存了线程，避免了频繁创建线程的开销。\n\n\n2. Worker这个类继承自AbstractQueuedSynchronizer\nAbstractQueuedSynchronizer即大名鼎鼎的AQS。\n\n\n3. Reetranlock的使用\n这其中有\n注意上面使用了重入锁 ReentrantLock，后来发现ThreadPoolExecutor中多处使用了这个类。\n\n4. Future,Callable,FutureTask等等\n\n最后，今天下午看到很多jdk里源码的注释，作者都是 Doug Lea ，实在佩服前人的功力。之前也看过一些自定义线程池的实现，现在看起来确实差很多，不要重复造轮子不意味着不需要去了解轮子是怎么造出来的。\n\nReference \n1. [Java 多线程：线程池实现原理](https://github.com/pzxwhc/MineKnowContainer/issues/9)","slug":"2017-04-30-concurrency-and-beyond","published":1,"updated":"2017-06-18T09:04:26.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdni3001ibovr3vaesbne","content":"<p>原本只打算写一点关于线程池的实现原理，后来发现坑越挖越大。不得不写到一半停下来，所以，这算是一篇不那么完善的关于原理的解析吧。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<ol>\n<li>线程池的常规使用方式<br>通常说的线程池对外表现为具有一系列操作功能的接口，Executor提供了execute一个runnable的功能，而其子类ExecutorService则对外提供了更多的实用功能，所以平时用的都是ExecutorService的实现类。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Executes the given command at some time in the future.  The command</div><div class=\"line\">     * may execute in a new thread, in a pooled thread, or in the calling</div><div class=\"line\">     * thread, at the discretion of the &#123;<span class=\"doctag\">@code</span> Executor&#125; implementation.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> command the runnable task</div><div class=\"line\">     * <span class=\"doctag\">@throws</span> RejectedExecutionException if this task cannot be</div><div class=\"line\">     * accepted for execution</div><div class=\"line\">     * <span class=\"doctag\">@throws</span> NullPointerException if command is null</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span></span>&#123;</div><div class=\"line\">true</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractExecutorService</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExecutorService</span> </span>&#123;</div><div class=\"line\">true</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPoolExecutor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractExecutorService</span> </span>&#123;</div><div class=\"line\">true</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>更具体一点来说，java.util.concurrent.ThreadPoolExecutor这个类提供了上述接口的具体实现，同时对外提供了一些hook(beforeExecute、afterExecute等)，当然开发者也可以继承这个方法，实现更多自定义功能。<br>它的构造函数如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ThreadPoolExecutor(int corePoolSize,</div><div class=\"line\">                              int maximumPoolSize,</div><div class=\"line\">                              long keepAliveTime,</div><div class=\"line\">                              TimeUnit unit,</div><div class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class=\"line\">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class=\"line\">             Executors.defaultThreadFactory(), defaultHandler);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>但实际上，java不建议这样直接弄一个线程池出来，而是使用java.util.concurrent.Executors中的一些现成的工厂方法来创建一个线程池实例，具体的方法名很好理解，newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool等等。关于线程池构造函数各个参数的意义以及Executors提供的各种线程方法的适用场合，网上有很多详尽的文章。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread有这些状态</div><div class=\"line\">    */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">        NEW,</div><div class=\"line\">        RUNNABLE,</div><div class=\"line\">        BLOCKED,</div><div class=\"line\">        WAITING,</div><div class=\"line\">        TIMED_WAITING,</div><div class=\"line\">        TERMINATED;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这里针对execute方法具体的实现来展开，即，如何做到自动扩容，如何做到线程缓存，如何实现终止，以及资源同步问题。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">       <span class=\"comment\">/*</div><div class=\"line\">        * Proceed in 3 steps:</div><div class=\"line\">        *</div><div class=\"line\">        * 1. If fewer than corePoolSize threads are running, try to</div><div class=\"line\">        * start a new thread with the given command as its first</div><div class=\"line\">        * task.  The call to addWorker atomically checks runState and</div><div class=\"line\">        * workerCount, and so prevents false alarms that would add</div><div class=\"line\">        * threads when it shouldn't, by returning false.</div><div class=\"line\">        *</div><div class=\"line\">        * 2. If a task can be successfully queued, then we still need</div><div class=\"line\">        * to double-check whether we should have added a thread</div><div class=\"line\">        * (because existing ones died since last checking，上一次检查之后可能有线程挂掉了) or that</div><div class=\"line\">        * the pool shut down since entry into this method. So we</div><div class=\"line\">        * recheck state and if necessary roll back the enqueuing if</div><div class=\"line\">        * stopped, or start a new thread if there are none.</div><div class=\"line\">        *</div><div class=\"line\">        * 3. If we cannot queue task, then we try to add a new</div><div class=\"line\">        * thread.  If it fails, we know we are shut down or saturated</div><div class=\"line\">        * and so reject the task.</div><div class=\"line\">        */</span></div><div class=\"line\">       <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">       <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class=\"comment\">//</span></div><div class=\"line\">      <span class=\"comment\">// Core pool size is the minimum number of workers to keep alive (and not allow to time out etc)</span></div><div class=\"line\">       unless allowCoreThreadTimeOut is set, in which <span class=\"keyword\">case</span> the minimum is zero.</div><div class=\"line\">           <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))<span class=\"comment\">//true表示创建新的Worker时的上限是coolPoolSize,false表示上限是maximunPoolSize</span></div><div class=\"line\">           一般前者都小于等于后者，成功创建新的Worker并执行任务的话,直接在这里就<span class=\"keyword\">return</span>掉了</div><div class=\"line\">               <span class=\"keyword\">return</span>;</div><div class=\"line\">           c = ctl.get(); <span class=\"comment\">//当前pool的state,ctl是一个AtomicInteger</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class=\"comment\">//addworker就是创建一个新的Worker并立即执行command，没能成功就得暂时放进queue了。offer就是往这里面加一个runnable</span></div><div class=\"line\">           <span class=\"keyword\">int</span> recheck = ctl.get();<span class=\"comment\">//recheck的原因源码中也说明了</span></div><div class=\"line\">          <span class=\"comment\">//走到这一步，说明已经成功加入到队列中了。</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class=\"line\">               reject(command);<span class=\"comment\">//pool随时可能会被关掉</span></div><div class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</div><div class=\"line\">               addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</div><div class=\"line\">           reject(command);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>来看addWorker的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</div><div class=\"line\">        retry:</div><div class=\"line\">        、、、省略代码</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            w = <span class=\"keyword\">new</span> Worker(firstTask);</div><div class=\"line\">            <span class=\"comment\">//每一个不为null的command都会创建一个新的worker</span></div><div class=\"line\">            <span class=\"keyword\">final</span> Thread t = w.thread;</div><div class=\"line\">            <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</div><div class=\"line\">                mainLock.lock();<span class=\"comment\">//加锁</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        workers.add(w); <span class=\"comment\">//workers就是一个普通的HashSet,同步的问题通过ReentrantLock解决</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    mainLock.unlock();</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (workerAdded) &#123;</div><div class=\"line\">                    t.start(); <span class=\"comment\">//这里就是真正执行command的方法了</span></div><div class=\"line\">                    workerStarted = <span class=\"keyword\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; </div><div class=\"line\">        <span class=\"keyword\">return</span> workerStarted; <span class=\"comment\">//这里可以看出来,addWorker返回值表示这个command有没有被执行</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123; <span class=\"comment\">//每一条线程运行起来的时候都会走这个方法</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                w.lock();<span class=\"comment\">//task可能是第一个runnable，也可能是从queue中取出来的</span></div><div class=\"line\">                <span class=\"comment\">//getTask方法就是不断的从队列中获取任务。注意之前addTask的方法入参说明,command是该worker执行的第一个任务。也就是说，一个worker之后还有可能从queue中获取新的任务。线程能够一直有任务执行，就不会进入死亡状态(Thread有几个状态)</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    beforeExecute(wt, task);<span class=\"comment\">//钩子</span></div><div class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        task.run(); </div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</div><div class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                        afterExecute(task, thrown);<span class=\"comment\">//钩子</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    task = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    w.completedTasks++;</div><div class=\"line\">                    w.unlock();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            processWorkerExit(w, completedAbruptly);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>addWorker会创建一个新的Worker(线程)，并将command作为这个线程要执行的第一个任务，而Worker的run方法是线程跑起来执行的方法。至于如何实现从queue中获取任务交给线程去完成，看getTask方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123; <span class=\"comment\">//轮询</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                Runnable r = timed ?</div><div class=\"line\">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class=\"comment\">//从queue中提取任务</span></div><div class=\"line\">                    workQueue.take();</div><div class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</div><div class=\"line\">                    <span class=\"keyword\">return</span> r;</div><div class=\"line\">                </div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</div><div class=\"line\">                timedOut = <span class=\"keyword\">false</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>整体来说，executor.execute方法就是通过new出Woker，而Worker则会在run方法中不停的从queue中获取新的任务，从而确保线程不会挂掉。也就是所谓的线程池缓存了线程，避免了频繁创建线程的开销。</p>\n<ol>\n<li>Worker这个类继承自AbstractQueuedSynchronizer<br>AbstractQueuedSynchronizer即大名鼎鼎的AQS。</li>\n</ol>\n<ol>\n<li><p>Reetranlock的使用<br>这其中有<br>注意上面使用了重入锁 ReentrantLock，后来发现ThreadPoolExecutor中多处使用了这个类。</p>\n</li>\n<li><p>Future,Callable,FutureTask等等</p>\n</li>\n</ol>\n<p>最后，今天下午看到很多jdk里源码的注释，作者都是 Doug Lea ，实在佩服前人的功力。之前也看过一些自定义线程池的实现，现在看起来确实差很多，不要重复造轮子不意味着不需要去了解轮子是怎么造出来的。</p>\n<p>Reference </p>\n<ol>\n<li><a href=\"https://github.com/pzxwhc/MineKnowContainer/issues/9\">Java 多线程：线程池实现原理</a></li>\n</ol>\n","excerpt":"<p>原本只打算写一点关于线程池的实现原理，后来发现坑越挖越大。不得不写到一半停下来，所以，这算是一篇不那么完善的关于原理的解析吧。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<ol>\n<li>线程池的常规使用方式<br>通常说的线程池对外表现为具有一系列操作功能的接口，Executor提供了execute一个runnable的功能，而其子类ExecutorService则对外提供了更多的实用功能，所以平时用的都是ExecutorService的实现类。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Executes the given command at some time in the future.  The command</div><div class=\"line\">     * may execute in a new thread, in a pooled thread, or in the calling</div><div class=\"line\">     * thread, at the discretion of the &#123;<span class=\"doctag\">@code</span> Executor&#125; implementation.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> command the runnable task</div><div class=\"line\">     * <span class=\"doctag\">@throws</span> RejectedExecutionException if this task cannot be</div><div class=\"line\">     * accepted for execution</div><div class=\"line\">     * <span class=\"doctag\">@throws</span> NullPointerException if command is null</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span></span>&#123;</div><div class=\"line\">true</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractExecutorService</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExecutorService</span> </span>&#123;</div><div class=\"line\">true</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPoolExecutor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractExecutorService</span> </span>&#123;</div><div class=\"line\">true</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>更具体一点来说，java.util.concurrent.ThreadPoolExecutor这个类提供了上述接口的具体实现，同时对外提供了一些hook(beforeExecute、afterExecute等)，当然开发者也可以继承这个方法，实现更多自定义功能。<br>它的构造函数如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ThreadPoolExecutor(int corePoolSize,</div><div class=\"line\">                              int maximumPoolSize,</div><div class=\"line\">                              long keepAliveTime,</div><div class=\"line\">                              TimeUnit unit,</div><div class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class=\"line\">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class=\"line\">             Executors.defaultThreadFactory(), defaultHandler);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>但实际上，java不建议这样直接弄一个线程池出来，而是使用java.util.concurrent.Executors中的一些现成的工厂方法来创建一个线程池实例，具体的方法名很好理解，newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool等等。关于线程池构造函数各个参数的意义以及Executors提供的各种线程方法的适用场合，网上有很多详尽的文章。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread有这些状态</div><div class=\"line\">    */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</div><div class=\"line\">        NEW,</div><div class=\"line\">        RUNNABLE,</div><div class=\"line\">        BLOCKED,</div><div class=\"line\">        WAITING,</div><div class=\"line\">        TIMED_WAITING,</div><div class=\"line\">        TERMINATED;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这里针对execute方法具体的实现来展开，即，如何做到自动扩容，如何做到线程缓存，如何实现终止，以及资源同步问题。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">       <span class=\"comment\">/*</div><div class=\"line\">        * Proceed in 3 steps:</div><div class=\"line\">        *</div><div class=\"line\">        * 1. If fewer than corePoolSize threads are running, try to</div><div class=\"line\">        * start a new thread with the given command as its first</div><div class=\"line\">        * task.  The call to addWorker atomically checks runState and</div><div class=\"line\">        * workerCount, and so prevents false alarms that would add</div><div class=\"line\">        * threads when it shouldn't, by returning false.</div><div class=\"line\">        *</div><div class=\"line\">        * 2. If a task can be successfully queued, then we still need</div><div class=\"line\">        * to double-check whether we should have added a thread</div><div class=\"line\">        * (because existing ones died since last checking，上一次检查之后可能有线程挂掉了) or that</div><div class=\"line\">        * the pool shut down since entry into this method. So we</div><div class=\"line\">        * recheck state and if necessary roll back the enqueuing if</div><div class=\"line\">        * stopped, or start a new thread if there are none.</div><div class=\"line\">        *</div><div class=\"line\">        * 3. If we cannot queue task, then we try to add a new</div><div class=\"line\">        * thread.  If it fails, we know we are shut down or saturated</div><div class=\"line\">        * and so reject the task.</div><div class=\"line\">        */</span></div><div class=\"line\">       <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">       <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class=\"comment\">//</span></div><div class=\"line\">      <span class=\"comment\">// Core pool size is the minimum number of workers to keep alive (and not allow to time out etc)</span></div><div class=\"line\">       unless allowCoreThreadTimeOut is set, in which <span class=\"keyword\">case</span> the minimum is zero.</div><div class=\"line\">           <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))<span class=\"comment\">//true表示创建新的Worker时的上限是coolPoolSize,false表示上限是maximunPoolSize</span></div><div class=\"line\">           一般前者都小于等于后者，成功创建新的Worker并执行任务的话,直接在这里就<span class=\"keyword\">return</span>掉了</div><div class=\"line\">               <span class=\"keyword\">return</span>;</div><div class=\"line\">           c = ctl.get(); <span class=\"comment\">//当前pool的state,ctl是一个AtomicInteger</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class=\"comment\">//addworker就是创建一个新的Worker并立即执行command，没能成功就得暂时放进queue了。offer就是往这里面加一个runnable</span></div><div class=\"line\">           <span class=\"keyword\">int</span> recheck = ctl.get();<span class=\"comment\">//recheck的原因源码中也说明了</span></div><div class=\"line\">          <span class=\"comment\">//走到这一步，说明已经成功加入到队列中了。</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class=\"line\">               reject(command);<span class=\"comment\">//pool随时可能会被关掉</span></div><div class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</div><div class=\"line\">               addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</div><div class=\"line\">           reject(command);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>来看addWorker的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</div><div class=\"line\">        retry:</div><div class=\"line\">        、、、省略代码</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            w = <span class=\"keyword\">new</span> Worker(firstTask);</div><div class=\"line\">            <span class=\"comment\">//每一个不为null的command都会创建一个新的worker</span></div><div class=\"line\">            <span class=\"keyword\">final</span> Thread t = w.thread;</div><div class=\"line\">            <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</div><div class=\"line\">                mainLock.lock();<span class=\"comment\">//加锁</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        workers.add(w); <span class=\"comment\">//workers就是一个普通的HashSet,同步的问题通过ReentrantLock解决</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    mainLock.unlock();</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (workerAdded) &#123;</div><div class=\"line\">                    t.start(); <span class=\"comment\">//这里就是真正执行command的方法了</span></div><div class=\"line\">                    workerStarted = <span class=\"keyword\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; </div><div class=\"line\">        <span class=\"keyword\">return</span> workerStarted; <span class=\"comment\">//这里可以看出来,addWorker返回值表示这个command有没有被执行</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123; <span class=\"comment\">//每一条线程运行起来的时候都会走这个方法</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                w.lock();<span class=\"comment\">//task可能是第一个runnable，也可能是从queue中取出来的</span></div><div class=\"line\">                <span class=\"comment\">//getTask方法就是不断的从队列中获取任务。注意之前addTask的方法入参说明,command是该worker执行的第一个任务。也就是说，一个worker之后还有可能从queue中获取新的任务。线程能够一直有任务执行，就不会进入死亡状态(Thread有几个状态)</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    beforeExecute(wt, task);<span class=\"comment\">//钩子</span></div><div class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        task.run(); </div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</div><div class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                        afterExecute(task, thrown);<span class=\"comment\">//钩子</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    task = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    w.completedTasks++;</div><div class=\"line\">                    w.unlock();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            processWorkerExit(w, completedAbruptly);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>addWorker会创建一个新的Worker(线程)，并将command作为这个线程要执行的第一个任务，而Worker的run方法是线程跑起来执行的方法。至于如何实现从queue中获取任务交给线程去完成，看getTask方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123; <span class=\"comment\">//轮询</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                Runnable r = timed ?</div><div class=\"line\">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class=\"comment\">//从queue中提取任务</span></div><div class=\"line\">                    workQueue.take();</div><div class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</div><div class=\"line\">                    <span class=\"keyword\">return</span> r;</div><div class=\"line\">                </div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</div><div class=\"line\">                timedOut = <span class=\"keyword\">false</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>整体来说，executor.execute方法就是通过new出Woker，而Worker则会在run方法中不停的从queue中获取新的任务，从而确保线程不会挂掉。也就是所谓的线程池缓存了线程，避免了频繁创建线程的开销。</p>\n<ol>\n<li>Worker这个类继承自AbstractQueuedSynchronizer<br>AbstractQueuedSynchronizer即大名鼎鼎的AQS。</li>\n</ol>\n<ol>\n<li><p>Reetranlock的使用<br>这其中有<br>注意上面使用了重入锁 ReentrantLock，后来发现ThreadPoolExecutor中多处使用了这个类。</p>\n</li>\n<li><p>Future,Callable,FutureTask等等</p>\n</li>\n</ol>\n<p>最后，今天下午看到很多jdk里源码的注释，作者都是 Doug Lea ，实在佩服前人的功力。之前也看过一些自定义线程池的实现，现在看起来确实差很多，不要重复造轮子不意味着不需要去了解轮子是怎么造出来的。</p>\n<p>Reference </p>\n<ol>\n<li><a href=\"https://github.com/pzxwhc/MineKnowContainer/issues/9\">Java 多线程：线程池实现原理</a></li>\n</ol>"},{"title":"VPS下载Youtube视频并同步到本地","date":"2017-05-07T08:48:01.000Z","_content":"\n几天前花几块钱买了个新的vps，试了下，速度不错。后来看到网上有关于如何使用vps下载视频并拖到Windows的，试了一下，确实酸爽。\n![](http://odzl05jxx.bkt.clouddn.com/4667305cbdace582c667f218e38fe70a.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n### 1. youtube下载视频到vps的硬盘上\n首先是安装一些必要的环境，我安装的系统是Ubuntu 14.0.4 ，这个版本默认的python是2.7。配置好pip,python等环境后，首先安装youtube-dl,基本上就是两行命令搞定的事情，参考[官网](http://rg3.github.io/youtube-dl/download.html)\n```\nsudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl\n\nsudo chmod a+rx /usr/local/bin/youtube-dl\n```\n\n为了方便管理，首先在/根目录下面创建一个文件夹并切换到该目录下\n> mkdir youtube   \n\n\n以一个普通的[视频链接](https://www.youtube.com/watch?v=7PtDrv5AUmA)为例 \n直接使用 \n> youtube-dl https://www.youtube.com/watch?v=7PtDrv5AUmA\n\n\n就能自动选择合适的格式，下载到当前目录。比较好的一点是，由于vps在美国，下载速度非常快，维持在20MB/ms的样子。下载好的文件会放在当前目录下，后面使用pscp工具从vps拖下来就好了，不过我实践下来，这一步往往是最慢的。关键要看vps到你的ip的速度。有些时候还会突然断掉，所以很麻烦。这个看后面能不能搞定百度云盘中转。\n还有一个要注意的，生成的文件名是随机的，比如\n> -yj74P_BY1zI.mp4\n\n由于前面带了一个横杠，很多命令是不认这种名字的，需要手动重命名一下 \n> mv -yj74P_BY1zI.mp4 porn.video\n> mv ./-yj74P_BY1zI.mp4 porn.video #. 表示当前目录\n\n\n\n\n有时候下载的文件带有空格，有时候带有中文，用单引号包起来就好了。\n\nyoutube-dl还有一些命令行参数可以设置\n> youtube-dl --all-formats https://www.youtube.com/watch?v=7PtDrv5AUmA\n\n\n这样会列出所有的可供下载的分辨率选项，每个选项前面带有一个序号，选择特定分辨率的选项下载只需要\n> youtube-dl -f 13 https://www.youtube.com/watch?v=7PtDrv5AUmA \n\n\n### 2.从vps的硬盘上把下载好的视频拖下来\nVPS下载视频的速度很快，但从vps到国内的速度就很慢了。\n目前可能的方案有从百度网盘或dropBox中转，测试了一下百度网盘的方案bypy，vps上传到网盘速度太慢，shell出现假死，据说是百度方面限速的原因，所以这条路基本也是堵上了的。\n\n\n### 3.后话\n[you-get](https://github.com/soimort/you-get)也是基于python3的下载工具，使用简单。在windows上安装还有点麻烦，\n在ubuntu上只需 pip3 install you-get 就安装好了\n使用方式更简单 > you-get \"url\"\nyou-get还提供了windows版本 下载youtube视频只需要\n> you-get -x 127.0.0.1:1080 -o \"D:\\Porn\" 'https://www.youtube.com/watch?v=jNQXAC9IVRw'\n\n\n\n[参考](https://doub.io/dbrj-1/)\n[百度云盘同步的方法](http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/)\n[讨论](https://www.v2ex.com/t/189034)\n","source":"_posts/2017-05-07-download-video-from-vps.md","raw":"---\ntitle: VPS下载Youtube视频并同步到本地\ndate: 2017-05-07 16:48:01\ncategories: blog\ntags: [linux,python]\n---\n\n几天前花几块钱买了个新的vps，试了下，速度不错。后来看到网上有关于如何使用vps下载视频并拖到Windows的，试了一下，确实酸爽。\n![](http://odzl05jxx.bkt.clouddn.com/4667305cbdace582c667f218e38fe70a.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n### 1. youtube下载视频到vps的硬盘上\n首先是安装一些必要的环境，我安装的系统是Ubuntu 14.0.4 ，这个版本默认的python是2.7。配置好pip,python等环境后，首先安装youtube-dl,基本上就是两行命令搞定的事情，参考[官网](http://rg3.github.io/youtube-dl/download.html)\n```\nsudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl\n\nsudo chmod a+rx /usr/local/bin/youtube-dl\n```\n\n为了方便管理，首先在/根目录下面创建一个文件夹并切换到该目录下\n> mkdir youtube   \n\n\n以一个普通的[视频链接](https://www.youtube.com/watch?v=7PtDrv5AUmA)为例 \n直接使用 \n> youtube-dl https://www.youtube.com/watch?v=7PtDrv5AUmA\n\n\n就能自动选择合适的格式，下载到当前目录。比较好的一点是，由于vps在美国，下载速度非常快，维持在20MB/ms的样子。下载好的文件会放在当前目录下，后面使用pscp工具从vps拖下来就好了，不过我实践下来，这一步往往是最慢的。关键要看vps到你的ip的速度。有些时候还会突然断掉，所以很麻烦。这个看后面能不能搞定百度云盘中转。\n还有一个要注意的，生成的文件名是随机的，比如\n> -yj74P_BY1zI.mp4\n\n由于前面带了一个横杠，很多命令是不认这种名字的，需要手动重命名一下 \n> mv -yj74P_BY1zI.mp4 porn.video\n> mv ./-yj74P_BY1zI.mp4 porn.video #. 表示当前目录\n\n\n\n\n有时候下载的文件带有空格，有时候带有中文，用单引号包起来就好了。\n\nyoutube-dl还有一些命令行参数可以设置\n> youtube-dl --all-formats https://www.youtube.com/watch?v=7PtDrv5AUmA\n\n\n这样会列出所有的可供下载的分辨率选项，每个选项前面带有一个序号，选择特定分辨率的选项下载只需要\n> youtube-dl -f 13 https://www.youtube.com/watch?v=7PtDrv5AUmA \n\n\n### 2.从vps的硬盘上把下载好的视频拖下来\nVPS下载视频的速度很快，但从vps到国内的速度就很慢了。\n目前可能的方案有从百度网盘或dropBox中转，测试了一下百度网盘的方案bypy，vps上传到网盘速度太慢，shell出现假死，据说是百度方面限速的原因，所以这条路基本也是堵上了的。\n\n\n### 3.后话\n[you-get](https://github.com/soimort/you-get)也是基于python3的下载工具，使用简单。在windows上安装还有点麻烦，\n在ubuntu上只需 pip3 install you-get 就安装好了\n使用方式更简单 > you-get \"url\"\nyou-get还提供了windows版本 下载youtube视频只需要\n> you-get -x 127.0.0.1:1080 -o \"D:\\Porn\" 'https://www.youtube.com/watch?v=jNQXAC9IVRw'\n\n\n\n[参考](https://doub.io/dbrj-1/)\n[百度云盘同步的方法](http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/)\n[讨论](https://www.v2ex.com/t/189034)\n","slug":"2017-05-07-download-video-from-vps","published":1,"updated":"2017-06-18T05:10:56.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnib001mbovr580nuzpn","content":"<p>几天前花几块钱买了个新的vps，试了下，速度不错。后来看到网上有关于如何使用vps下载视频并拖到Windows的，试了一下，确实酸爽。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/4667305cbdace582c667f218e38fe70a.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-youtube下载视频到vps的硬盘上\"><a href=\"#1-youtube下载视频到vps的硬盘上\" class=\"headerlink\" title=\"1. youtube下载视频到vps的硬盘上\"></a>1. youtube下载视频到vps的硬盘上</h3><p>首先是安装一些必要的环境，我安装的系统是Ubuntu 14.0.4 ，这个版本默认的python是2.7。配置好pip,python等环境后，首先安装youtube-dl,基本上就是两行命令搞定的事情，参考<a href=\"http://rg3.github.io/youtube-dl/download.html\">官网</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl</div><div class=\"line\"></div><div class=\"line\">sudo chmod a+rx /usr/local/bin/youtube-dl</div></pre></td></tr></table></figure></p>\n<p>为了方便管理，首先在/根目录下面创建一个文件夹并切换到该目录下</p>\n<blockquote>\n<p>mkdir youtube   </p>\n</blockquote>\n<p>以一个普通的<a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">视频链接</a>为例<br>直接使用 </p>\n<blockquote>\n<p>youtube-dl <a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">https://www.youtube.com/watch?v=7PtDrv5AUmA</a></p>\n</blockquote>\n<p>就能自动选择合适的格式，下载到当前目录。比较好的一点是，由于vps在美国，下载速度非常快，维持在20MB/ms的样子。下载好的文件会放在当前目录下，后面使用pscp工具从vps拖下来就好了，不过我实践下来，这一步往往是最慢的。关键要看vps到你的ip的速度。有些时候还会突然断掉，所以很麻烦。这个看后面能不能搞定百度云盘中转。<br>还有一个要注意的，生成的文件名是随机的，比如</p>\n<blockquote>\n<p>-yj74P_BY1zI.mp4</p>\n</blockquote>\n<p>由于前面带了一个横杠，很多命令是不认这种名字的，需要手动重命名一下 </p>\n<blockquote>\n<p>mv -yj74P_BY1zI.mp4 porn.video<br>mv ./-yj74P_BY1zI.mp4 porn.video #. 表示当前目录</p>\n</blockquote>\n<p>有时候下载的文件带有空格，有时候带有中文，用单引号包起来就好了。</p>\n<p>youtube-dl还有一些命令行参数可以设置</p>\n<blockquote>\n<p>youtube-dl –all-formats <a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">https://www.youtube.com/watch?v=7PtDrv5AUmA</a></p>\n</blockquote>\n<p>这样会列出所有的可供下载的分辨率选项，每个选项前面带有一个序号，选择特定分辨率的选项下载只需要</p>\n<blockquote>\n<p>youtube-dl -f 13 <a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">https://www.youtube.com/watch?v=7PtDrv5AUmA</a> </p>\n</blockquote>\n<h3 id=\"2-从vps的硬盘上把下载好的视频拖下来\"><a href=\"#2-从vps的硬盘上把下载好的视频拖下来\" class=\"headerlink\" title=\"2.从vps的硬盘上把下载好的视频拖下来\"></a>2.从vps的硬盘上把下载好的视频拖下来</h3><p>VPS下载视频的速度很快，但从vps到国内的速度就很慢了。<br>目前可能的方案有从百度网盘或dropBox中转，测试了一下百度网盘的方案bypy，vps上传到网盘速度太慢，shell出现假死，据说是百度方面限速的原因，所以这条路基本也是堵上了的。</p>\n<h3 id=\"3-后话\"><a href=\"#3-后话\" class=\"headerlink\" title=\"3.后话\"></a>3.后话</h3><p><a href=\"https://github.com/soimort/you-get\">you-get</a>也是基于python3的下载工具，使用简单。在windows上安装还有点麻烦，<br>在ubuntu上只需 pip3 install you-get 就安装好了<br>使用方式更简单 &gt; you-get “url”<br>you-get还提供了windows版本 下载youtube视频只需要</p>\n<blockquote>\n<p>you-get -x 127.0.0.1:1080 -o “D:\\Porn” ‘<a href=\"https://www.youtube.com/watch?v=jNQXAC9IVRw\">https://www.youtube.com/watch?v=jNQXAC9IVRw</a>‘</p>\n</blockquote>\n<p><a href=\"https://doub.io/dbrj-1/\">参考</a><br><a href=\"http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/\">百度云盘同步的方法</a><br><a href=\"https://www.v2ex.com/t/189034\">讨论</a></p>\n","excerpt":"<p>几天前花几块钱买了个新的vps，试了下，速度不错。后来看到网上有关于如何使用vps下载视频并拖到Windows的，试了一下，确实酸爽。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/4667305cbdace582c667f218e38fe70a.jpg?imageView2/2/w/600\" alt=\"\"></p>","more":"<h3 id=\"1-youtube下载视频到vps的硬盘上\"><a href=\"#1-youtube下载视频到vps的硬盘上\" class=\"headerlink\" title=\"1. youtube下载视频到vps的硬盘上\"></a>1. youtube下载视频到vps的硬盘上</h3><p>首先是安装一些必要的环境，我安装的系统是Ubuntu 14.0.4 ，这个版本默认的python是2.7。配置好pip,python等环境后，首先安装youtube-dl,基本上就是两行命令搞定的事情，参考<a href=\"http://rg3.github.io/youtube-dl/download.html\">官网</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl</div><div class=\"line\"></div><div class=\"line\">sudo chmod a+rx /usr/local/bin/youtube-dl</div></pre></td></tr></table></figure></p>\n<p>为了方便管理，首先在/根目录下面创建一个文件夹并切换到该目录下</p>\n<blockquote>\n<p>mkdir youtube   </p>\n</blockquote>\n<p>以一个普通的<a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">视频链接</a>为例<br>直接使用 </p>\n<blockquote>\n<p>youtube-dl <a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">https://www.youtube.com/watch?v=7PtDrv5AUmA</a></p>\n</blockquote>\n<p>就能自动选择合适的格式，下载到当前目录。比较好的一点是，由于vps在美国，下载速度非常快，维持在20MB/ms的样子。下载好的文件会放在当前目录下，后面使用pscp工具从vps拖下来就好了，不过我实践下来，这一步往往是最慢的。关键要看vps到你的ip的速度。有些时候还会突然断掉，所以很麻烦。这个看后面能不能搞定百度云盘中转。<br>还有一个要注意的，生成的文件名是随机的，比如</p>\n<blockquote>\n<p>-yj74P_BY1zI.mp4</p>\n</blockquote>\n<p>由于前面带了一个横杠，很多命令是不认这种名字的，需要手动重命名一下 </p>\n<blockquote>\n<p>mv -yj74P_BY1zI.mp4 porn.video<br>mv ./-yj74P_BY1zI.mp4 porn.video #. 表示当前目录</p>\n</blockquote>\n<p>有时候下载的文件带有空格，有时候带有中文，用单引号包起来就好了。</p>\n<p>youtube-dl还有一些命令行参数可以设置</p>\n<blockquote>\n<p>youtube-dl –all-formats <a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">https://www.youtube.com/watch?v=7PtDrv5AUmA</a></p>\n</blockquote>\n<p>这样会列出所有的可供下载的分辨率选项，每个选项前面带有一个序号，选择特定分辨率的选项下载只需要</p>\n<blockquote>\n<p>youtube-dl -f 13 <a href=\"https://www.youtube.com/watch?v=7PtDrv5AUmA\">https://www.youtube.com/watch?v=7PtDrv5AUmA</a> </p>\n</blockquote>\n<h3 id=\"2-从vps的硬盘上把下载好的视频拖下来\"><a href=\"#2-从vps的硬盘上把下载好的视频拖下来\" class=\"headerlink\" title=\"2.从vps的硬盘上把下载好的视频拖下来\"></a>2.从vps的硬盘上把下载好的视频拖下来</h3><p>VPS下载视频的速度很快，但从vps到国内的速度就很慢了。<br>目前可能的方案有从百度网盘或dropBox中转，测试了一下百度网盘的方案bypy，vps上传到网盘速度太慢，shell出现假死，据说是百度方面限速的原因，所以这条路基本也是堵上了的。</p>\n<h3 id=\"3-后话\"><a href=\"#3-后话\" class=\"headerlink\" title=\"3.后话\"></a>3.后话</h3><p><a href=\"https://github.com/soimort/you-get\">you-get</a>也是基于python3的下载工具，使用简单。在windows上安装还有点麻烦，<br>在ubuntu上只需 pip3 install you-get 就安装好了<br>使用方式更简单 &gt; you-get “url”<br>you-get还提供了windows版本 下载youtube视频只需要</p>\n<blockquote>\n<p>you-get -x 127.0.0.1:1080 -o “D:\\Porn” ‘<a href=\"https://www.youtube.com/watch?v=jNQXAC9IVRw\">https://www.youtube.com/watch?v=jNQXAC9IVRw</a>‘</p>\n</blockquote>\n<p><a href=\"https://doub.io/dbrj-1/\">参考</a><br><a href=\"http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/\">百度云盘同步的方法</a><br><a href=\"https://www.v2ex.com/t/189034\">讨论</a></p>"},{"title":"Python localHost部署命令","date":"2017-05-01T00:57:27.000Z","_content":"\n一行命令即可\n>  python -m http.server 8000 --bind 127.0.0.1 \n\n打开浏览器，输入127.0.0.1 ， 即可浏览当前目录下的文件，以GET的方式进行，命令行窗口会出现浏览记录。\n![](http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600)\n<!--more-->\n\n据说SimpleHttpServer也可以，\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\nimport sys\nfrom http.server import SimpleHTTPRequestHandler\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\n\ndef test(HandlerClass=SimpleHTTPRequestHandler,\n         ServerClass=HTTPServer):\n    protocol = \"HTTP/1.0\"\n    host = ''\n    port = 8000\n    if len(sys.argv) > 1:\n        arg = sys.argv[1]\n        if ':' in arg:\n            host, port = arg.split(':')\n            port = int(port)\n        else:\n            try:\n                port = int(sys.argv[1])\n            except:\n                host = sys.argv[1]\n\n    server_address = (host, port)\n\n    HandlerClass.protocol_version = protocol\n    httpd = ServerClass(server_address, HandlerClass)\n\n    sa = httpd.socket.getsockname()\n    print(\"Serving HTTP on\", sa[0], \"port\", sa[1], \"...\")\n    httpd.serve_forever()\n\n\nif __name__ == \"__main__\":\n    test()\n```\n\n\n### 2 .sys.args[]的使用\ncmd中\n> python\n\nPython 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n\n退出方式 ctrl+Z\n\n切换到脚本所在目录 ,例如test.py\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport sys\n\n# sys.argv接收参数，第一个参数是文件名，第二个参数开始是用户输入的参数，以空格隔开\n# cmd到该文件位置\n\ndef run1():\n    print('I\\'m action1')\n\n\ndef run2():\n    print('I\\'m action2')\n\n\nif 2 > len(sys.argv):\n    print('none')\nelse:\n    action1 = sys.argv[0]\n    action2 = sys.argv[1]\n    <!-- if 'run1' == action1:\n        run1()\n    if 'run2' == action2:\n        run2() -->\n\n    print(action1)\n    print(action2)    \n\n```\n\n输入 python test.py run1\n输出 test.py 'run1'","source":"_posts/2017-05-01-python-server-test.md","raw":"---\ntitle: Python localHost部署命令\ndate: 2017-05-01 08:57:27\ncategories: blog\ntags: [python]\n---\n\n一行命令即可\n>  python -m http.server 8000 --bind 127.0.0.1 \n\n打开浏览器，输入127.0.0.1 ， 即可浏览当前目录下的文件，以GET的方式进行，命令行窗口会出现浏览记录。\n![](http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600)\n<!--more-->\n\n据说SimpleHttpServer也可以，\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\nimport sys\nfrom http.server import SimpleHTTPRequestHandler\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\n\ndef test(HandlerClass=SimpleHTTPRequestHandler,\n         ServerClass=HTTPServer):\n    protocol = \"HTTP/1.0\"\n    host = ''\n    port = 8000\n    if len(sys.argv) > 1:\n        arg = sys.argv[1]\n        if ':' in arg:\n            host, port = arg.split(':')\n            port = int(port)\n        else:\n            try:\n                port = int(sys.argv[1])\n            except:\n                host = sys.argv[1]\n\n    server_address = (host, port)\n\n    HandlerClass.protocol_version = protocol\n    httpd = ServerClass(server_address, HandlerClass)\n\n    sa = httpd.socket.getsockname()\n    print(\"Serving HTTP on\", sa[0], \"port\", sa[1], \"...\")\n    httpd.serve_forever()\n\n\nif __name__ == \"__main__\":\n    test()\n```\n\n\n### 2 .sys.args[]的使用\ncmd中\n> python\n\nPython 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n\n退出方式 ctrl+Z\n\n切换到脚本所在目录 ,例如test.py\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport sys\n\n# sys.argv接收参数，第一个参数是文件名，第二个参数开始是用户输入的参数，以空格隔开\n# cmd到该文件位置\n\ndef run1():\n    print('I\\'m action1')\n\n\ndef run2():\n    print('I\\'m action2')\n\n\nif 2 > len(sys.argv):\n    print('none')\nelse:\n    action1 = sys.argv[0]\n    action2 = sys.argv[1]\n    <!-- if 'run1' == action1:\n        run1()\n    if 'run2' == action2:\n        run2() -->\n\n    print(action1)\n    print(action2)    \n\n```\n\n输入 python test.py run1\n输出 test.py 'run1'","slug":"2017-05-01-python-server-test","published":1,"updated":"2017-06-25T14:44:59.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnig001obovrmvw331y2","content":"<p>一行命令即可</p>\n<blockquote>\n<p> python -m http.server 8000 –bind 127.0.0.1 </p>\n</blockquote>\n<p>打开浏览器，输入127.0.0.1 ， 即可浏览当前目录下的文件，以GET的方式进行，命令行窗口会出现浏览记录。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<p>据说SimpleHttpServer也可以，<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">from</span> http.server <span class=\"keyword\">import</span> SimpleHTTPRequestHandler</div><div class=\"line\"><span class=\"keyword\">from</span> http.server <span class=\"keyword\">import</span> BaseHTTPRequestHandler, HTTPServer</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(HandlerClass=SimpleHTTPRequestHandler,</div><div class=\"line\">         ServerClass=HTTPServer)</span>:</span></div><div class=\"line\">    protocol = <span class=\"string\">\"HTTP/1.0\"</span></div><div class=\"line\">    host = <span class=\"string\">''</span></div><div class=\"line\">    port = <span class=\"number\">8000</span></div><div class=\"line\">    <span class=\"keyword\">if</span> len(sys.argv) &gt; <span class=\"number\">1</span>:</div><div class=\"line\">        arg = sys.argv[<span class=\"number\">1</span>]</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">':'</span> <span class=\"keyword\">in</span> arg:</div><div class=\"line\">            host, port = arg.split(<span class=\"string\">':'</span>)</div><div class=\"line\">            port = int(port)</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                port = int(sys.argv[<span class=\"number\">1</span>])</div><div class=\"line\">            <span class=\"keyword\">except</span>:</div><div class=\"line\">                host = sys.argv[<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\">    server_address = (host, port)</div><div class=\"line\"></div><div class=\"line\">    HandlerClass.protocol_version = protocol</div><div class=\"line\">    httpd = ServerClass(server_address, HandlerClass)</div><div class=\"line\"></div><div class=\"line\">    sa = httpd.socket.getsockname()</div><div class=\"line\">    print(<span class=\"string\">\"Serving HTTP on\"</span>, sa[<span class=\"number\">0</span>], <span class=\"string\">\"port\"</span>, sa[<span class=\"number\">1</span>], <span class=\"string\">\"...\"</span>)</div><div class=\"line\">    httpd.serve_forever()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    test()</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-sys-args-的使用\"><a href=\"#2-sys-args-的使用\" class=\"headerlink\" title=\"2 .sys.args[]的使用\"></a>2 .sys.args[]的使用</h3><p>cmd中</p>\n<blockquote>\n<p>python</p>\n</blockquote>\n<p>Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<p>退出方式 ctrl+Z</p>\n<p>切换到脚本所在目录 ,例如test.py</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/env python3</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\"># sys.argv接收参数，第一个参数是文件名，第二个参数开始是用户输入的参数，以空格隔开</div><div class=\"line\"># cmd到该文件位置</div><div class=\"line\"></div><div class=\"line\">def run1():</div><div class=\"line\">    print('I\\'m action1')</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def run2():</div><div class=\"line\">    print('I\\'m action2')</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if 2 &gt; len(sys.argv):</div><div class=\"line\">    print('none')</div><div class=\"line\">else:</div><div class=\"line\">    action1 = sys.argv[0]</div><div class=\"line\">    action2 = sys.argv[1]</div><div class=\"line\">    &lt;!-- if 'run1' == action1:</div><div class=\"line\">        run1()</div><div class=\"line\">    if 'run2' == action2:</div><div class=\"line\">        run2() --&gt;</div><div class=\"line\"></div><div class=\"line\">    print(action1)</div><div class=\"line\">    print(action2)</div></pre></td></tr></table></figure>\n<p>输入 python test.py run1<br>输出 test.py ‘run1’</p>\n","excerpt":"<p>一行命令即可</p>\n<blockquote>\n<p> python -m http.server 8000 –bind 127.0.0.1 </p>\n</blockquote>\n<p>打开浏览器，输入127.0.0.1 ， 即可浏览当前目录下的文件，以GET的方式进行，命令行窗口会出现浏览记录。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<p>据说SimpleHttpServer也可以，<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">from</span> http.server <span class=\"keyword\">import</span> SimpleHTTPRequestHandler</div><div class=\"line\"><span class=\"keyword\">from</span> http.server <span class=\"keyword\">import</span> BaseHTTPRequestHandler, HTTPServer</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(HandlerClass=SimpleHTTPRequestHandler,</div><div class=\"line\">         ServerClass=HTTPServer)</span>:</span></div><div class=\"line\">    protocol = <span class=\"string\">\"HTTP/1.0\"</span></div><div class=\"line\">    host = <span class=\"string\">''</span></div><div class=\"line\">    port = <span class=\"number\">8000</span></div><div class=\"line\">    <span class=\"keyword\">if</span> len(sys.argv) &gt; <span class=\"number\">1</span>:</div><div class=\"line\">        arg = sys.argv[<span class=\"number\">1</span>]</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">':'</span> <span class=\"keyword\">in</span> arg:</div><div class=\"line\">            host, port = arg.split(<span class=\"string\">':'</span>)</div><div class=\"line\">            port = int(port)</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                port = int(sys.argv[<span class=\"number\">1</span>])</div><div class=\"line\">            <span class=\"keyword\">except</span>:</div><div class=\"line\">                host = sys.argv[<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\">    server_address = (host, port)</div><div class=\"line\"></div><div class=\"line\">    HandlerClass.protocol_version = protocol</div><div class=\"line\">    httpd = ServerClass(server_address, HandlerClass)</div><div class=\"line\"></div><div class=\"line\">    sa = httpd.socket.getsockname()</div><div class=\"line\">    print(<span class=\"string\">\"Serving HTTP on\"</span>, sa[<span class=\"number\">0</span>], <span class=\"string\">\"port\"</span>, sa[<span class=\"number\">1</span>], <span class=\"string\">\"...\"</span>)</div><div class=\"line\">    httpd.serve_forever()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    test()</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-sys-args-的使用\"><a href=\"#2-sys-args-的使用\" class=\"headerlink\" title=\"2 .sys.args[]的使用\"></a>2 .sys.args[]的使用</h3><p>cmd中</p>\n<blockquote>\n<p>python</p>\n</blockquote>\n<p>Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<p>退出方式 ctrl+Z</p>\n<p>切换到脚本所在目录 ,例如test.py</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/env python3</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\"># sys.argv接收参数，第一个参数是文件名，第二个参数开始是用户输入的参数，以空格隔开</div><div class=\"line\"># cmd到该文件位置</div><div class=\"line\"></div><div class=\"line\">def run1():</div><div class=\"line\">    print('I\\'m action1')</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def run2():</div><div class=\"line\">    print('I\\'m action2')</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if 2 &gt; len(sys.argv):</div><div class=\"line\">    print('none')</div><div class=\"line\">else:</div><div class=\"line\">    action1 = sys.argv[0]</div><div class=\"line\">    action2 = sys.argv[1]</div><div class=\"line\">    &lt;!-- if 'run1' == action1:</div><div class=\"line\">        run1()</div><div class=\"line\">    if 'run2' == action2:</div><div class=\"line\">        run2() --&gt;</div><div class=\"line\"></div><div class=\"line\">    print(action1)</div><div class=\"line\">    print(action2)</div></pre></td></tr></table></figure>\n<p>输入 python test.py run1<br>输出 test.py ‘run1’</p>"},{"title":"jvm架构概述","date":"2017-05-24T14:48:58.000Z","_content":"\n关于jvm运行的大致架构，最近找到一个比较合适的视频，记录要点如下\n![](http://odzl05jxx.bkt.clouddn.com/high_way_scene.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1.从MyApp.java文件开始\n大家都知道最开始学习Java的时候，要用javac 来编译MyApp.java来生成一个class文件。\n在命令行里，大致是这样的执行顺序:\n```java\njavac MyApp.java\njava MyApp\n```\n** 实际上后一句话就创建了一个jvm instance.**\n\n## 2. 从class loader进入Execution Engine 再到Host Operating System\njava MyApp会调用class loader，后者不仅要负责加载MyApp.class文件，还需要加载java API中的class文件（String,Object,Collection....）。加载的class文件（byte code）被传递给Execution Engine,后者则负责执行byte code（其实也是调用宿主操作系统的方法执行操作）\n\n## 3. where did class loader load class into ?\nclassloader将class 文件加载进内存中的一部分（Runtime data areas）。到此，jvm architecture的三个主要组件：class loader subsystem,Runtime data areas 以及execution Enigne的主要功能都说清楚了。\n所以，这篇文章主要就按照class loader subsystem -> Runtime data areas -> Execution Engine的顺序来讲。\n\n\n## 4.从classloader开始执行（class loading subsystem）\n\t- load 将byte code 加载进内存，来源可以是.java文件，可以是.jar文件，甚至可以是network Socket（这要看具体class loader的implementation）。load阶段包含三种不同的class loader，这也是面试时的重点。\n\n\t> 1. Bootstrap class loader (jre文件夹中有一个rt.jar文件，里面装的就是java的internal class) //\n\n\t> 2. extension class loader (jre/lib/ext) //负责加载这个文件夹中的class文件\n\n\t> 3. Application class loader (CLASSPATH, -cp)//加载CLASSPATH变量中描述的位置\n\n\t- load完成后是link\n\tverify(检查是否是符合jvm标准的byte code) -> prepare(为class中的static variable分配内存，variable被赋默认值) -> Resolve(when all the symbolic reference inside currentclass are resolved，例如引用了其他的class，例如引用了常量池里面的东西，classDefNotFoundException也是在这个时候抛出的)\n\n\t注意，以上步骤都是java specification所规定的，但不同的jvm实现可能有微小的差异\n\nclass loading subsystem的最后一步是initialize\nclass vars to initiazed Value in code(比如静态代码块就是在这时执行的)\n\n## 5. Runtime data area五个部分的划分\nRuntime data area 即java virtural machine的内存，可以划分成五部分\n\t//per jvm ,shared by all threads\n\t- Method Area\n\t- Heap\n\n\t// per thread\n\t- java stack\n\t- pc Registers\n\t- Native method stacks\n\n### 1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)\t，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。\n\n### java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)\n\n### 2. Heap\n日常开发中new出来的东西都放在这里\n\n-Xms , minimun size\n-Xmx , maximum size\n\n### 3. Java Stack\njava stacks contains stack frames of the current execution per thread.\neg : method a -> 调用 method b -> 调用method c\n当前线程的方法栈中就会push三个stack frame(每个Frame对应一个方法的执行环境)\nstack Frame包含当前方法中的变量，以及返回值，etc\n这里定义了stackoverFlowError\n\n\n\n### 4. pc Registers\n这里面装的是程序计数器，后者是指向下一个将要被执行的指令的指针（每条线程都有）。\n\n### 5. Native method stacks\nNative method stacks 是由java stack中的方法调用native方法创建的，例如windows上的dll库\n\n\n\n\n\n\n\n\n## 6. Execution Engine的任务\n![](http://odzl05jxx.bkt.clouddn.com/starry_sky.jpg?imageView2/2/w/500)\n\t- Interpreter 将byte code 翻译成机器指令并执行(根据指令去调用Native方法，在windows上jre/bin/文件夹中一大堆的dll就是windows平台提供的Native库，在linux上是.so文件)\n\n\t- JIT Compiler  just in time compiler（如果有某项byte code instruction被多次调用，这些byte code不会每次都被inteprete，JIT will hold on to that system level target machine code for future usage,which is fast）\n\t- Hotspot profiler(it helps the JIT Compiler analysise the frequently used byte codess)\n\t- GC (a lengthy talk)\n\n调用Native Method Interface(JNI) -> Native method libraries（.dll,.so etc）\n\n\n\n\n\n\n\n\n### 参考\n[JVM ( java virtual machine) architecture - tutorial](https://www.youtube.com/watch?v=ZBJ0u9MaKtM)\n[Java系列笔记(3) - Java 内存区域和GC机制](http://www.cnblogs.com/zhguang/p/3257367.html)\n","source":"_posts/2017-05-24-jvm-architecture.md","raw":"---\ntitle: jvm架构概述\ndate: 2017-05-24 22:48:58\ncategories: blog\ntags: [jvm]\n---\n\n关于jvm运行的大致架构，最近找到一个比较合适的视频，记录要点如下\n![](http://odzl05jxx.bkt.clouddn.com/high_way_scene.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1.从MyApp.java文件开始\n大家都知道最开始学习Java的时候，要用javac 来编译MyApp.java来生成一个class文件。\n在命令行里，大致是这样的执行顺序:\n```java\njavac MyApp.java\njava MyApp\n```\n** 实际上后一句话就创建了一个jvm instance.**\n\n## 2. 从class loader进入Execution Engine 再到Host Operating System\njava MyApp会调用class loader，后者不仅要负责加载MyApp.class文件，还需要加载java API中的class文件（String,Object,Collection....）。加载的class文件（byte code）被传递给Execution Engine,后者则负责执行byte code（其实也是调用宿主操作系统的方法执行操作）\n\n## 3. where did class loader load class into ?\nclassloader将class 文件加载进内存中的一部分（Runtime data areas）。到此，jvm architecture的三个主要组件：class loader subsystem,Runtime data areas 以及execution Enigne的主要功能都说清楚了。\n所以，这篇文章主要就按照class loader subsystem -> Runtime data areas -> Execution Engine的顺序来讲。\n\n\n## 4.从classloader开始执行（class loading subsystem）\n\t- load 将byte code 加载进内存，来源可以是.java文件，可以是.jar文件，甚至可以是network Socket（这要看具体class loader的implementation）。load阶段包含三种不同的class loader，这也是面试时的重点。\n\n\t> 1. Bootstrap class loader (jre文件夹中有一个rt.jar文件，里面装的就是java的internal class) //\n\n\t> 2. extension class loader (jre/lib/ext) //负责加载这个文件夹中的class文件\n\n\t> 3. Application class loader (CLASSPATH, -cp)//加载CLASSPATH变量中描述的位置\n\n\t- load完成后是link\n\tverify(检查是否是符合jvm标准的byte code) -> prepare(为class中的static variable分配内存，variable被赋默认值) -> Resolve(when all the symbolic reference inside currentclass are resolved，例如引用了其他的class，例如引用了常量池里面的东西，classDefNotFoundException也是在这个时候抛出的)\n\n\t注意，以上步骤都是java specification所规定的，但不同的jvm实现可能有微小的差异\n\nclass loading subsystem的最后一步是initialize\nclass vars to initiazed Value in code(比如静态代码块就是在这时执行的)\n\n## 5. Runtime data area五个部分的划分\nRuntime data area 即java virtural machine的内存，可以划分成五部分\n\t//per jvm ,shared by all threads\n\t- Method Area\n\t- Heap\n\n\t// per thread\n\t- java stack\n\t- pc Registers\n\t- Native method stacks\n\n### 1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)\t，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。\n\n### java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)\n\n### 2. Heap\n日常开发中new出来的东西都放在这里\n\n-Xms , minimun size\n-Xmx , maximum size\n\n### 3. Java Stack\njava stacks contains stack frames of the current execution per thread.\neg : method a -> 调用 method b -> 调用method c\n当前线程的方法栈中就会push三个stack frame(每个Frame对应一个方法的执行环境)\nstack Frame包含当前方法中的变量，以及返回值，etc\n这里定义了stackoverFlowError\n\n\n\n### 4. pc Registers\n这里面装的是程序计数器，后者是指向下一个将要被执行的指令的指针（每条线程都有）。\n\n### 5. Native method stacks\nNative method stacks 是由java stack中的方法调用native方法创建的，例如windows上的dll库\n\n\n\n\n\n\n\n\n## 6. Execution Engine的任务\n![](http://odzl05jxx.bkt.clouddn.com/starry_sky.jpg?imageView2/2/w/500)\n\t- Interpreter 将byte code 翻译成机器指令并执行(根据指令去调用Native方法，在windows上jre/bin/文件夹中一大堆的dll就是windows平台提供的Native库，在linux上是.so文件)\n\n\t- JIT Compiler  just in time compiler（如果有某项byte code instruction被多次调用，这些byte code不会每次都被inteprete，JIT will hold on to that system level target machine code for future usage,which is fast）\n\t- Hotspot profiler(it helps the JIT Compiler analysise the frequently used byte codess)\n\t- GC (a lengthy talk)\n\n调用Native Method Interface(JNI) -> Native method libraries（.dll,.so etc）\n\n\n\n\n\n\n\n\n### 参考\n[JVM ( java virtual machine) architecture - tutorial](https://www.youtube.com/watch?v=ZBJ0u9MaKtM)\n[Java系列笔记(3) - Java 内存区域和GC机制](http://www.cnblogs.com/zhguang/p/3257367.html)\n","slug":"2017-05-24-jvm-architecture","published":1,"updated":"2017-07-28T23:49:48.666Z","_id":"cj5gmdnik001rbovrwuif7ghh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>关于jvm运行的大致架构，最近找到一个比较合适的视频，记录要点如下<br><img src=\"http://odzl05jxx.bkt.clouddn.com/high_way_scene.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"1-从MyApp-java文件开始\"><a href=\"#1-从MyApp-java文件开始\" class=\"headerlink\" title=\"1.从MyApp.java文件开始\"></a>1.从MyApp.java文件开始</h2><p>大家都知道最开始学习Java的时候，要用javac 来编译MyApp.java来生成一个class文件。<br>在命令行里，大致是这样的执行顺序:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">javac MyApp.java</div><div class=\"line\">java MyApp</div></pre></td></tr></table></figure></p>\n<p><strong> 实际上后一句话就创建了一个jvm instance.</strong></p>\n<h2 id=\"2-从class-loader进入Execution-Engine-再到Host-Operating-System\"><a href=\"#2-从class-loader进入Execution-Engine-再到Host-Operating-System\" class=\"headerlink\" title=\"2. 从class loader进入Execution Engine 再到Host Operating System\"></a>2. 从class loader进入Execution Engine 再到Host Operating System</h2><p>java MyApp会调用class loader，后者不仅要负责加载MyApp.class文件，还需要加载java API中的class文件（String,Object,Collection….）。加载的class文件（byte code）被传递给Execution Engine,后者则负责执行byte code（其实也是调用宿主操作系统的方法执行操作）</p>\n<h2 id=\"3-where-did-class-loader-load-class-into\"><a href=\"#3-where-did-class-loader-load-class-into\" class=\"headerlink\" title=\"3. where did class loader load class into ?\"></a>3. where did class loader load class into ?</h2><p>classloader将class 文件加载进内存中的一部分（Runtime data areas）。到此，jvm architecture的三个主要组件：class loader subsystem,Runtime data areas 以及execution Enigne的主要功能都说清楚了。<br>所以，这篇文章主要就按照class loader subsystem -&gt; Runtime data areas -&gt; Execution Engine的顺序来讲。</p>\n<h2 id=\"4-从classloader开始执行（class-loading-subsystem）\"><a href=\"#4-从classloader开始执行（class-loading-subsystem）\" class=\"headerlink\" title=\"4.从classloader开始执行（class loading subsystem）\"></a>4.从classloader开始执行（class loading subsystem）</h2><pre><code>- load 将byte code 加载进内存，来源可以是.java文件，可以是.jar文件，甚至可以是network Socket（这要看具体class loader的implementation）。load阶段包含三种不同的class loader，这也是面试时的重点。\n\n&gt; 1. Bootstrap class loader (jre文件夹中有一个rt.jar文件，里面装的就是java的internal class) //\n\n&gt; 2. extension class loader (jre/lib/ext) //负责加载这个文件夹中的class文件\n\n&gt; 3. Application class loader (CLASSPATH, -cp)//加载CLASSPATH变量中描述的位置\n\n- load完成后是link\nverify(检查是否是符合jvm标准的byte code) -&gt; prepare(为class中的static variable分配内存，variable被赋默认值) -&gt; Resolve(when all the symbolic reference inside currentclass are resolved，例如引用了其他的class，例如引用了常量池里面的东西，classDefNotFoundException也是在这个时候抛出的)\n\n注意，以上步骤都是java specification所规定的，但不同的jvm实现可能有微小的差异\n</code></pre><p>class loading subsystem的最后一步是initialize<br>class vars to initiazed Value in code(比如静态代码块就是在这时执行的)</p>\n<h2 id=\"5-Runtime-data-area五个部分的划分\"><a href=\"#5-Runtime-data-area五个部分的划分\" class=\"headerlink\" title=\"5. Runtime data area五个部分的划分\"></a>5. Runtime data area五个部分的划分</h2><p>Runtime data area 即java virtural machine的内存，可以划分成五部分<br>    //per jvm ,shared by all threads</p>\n<pre><code>- Method Area\n- Heap\n\n// per thread\n- java stack\n- pc Registers\n- Native method stacks\n</code></pre><h3 id=\"1-Method-Area-方法区，用于存储class的数据，static-variable-byte-code-class-level-constant-pool都放在这里-，Method-Area也称为Perm-gen-space-永生代-，默认大小是64MB-，可以通过-XX-MaxPermSize-调节-。这里有可能抛出out-of-memory-error。\"><a href=\"#1-Method-Area-方法区，用于存储class的数据，static-variable-byte-code-class-level-constant-pool都放在这里-，Method-Area也称为Perm-gen-space-永生代-，默认大小是64MB-，可以通过-XX-MaxPermSize-调节-。这里有可能抛出out-of-memory-error。\" class=\"headerlink\" title=\"1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)    ，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。\"></a>1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)    ，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。</h3><h3 id=\"java8将method-Area移除，改为-metaspace-就是将method-area移到了Native-Memory，这样就不会有限制了，也可以人为设置上限\"><a href=\"#java8将method-Area移除，改为-metaspace-就是将method-area移到了Native-Memory，这样就不会有限制了，也可以人为设置上限\" class=\"headerlink\" title=\"java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)\"></a>java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)</h3><h3 id=\"2-Heap\"><a href=\"#2-Heap\" class=\"headerlink\" title=\"2. Heap\"></a>2. Heap</h3><p>日常开发中new出来的东西都放在这里</p>\n<p>-Xms , minimun size<br>-Xmx , maximum size</p>\n<h3 id=\"3-Java-Stack\"><a href=\"#3-Java-Stack\" class=\"headerlink\" title=\"3. Java Stack\"></a>3. Java Stack</h3><p>java stacks contains stack frames of the current execution per thread.<br>eg : method a -&gt; 调用 method b -&gt; 调用method c<br>当前线程的方法栈中就会push三个stack frame(每个Frame对应一个方法的执行环境)<br>stack Frame包含当前方法中的变量，以及返回值，etc<br>这里定义了stackoverFlowError</p>\n<h3 id=\"4-pc-Registers\"><a href=\"#4-pc-Registers\" class=\"headerlink\" title=\"4. pc Registers\"></a>4. pc Registers</h3><p>这里面装的是程序计数器，后者是指向下一个将要被执行的指令的指针（每条线程都有）。</p>\n<h3 id=\"5-Native-method-stacks\"><a href=\"#5-Native-method-stacks\" class=\"headerlink\" title=\"5. Native method stacks\"></a>5. Native method stacks</h3><p>Native method stacks 是由java stack中的方法调用native方法创建的，例如windows上的dll库</p>\n<h2 id=\"6-Execution-Engine的任务\"><a href=\"#6-Execution-Engine的任务\" class=\"headerlink\" title=\"6. Execution Engine的任务\"></a>6. Execution Engine的任务</h2><p><img src=\"http://odzl05jxx.bkt.clouddn.com/starry_sky.jpg?imageView2/2/w/500\" alt=\"\"></p>\n<pre><code>- Interpreter 将byte code 翻译成机器指令并执行(根据指令去调用Native方法，在windows上jre/bin/文件夹中一大堆的dll就是windows平台提供的Native库，在linux上是.so文件)\n\n- JIT Compiler  just in time compiler（如果有某项byte code instruction被多次调用，这些byte code不会每次都被inteprete，JIT will hold on to that system level target machine code for future usage,which is fast）\n- Hotspot profiler(it helps the JIT Compiler analysise the frequently used byte codess)\n- GC (a lengthy talk)\n</code></pre><p>调用Native Method Interface(JNI) -&gt; Native method libraries（.dll,.so etc）</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.youtube.com/watch?v=ZBJ0u9MaKtM\">JVM ( java virtual machine) architecture - tutorial</a><br><a href=\"http://www.cnblogs.com/zhguang/p/3257367.html\">Java系列笔记(3) - Java 内存区域和GC机制</a></p>\n","excerpt":"<p>关于jvm运行的大致架构，最近找到一个比较合适的视频，记录要点如下<br><img src=\"http://odzl05jxx.bkt.clouddn.com/high_way_scene.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<h2 id=\"1-从MyApp-java文件开始\"><a href=\"#1-从MyApp-java文件开始\" class=\"headerlink\" title=\"1.从MyApp.java文件开始\"></a>1.从MyApp.java文件开始</h2><p>大家都知道最开始学习Java的时候，要用javac 来编译MyApp.java来生成一个class文件。<br>在命令行里，大致是这样的执行顺序:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">javac MyApp.java</div><div class=\"line\">java MyApp</div></pre></td></tr></table></figure></p>\n<p><strong> 实际上后一句话就创建了一个jvm instance.</strong></p>\n<h2 id=\"2-从class-loader进入Execution-Engine-再到Host-Operating-System\"><a href=\"#2-从class-loader进入Execution-Engine-再到Host-Operating-System\" class=\"headerlink\" title=\"2. 从class loader进入Execution Engine 再到Host Operating System\"></a>2. 从class loader进入Execution Engine 再到Host Operating System</h2><p>java MyApp会调用class loader，后者不仅要负责加载MyApp.class文件，还需要加载java API中的class文件（String,Object,Collection….）。加载的class文件（byte code）被传递给Execution Engine,后者则负责执行byte code（其实也是调用宿主操作系统的方法执行操作）</p>\n<h2 id=\"3-where-did-class-loader-load-class-into\"><a href=\"#3-where-did-class-loader-load-class-into\" class=\"headerlink\" title=\"3. where did class loader load class into ?\"></a>3. where did class loader load class into ?</h2><p>classloader将class 文件加载进内存中的一部分（Runtime data areas）。到此，jvm architecture的三个主要组件：class loader subsystem,Runtime data areas 以及execution Enigne的主要功能都说清楚了。<br>所以，这篇文章主要就按照class loader subsystem -&gt; Runtime data areas -&gt; Execution Engine的顺序来讲。</p>\n<h2 id=\"4-从classloader开始执行（class-loading-subsystem）\"><a href=\"#4-从classloader开始执行（class-loading-subsystem）\" class=\"headerlink\" title=\"4.从classloader开始执行（class loading subsystem）\"></a>4.从classloader开始执行（class loading subsystem）</h2><pre><code>- load 将byte code 加载进内存，来源可以是.java文件，可以是.jar文件，甚至可以是network Socket（这要看具体class loader的implementation）。load阶段包含三种不同的class loader，这也是面试时的重点。\n\n&gt; 1. Bootstrap class loader (jre文件夹中有一个rt.jar文件，里面装的就是java的internal class) //\n\n&gt; 2. extension class loader (jre/lib/ext) //负责加载这个文件夹中的class文件\n\n&gt; 3. Application class loader (CLASSPATH, -cp)//加载CLASSPATH变量中描述的位置\n\n- load完成后是link\nverify(检查是否是符合jvm标准的byte code) -&gt; prepare(为class中的static variable分配内存，variable被赋默认值) -&gt; Resolve(when all the symbolic reference inside currentclass are resolved，例如引用了其他的class，例如引用了常量池里面的东西，classDefNotFoundException也是在这个时候抛出的)\n\n注意，以上步骤都是java specification所规定的，但不同的jvm实现可能有微小的差异\n</code></pre><p>class loading subsystem的最后一步是initialize<br>class vars to initiazed Value in code(比如静态代码块就是在这时执行的)</p>\n<h2 id=\"5-Runtime-data-area五个部分的划分\"><a href=\"#5-Runtime-data-area五个部分的划分\" class=\"headerlink\" title=\"5. Runtime data area五个部分的划分\"></a>5. Runtime data area五个部分的划分</h2><p>Runtime data area 即java virtural machine的内存，可以划分成五部分<br>    //per jvm ,shared by all threads</p>\n<pre><code>- Method Area\n- Heap\n\n// per thread\n- java stack\n- pc Registers\n- Native method stacks\n</code></pre><h3 id=\"1-Method-Area-方法区，用于存储class的数据，static-variable-byte-code-class-level-constant-pool都放在这里-，Method-Area也称为Perm-gen-space-永生代-，默认大小是64MB-，可以通过-XX-MaxPermSize-调节-。这里有可能抛出out-of-memory-error。\"><a href=\"#1-Method-Area-方法区，用于存储class的数据，static-variable-byte-code-class-level-constant-pool都放在这里-，Method-Area也称为Perm-gen-space-永生代-，默认大小是64MB-，可以通过-XX-MaxPermSize-调节-。这里有可能抛出out-of-memory-error。\" class=\"headerlink\" title=\"1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)    ，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。\"></a>1. Method Area(方法区，用于存储class的数据，static variable,byte code,class level constant pool都放在这里)    ，Method Area也称为Perm gen space(永生代)，默认大小是64MB ，可以通过-XX:MaxPermSize 调节 。这里有可能抛出out of memory error。</h3><h3 id=\"java8将method-Area移除，改为-metaspace-就是将method-area移到了Native-Memory，这样就不会有限制了，也可以人为设置上限\"><a href=\"#java8将method-Area移除，改为-metaspace-就是将method-area移到了Native-Memory，这样就不会有限制了，也可以人为设置上限\" class=\"headerlink\" title=\"java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)\"></a>java8将method Area移除，改为 metaspace (就是将method area移到了Native Memory，这样就不会有限制了，也可以人为设置上限)</h3><h3 id=\"2-Heap\"><a href=\"#2-Heap\" class=\"headerlink\" title=\"2. Heap\"></a>2. Heap</h3><p>日常开发中new出来的东西都放在这里</p>\n<p>-Xms , minimun size<br>-Xmx , maximum size</p>\n<h3 id=\"3-Java-Stack\"><a href=\"#3-Java-Stack\" class=\"headerlink\" title=\"3. Java Stack\"></a>3. Java Stack</h3><p>java stacks contains stack frames of the current execution per thread.<br>eg : method a -&gt; 调用 method b -&gt; 调用method c<br>当前线程的方法栈中就会push三个stack frame(每个Frame对应一个方法的执行环境)<br>stack Frame包含当前方法中的变量，以及返回值，etc<br>这里定义了stackoverFlowError</p>\n<h3 id=\"4-pc-Registers\"><a href=\"#4-pc-Registers\" class=\"headerlink\" title=\"4. pc Registers\"></a>4. pc Registers</h3><p>这里面装的是程序计数器，后者是指向下一个将要被执行的指令的指针（每条线程都有）。</p>\n<h3 id=\"5-Native-method-stacks\"><a href=\"#5-Native-method-stacks\" class=\"headerlink\" title=\"5. Native method stacks\"></a>5. Native method stacks</h3><p>Native method stacks 是由java stack中的方法调用native方法创建的，例如windows上的dll库</p>\n<h2 id=\"6-Execution-Engine的任务\"><a href=\"#6-Execution-Engine的任务\" class=\"headerlink\" title=\"6. Execution Engine的任务\"></a>6. Execution Engine的任务</h2><p><img src=\"http://odzl05jxx.bkt.clouddn.com/starry_sky.jpg?imageView2/2/w/500\" alt=\"\"></p>\n<pre><code>- Interpreter 将byte code 翻译成机器指令并执行(根据指令去调用Native方法，在windows上jre/bin/文件夹中一大堆的dll就是windows平台提供的Native库，在linux上是.so文件)\n\n- JIT Compiler  just in time compiler（如果有某项byte code instruction被多次调用，这些byte code不会每次都被inteprete，JIT will hold on to that system level target machine code for future usage,which is fast）\n- Hotspot profiler(it helps the JIT Compiler analysise the frequently used byte codess)\n- GC (a lengthy talk)\n</code></pre><p>调用Native Method Interface(JNI) -&gt; Native method libraries（.dll,.so etc）</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.youtube.com/watch?v=ZBJ0u9MaKtM\">JVM ( java virtual machine) architecture - tutorial</a><br><a href=\"http://www.cnblogs.com/zhguang/p/3257367.html\">Java系列笔记(3) - Java 内存区域和GC机制</a></p>"},{"title":"Java集合类的一些整理","date":"2017-06-25T14:56:33.000Z","_content":"\n根据网上的大部分博客的分类，集合框架分为Collections(具有类似数组的功能)和Map(存储键值对)这两大部分。针对jdk1.8的java.util里面的一些常用的或者不常用的集合做一些分析。写这篇文章的过程中，我慢慢发现不同版本jdk的同一个class的实现是有一些差异的(LinkedList)，由于对照的是java1.8的代码，里面会多一些since 1.8的代码，这里不作论述。\n![](http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600)\n\n<!--more-->\n\njava集合的大致框架建议参考网上博客的总结，[Java集合干货系列](http://www.jianshu.com/p/2cd7be850540)写的比较好，图画的也不错，针对jdk 1.6源码讲的。我这里只是自己学习过程中的一些笔记。\n\n\n## List\nArrayList (建议new出来的时候给定一个适当的size，不然每次扩容很慢的，可以放null)\nLinkedList(not recommended，增删元素的时候快一点)\nVector（线程安全,重同步，不推荐）\n\n## Set\nHashSet (底层是HashMap)\nTreeSet(排序存储)\nLinkedHashSet(底层是LinkedHashMap)\n\n## Queue\n\nStack ArrayDeque(不常用)\n\n## Map\nHashMap （键值都可以为null,底层是哈希表）\nTreeMap(底层二叉树)\nHashTable(线程安全，键值都不允许为null)\nSparseArray(Android平台用)\n\n关于集合，不得不提到泛型，Java 1.5引入了泛型，关于泛型，找到一篇很好的文章\n[类型擦除原理](http://blog.csdn.net/lonelyroamer/article/details/7868820)。本质上只是提供了编译期类型检查。编译通过后都是Object，所以叫做[类型擦除](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4)。\n\n## 1. List的解析\n\n### 1.1 ArrayList源码解析\n\n- 先上一段崩溃代码\n```java\n public static void main(String[] args) {\n    String[] array = new String[]{\"a\", \"b\", \"c\", \"d\"};\n    List<String> l = Arrays.asList(array);\n    l.add(\"d\");\n}\n\nException in thread \"main\" java.lang.UnsupportedOperationException\n    at java.util.AbstractList.add(AbstractList.java:148)\n    at java.util.AbstractList.add(AbstractList.java:108)\n    at com.example.demo.main(ConcurrentModificationListDemo.java:13)\n```\n问题出在Arrays.asList返回了一个**java.util.Arrays.ArrayList**，而不是**java.util.ArrayList**。前者只实现了List接口的有限的几个方法，并且是Arrays内部的一个private class。\n正确的用法是new 一个ArrayList，把这个有限的list的元素(的指针)copy进去，即addAll()方法\nArrayList.toArray(T[] a)是把所有的elements通过System.arraycopy(elementData, 0, a, 0, size);复制到a数组中。\n\n- System.arraycopy可以从自己的数组复制到自己的数组\n```java\n  public void add(int index, E element) {\n        rangeCheckForAdd(index);\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);  \n        elementData[index] = element;\n        size++;\n    }\n```\n添加到指定位置，System.arrayCopy可以从同一个数组复制到同一个数组，几乎就是挪动指针了。\n\n- 不常见的方法\n\n```java\n//下面这两个是因为ArrayList implements java.io.Serializable，是序列化时会调用的\nprivate void writeObject(java.io.ObjectOutputStream s)\nprivate void readObject(java.io.ObjectInputStream s)\n\nprotected void removeRange(int fromIndex, int toIndex)\n\npublic boolean removeAll(Collection<?> c) //给一个集合，删除list与之的交集\npublic boolean retainAll(Collection<?> c) //  给定一个集合，从list中删除所有不在这个集合里面的元素\n\npublic void trimToSize() // 内存压力大的时候可以释放掉一部分内存，记得那个1.5倍的默认扩容嘛，释放的就是这0.5的内存\n```\n\n\n多线程场景下要注意的问题\n\n> 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。\n\n\n### 1.2 LinkedList的一些点\nLinkedList是双向链表实现的，可以想象成一帮小孩左手拉右手绕成一个圈，只不过这里面的每一个小孩并不是你放进去的 T 类型数据，而是一个Node<T> 。所以LinkedList是可以放进去一个Null的。\nLinkedList往往被人诟病的就是除了添加和删除快之外，get和set很慢。\n来看下add的实现（jdk 1.8）\n\n```java\n   public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n\n/**\n     * Links e as last element.\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;  //先把链表的尾巴找出来\n        final Node<E> newNode = new Node<>(l, e, null); // 可以想象每次add都有new的操作，并将原来的尾巴作为这个新的Entry的头部\n        last = newNode; //新的Node将成为新的尾巴\n        if (l == null) //这种情况是原来没有尾巴，也就是说size = 0\n            first = newNode; //这时候就只有一个Node，头和尾都是Null\n        else\n            l.next = newNode; //不然的话，旧的尾巴变成了倒数第二个，它的next指向了新的Entry.\n\n        size++;\n        modCount++;\n    }\n\n```\n\nadd的过程看起来很快，new一个entery，确定下前后的指针就可以了。remove也差不多，取消指针引用即可。\n\n来看比较慢的get\n\n```java\n public E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n\n  /**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next; //一直遍历到这个index才返回，慢\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n```\n\n值得注意的一点小事：\nArrayList implement RandomAccess接口，而LinkedList并没有。RandomAccess接口的定义如下\n\n> * Marker interface used by <tt>List</tt> implementations to indicate that\n * they support fast (generally constant time) random access.  The primary\n * purpose of this interface is to allow generic algorithms to alter their\n * behavior to provide good performance when applied to either random or\n * sequential access lists.\n *\n * <p>The best algorithms for manipulating random access lists (such as\n * <tt>ArrayList</tt>) can produce quadratic behavior when applied to\n * sequential access lists (such as <tt>LinkedList</tt>).  Generic list\n * algorithms are encouraged to check whether the given list is an\n * <tt>instanceof</tt> this interface before applying an algorithm that would\n * provide poor performance if it were applied to a sequential access list,\n * and to alter their behavior if necessary to guarantee acceptable\n * performance.\n *\n * <p>It is recognized that the distinction between random and sequential\n * access is often fuzzy.  For example, some <tt>List</tt> implementations\n * provide asymptotically linear access times if they get huge, but constant\n * access times in practice.  Such a <tt>List</tt> implementation\n * should generally implement this interface.  As a rule of thumb, a\n * List implementation should implement this interface if,\n * for typical instances of the class, this loop:\n *     for (int i=0, n=list.size(); i &lt; n; i++)\n *         list.get(i); //get的速度应该是恒定的\n * runs faster than this loop:\n *     for (Iterator i=list.iterator(); i.hasNext(); )\n *         i.next();\n\n\n这种接口就是给外界使用者看的，用来说明该集合支持这种通过下标查找（速度不变）的快速操作\n\n实践表明，对于linkedList，采用for loop的方式要很慢，但使用ListIterator<T>的方式，速度并不慢，简单来想，沿着链表的一个方向一致往下走就是了嘛。\n一些经验表明(摘自简书作者嘟爷MD的文章)\n\n[ArryList和LinkedList的对比结论](http://www.jianshu.com/p/d5ec2ff72b33)\n\n> 1、顺序插入速度ArrayList会比较快\n> 2、LinkedList将比ArrayList更耗费一些内存\n> 3、ArrayList的遍历效率会比LinkedList的遍历效率高一些\n> 4、有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：如果增加或者删除的元素在前半部分的时候，ArrayList会频繁调用System.arrayCopy方法，虽然native方法快，但高频率调用肯定慢，至少比不上移动指针。\n\n\n## 2. Map的几个实现类\n### 2.1 HashMap源码解析\n\n>public class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n\nHashMap不是线程安全的，Key和Value都有可能为null，存储数据不是有序的(get的顺序不是put的顺序)\n\nHashMap中有几个默认值常量\n\n    默认初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    默认加载因子是0.75f ，加载因子是指Hashmap在自动扩容之前可以达到多满\n    static final float DEFAULT_LOAD_FACTOR = 0.75f; //一般不需要改\n\n构造函数有好几个\n\n```java\n public HashMap(int initialCapacity, float loadFactor)  //自定义加载因子，比较玄学\n public HashMap(int initialCapacity) // 避免扩容，和ArrayList初始化指定容量类似的道理\n public HashMap() //直接把初始容量设置成16\n public HashMap(Map<? extends K, ? extends V> m)\n```\n[注意这个初始容量必须是2的n次方](https://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity-be-a-power-of-two)\n\n来看常见的CURD操作(jdk 1.8源码，和我在网上找到的jdk1.6源码有一些变化了)\n```java\n public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true); //HashMap允许key为null,key为null的话，直接放到数组的0的位置（hash方法返回的是0）\n    }\n\n    static final int hash(Object key) {\n           int h;\n           return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); //如果是null，放到数组的第一个\n// 这里面就是HashMap算法的高明之处  ，\n//  1. 首先算出object的hashcode，\n//2.然后根据上述公式将二进制的1尽量分散的均匀一点         \n// 3. 在putVal的时候将这个值跟数组的长度length-1进行位运算，得到一个比length小的正数，作为这个新元素在数组中的index.但这样仍不免会产生冲突(hash Collision)\n       }\n\n\n /**\n     * Implements Map.put and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @param value the value to put\n     * @param onlyIfAbsent if true, don't change existing value\n     * @param evict if false, the table is in creation mode.\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length; //table为成员变量，是一个Node数组，为空的话则创建 。在resize中创建\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p; //Table数组中找到了这个下标的元素，直接指定\n            else if (p instanceof TreeNode)//p可以理解为previous 。 如果发现这个节点是一棵树（红黑树？）\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {//否则该节点是链表，各个元素之间手拉手的那种\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null); //找到这个链表的尾巴了\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e); //回调函数\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);//回调函数\n        return null;\n    }\n\n```\n\nget方法\n```java\n  public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;//根据key来找value\n    }\n    /**\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @return the node, or null if none\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) { //table不为空说明曾经put过\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n\n\n  public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n\n    /**\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @return the node, or null if none\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n    //可以看出比较的方式就是hash（int）相等且key(指针相等)  或者key equals(所以经常说重写equals需要确保hashcode一致，这里至少反应了这一点)\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n\n```\n\n回想一下平时迭代一个HashMap的方式\n```java\nlong i = 0;\nIterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\nwhile (it.hasNext()) {\n    Map.Entry<Integer, Integer> pair = it.next(); //上面的get也是这种不断查找next的方式\n    i += pair.getKey() + pair.getValue();\n}\n```\n\nentrySet方法是Map接口定义的\n```\nSet<Map.Entry<K, V>> entrySet();\n   * Returns a Set view of the mappings contained in this map.\n     * The set is backed by the map, so changes to the map are\n     * reflected in the set, and vice-versa.  If the map is modified\n     * while an iteration over the set is in progress (except through\n     * the iterator's own <tt>remove</tt> operation, or through the\n     * <tt>setValue</tt> operation on a map entry returned by the\n     * iterator) the results of the iteration are undefined.  The set\n     * supports element removal, which removes the corresponding\n     * mapping from the map, via the <tt>Iterator.remove</tt>,\n     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n     * <tt>clear</tt> operations.  It does not support the\n     * <tt>add</tt> or <tt>addAll</tt> operations.\n     *\n     * @return a set view of the mappings contained in this map\n```\n\n大致意思是： 返回一个能够反映该map元素组合的一个Set，对这个Set的操作都将反映到原map上，反之亦然。在通过entrySet迭代这个map的时候，除了remove和操作操作都是不被支持的。返回的Set支持删除对应的mapping组合。但不支持add操作\n\nHashMap内部保留了一个这样的成员变量：\ntransient Set<Map.Entry<K,V>> entrySet; //成员变量\n具体实现enterySet方法的地方：\n```java\n  public Set<Map.Entry<K,V>> entrySet() {\n        Set<Map.Entry<K,V>> es;\n        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;\n    }\n\n// 这个EntrySet大致长这样\n  final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n        public final int size()                 { return size; }\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n        public final boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Node<K,V> candidate = getNode(hash(key), key);\n            return candidate != null && candidate.equals(e);\n        }\n        public final boolean remove(Object o) {\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n                Object key = e.getKey();\n                Object value = e.getValue();\n                return removeNode(hash(key), key, value, true, true) != null;\n            }\n            return false;\n        }\n    }\n\n```\n整理的关键在于removeNode方法，和getNode和putVal很像\n```java\n   final Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            } //先把p(previous)找出来，这里的matchValue和movable都是true\n            // node 就是包含了要移出对象的Node\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                else if (node == p) //数组这个位置就一个\n                    tab[index] = node.next;//直接指向下一个\n                else\n                    p.next = node.next; //数组这个位置指向链表下一个节点，释放引用\n                ++modCount;\n                --size;\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n```\n比较元素是否相同的关键是\n> e.hash == hash || (key!=null &&key.equals(k)) //后半部分其实也是比较hashCode\n\n另外一些平时常用的方法包括：\n```java\n  public boolean containsKey(Object key) {\n        return getNode(hash(key), key) != null; //就是检查下有没有这个key对应的Node\n    }\n\n   public boolean containsValue(Object value) {\n        Node<K,V>[] tab; V v;\n        if ((tab = table) != null && size > 0) {\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next) {\n                    if ((v = e.value) == value ||\n                        (value != null && value.equals(v)))\n                        return true; //遍历内部的数组，仅此而已\n                }\n            }\n        }\n        return false;\n    }\n```\n\n和ArrayList、LinkedList比起来，HashMap的源码要麻烦许多，这里面涉及到hashCode，链表，红黑树。需要一点数据结构的知识。另外，HashMap还针对hashCode冲突（hash Collision，不同的Object居然有相同的hashCode）的情况作了[预处理](https://stackoverflow.com/questions/6493605/how-does-a-java-hashmap-handle-different-objects-with-the-same-hash-code)\n通俗的来说，HashMap内部维护了一个数组，每一个数组元素内部不一定只有一个，有可能是一个链表。每次添加(key,value)不是盲目的往这个数组里面塞，而是算下key的hash值，放到对应的节点上。如果这个节点上还没有元素，直接放就好了。如果有的话，新加入的value将被作为原有元素的Next(外部调用get的时候，先根据传入的key的hashCode找到节点，然后根据key.equals来找)。简单如此，精致如斯。\n\n### 2.2 LinkedHashMap\n\npublic class LinkedHashMap<K,V>\n    extends HashMap<K,V>\n    implements Map<K,V>\nHashMap源码我看了下有两千多行，LinkedHashMap只有七百多行，显然这是继承带来的简便之处。\n关键的成员变量  \nfinal boolean accessOrder; 默认是false\n> The iteration ordering method for this linked hash map: <tt>true</tt>\nfor access-order, false for insertion-order.\n\nLinkedHashMap常用的属性就是它支持有序，这个有序是指迭代的时候有序\n\n### 2.3 SparseArray\n先来看一段崩溃日志\n```\nFatal Exception: java.lang.ArrayIndexOutOfBoundsException: src.length=509 srcPos=60 dst.length=509 dstPos=61 length=-60\n       at java.lang.System.arraycopy(System.java:388)\n       at com.android.internal.util.GrowingArrayUtils.insert(GrowingArrayUtils.java:135)\n       at android.util.SparseIntArray.put(SparseIntArray.java:144)\n```\nSparseArry提供了类似于HashMap的调用接口，\n\n使用SparseArray的初衷还是在android这种内存比cpu金贵的平台中，使用SparseArry相比HashMap能够减轻内存压力，获得更好的性能。\n[liaohuqiu指出SparseArry并不是任何时候都更快](https://www.liaohuqiu.net/cn/posts/sparse-array-in-android/)，主要是节省内存，避免autoBoxing，二分法查找对于cpu的消耗需要权衡。尤其是存储的量很大的时候，二分法查找的速度会很慢。\n\nSparseArry类似的class有好几个，据说有八个，以SparseIntArry为例\nSparseIntArry的几个常用方法,值得注意的是 clear方法只不过是把计数清零了。\n```java\npublic int indexOfKey(int key)\npublic int indexOfValue(int value)\npublic int get(int key)\npublic void put(int key, int value)\n\npublic void clear() {\n       mSize = 0;\n   }\n//迭代一个SparseArry的方法\nfor(int i = 0; i < sparseArray.size(); i++) {\n   int key = sparseArray.keyAt(i);\n   // get the object by the key.\n   Object obj = sparseArray.get(key);\n}\n\n// 从源码来看变量结构\npublic class SparseIntArray implements Cloneable{\n    private int[] mKeys;\n    private int[] mValues;\n    private int mSize;\n}\n\n\n\npublic void put(int key, int value) {\n     int i = ContainerHelpers.binarySearch(mKeys, mSize, key); //二分法查找\n\n     if (i >= 0) {\n         mValues[i] = value; //找到了在Value数组中的index,直接替换掉\n     } else {\n         i = ~i;\n         mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);\n         mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);\n         mSize++;\n     }\n }\n\n```\n\n廖祜秋 特地强调\n1. SparseArray 是针对HashMap做的优化。\n    1.HashMap 内部的存储结构，导致一些内存的浪费。\n    2.在刚扩容完，SparseArray 和 HashMap 都会存在一些没被利用的内存。\n2. SparseArray 并不是任何时候都会更快，有时反而会更慢\n\n\n\n\n### 2.4 ArrayMap\n\n\n\n\n\n\n## 3. Set的介绍\nSet用比较少，HashSet、TreeSet和LinkedHashSet是jdk的实现类\n\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\nSet的重要特点就是**不能放进去重复**的元素，Set中不会存在e1和e2，e1.equals(e2)的情况\nHashSet的源码只有三百多行，内部有一个map（HashMap）相对来说是比较简单的。其实Set平时用的也不是那么多。。。\n\n### 4. 一些不常用的类\n\n    Vetor，Stack，ArrayDeque,Queue\n\n    Vector属于List,线程安全，但效率低（就是简单的在所有方法前面加上了synchronized）\n\n    Queue是一个interface，属于两端可以出入的List，通常是(FIFO模式)，实现类有\n    PriorityQueue，\n    java.util.concurrent.LinkedBlockingQueue\n    java.util.concurrent.LinkedBlockingQueue\n    java.util.concurrent.PriorityBlockingQueue\n    作者都是大名鼎鼎的Doug Lea\n\n    Stack是Vector的子类(属于LIFO的栈)\n    The Stack class represents a last-in-first-out (LIFO) stack of object\n\n    Deque(双端队列)\n\n\n### 5. concurrentHashMap等\njdk1.8的concurrentHashMap不是用synchronized实现的，是Doug Lea使用CAS操作写的，非常高效。\n\n### 6. WeakHaskMap\nWeakHashMap的Key是WeakReference，但Value不是。\n常见用法\n\n```java\nString a = \"a\";\nmap.put(1,a);\na = null;\n//map中的a可以出了map自身外没有其他地方被引用，a将被被gc回收\n```\n\nAndroid [官方开发文档](https://developer.android.com/reference/java/util/WeakHashMap.html)上指出了一点\n\n> Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get.\n\nWeakHashMap的value不要持有key的强引用，否则，key永远不会被清除,value也别想被清除。\n\n\n## 7. java 8的一些新的方法\nlist.replaceAll(String::toUpperCase) //method reference\ncan not change the elemeet type, for that you need an stream\n[Collections Refuled by Stuart Marks](https://www.youtube.com/watch?v=q6zF3vf114M)\n\n## 8.结束语\n8.1 [Doug Lea](https://en.wikipedia.org/wiki/Doug_Lea) 是非常聪明的人，估计并发经常会牵涉到集合，所以jdk里面很多集合都有他的作品\n8.2 jdk只是定义了这些框架，像List，Map这些全都是接口，完全可以自己去实现。Apache就有一大堆适合特定场景的集合实现类。jdk只是帮助我们实现了一些常见的类。如果有现成的满足需求的框架，不要重复造轮子。\n8.3 平时只要记住ArrayList和HashMap的**大致内部实现**就可以了，至于别的，除非面试，平时没必要记录。\n8.4 [Stuart Mark](https://blogs.oracle.com/java/collections-refueled)特别喜欢把一个class搞成**@deprecated**\n8.5 就连[Joshua Bloch](https://www.youtube.com/watch?v=V1vQf4qyMXg) 都承认，除非性能真的很重要的，平时没必要过度优化。By the way , he said Doug Lea is very smart .\n\n\n\n### Reference\n1. [Collections Refuled by Stuart Marks](https://www.youtube.com/watch?v=q6zF3vf114M)\n2. [From Java Code to Java Heap: Understanding the Memory Usage of Your Application](https://www.youtube.com/watch?v=FLcXf9pO27w)\n3. [Java集合干货系列](http://www.jianshu.com/p/2cd7be850540)\n4. [Arrays.asList()返回的List不是jva.util.ArrayList](http://www.programcreek.com/2014/01/java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF/)\n5. [WeakHashMap和HashMap的区别](http://blog.csdn.net/yangzl2008/article/details/6980709)\n","source":"_posts/2017-06-12-Collections-Refuled-by-Stuart-Marks.md","raw":"---\ntitle: Java集合类的一些整理\ndate: 2017-06-25 22:56:33\ncategories: blog\ntags: [java]\n---\n\n根据网上的大部分博客的分类，集合框架分为Collections(具有类似数组的功能)和Map(存储键值对)这两大部分。针对jdk1.8的java.util里面的一些常用的或者不常用的集合做一些分析。写这篇文章的过程中，我慢慢发现不同版本jdk的同一个class的实现是有一些差异的(LinkedList)，由于对照的是java1.8的代码，里面会多一些since 1.8的代码，这里不作论述。\n![](http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600)\n\n<!--more-->\n\njava集合的大致框架建议参考网上博客的总结，[Java集合干货系列](http://www.jianshu.com/p/2cd7be850540)写的比较好，图画的也不错，针对jdk 1.6源码讲的。我这里只是自己学习过程中的一些笔记。\n\n\n## List\nArrayList (建议new出来的时候给定一个适当的size，不然每次扩容很慢的，可以放null)\nLinkedList(not recommended，增删元素的时候快一点)\nVector（线程安全,重同步，不推荐）\n\n## Set\nHashSet (底层是HashMap)\nTreeSet(排序存储)\nLinkedHashSet(底层是LinkedHashMap)\n\n## Queue\n\nStack ArrayDeque(不常用)\n\n## Map\nHashMap （键值都可以为null,底层是哈希表）\nTreeMap(底层二叉树)\nHashTable(线程安全，键值都不允许为null)\nSparseArray(Android平台用)\n\n关于集合，不得不提到泛型，Java 1.5引入了泛型，关于泛型，找到一篇很好的文章\n[类型擦除原理](http://blog.csdn.net/lonelyroamer/article/details/7868820)。本质上只是提供了编译期类型检查。编译通过后都是Object，所以叫做[类型擦除](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4)。\n\n## 1. List的解析\n\n### 1.1 ArrayList源码解析\n\n- 先上一段崩溃代码\n```java\n public static void main(String[] args) {\n    String[] array = new String[]{\"a\", \"b\", \"c\", \"d\"};\n    List<String> l = Arrays.asList(array);\n    l.add(\"d\");\n}\n\nException in thread \"main\" java.lang.UnsupportedOperationException\n    at java.util.AbstractList.add(AbstractList.java:148)\n    at java.util.AbstractList.add(AbstractList.java:108)\n    at com.example.demo.main(ConcurrentModificationListDemo.java:13)\n```\n问题出在Arrays.asList返回了一个**java.util.Arrays.ArrayList**，而不是**java.util.ArrayList**。前者只实现了List接口的有限的几个方法，并且是Arrays内部的一个private class。\n正确的用法是new 一个ArrayList，把这个有限的list的元素(的指针)copy进去，即addAll()方法\nArrayList.toArray(T[] a)是把所有的elements通过System.arraycopy(elementData, 0, a, 0, size);复制到a数组中。\n\n- System.arraycopy可以从自己的数组复制到自己的数组\n```java\n  public void add(int index, E element) {\n        rangeCheckForAdd(index);\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);  \n        elementData[index] = element;\n        size++;\n    }\n```\n添加到指定位置，System.arrayCopy可以从同一个数组复制到同一个数组，几乎就是挪动指针了。\n\n- 不常见的方法\n\n```java\n//下面这两个是因为ArrayList implements java.io.Serializable，是序列化时会调用的\nprivate void writeObject(java.io.ObjectOutputStream s)\nprivate void readObject(java.io.ObjectInputStream s)\n\nprotected void removeRange(int fromIndex, int toIndex)\n\npublic boolean removeAll(Collection<?> c) //给一个集合，删除list与之的交集\npublic boolean retainAll(Collection<?> c) //  给定一个集合，从list中删除所有不在这个集合里面的元素\n\npublic void trimToSize() // 内存压力大的时候可以释放掉一部分内存，记得那个1.5倍的默认扩容嘛，释放的就是这0.5的内存\n```\n\n\n多线程场景下要注意的问题\n\n> 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。\n\n\n### 1.2 LinkedList的一些点\nLinkedList是双向链表实现的，可以想象成一帮小孩左手拉右手绕成一个圈，只不过这里面的每一个小孩并不是你放进去的 T 类型数据，而是一个Node<T> 。所以LinkedList是可以放进去一个Null的。\nLinkedList往往被人诟病的就是除了添加和删除快之外，get和set很慢。\n来看下add的实现（jdk 1.8）\n\n```java\n   public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n\n/**\n     * Links e as last element.\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;  //先把链表的尾巴找出来\n        final Node<E> newNode = new Node<>(l, e, null); // 可以想象每次add都有new的操作，并将原来的尾巴作为这个新的Entry的头部\n        last = newNode; //新的Node将成为新的尾巴\n        if (l == null) //这种情况是原来没有尾巴，也就是说size = 0\n            first = newNode; //这时候就只有一个Node，头和尾都是Null\n        else\n            l.next = newNode; //不然的话，旧的尾巴变成了倒数第二个，它的next指向了新的Entry.\n\n        size++;\n        modCount++;\n    }\n\n```\n\nadd的过程看起来很快，new一个entery，确定下前后的指针就可以了。remove也差不多，取消指针引用即可。\n\n来看比较慢的get\n\n```java\n public E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n\n  /**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next; //一直遍历到这个index才返回，慢\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n```\n\n值得注意的一点小事：\nArrayList implement RandomAccess接口，而LinkedList并没有。RandomAccess接口的定义如下\n\n> * Marker interface used by <tt>List</tt> implementations to indicate that\n * they support fast (generally constant time) random access.  The primary\n * purpose of this interface is to allow generic algorithms to alter their\n * behavior to provide good performance when applied to either random or\n * sequential access lists.\n *\n * <p>The best algorithms for manipulating random access lists (such as\n * <tt>ArrayList</tt>) can produce quadratic behavior when applied to\n * sequential access lists (such as <tt>LinkedList</tt>).  Generic list\n * algorithms are encouraged to check whether the given list is an\n * <tt>instanceof</tt> this interface before applying an algorithm that would\n * provide poor performance if it were applied to a sequential access list,\n * and to alter their behavior if necessary to guarantee acceptable\n * performance.\n *\n * <p>It is recognized that the distinction between random and sequential\n * access is often fuzzy.  For example, some <tt>List</tt> implementations\n * provide asymptotically linear access times if they get huge, but constant\n * access times in practice.  Such a <tt>List</tt> implementation\n * should generally implement this interface.  As a rule of thumb, a\n * List implementation should implement this interface if,\n * for typical instances of the class, this loop:\n *     for (int i=0, n=list.size(); i &lt; n; i++)\n *         list.get(i); //get的速度应该是恒定的\n * runs faster than this loop:\n *     for (Iterator i=list.iterator(); i.hasNext(); )\n *         i.next();\n\n\n这种接口就是给外界使用者看的，用来说明该集合支持这种通过下标查找（速度不变）的快速操作\n\n实践表明，对于linkedList，采用for loop的方式要很慢，但使用ListIterator<T>的方式，速度并不慢，简单来想，沿着链表的一个方向一致往下走就是了嘛。\n一些经验表明(摘自简书作者嘟爷MD的文章)\n\n[ArryList和LinkedList的对比结论](http://www.jianshu.com/p/d5ec2ff72b33)\n\n> 1、顺序插入速度ArrayList会比较快\n> 2、LinkedList将比ArrayList更耗费一些内存\n> 3、ArrayList的遍历效率会比LinkedList的遍历效率高一些\n> 4、有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：如果增加或者删除的元素在前半部分的时候，ArrayList会频繁调用System.arrayCopy方法，虽然native方法快，但高频率调用肯定慢，至少比不上移动指针。\n\n\n## 2. Map的几个实现类\n### 2.1 HashMap源码解析\n\n>public class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n\nHashMap不是线程安全的，Key和Value都有可能为null，存储数据不是有序的(get的顺序不是put的顺序)\n\nHashMap中有几个默认值常量\n\n    默认初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    默认加载因子是0.75f ，加载因子是指Hashmap在自动扩容之前可以达到多满\n    static final float DEFAULT_LOAD_FACTOR = 0.75f; //一般不需要改\n\n构造函数有好几个\n\n```java\n public HashMap(int initialCapacity, float loadFactor)  //自定义加载因子，比较玄学\n public HashMap(int initialCapacity) // 避免扩容，和ArrayList初始化指定容量类似的道理\n public HashMap() //直接把初始容量设置成16\n public HashMap(Map<? extends K, ? extends V> m)\n```\n[注意这个初始容量必须是2的n次方](https://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity-be-a-power-of-two)\n\n来看常见的CURD操作(jdk 1.8源码，和我在网上找到的jdk1.6源码有一些变化了)\n```java\n public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true); //HashMap允许key为null,key为null的话，直接放到数组的0的位置（hash方法返回的是0）\n    }\n\n    static final int hash(Object key) {\n           int h;\n           return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); //如果是null，放到数组的第一个\n// 这里面就是HashMap算法的高明之处  ，\n//  1. 首先算出object的hashcode，\n//2.然后根据上述公式将二进制的1尽量分散的均匀一点         \n// 3. 在putVal的时候将这个值跟数组的长度length-1进行位运算，得到一个比length小的正数，作为这个新元素在数组中的index.但这样仍不免会产生冲突(hash Collision)\n       }\n\n\n /**\n     * Implements Map.put and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @param value the value to put\n     * @param onlyIfAbsent if true, don't change existing value\n     * @param evict if false, the table is in creation mode.\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length; //table为成员变量，是一个Node数组，为空的话则创建 。在resize中创建\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p; //Table数组中找到了这个下标的元素，直接指定\n            else if (p instanceof TreeNode)//p可以理解为previous 。 如果发现这个节点是一棵树（红黑树？）\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {//否则该节点是链表，各个元素之间手拉手的那种\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null); //找到这个链表的尾巴了\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e); //回调函数\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);//回调函数\n        return null;\n    }\n\n```\n\nget方法\n```java\n  public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;//根据key来找value\n    }\n    /**\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @return the node, or null if none\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) { //table不为空说明曾经put过\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n\n\n  public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n\n    /**\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @return the node, or null if none\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n    //可以看出比较的方式就是hash（int）相等且key(指针相等)  或者key equals(所以经常说重写equals需要确保hashcode一致，这里至少反应了这一点)\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n\n```\n\n回想一下平时迭代一个HashMap的方式\n```java\nlong i = 0;\nIterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\nwhile (it.hasNext()) {\n    Map.Entry<Integer, Integer> pair = it.next(); //上面的get也是这种不断查找next的方式\n    i += pair.getKey() + pair.getValue();\n}\n```\n\nentrySet方法是Map接口定义的\n```\nSet<Map.Entry<K, V>> entrySet();\n   * Returns a Set view of the mappings contained in this map.\n     * The set is backed by the map, so changes to the map are\n     * reflected in the set, and vice-versa.  If the map is modified\n     * while an iteration over the set is in progress (except through\n     * the iterator's own <tt>remove</tt> operation, or through the\n     * <tt>setValue</tt> operation on a map entry returned by the\n     * iterator) the results of the iteration are undefined.  The set\n     * supports element removal, which removes the corresponding\n     * mapping from the map, via the <tt>Iterator.remove</tt>,\n     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n     * <tt>clear</tt> operations.  It does not support the\n     * <tt>add</tt> or <tt>addAll</tt> operations.\n     *\n     * @return a set view of the mappings contained in this map\n```\n\n大致意思是： 返回一个能够反映该map元素组合的一个Set，对这个Set的操作都将反映到原map上，反之亦然。在通过entrySet迭代这个map的时候，除了remove和操作操作都是不被支持的。返回的Set支持删除对应的mapping组合。但不支持add操作\n\nHashMap内部保留了一个这样的成员变量：\ntransient Set<Map.Entry<K,V>> entrySet; //成员变量\n具体实现enterySet方法的地方：\n```java\n  public Set<Map.Entry<K,V>> entrySet() {\n        Set<Map.Entry<K,V>> es;\n        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;\n    }\n\n// 这个EntrySet大致长这样\n  final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n        public final int size()                 { return size; }\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n        public final boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Node<K,V> candidate = getNode(hash(key), key);\n            return candidate != null && candidate.equals(e);\n        }\n        public final boolean remove(Object o) {\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n                Object key = e.getKey();\n                Object value = e.getValue();\n                return removeNode(hash(key), key, value, true, true) != null;\n            }\n            return false;\n        }\n    }\n\n```\n整理的关键在于removeNode方法，和getNode和putVal很像\n```java\n   final Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            } //先把p(previous)找出来，这里的matchValue和movable都是true\n            // node 就是包含了要移出对象的Node\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                else if (node == p) //数组这个位置就一个\n                    tab[index] = node.next;//直接指向下一个\n                else\n                    p.next = node.next; //数组这个位置指向链表下一个节点，释放引用\n                ++modCount;\n                --size;\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n```\n比较元素是否相同的关键是\n> e.hash == hash || (key!=null &&key.equals(k)) //后半部分其实也是比较hashCode\n\n另外一些平时常用的方法包括：\n```java\n  public boolean containsKey(Object key) {\n        return getNode(hash(key), key) != null; //就是检查下有没有这个key对应的Node\n    }\n\n   public boolean containsValue(Object value) {\n        Node<K,V>[] tab; V v;\n        if ((tab = table) != null && size > 0) {\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next) {\n                    if ((v = e.value) == value ||\n                        (value != null && value.equals(v)))\n                        return true; //遍历内部的数组，仅此而已\n                }\n            }\n        }\n        return false;\n    }\n```\n\n和ArrayList、LinkedList比起来，HashMap的源码要麻烦许多，这里面涉及到hashCode，链表，红黑树。需要一点数据结构的知识。另外，HashMap还针对hashCode冲突（hash Collision，不同的Object居然有相同的hashCode）的情况作了[预处理](https://stackoverflow.com/questions/6493605/how-does-a-java-hashmap-handle-different-objects-with-the-same-hash-code)\n通俗的来说，HashMap内部维护了一个数组，每一个数组元素内部不一定只有一个，有可能是一个链表。每次添加(key,value)不是盲目的往这个数组里面塞，而是算下key的hash值，放到对应的节点上。如果这个节点上还没有元素，直接放就好了。如果有的话，新加入的value将被作为原有元素的Next(外部调用get的时候，先根据传入的key的hashCode找到节点，然后根据key.equals来找)。简单如此，精致如斯。\n\n### 2.2 LinkedHashMap\n\npublic class LinkedHashMap<K,V>\n    extends HashMap<K,V>\n    implements Map<K,V>\nHashMap源码我看了下有两千多行，LinkedHashMap只有七百多行，显然这是继承带来的简便之处。\n关键的成员变量  \nfinal boolean accessOrder; 默认是false\n> The iteration ordering method for this linked hash map: <tt>true</tt>\nfor access-order, false for insertion-order.\n\nLinkedHashMap常用的属性就是它支持有序，这个有序是指迭代的时候有序\n\n### 2.3 SparseArray\n先来看一段崩溃日志\n```\nFatal Exception: java.lang.ArrayIndexOutOfBoundsException: src.length=509 srcPos=60 dst.length=509 dstPos=61 length=-60\n       at java.lang.System.arraycopy(System.java:388)\n       at com.android.internal.util.GrowingArrayUtils.insert(GrowingArrayUtils.java:135)\n       at android.util.SparseIntArray.put(SparseIntArray.java:144)\n```\nSparseArry提供了类似于HashMap的调用接口，\n\n使用SparseArray的初衷还是在android这种内存比cpu金贵的平台中，使用SparseArry相比HashMap能够减轻内存压力，获得更好的性能。\n[liaohuqiu指出SparseArry并不是任何时候都更快](https://www.liaohuqiu.net/cn/posts/sparse-array-in-android/)，主要是节省内存，避免autoBoxing，二分法查找对于cpu的消耗需要权衡。尤其是存储的量很大的时候，二分法查找的速度会很慢。\n\nSparseArry类似的class有好几个，据说有八个，以SparseIntArry为例\nSparseIntArry的几个常用方法,值得注意的是 clear方法只不过是把计数清零了。\n```java\npublic int indexOfKey(int key)\npublic int indexOfValue(int value)\npublic int get(int key)\npublic void put(int key, int value)\n\npublic void clear() {\n       mSize = 0;\n   }\n//迭代一个SparseArry的方法\nfor(int i = 0; i < sparseArray.size(); i++) {\n   int key = sparseArray.keyAt(i);\n   // get the object by the key.\n   Object obj = sparseArray.get(key);\n}\n\n// 从源码来看变量结构\npublic class SparseIntArray implements Cloneable{\n    private int[] mKeys;\n    private int[] mValues;\n    private int mSize;\n}\n\n\n\npublic void put(int key, int value) {\n     int i = ContainerHelpers.binarySearch(mKeys, mSize, key); //二分法查找\n\n     if (i >= 0) {\n         mValues[i] = value; //找到了在Value数组中的index,直接替换掉\n     } else {\n         i = ~i;\n         mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);\n         mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);\n         mSize++;\n     }\n }\n\n```\n\n廖祜秋 特地强调\n1. SparseArray 是针对HashMap做的优化。\n    1.HashMap 内部的存储结构，导致一些内存的浪费。\n    2.在刚扩容完，SparseArray 和 HashMap 都会存在一些没被利用的内存。\n2. SparseArray 并不是任何时候都会更快，有时反而会更慢\n\n\n\n\n### 2.4 ArrayMap\n\n\n\n\n\n\n## 3. Set的介绍\nSet用比较少，HashSet、TreeSet和LinkedHashSet是jdk的实现类\n\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\nSet的重要特点就是**不能放进去重复**的元素，Set中不会存在e1和e2，e1.equals(e2)的情况\nHashSet的源码只有三百多行，内部有一个map（HashMap）相对来说是比较简单的。其实Set平时用的也不是那么多。。。\n\n### 4. 一些不常用的类\n\n    Vetor，Stack，ArrayDeque,Queue\n\n    Vector属于List,线程安全，但效率低（就是简单的在所有方法前面加上了synchronized）\n\n    Queue是一个interface，属于两端可以出入的List，通常是(FIFO模式)，实现类有\n    PriorityQueue，\n    java.util.concurrent.LinkedBlockingQueue\n    java.util.concurrent.LinkedBlockingQueue\n    java.util.concurrent.PriorityBlockingQueue\n    作者都是大名鼎鼎的Doug Lea\n\n    Stack是Vector的子类(属于LIFO的栈)\n    The Stack class represents a last-in-first-out (LIFO) stack of object\n\n    Deque(双端队列)\n\n\n### 5. concurrentHashMap等\njdk1.8的concurrentHashMap不是用synchronized实现的，是Doug Lea使用CAS操作写的，非常高效。\n\n### 6. WeakHaskMap\nWeakHashMap的Key是WeakReference，但Value不是。\n常见用法\n\n```java\nString a = \"a\";\nmap.put(1,a);\na = null;\n//map中的a可以出了map自身外没有其他地方被引用，a将被被gc回收\n```\n\nAndroid [官方开发文档](https://developer.android.com/reference/java/util/WeakHashMap.html)上指出了一点\n\n> Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get.\n\nWeakHashMap的value不要持有key的强引用，否则，key永远不会被清除,value也别想被清除。\n\n\n## 7. java 8的一些新的方法\nlist.replaceAll(String::toUpperCase) //method reference\ncan not change the elemeet type, for that you need an stream\n[Collections Refuled by Stuart Marks](https://www.youtube.com/watch?v=q6zF3vf114M)\n\n## 8.结束语\n8.1 [Doug Lea](https://en.wikipedia.org/wiki/Doug_Lea) 是非常聪明的人，估计并发经常会牵涉到集合，所以jdk里面很多集合都有他的作品\n8.2 jdk只是定义了这些框架，像List，Map这些全都是接口，完全可以自己去实现。Apache就有一大堆适合特定场景的集合实现类。jdk只是帮助我们实现了一些常见的类。如果有现成的满足需求的框架，不要重复造轮子。\n8.3 平时只要记住ArrayList和HashMap的**大致内部实现**就可以了，至于别的，除非面试，平时没必要记录。\n8.4 [Stuart Mark](https://blogs.oracle.com/java/collections-refueled)特别喜欢把一个class搞成**@deprecated**\n8.5 就连[Joshua Bloch](https://www.youtube.com/watch?v=V1vQf4qyMXg) 都承认，除非性能真的很重要的，平时没必要过度优化。By the way , he said Doug Lea is very smart .\n\n\n\n### Reference\n1. [Collections Refuled by Stuart Marks](https://www.youtube.com/watch?v=q6zF3vf114M)\n2. [From Java Code to Java Heap: Understanding the Memory Usage of Your Application](https://www.youtube.com/watch?v=FLcXf9pO27w)\n3. [Java集合干货系列](http://www.jianshu.com/p/2cd7be850540)\n4. [Arrays.asList()返回的List不是jva.util.ArrayList](http://www.programcreek.com/2014/01/java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF/)\n5. [WeakHashMap和HashMap的区别](http://blog.csdn.net/yangzl2008/article/details/6980709)\n","slug":"2017-06-12-Collections-Refuled-by-Stuart-Marks","published":1,"updated":"2017-07-15T08:56:34.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnio001ubovrtusk6yvj","content":"<p>根据网上的大部分博客的分类，集合框架分为Collections(具有类似数组的功能)和Map(存储键值对)这两大部分。针对jdk1.8的java.util里面的一些常用的或者不常用的集合做一些分析。写这篇文章的过程中，我慢慢发现不同版本jdk的同一个class的实现是有一些差异的(LinkedList)，由于对照的是java1.8的代码，里面会多一些since 1.8的代码，这里不作论述。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>java集合的大致框架建议参考网上博客的总结，<a href=\"http://www.jianshu.com/p/2cd7be850540\">Java集合干货系列</a>写的比较好，图画的也不错，针对jdk 1.6源码讲的。我这里只是自己学习过程中的一些笔记。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>ArrayList (建议new出来的时候给定一个适当的size，不然每次扩容很慢的，可以放null)<br>LinkedList(not recommended，增删元素的时候快一点)<br>Vector（线程安全,重同步，不推荐）</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>HashSet (底层是HashMap)<br>TreeSet(排序存储)<br>LinkedHashSet(底层是LinkedHashMap)</p>\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><p>Stack ArrayDeque(不常用)</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>HashMap （键值都可以为null,底层是哈希表）<br>TreeMap(底层二叉树)<br>HashTable(线程安全，键值都不允许为null)<br>SparseArray(Android平台用)</p>\n<p>关于集合，不得不提到泛型，Java 1.5引入了泛型，关于泛型，找到一篇很好的文章<br><a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\">类型擦除原理</a>。本质上只是提供了编译期类型检查。编译通过后都是Object，所以叫做<a href=\"https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4\">类型擦除</a>。</p>\n<h2 id=\"1-List的解析\"><a href=\"#1-List的解析\" class=\"headerlink\" title=\"1. List的解析\"></a>1. List的解析</h2><h3 id=\"1-1-ArrayList源码解析\"><a href=\"#1-1-ArrayList源码解析\" class=\"headerlink\" title=\"1.1 ArrayList源码解析\"></a>1.1 ArrayList源码解析</h3><ul>\n<li>先上一段崩溃代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    String[] array = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>&#125;;</div><div class=\"line\">    List&lt;String&gt; l = Arrays.asList(array);</div><div class=\"line\">    l.add(<span class=\"string\">\"d\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.UnsupportedOperationException</div><div class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">148</span>)</div><div class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">108</span>)</div><div class=\"line\">    at com.example.demo.main(ConcurrentModificationListDemo.java:<span class=\"number\">13</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>问题出在Arrays.asList返回了一个<strong>java.util.Arrays.ArrayList</strong>，而不是<strong>java.util.ArrayList</strong>。前者只实现了List接口的有限的几个方法，并且是Arrays内部的一个private class。<br>正确的用法是new 一个ArrayList，把这个有限的list的元素(的指针)copy进去，即addAll()方法<br>ArrayList.toArray(T[] a)是把所有的elements通过System.arraycopy(elementData, 0, a, 0, size);复制到a数组中。</p>\n<ul>\n<li>System.arraycopy可以从自己的数组复制到自己的数组<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</div><div class=\"line\">      rangeCheckForAdd(index);</div><div class=\"line\">      ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></div><div class=\"line\">      System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</div><div class=\"line\">                       size - index);  </div><div class=\"line\">      elementData[index] = element;</div><div class=\"line\">      size++;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加到指定位置，System.arrayCopy可以从同一个数组复制到同一个数组，几乎就是挪动指针了。</p>\n<ul>\n<li>不常见的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//下面这两个是因为ArrayList implements java.io.Serializable，是序列化时会调用的</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeObject</span><span class=\"params\">(java.io.ObjectOutputStream s)</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObject</span><span class=\"params\">(java.io.ObjectInputStream s)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRange</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> <span class=\"comment\">//给一个集合，删除list与之的交集</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> <span class=\"comment\">//  给定一个集合，从list中删除所有不在这个集合里面的元素</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">()</span> <span class=\"comment\">// 内存压力大的时候可以释放掉一部分内存，记得那个1.5倍的默认扩容嘛，释放的就是这0.5的内存</span></span></div></pre></td></tr></table></figure>\n<p>多线程场景下要注意的问题</p>\n<blockquote>\n<p>和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p>\n</blockquote>\n<h3 id=\"1-2-LinkedList的一些点\"><a href=\"#1-2-LinkedList的一些点\" class=\"headerlink\" title=\"1.2 LinkedList的一些点\"></a>1.2 LinkedList的一些点</h3><p>LinkedList是双向链表实现的，可以想象成一帮小孩左手拉右手绕成一个圈，只不过这里面的每一个小孩并不是你放进去的 T 类型数据，而是一个Node<T> 。所以LinkedList是可以放进去一个Null的。<br>LinkedList往往被人诟病的就是除了添加和删除快之外，get和set很慢。<br>来看下add的实现（jdk 1.8）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        linkLast(e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     * Links e as last element.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;  <span class=\"comment\">//先把链表的尾巴找出来</span></div><div class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>); <span class=\"comment\">// 可以想象每次add都有new的操作，并将原来的尾巴作为这个新的Entry的头部</span></div><div class=\"line\">        last = newNode; <span class=\"comment\">//新的Node将成为新的尾巴</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>) <span class=\"comment\">//这种情况是原来没有尾巴，也就是说size = 0</span></div><div class=\"line\">            first = newNode; <span class=\"comment\">//这时候就只有一个Node，头和尾都是Null</span></div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            l.next = newNode; <span class=\"comment\">//不然的话，旧的尾巴变成了倒数第二个，它的next指向了新的Entry.</span></div><div class=\"line\"></div><div class=\"line\">        size++;</div><div class=\"line\">        modCount++;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>add的过程看起来很快，new一个entery，确定下前后的指针就可以了。remove也差不多，取消指针引用即可。</p>\n<p>来看比较慢的get</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">       checkElementIndex(index);</div><div class=\"line\">       <span class=\"keyword\">return</span> node(index).item;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">/**</div><div class=\"line\">    * Returns the (non-null) Node at the specified element index.</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// assert isElementIndex(index);</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</div><div class=\"line\">           Node&lt;E&gt; x = first;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</div><div class=\"line\">               x = x.next; <span class=\"comment\">//一直遍历到这个index才返回，慢</span></div><div class=\"line\">           <span class=\"keyword\">return</span> x;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           Node&lt;E&gt; x = last;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</div><div class=\"line\">               x = x.prev;</div><div class=\"line\">           <span class=\"keyword\">return</span> x;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>值得注意的一点小事：<br>ArrayList implement RandomAccess接口，而LinkedList并没有。RandomAccess接口的定义如下</p>\n<blockquote>\n<ul>\n<li>Marker interface used by <tt>List</tt> implementations to indicate that<ul>\n<li>they support fast (generally constant time) random access.  The primary</li>\n<li>purpose of this interface is to allow generic algorithms to alter their</li>\n<li>behavior to provide good performance when applied to either random or</li>\n<li>sequential access lists.<br>*</li>\n<li><p>The best algorithms for manipulating random access lists (such as</li>\n<li><tt>ArrayList</tt>) can produce quadratic behavior when applied to</li>\n<li>sequential access lists (such as <tt>LinkedList</tt>).  Generic list</li>\n<li>algorithms are encouraged to check whether the given list is an</li>\n<li><tt>instanceof</tt> this interface before applying an algorithm that would</li>\n<li>provide poor performance if it were applied to a sequential access list,</li>\n<li>and to alter their behavior if necessary to guarantee acceptable</li>\n<li>performance.<br>*</li>\n<li><p>It is recognized that the distinction between random and sequential</li>\n<li>access is often fuzzy.  For example, some <tt>List</tt> implementations</li>\n<li>provide asymptotically linear access times if they get huge, but constant</li>\n<li>access times in practice.  Such a <tt>List</tt> implementation</li>\n<li>should generally implement this interface.  As a rule of thumb, a</li>\n<li>List implementation should implement this interface if,</li>\n<li>for typical instances of the class, this loop:</li>\n<li>for (int i=0, n=list.size(); i &lt; n; i++)</li>\n<li>list.get(i); //get的速度应该是恒定的</li>\n<li>runs faster than this loop:</li>\n<li>for (Iterator i=list.iterator(); i.hasNext(); )</li>\n<li>i.next();</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>这种接口就是给外界使用者看的，用来说明该集合支持这种通过下标查找（速度不变）的快速操作</p>\n<p>实践表明，对于linkedList，采用for loop的方式要很慢，但使用ListIterator<T>的方式，速度并不慢，简单来想，沿着链表的一个方向一致往下走就是了嘛。<br>一些经验表明(摘自简书作者嘟爷MD的文章)</p>\n<p><a href=\"http://www.jianshu.com/p/d5ec2ff72b33\">ArryList和LinkedList的对比结论</a></p>\n<blockquote>\n<p>1、顺序插入速度ArrayList会比较快<br>2、LinkedList将比ArrayList更耗费一些内存<br>3、ArrayList的遍历效率会比LinkedList的遍历效率高一些<br>4、有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：如果增加或者删除的元素在前半部分的时候，ArrayList会频繁调用System.arrayCopy方法，虽然native方法快，但高频率调用肯定慢，至少比不上移动指针。</p>\n</blockquote>\n<h2 id=\"2-Map的几个实现类\"><a href=\"#2-Map的几个实现类\" class=\"headerlink\" title=\"2. Map的几个实现类\"></a>2. Map的几个实现类</h2><h3 id=\"2-1-HashMap源码解析\"><a href=\"#2-1-HashMap源码解析\" class=\"headerlink\" title=\"2.1 HashMap源码解析\"></a>2.1 HashMap源码解析</h3><blockquote>\n<p>public class HashMap<K,V> extends AbstractMap<K,V><br>    implements Map<K,V>, Cloneable, Serializable</p>\n</blockquote>\n<p>HashMap不是线程安全的，Key和Value都有可能为null，存储数据不是有序的(get的顺序不是put的顺序)</p>\n<p>HashMap中有几个默认值常量</p>\n<pre><code>默认初始容量是16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16\n\n默认加载因子是0.75f ，加载因子是指Hashmap在自动扩容之前可以达到多满\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; //一般不需要改\n</code></pre><p>构造函数有好几个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span>  <span class=\"comment\">//自定义加载因子，比较玄学</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> <span class=\"comment\">// 避免扩容，和ArrayList初始化指定容量类似的道理</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> <span class=\"comment\">//直接把初始容量设置成16</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span></span></div></pre></td></tr></table></figure>\n<p><a href=\"https://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity-be-a-power-of-two\">注意这个初始容量必须是2的n次方</a></p>\n<p>来看常见的CURD操作(jdk 1.8源码，和我在网上找到的jdk1.6源码有一些变化了)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>); <span class=\"comment\">//HashMap允许key为null,key为null的话，直接放到数组的0的位置（hash方法返回的是0）</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">int</span> h;</div><div class=\"line\">           <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>); <span class=\"comment\">//如果是null，放到数组的第一个</span></div><div class=\"line\"><span class=\"comment\">// 这里面就是HashMap算法的高明之处  ，</span></div><div class=\"line\"><span class=\"comment\">//  1. 首先算出object的hashcode，</span></div><div class=\"line\"><span class=\"comment\">//2.然后根据上述公式将二进制的1尽量分散的均匀一点         </span></div><div class=\"line\"><span class=\"comment\">// 3. 在putVal的时候将这个值跟数组的长度length-1进行位运算，得到一个比length小的正数，作为这个新元素在数组中的index.但这样仍不免会产生冲突(hash Collision)</span></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">/**</div><div class=\"line\">     * Implements Map.put and related methods</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> hash hash for key</div><div class=\"line\">     * <span class=\"doctag\">@param</span> key the key</div><div class=\"line\">     * <span class=\"doctag\">@param</span> value the value to put</div><div class=\"line\">     * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don't change existing value</div><div class=\"line\">     * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</div><div class=\"line\">     * <span class=\"doctag\">@return</span> previous value, or null if none</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</div><div class=\"line\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</div><div class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</div><div class=\"line\">            n = (tab = resize()).length; <span class=\"comment\">//table为成员变量，是一个Node数组，为空的话则创建 。在resize中创建</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</div><div class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            Node&lt;K,V&gt; e; K k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</div><div class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                e = p; <span class=\"comment\">//Table数组中找到了这个下标的元素，直接指定</span></div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)<span class=\"comment\">//p可以理解为previous 。 如果发现这个节点是一棵树（红黑树？）</span></div><div class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//否则该节点是链表，各个元素之间手拉手的那种</span></div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>); <span class=\"comment\">//找到这个链表的尾巴了</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></div><div class=\"line\">                            treeifyBin(tab, hash);</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    p = e;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</div><div class=\"line\">                    e.value = value;</div><div class=\"line\">                afterNodeAccess(e); <span class=\"comment\">//回调函数</span></div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ++modCount;</div><div class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</div><div class=\"line\">            resize();</div><div class=\"line\">        afterNodeInsertion(evict);<span class=\"comment\">//回调函数</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>get方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt; e;</div><div class=\"line\">      <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;<span class=\"comment\">//根据key来找value</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * Implements Map.get and related methods</div><div class=\"line\">   *</div><div class=\"line\">   * <span class=\"doctag\">@param</span> hash hash for key</div><div class=\"line\">   * <span class=\"doctag\">@param</span> key the key</div><div class=\"line\">   * <span class=\"doctag\">@return</span> the node, or null if none</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</div><div class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">          (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//table不为空说明曾经put过</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></div><div class=\"line\">              ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">              <span class=\"keyword\">return</span> first;</div><div class=\"line\">          <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                  <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class=\"line\">              do &#123;</div><div class=\"line\">                  <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                      ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                      <span class=\"keyword\">return</span> e;</div><div class=\"line\">              &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt; e;</div><div class=\"line\">      <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * Implements Map.get and related methods</div><div class=\"line\">   *</div><div class=\"line\">   * <span class=\"doctag\">@param</span> hash hash for key</div><div class=\"line\">   * <span class=\"doctag\">@param</span> key the key</div><div class=\"line\">   * <span class=\"doctag\">@return</span> the node, or null if none</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</div><div class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">          (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></div><div class=\"line\">              ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">              <span class=\"keyword\">return</span> first;</div><div class=\"line\">          <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                  <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class=\"line\">              do &#123;</div><div class=\"line\">                  <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                      ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                      <span class=\"keyword\">return</span> e;</div><div class=\"line\">  <span class=\"comment\">//可以看出比较的方式就是hash（int）相等且key(指针相等)  或者key equals(所以经常说重写equals需要确保hashcode一致，这里至少反应了这一点)</span></div><div class=\"line\">              &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>回想一下平时迭代一个HashMap的方式<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">long</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\">    Map.Entry&lt;Integer, Integer&gt; pair = it.next(); <span class=\"comment\">//上面的get也是这种不断查找next的方式</span></div><div class=\"line\">    i += pair.getKey() + pair.getValue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>entrySet方法是Map接口定义的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</div><div class=\"line\">   * Returns a Set view of the mappings contained in this map.</div><div class=\"line\">     * The set is backed by the map, so changes to the map are</div><div class=\"line\">     * reflected in the set, and vice-versa.  If the map is modified</div><div class=\"line\">     * while an iteration over the set is in progress (except through</div><div class=\"line\">     * the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</div><div class=\"line\">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</div><div class=\"line\">     * iterator) the results of the iteration are undefined.  The set</div><div class=\"line\">     * supports element removal, which removes the corresponding</div><div class=\"line\">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</div><div class=\"line\">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</div><div class=\"line\">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</div><div class=\"line\">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</div><div class=\"line\">     *</div><div class=\"line\">     * @return a set view of the mappings contained in this map</div></pre></td></tr></table></figure></p>\n<p>大致意思是： 返回一个能够反映该map元素组合的一个Set，对这个Set的操作都将反映到原map上，反之亦然。在通过entrySet迭代这个map的时候，除了remove和操作操作都是不被支持的。返回的Set支持删除对应的mapping组合。但不支持add操作</p>\n<p>HashMap内部保留了一个这样的成员变量：<br>transient Set<Map.Entry<K,V>&gt; entrySet; //成员变量<br>具体实现enterySet方法的地方：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"keyword\">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class=\"line\">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div class=\"line\">        <span class=\"keyword\">return</span> (es = entrySet) == <span class=\"keyword\">null</span> ? (entrySet = <span class=\"keyword\">new</span> EntrySet()) : es;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个EntrySet大致长这样</span></div><div class=\"line\">  <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EntrySet</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSet</span>&lt;<span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;&gt; </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span>                 </span>&#123; <span class=\"keyword\">return</span> size; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span>               </span>&#123; HashMap.<span class=\"keyword\">this</span>.clear(); &#125;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EntryIterator();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class=\"line\">            Object key = e.getKey();</div><div class=\"line\">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</div><div class=\"line\">            <span class=\"keyword\">return</span> candidate != <span class=\"keyword\">null</span> &amp;&amp; candidate.equals(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</div><div class=\"line\">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class=\"line\">                Object key = e.getKey();</div><div class=\"line\">                Object value = e.getValue();</div><div class=\"line\">                <span class=\"keyword\">return</span> removeNode(hash(key), key, value, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>) != <span class=\"keyword\">null</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>整理的关键在于removeNode方法，和getNode和putVal很像<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</div><div class=\"line\">                            <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</div><div class=\"line\">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</div><div class=\"line\">     <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">         (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</div><div class=\"line\">         <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</div><div class=\"line\">             ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">             node = p;</div><div class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class=\"line\">             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                 do &#123;</div><div class=\"line\">                     <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                         ((k = e.key) == key ||</div><div class=\"line\">                          (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class=\"line\">                         node = e;</div><div class=\"line\">                         <span class=\"keyword\">break</span>;</div><div class=\"line\">                     &#125;</div><div class=\"line\">                     p = e;</div><div class=\"line\">                 &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; <span class=\"comment\">//先把p(previous)找出来，这里的matchValue和movable都是true</span></div><div class=\"line\">         <span class=\"comment\">// node 就是包含了要移出对象的Node</span></div><div class=\"line\">         <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class=\"line\">                              (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</div><div class=\"line\">             <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p) <span class=\"comment\">//数组这个位置就一个</span></div><div class=\"line\">                 tab[index] = node.next;<span class=\"comment\">//直接指向下一个</span></div><div class=\"line\">             <span class=\"keyword\">else</span></div><div class=\"line\">                 p.next = node.next; <span class=\"comment\">//数组这个位置指向链表下一个节点，释放引用</span></div><div class=\"line\">             ++modCount;</div><div class=\"line\">             --size;</div><div class=\"line\">             afterNodeRemoval(node);</div><div class=\"line\">             <span class=\"keyword\">return</span> node;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>比较元素是否相同的关键是</p>\n<blockquote>\n<p>e.hash == hash || (key!=null &amp;&amp;key.equals(k)) //后半部分其实也是比较hashCode</p>\n</blockquote>\n<p>另外一些平时常用的方法包括：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> getNode(hash(key), key) != <span class=\"keyword\">null</span>; <span class=\"comment\">//就是检查下有没有这个key对应的Node</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt;[] tab; V v;</div><div class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i) &#123;</div><div class=\"line\">              <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">                  <span class=\"keyword\">if</span> ((v = e.value) == value ||</div><div class=\"line\">                      (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">//遍历内部的数组，仅此而已</span></div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>和ArrayList、LinkedList比起来，HashMap的源码要麻烦许多，这里面涉及到hashCode，链表，红黑树。需要一点数据结构的知识。另外，HashMap还针对hashCode冲突（hash Collision，不同的Object居然有相同的hashCode）的情况作了<a href=\"https://stackoverflow.com/questions/6493605/how-does-a-java-hashmap-handle-different-objects-with-the-same-hash-code\">预处理</a><br>通俗的来说，HashMap内部维护了一个数组，每一个数组元素内部不一定只有一个，有可能是一个链表。每次添加(key,value)不是盲目的往这个数组里面塞，而是算下key的hash值，放到对应的节点上。如果这个节点上还没有元素，直接放就好了。如果有的话，新加入的value将被作为原有元素的Next(外部调用get的时候，先根据传入的key的hashCode找到节点，然后根据key.equals来找)。简单如此，精致如斯。</p>\n<h3 id=\"2-2-LinkedHashMap\"><a href=\"#2-2-LinkedHashMap\" class=\"headerlink\" title=\"2.2 LinkedHashMap\"></a>2.2 LinkedHashMap</h3><p>public class LinkedHashMap<K,V><br>    extends HashMap<K,V><br>    implements Map<K,V><br>HashMap源码我看了下有两千多行，LinkedHashMap只有七百多行，显然这是继承带来的简便之处。<br>关键的成员变量<br>final boolean accessOrder; 默认是false</p>\n<blockquote>\n<p>The iteration ordering method for this linked hash map: <tt>true</tt><br>for access-order, false for insertion-order.</p>\n</blockquote>\n<p>LinkedHashMap常用的属性就是它支持有序，这个有序是指迭代的时候有序</p>\n<h3 id=\"2-3-SparseArray\"><a href=\"#2-3-SparseArray\" class=\"headerlink\" title=\"2.3 SparseArray\"></a>2.3 SparseArray</h3><p>先来看一段崩溃日志<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Fatal Exception: java.lang.ArrayIndexOutOfBoundsException: src.length=509 srcPos=60 dst.length=509 dstPos=61 length=-60</div><div class=\"line\">       at java.lang.System.arraycopy(System.java:388)</div><div class=\"line\">       at com.android.internal.util.GrowingArrayUtils.insert(GrowingArrayUtils.java:135)</div><div class=\"line\">       at android.util.SparseIntArray.put(SparseIntArray.java:144)</div></pre></td></tr></table></figure></p>\n<p>SparseArry提供了类似于HashMap的调用接口，</p>\n<p>使用SparseArray的初衷还是在android这种内存比cpu金贵的平台中，使用SparseArry相比HashMap能够减轻内存压力，获得更好的性能。<br><a href=\"https://www.liaohuqiu.net/cn/posts/sparse-array-in-android/\">liaohuqiu指出SparseArry并不是任何时候都更快</a>，主要是节省内存，避免autoBoxing，二分法查找对于cpu的消耗需要权衡。尤其是存储的量很大的时候，二分法查找的速度会很慢。</p>\n<p>SparseArry类似的class有好几个，据说有八个，以SparseIntArry为例<br>SparseIntArry的几个常用方法,值得注意的是 clear方法只不过是把计数清零了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOfKey</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOfValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       mSize = <span class=\"number\">0</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//迭代一个SparseArry的方法</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sparseArray.size(); i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">int</span> key = sparseArray.keyAt(i);</div><div class=\"line\">   <span class=\"comment\">// get the object by the key.</span></div><div class=\"line\">   Object obj = sparseArray.get(key);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从源码来看变量结构</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SparseIntArray</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mKeys;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mValues;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mSize;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key); <span class=\"comment\">//二分法查找</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         mValues[i] = value; <span class=\"comment\">//找到了在Value数组中的index,直接替换掉</span></div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         i = ~i;</div><div class=\"line\">         mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</div><div class=\"line\">         mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</div><div class=\"line\">         mSize++;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>廖祜秋 特地强调</p>\n<ol>\n<li>SparseArray 是针对HashMap做的优化。<br> 1.HashMap 内部的存储结构，导致一些内存的浪费。<br> 2.在刚扩容完，SparseArray 和 HashMap 都会存在一些没被利用的内存。</li>\n<li>SparseArray 并不是任何时候都会更快，有时反而会更慢</li>\n</ol>\n<h3 id=\"2-4-ArrayMap\"><a href=\"#2-4-ArrayMap\" class=\"headerlink\" title=\"2.4 ArrayMap\"></a>2.4 ArrayMap</h3><h2 id=\"3-Set的介绍\"><a href=\"#3-Set的介绍\" class=\"headerlink\" title=\"3. Set的介绍\"></a>3. Set的介绍</h2><p>Set用比较少，HashSet、TreeSet和LinkedHashSet是jdk的实现类</p>\n<p>public class HashSet<E><br>    extends AbstractSet<E><br>    implements Set<E>, Cloneable, java.io.Serializable<br>Set的重要特点就是<strong>不能放进去重复</strong>的元素，Set中不会存在e1和e2，e1.equals(e2)的情况<br>HashSet的源码只有三百多行，内部有一个map（HashMap）相对来说是比较简单的。其实Set平时用的也不是那么多。。。</p>\n<h3 id=\"4-一些不常用的类\"><a href=\"#4-一些不常用的类\" class=\"headerlink\" title=\"4. 一些不常用的类\"></a>4. 一些不常用的类</h3><pre><code>Vetor，Stack，ArrayDeque,Queue\n\nVector属于List,线程安全，但效率低（就是简单的在所有方法前面加上了synchronized）\n\nQueue是一个interface，属于两端可以出入的List，通常是(FIFO模式)，实现类有\nPriorityQueue，\njava.util.concurrent.LinkedBlockingQueue\njava.util.concurrent.LinkedBlockingQueue\njava.util.concurrent.PriorityBlockingQueue\n作者都是大名鼎鼎的Doug Lea\n\nStack是Vector的子类(属于LIFO的栈)\nThe Stack class represents a last-in-first-out (LIFO) stack of object\n\nDeque(双端队列)\n</code></pre><h3 id=\"5-concurrentHashMap等\"><a href=\"#5-concurrentHashMap等\" class=\"headerlink\" title=\"5. concurrentHashMap等\"></a>5. concurrentHashMap等</h3><p>jdk1.8的concurrentHashMap不是用synchronized实现的，是Doug Lea使用CAS操作写的，非常高效。</p>\n<h3 id=\"6-WeakHaskMap\"><a href=\"#6-WeakHaskMap\" class=\"headerlink\" title=\"6. WeakHaskMap\"></a>6. WeakHaskMap</h3><p>WeakHashMap的Key是WeakReference，但Value不是。<br>常见用法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String a = <span class=\"string\">\"a\"</span>;</div><div class=\"line\">map.put(<span class=\"number\">1</span>,a);</div><div class=\"line\">a = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"comment\">//map中的a可以出了map自身外没有其他地方被引用，a将被被gc回收</span></div></pre></td></tr></table></figure>\n<p>Android <a href=\"https://developer.android.com/reference/java/util/WeakHashMap.html\">官方开发文档</a>上指出了一点</p>\n<blockquote>\n<p>Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get.</p>\n</blockquote>\n<p>WeakHashMap的value不要持有key的强引用，否则，key永远不会被清除,value也别想被清除。</p>\n<h2 id=\"7-java-8的一些新的方法\"><a href=\"#7-java-8的一些新的方法\" class=\"headerlink\" title=\"7. java 8的一些新的方法\"></a>7. java 8的一些新的方法</h2><p>list.replaceAll(String::toUpperCase) //method reference<br>can not change the elemeet type, for that you need an stream<br><a href=\"https://www.youtube.com/watch?v=q6zF3vf114M\">Collections Refuled by Stuart Marks</a></p>\n<h2 id=\"8-结束语\"><a href=\"#8-结束语\" class=\"headerlink\" title=\"8.结束语\"></a>8.结束语</h2><p>8.1 <a href=\"https://en.wikipedia.org/wiki/Doug_Lea\">Doug Lea</a> 是非常聪明的人，估计并发经常会牵涉到集合，所以jdk里面很多集合都有他的作品<br>8.2 jdk只是定义了这些框架，像List，Map这些全都是接口，完全可以自己去实现。Apache就有一大堆适合特定场景的集合实现类。jdk只是帮助我们实现了一些常见的类。如果有现成的满足需求的框架，不要重复造轮子。<br>8.3 平时只要记住ArrayList和HashMap的<strong>大致内部实现</strong>就可以了，至于别的，除非面试，平时没必要记录。<br>8.4 <a href=\"https://blogs.oracle.com/java/collections-refueled\">Stuart Mark</a>特别喜欢把一个class搞成<strong>@deprecated</strong><br>8.5 就连<a href=\"https://www.youtube.com/watch?v=V1vQf4qyMXg\">Joshua Bloch</a> 都承认，除非性能真的很重要的，平时没必要过度优化。By the way , he said Doug Lea is very smart .</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"https://www.youtube.com/watch?v=q6zF3vf114M\">Collections Refuled by Stuart Marks</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=FLcXf9pO27w\">From Java Code to Java Heap: Understanding the Memory Usage of Your Application</a></li>\n<li><a href=\"http://www.jianshu.com/p/2cd7be850540\">Java集合干货系列</a></li>\n<li><a href=\"http://www.programcreek.com/2014/01/java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF/\">Arrays.asList()返回的List不是jva.util.ArrayList</a></li>\n<li><a href=\"http://blog.csdn.net/yangzl2008/article/details/6980709\">WeakHashMap和HashMap的区别</a></li>\n</ol>\n","excerpt":"<p>根据网上的大部分博客的分类，集合框架分为Collections(具有类似数组的功能)和Map(存储键值对)这两大部分。针对jdk1.8的java.util里面的一些常用的或者不常用的集合做一些分析。写这篇文章的过程中，我慢慢发现不同版本jdk的同一个class的实现是有一些差异的(LinkedList)，由于对照的是java1.8的代码，里面会多一些since 1.8的代码，这里不作论述。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/16d714eb6e8ecc23e4d6ba20d0be17a0.jpg?imageView2/2/w/600\" alt=\"\"></p>","more":"<p>java集合的大致框架建议参考网上博客的总结，<a href=\"http://www.jianshu.com/p/2cd7be850540\">Java集合干货系列</a>写的比较好，图画的也不错，针对jdk 1.6源码讲的。我这里只是自己学习过程中的一些笔记。</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>ArrayList (建议new出来的时候给定一个适当的size，不然每次扩容很慢的，可以放null)<br>LinkedList(not recommended，增删元素的时候快一点)<br>Vector（线程安全,重同步，不推荐）</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>HashSet (底层是HashMap)<br>TreeSet(排序存储)<br>LinkedHashSet(底层是LinkedHashMap)</p>\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><p>Stack ArrayDeque(不常用)</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>HashMap （键值都可以为null,底层是哈希表）<br>TreeMap(底层二叉树)<br>HashTable(线程安全，键值都不允许为null)<br>SparseArray(Android平台用)</p>\n<p>关于集合，不得不提到泛型，Java 1.5引入了泛型，关于泛型，找到一篇很好的文章<br><a href=\"http://blog.csdn.net/lonelyroamer/article/details/7868820\">类型擦除原理</a>。本质上只是提供了编译期类型检查。编译通过后都是Object，所以叫做<a href=\"https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4\">类型擦除</a>。</p>\n<h2 id=\"1-List的解析\"><a href=\"#1-List的解析\" class=\"headerlink\" title=\"1. List的解析\"></a>1. List的解析</h2><h3 id=\"1-1-ArrayList源码解析\"><a href=\"#1-1-ArrayList源码解析\" class=\"headerlink\" title=\"1.1 ArrayList源码解析\"></a>1.1 ArrayList源码解析</h3><ul>\n<li>先上一段崩溃代码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    String[] array = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>&#125;;</div><div class=\"line\">    List&lt;String&gt; l = Arrays.asList(array);</div><div class=\"line\">    l.add(<span class=\"string\">\"d\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.UnsupportedOperationException</div><div class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">148</span>)</div><div class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">108</span>)</div><div class=\"line\">    at com.example.demo.main(ConcurrentModificationListDemo.java:<span class=\"number\">13</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>问题出在Arrays.asList返回了一个<strong>java.util.Arrays.ArrayList</strong>，而不是<strong>java.util.ArrayList</strong>。前者只实现了List接口的有限的几个方法，并且是Arrays内部的一个private class。<br>正确的用法是new 一个ArrayList，把这个有限的list的元素(的指针)copy进去，即addAll()方法<br>ArrayList.toArray(T[] a)是把所有的elements通过System.arraycopy(elementData, 0, a, 0, size);复制到a数组中。</p>\n<ul>\n<li>System.arraycopy可以从自己的数组复制到自己的数组<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</div><div class=\"line\">      rangeCheckForAdd(index);</div><div class=\"line\">      ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></div><div class=\"line\">      System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</div><div class=\"line\">                       size - index);  </div><div class=\"line\">      elementData[index] = element;</div><div class=\"line\">      size++;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加到指定位置，System.arrayCopy可以从同一个数组复制到同一个数组，几乎就是挪动指针了。</p>\n<ul>\n<li>不常见的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//下面这两个是因为ArrayList implements java.io.Serializable，是序列化时会调用的</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeObject</span><span class=\"params\">(java.io.ObjectOutputStream s)</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObject</span><span class=\"params\">(java.io.ObjectInputStream s)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRange</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> <span class=\"comment\">//给一个集合，删除list与之的交集</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> <span class=\"comment\">//  给定一个集合，从list中删除所有不在这个集合里面的元素</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">()</span> <span class=\"comment\">// 内存压力大的时候可以释放掉一部分内存，记得那个1.5倍的默认扩容嘛，释放的就是这0.5的内存</span></span></div></pre></td></tr></table></figure>\n<p>多线程场景下要注意的问题</p>\n<blockquote>\n<p>和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p>\n</blockquote>\n<h3 id=\"1-2-LinkedList的一些点\"><a href=\"#1-2-LinkedList的一些点\" class=\"headerlink\" title=\"1.2 LinkedList的一些点\"></a>1.2 LinkedList的一些点</h3><p>LinkedList是双向链表实现的，可以想象成一帮小孩左手拉右手绕成一个圈，只不过这里面的每一个小孩并不是你放进去的 T 类型数据，而是一个Node<T> 。所以LinkedList是可以放进去一个Null的。<br>LinkedList往往被人诟病的就是除了添加和删除快之外，get和set很慢。<br>来看下add的实现（jdk 1.8）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        linkLast(e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     * Links e as last element.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;  <span class=\"comment\">//先把链表的尾巴找出来</span></div><div class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>); <span class=\"comment\">// 可以想象每次add都有new的操作，并将原来的尾巴作为这个新的Entry的头部</span></div><div class=\"line\">        last = newNode; <span class=\"comment\">//新的Node将成为新的尾巴</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>) <span class=\"comment\">//这种情况是原来没有尾巴，也就是说size = 0</span></div><div class=\"line\">            first = newNode; <span class=\"comment\">//这时候就只有一个Node，头和尾都是Null</span></div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            l.next = newNode; <span class=\"comment\">//不然的话，旧的尾巴变成了倒数第二个，它的next指向了新的Entry.</span></div><div class=\"line\"></div><div class=\"line\">        size++;</div><div class=\"line\">        modCount++;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>add的过程看起来很快，new一个entery，确定下前后的指针就可以了。remove也差不多，取消指针引用即可。</p>\n<p>来看比较慢的get</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">       checkElementIndex(index);</div><div class=\"line\">       <span class=\"keyword\">return</span> node(index).item;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">/**</div><div class=\"line\">    * Returns the (non-null) Node at the specified element index.</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// assert isElementIndex(index);</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</div><div class=\"line\">           Node&lt;E&gt; x = first;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</div><div class=\"line\">               x = x.next; <span class=\"comment\">//一直遍历到这个index才返回，慢</span></div><div class=\"line\">           <span class=\"keyword\">return</span> x;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           Node&lt;E&gt; x = last;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</div><div class=\"line\">               x = x.prev;</div><div class=\"line\">           <span class=\"keyword\">return</span> x;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>值得注意的一点小事：<br>ArrayList implement RandomAccess接口，而LinkedList并没有。RandomAccess接口的定义如下</p>\n<blockquote>\n<ul>\n<li>Marker interface used by <tt>List</tt> implementations to indicate that<ul>\n<li>they support fast (generally constant time) random access.  The primary</li>\n<li>purpose of this interface is to allow generic algorithms to alter their</li>\n<li>behavior to provide good performance when applied to either random or</li>\n<li>sequential access lists.<br>*</li>\n<li><p>The best algorithms for manipulating random access lists (such as</li>\n<li><tt>ArrayList</tt>) can produce quadratic behavior when applied to</li>\n<li>sequential access lists (such as <tt>LinkedList</tt>).  Generic list</li>\n<li>algorithms are encouraged to check whether the given list is an</li>\n<li><tt>instanceof</tt> this interface before applying an algorithm that would</li>\n<li>provide poor performance if it were applied to a sequential access list,</li>\n<li>and to alter their behavior if necessary to guarantee acceptable</li>\n<li>performance.<br>*</li>\n<li><p>It is recognized that the distinction between random and sequential</li>\n<li>access is often fuzzy.  For example, some <tt>List</tt> implementations</li>\n<li>provide asymptotically linear access times if they get huge, but constant</li>\n<li>access times in practice.  Such a <tt>List</tt> implementation</li>\n<li>should generally implement this interface.  As a rule of thumb, a</li>\n<li>List implementation should implement this interface if,</li>\n<li>for typical instances of the class, this loop:</li>\n<li>for (int i=0, n=list.size(); i &lt; n; i++)</li>\n<li>list.get(i); //get的速度应该是恒定的</li>\n<li>runs faster than this loop:</li>\n<li>for (Iterator i=list.iterator(); i.hasNext(); )</li>\n<li>i.next();</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>这种接口就是给外界使用者看的，用来说明该集合支持这种通过下标查找（速度不变）的快速操作</p>\n<p>实践表明，对于linkedList，采用for loop的方式要很慢，但使用ListIterator<T>的方式，速度并不慢，简单来想，沿着链表的一个方向一致往下走就是了嘛。<br>一些经验表明(摘自简书作者嘟爷MD的文章)</p>\n<p><a href=\"http://www.jianshu.com/p/d5ec2ff72b33\">ArryList和LinkedList的对比结论</a></p>\n<blockquote>\n<p>1、顺序插入速度ArrayList会比较快<br>2、LinkedList将比ArrayList更耗费一些内存<br>3、ArrayList的遍历效率会比LinkedList的遍历效率高一些<br>4、有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：如果增加或者删除的元素在前半部分的时候，ArrayList会频繁调用System.arrayCopy方法，虽然native方法快，但高频率调用肯定慢，至少比不上移动指针。</p>\n</blockquote>\n<h2 id=\"2-Map的几个实现类\"><a href=\"#2-Map的几个实现类\" class=\"headerlink\" title=\"2. Map的几个实现类\"></a>2. Map的几个实现类</h2><h3 id=\"2-1-HashMap源码解析\"><a href=\"#2-1-HashMap源码解析\" class=\"headerlink\" title=\"2.1 HashMap源码解析\"></a>2.1 HashMap源码解析</h3><blockquote>\n<p>public class HashMap<K,V> extends AbstractMap<K,V><br>    implements Map<K,V>, Cloneable, Serializable</p>\n</blockquote>\n<p>HashMap不是线程安全的，Key和Value都有可能为null，存储数据不是有序的(get的顺序不是put的顺序)</p>\n<p>HashMap中有几个默认值常量</p>\n<pre><code>默认初始容量是16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16\n\n默认加载因子是0.75f ，加载因子是指Hashmap在自动扩容之前可以达到多满\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; //一般不需要改\n</code></pre><p>构造函数有好几个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span>  <span class=\"comment\">//自定义加载因子，比较玄学</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> <span class=\"comment\">// 避免扩容，和ArrayList初始化指定容量类似的道理</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> <span class=\"comment\">//直接把初始容量设置成16</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span></span></div></pre></td></tr></table></figure>\n<p><a href=\"https://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity-be-a-power-of-two\">注意这个初始容量必须是2的n次方</a></p>\n<p>来看常见的CURD操作(jdk 1.8源码，和我在网上找到的jdk1.6源码有一些变化了)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>); <span class=\"comment\">//HashMap允许key为null,key为null的话，直接放到数组的0的位置（hash方法返回的是0）</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">int</span> h;</div><div class=\"line\">           <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>); <span class=\"comment\">//如果是null，放到数组的第一个</span></div><div class=\"line\"><span class=\"comment\">// 这里面就是HashMap算法的高明之处  ，</span></div><div class=\"line\"><span class=\"comment\">//  1. 首先算出object的hashcode，</span></div><div class=\"line\"><span class=\"comment\">//2.然后根据上述公式将二进制的1尽量分散的均匀一点         </span></div><div class=\"line\"><span class=\"comment\">// 3. 在putVal的时候将这个值跟数组的长度length-1进行位运算，得到一个比length小的正数，作为这个新元素在数组中的index.但这样仍不免会产生冲突(hash Collision)</span></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">/**</div><div class=\"line\">     * Implements Map.put and related methods</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> hash hash for key</div><div class=\"line\">     * <span class=\"doctag\">@param</span> key the key</div><div class=\"line\">     * <span class=\"doctag\">@param</span> value the value to put</div><div class=\"line\">     * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don't change existing value</div><div class=\"line\">     * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</div><div class=\"line\">     * <span class=\"doctag\">@return</span> previous value, or null if none</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</div><div class=\"line\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</div><div class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</div><div class=\"line\">            n = (tab = resize()).length; <span class=\"comment\">//table为成员变量，是一个Node数组，为空的话则创建 。在resize中创建</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</div><div class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            Node&lt;K,V&gt; e; K k;</div><div class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</div><div class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                e = p; <span class=\"comment\">//Table数组中找到了这个下标的元素，直接指定</span></div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)<span class=\"comment\">//p可以理解为previous 。 如果发现这个节点是一棵树（红黑树？）</span></div><div class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//否则该节点是链表，各个元素之间手拉手的那种</span></div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>); <span class=\"comment\">//找到这个链表的尾巴了</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></div><div class=\"line\">                            treeifyBin(tab, hash);</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                    p = e;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></div><div class=\"line\">                V oldValue = e.value;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</div><div class=\"line\">                    e.value = value;</div><div class=\"line\">                afterNodeAccess(e); <span class=\"comment\">//回调函数</span></div><div class=\"line\">                <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ++modCount;</div><div class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</div><div class=\"line\">            resize();</div><div class=\"line\">        afterNodeInsertion(evict);<span class=\"comment\">//回调函数</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>get方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt; e;</div><div class=\"line\">      <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;<span class=\"comment\">//根据key来找value</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * Implements Map.get and related methods</div><div class=\"line\">   *</div><div class=\"line\">   * <span class=\"doctag\">@param</span> hash hash for key</div><div class=\"line\">   * <span class=\"doctag\">@param</span> key the key</div><div class=\"line\">   * <span class=\"doctag\">@return</span> the node, or null if none</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</div><div class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">          (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//table不为空说明曾经put过</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></div><div class=\"line\">              ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">              <span class=\"keyword\">return</span> first;</div><div class=\"line\">          <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                  <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class=\"line\">              do &#123;</div><div class=\"line\">                  <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                      ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                      <span class=\"keyword\">return</span> e;</div><div class=\"line\">              &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt; e;</div><div class=\"line\">      <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * Implements Map.get and related methods</div><div class=\"line\">   *</div><div class=\"line\">   * <span class=\"doctag\">@param</span> hash hash for key</div><div class=\"line\">   * <span class=\"doctag\">@param</span> key the key</div><div class=\"line\">   * <span class=\"doctag\">@return</span> the node, or null if none</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</div><div class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">          (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></div><div class=\"line\">              ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">              <span class=\"keyword\">return</span> first;</div><div class=\"line\">          <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                  <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class=\"line\">              do &#123;</div><div class=\"line\">                  <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                      ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                      <span class=\"keyword\">return</span> e;</div><div class=\"line\">  <span class=\"comment\">//可以看出比较的方式就是hash（int）相等且key(指针相等)  或者key equals(所以经常说重写equals需要确保hashcode一致，这里至少反应了这一点)</span></div><div class=\"line\">              &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>回想一下平时迭代一个HashMap的方式<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">long</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\">    Map.Entry&lt;Integer, Integer&gt; pair = it.next(); <span class=\"comment\">//上面的get也是这种不断查找next的方式</span></div><div class=\"line\">    i += pair.getKey() + pair.getValue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>entrySet方法是Map接口定义的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</div><div class=\"line\">   * Returns a Set view of the mappings contained in this map.</div><div class=\"line\">     * The set is backed by the map, so changes to the map are</div><div class=\"line\">     * reflected in the set, and vice-versa.  If the map is modified</div><div class=\"line\">     * while an iteration over the set is in progress (except through</div><div class=\"line\">     * the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</div><div class=\"line\">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</div><div class=\"line\">     * iterator) the results of the iteration are undefined.  The set</div><div class=\"line\">     * supports element removal, which removes the corresponding</div><div class=\"line\">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</div><div class=\"line\">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</div><div class=\"line\">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</div><div class=\"line\">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</div><div class=\"line\">     *</div><div class=\"line\">     * @return a set view of the mappings contained in this map</div></pre></td></tr></table></figure></p>\n<p>大致意思是： 返回一个能够反映该map元素组合的一个Set，对这个Set的操作都将反映到原map上，反之亦然。在通过entrySet迭代这个map的时候，除了remove和操作操作都是不被支持的。返回的Set支持删除对应的mapping组合。但不支持add操作</p>\n<p>HashMap内部保留了一个这样的成员变量：<br>transient Set<Map.Entry<K,V>&gt; entrySet; //成员变量<br>具体实现enterySet方法的地方：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"keyword\">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class=\"line\">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div class=\"line\">        <span class=\"keyword\">return</span> (es = entrySet) == <span class=\"keyword\">null</span> ? (entrySet = <span class=\"keyword\">new</span> EntrySet()) : es;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个EntrySet大致长这样</span></div><div class=\"line\">  <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EntrySet</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSet</span>&lt;<span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;&gt; </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span>                 </span>&#123; <span class=\"keyword\">return</span> size; &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span>               </span>&#123; HashMap.<span class=\"keyword\">this</span>.clear(); &#125;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EntryIterator();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class=\"line\">            Object key = e.getKey();</div><div class=\"line\">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</div><div class=\"line\">            <span class=\"keyword\">return</span> candidate != <span class=\"keyword\">null</span> &amp;&amp; candidate.equals(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</div><div class=\"line\">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class=\"line\">                Object key = e.getKey();</div><div class=\"line\">                Object value = e.getValue();</div><div class=\"line\">                <span class=\"keyword\">return</span> removeNode(hash(key), key, value, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>) != <span class=\"keyword\">null</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>整理的关键在于removeNode方法，和getNode和putVal很像<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</div><div class=\"line\">                            <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</div><div class=\"line\">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</div><div class=\"line\">     <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">         (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</div><div class=\"line\">         <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</div><div class=\"line\">             ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">             node = p;</div><div class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class=\"line\">             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                 do &#123;</div><div class=\"line\">                     <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                         ((k = e.key) == key ||</div><div class=\"line\">                          (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class=\"line\">                         node = e;</div><div class=\"line\">                         <span class=\"keyword\">break</span>;</div><div class=\"line\">                     &#125;</div><div class=\"line\">                     p = e;</div><div class=\"line\">                 &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; <span class=\"comment\">//先把p(previous)找出来，这里的matchValue和movable都是true</span></div><div class=\"line\">         <span class=\"comment\">// node 就是包含了要移出对象的Node</span></div><div class=\"line\">         <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class=\"line\">                              (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</div><div class=\"line\">             <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p) <span class=\"comment\">//数组这个位置就一个</span></div><div class=\"line\">                 tab[index] = node.next;<span class=\"comment\">//直接指向下一个</span></div><div class=\"line\">             <span class=\"keyword\">else</span></div><div class=\"line\">                 p.next = node.next; <span class=\"comment\">//数组这个位置指向链表下一个节点，释放引用</span></div><div class=\"line\">             ++modCount;</div><div class=\"line\">             --size;</div><div class=\"line\">             afterNodeRemoval(node);</div><div class=\"line\">             <span class=\"keyword\">return</span> node;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>比较元素是否相同的关键是</p>\n<blockquote>\n<p>e.hash == hash || (key!=null &amp;&amp;key.equals(k)) //后半部分其实也是比较hashCode</p>\n</blockquote>\n<p>另外一些平时常用的方法包括：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> getNode(hash(key), key) != <span class=\"keyword\">null</span>; <span class=\"comment\">//就是检查下有没有这个key对应的Node</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</div><div class=\"line\">      Node&lt;K,V&gt;[] tab; V v;</div><div class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i) &#123;</div><div class=\"line\">              <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\">                  <span class=\"keyword\">if</span> ((v = e.value) == value ||</div><div class=\"line\">                      (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">//遍历内部的数组，仅此而已</span></div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>和ArrayList、LinkedList比起来，HashMap的源码要麻烦许多，这里面涉及到hashCode，链表，红黑树。需要一点数据结构的知识。另外，HashMap还针对hashCode冲突（hash Collision，不同的Object居然有相同的hashCode）的情况作了<a href=\"https://stackoverflow.com/questions/6493605/how-does-a-java-hashmap-handle-different-objects-with-the-same-hash-code\">预处理</a><br>通俗的来说，HashMap内部维护了一个数组，每一个数组元素内部不一定只有一个，有可能是一个链表。每次添加(key,value)不是盲目的往这个数组里面塞，而是算下key的hash值，放到对应的节点上。如果这个节点上还没有元素，直接放就好了。如果有的话，新加入的value将被作为原有元素的Next(外部调用get的时候，先根据传入的key的hashCode找到节点，然后根据key.equals来找)。简单如此，精致如斯。</p>\n<h3 id=\"2-2-LinkedHashMap\"><a href=\"#2-2-LinkedHashMap\" class=\"headerlink\" title=\"2.2 LinkedHashMap\"></a>2.2 LinkedHashMap</h3><p>public class LinkedHashMap<K,V><br>    extends HashMap<K,V><br>    implements Map<K,V><br>HashMap源码我看了下有两千多行，LinkedHashMap只有七百多行，显然这是继承带来的简便之处。<br>关键的成员变量<br>final boolean accessOrder; 默认是false</p>\n<blockquote>\n<p>The iteration ordering method for this linked hash map: <tt>true</tt><br>for access-order, false for insertion-order.</p>\n</blockquote>\n<p>LinkedHashMap常用的属性就是它支持有序，这个有序是指迭代的时候有序</p>\n<h3 id=\"2-3-SparseArray\"><a href=\"#2-3-SparseArray\" class=\"headerlink\" title=\"2.3 SparseArray\"></a>2.3 SparseArray</h3><p>先来看一段崩溃日志<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Fatal Exception: java.lang.ArrayIndexOutOfBoundsException: src.length=509 srcPos=60 dst.length=509 dstPos=61 length=-60</div><div class=\"line\">       at java.lang.System.arraycopy(System.java:388)</div><div class=\"line\">       at com.android.internal.util.GrowingArrayUtils.insert(GrowingArrayUtils.java:135)</div><div class=\"line\">       at android.util.SparseIntArray.put(SparseIntArray.java:144)</div></pre></td></tr></table></figure></p>\n<p>SparseArry提供了类似于HashMap的调用接口，</p>\n<p>使用SparseArray的初衷还是在android这种内存比cpu金贵的平台中，使用SparseArry相比HashMap能够减轻内存压力，获得更好的性能。<br><a href=\"https://www.liaohuqiu.net/cn/posts/sparse-array-in-android/\">liaohuqiu指出SparseArry并不是任何时候都更快</a>，主要是节省内存，避免autoBoxing，二分法查找对于cpu的消耗需要权衡。尤其是存储的量很大的时候，二分法查找的速度会很慢。</p>\n<p>SparseArry类似的class有好几个，据说有八个，以SparseIntArry为例<br>SparseIntArry的几个常用方法,值得注意的是 clear方法只不过是把计数清零了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOfKey</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOfValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       mSize = <span class=\"number\">0</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//迭代一个SparseArry的方法</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sparseArray.size(); i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">int</span> key = sparseArray.keyAt(i);</div><div class=\"line\">   <span class=\"comment\">// get the object by the key.</span></div><div class=\"line\">   Object obj = sparseArray.get(key);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从源码来看变量结构</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SparseIntArray</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mKeys;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mValues;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mSize;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key); <span class=\"comment\">//二分法查找</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         mValues[i] = value; <span class=\"comment\">//找到了在Value数组中的index,直接替换掉</span></div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         i = ~i;</div><div class=\"line\">         mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</div><div class=\"line\">         mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</div><div class=\"line\">         mSize++;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>廖祜秋 特地强调</p>\n<ol>\n<li>SparseArray 是针对HashMap做的优化。<br> 1.HashMap 内部的存储结构，导致一些内存的浪费。<br> 2.在刚扩容完，SparseArray 和 HashMap 都会存在一些没被利用的内存。</li>\n<li>SparseArray 并不是任何时候都会更快，有时反而会更慢</li>\n</ol>\n<h3 id=\"2-4-ArrayMap\"><a href=\"#2-4-ArrayMap\" class=\"headerlink\" title=\"2.4 ArrayMap\"></a>2.4 ArrayMap</h3><h2 id=\"3-Set的介绍\"><a href=\"#3-Set的介绍\" class=\"headerlink\" title=\"3. Set的介绍\"></a>3. Set的介绍</h2><p>Set用比较少，HashSet、TreeSet和LinkedHashSet是jdk的实现类</p>\n<p>public class HashSet<E><br>    extends AbstractSet<E><br>    implements Set<E>, Cloneable, java.io.Serializable<br>Set的重要特点就是<strong>不能放进去重复</strong>的元素，Set中不会存在e1和e2，e1.equals(e2)的情况<br>HashSet的源码只有三百多行，内部有一个map（HashMap）相对来说是比较简单的。其实Set平时用的也不是那么多。。。</p>\n<h3 id=\"4-一些不常用的类\"><a href=\"#4-一些不常用的类\" class=\"headerlink\" title=\"4. 一些不常用的类\"></a>4. 一些不常用的类</h3><pre><code>Vetor，Stack，ArrayDeque,Queue\n\nVector属于List,线程安全，但效率低（就是简单的在所有方法前面加上了synchronized）\n\nQueue是一个interface，属于两端可以出入的List，通常是(FIFO模式)，实现类有\nPriorityQueue，\njava.util.concurrent.LinkedBlockingQueue\njava.util.concurrent.LinkedBlockingQueue\njava.util.concurrent.PriorityBlockingQueue\n作者都是大名鼎鼎的Doug Lea\n\nStack是Vector的子类(属于LIFO的栈)\nThe Stack class represents a last-in-first-out (LIFO) stack of object\n\nDeque(双端队列)\n</code></pre><h3 id=\"5-concurrentHashMap等\"><a href=\"#5-concurrentHashMap等\" class=\"headerlink\" title=\"5. concurrentHashMap等\"></a>5. concurrentHashMap等</h3><p>jdk1.8的concurrentHashMap不是用synchronized实现的，是Doug Lea使用CAS操作写的，非常高效。</p>\n<h3 id=\"6-WeakHaskMap\"><a href=\"#6-WeakHaskMap\" class=\"headerlink\" title=\"6. WeakHaskMap\"></a>6. WeakHaskMap</h3><p>WeakHashMap的Key是WeakReference，但Value不是。<br>常见用法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">String a = <span class=\"string\">\"a\"</span>;</div><div class=\"line\">map.put(<span class=\"number\">1</span>,a);</div><div class=\"line\">a = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"comment\">//map中的a可以出了map自身外没有其他地方被引用，a将被被gc回收</span></div></pre></td></tr></table></figure>\n<p>Android <a href=\"https://developer.android.com/reference/java/util/WeakHashMap.html\">官方开发文档</a>上指出了一点</p>\n<blockquote>\n<p>Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get.</p>\n</blockquote>\n<p>WeakHashMap的value不要持有key的强引用，否则，key永远不会被清除,value也别想被清除。</p>\n<h2 id=\"7-java-8的一些新的方法\"><a href=\"#7-java-8的一些新的方法\" class=\"headerlink\" title=\"7. java 8的一些新的方法\"></a>7. java 8的一些新的方法</h2><p>list.replaceAll(String::toUpperCase) //method reference<br>can not change the elemeet type, for that you need an stream<br><a href=\"https://www.youtube.com/watch?v=q6zF3vf114M\">Collections Refuled by Stuart Marks</a></p>\n<h2 id=\"8-结束语\"><a href=\"#8-结束语\" class=\"headerlink\" title=\"8.结束语\"></a>8.结束语</h2><p>8.1 <a href=\"https://en.wikipedia.org/wiki/Doug_Lea\">Doug Lea</a> 是非常聪明的人，估计并发经常会牵涉到集合，所以jdk里面很多集合都有他的作品<br>8.2 jdk只是定义了这些框架，像List，Map这些全都是接口，完全可以自己去实现。Apache就有一大堆适合特定场景的集合实现类。jdk只是帮助我们实现了一些常见的类。如果有现成的满足需求的框架，不要重复造轮子。<br>8.3 平时只要记住ArrayList和HashMap的<strong>大致内部实现</strong>就可以了，至于别的，除非面试，平时没必要记录。<br>8.4 <a href=\"https://blogs.oracle.com/java/collections-refueled\">Stuart Mark</a>特别喜欢把一个class搞成<strong>@deprecated</strong><br>8.5 就连<a href=\"https://www.youtube.com/watch?v=V1vQf4qyMXg\">Joshua Bloch</a> 都承认，除非性能真的很重要的，平时没必要过度优化。By the way , he said Doug Lea is very smart .</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"https://www.youtube.com/watch?v=q6zF3vf114M\">Collections Refuled by Stuart Marks</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=FLcXf9pO27w\">From Java Code to Java Heap: Understanding the Memory Usage of Your Application</a></li>\n<li><a href=\"http://www.jianshu.com/p/2cd7be850540\">Java集合干货系列</a></li>\n<li><a href=\"http://www.programcreek.com/2014/01/java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF/\">Arrays.asList()返回的List不是jva.util.ArrayList</a></li>\n<li><a href=\"http://blog.csdn.net/yangzl2008/article/details/6980709\">WeakHashMap和HashMap的区别</a></li>\n</ol>"},{"title":"使用Python搭建本地服务器","date":"2017-06-15T15:56:26.000Z","_content":"\n![Kitty](http://odzl05jxx.bkt.clouddn.com/c6dd030bf8cc75628fce3aec8216ba52.jpg?imageView2/2/w/600)\n关于如何使用Python搭建后台的方法很多，这里列举出一些实例。<!--more-->\n\n## 1. The Flask Way\n\n### 1.1 Basics\n> Flask is a very simple, but extremely flexible framework Flask使用Decorator对请求进行处理\n\n\n```Python\n#!/usr/bin/python3\n# -*- coding:utf8 -*-\n\nfrom flask import Flask\nfrom flask import request\nfrom flask import jsonify\nfrom flask import send_file\n\n# create the flask object\napp = Flask(__name__)\n\n# 处理GET请求像这样就可以了\n\n@app.route('/', methods=['GET'])\ndef handle_get():\n    return 'haha ,this is http status code 200'\n\n#处理POST请求，从request中拿东西，返回response\n@app.route('/', methods=['POST'])\ndef handle_post():\n    uid = request.form['uid'] # requets.form是一个list，从里面获取想表单的参数\n    name = request.form['name']\n    print('uid is %s ,name is %s ' % (uid, name))\n    return '200 Ok, or whatever you like'  \n\nif __name__ == '__main__':\n    app.run(port=12345, debug=True) #设置为True后，会自动检测到服务端代码更改并reload，出错了也会给client返回实际的错误堆栈， 生产环境不要打开Debug 。\n\n# 对于GET请求，获得query参数的方式\nhttp://127.0.0.1:12345/_search_user?user=111&date=190\n\n@app.route('/_search_user', methods=['GET'])\ndef query_user_profile():\n    user = request.args.get('user')\n    date = request.args.get('date')\n    print(user)\n    print(date)\n    return 'every Thing Ok'\n\n 输出\n 111\n 190   \n\n #返回json，作为API\n@app.route('/_get_current_user', methods=['GET'])\ndef get_current_user():\n    return jsonify(\n        username='Admin',\n        email='Bob@gmail.com',\n        age=18\n    )    \n\n{\n    username: 'Admin';\n    email: 'Bob@gamil.com';\n    age: 18\n}\n\n#返回复杂一点的json，或者json数组\n@app.route('/_get_user_list', methods=['GET'])\ndef get_user_list():\n    user_list = create_user_list()\n    return Response(json.dumps(user_list), mimetype='application/json')\n\n\n#生成数据\ndef create_user_list():\n    alice = {'name': 'alice', 'age': 16, 'sex': 'female'}\n    tom = {'name': 'tom', 'age': 23, 'sex': 'male'}\n    josh = {'name': 'josh', 'age': 20, 'sex': 'male'}\n    bill = {'name': 'bill', 'age': 19, 'sex': 'male'}\n    li = [alice, tom, josh, bill]\n    return li\n\n\n# 在Postman中就能获得这样的result\n[\n    {\n        \"name\": \"alice\",\n        \"age\": 16,\n        \"sex\": \"female\"\n    },\n    {\n        \"name\": \"tom\",\n        \"age\": 23,\n        \"sex\": \"male\"\n    },\n    {\n        \"name\": \"josh\",\n        \"age\": 20,\n        \"sex\": \"male\"\n    },\n    {\n        \"name\": \"bill\",\n        \"age\": 19,\n        \"sex\": \"male\"\n    }\n]\n\n# hosting static file，image,css,etc\n# 提供图片什么的\n\n@app.route('/_get_image', methods=['GET'])\ndef get_image():\n    filename = 'static/image/b1.jpg'\n    fullpath = os.path.join(os.path.curdir, filename)\n    print(filename, fullpath)\n    return send_file(fullpath, mimetype='image/jpeg')\n```\n\n我觉得Flask的官方Doc对初学者的友好度几乎是满分\n- [accessing-request-data](http://flask.pocoo.org/docs/0.12/quickstart/#accessing-request-data)\n- [cookies](http://flask.pocoo.org/docs/0.12/quickstart/#cookies)\n- [sessions](http://flask.pocoo.org/docs/0.12/quickstart/#sessions)\n- [static files](http://flask.pocoo.org/docs/0.12/quickstart/#static-files)\n所有的静态文件必须放在当前目录下的static目录中，里面可以再创建image，css,404.html等文件\n另外，如果要调试接口的话，用Postman吧，比Fiddler简单点\n返回response的时候一定要指明mime-type，或者content-type\ntext/html、text/css、application/json什么的，[详细的http-content-type表格](http://www.runoob.com/http/http-content-type.html)\n关于content-type,找到一篇[介绍](http://homeway.me/2015/07/19/understand-http-about-content-type/)\n关于Http header常用字段[理解Http Header](http://zq210wl.github.io/2014/12/30/html-http-header-analysis/)\nHttp底层TCP ,ACK 等等需要tcpcump结合wireShark抓包\n\n>下面是几个常见的Content-Type:\n1.text/html\n2.text/plain\n3.text/css\n4.text/javascript\n5.application/x-www-form-urlencoded\n6.multipart/form-data\n7.application/json\n8.application/xml\n…\n前面几个都很好理解，都是html，css，javascript的文件类型，后面四个是POST的发包方式。\n\n### 1.2 Flask BluePrints\n\n### 1.3 Flask + gevent 提高web 框架的性能\n[docs](http://flask.pocoo.org/docs/0.12/deploying/wsgi-standalone/)\n\n### 2. The Django Way\nDjango是**web framework**，不是**WebServer**\n\n\n\n## 3. Using Tornado\n\n## 4. 其他的点\n### 4.1 Web架构\n网络库上手比较快，很重要的一点是理解其在通讯中的层级，Nigix属于代理转发，Flask处理业务逻辑，Tornado处理Http底层实现，Django负责用于高效网络应用开发\n - [Django和Flask这两个框架在设计上各方面有什么优缺点？\n](https://www.zhihu.com/question/41564604)\n\n\nUrlLib，Socket这些属于Python底层的基础性的network库，属于基础的东西。\n\n### 4.2不服跑个分\n引用一篇[测评](http://www.vimer.cn/archives/2926.html)\n>可见纯框架自身的性能为:\n\n    bottle > flask > tornado > django\n\n结合实际使用:\n\n    tornado 使用了异步驱动，所以在写业务代码时如果稍有同步耗时性能就会急剧下降；\n    bottle需要自己实现的东西太多，加上之后不知道性能会怎样；\n    flask性能稍微差点，但周边的支持已经很丰富了；\n    django就不说了，性能已经没法看了，唯一的好处就是开发的架子都已经搭好，开发速度快很多\n当然这些框架不是纯粹一个功能层面上的东西，可能有所偏差。\n\n\n\n### Reference\n1. xxxx\n2. xxxx\n","source":"_posts/2017-06-15-python-networks.md","raw":"---\ntitle: 使用Python搭建本地服务器\ndate: 2017-06-15 23:56:26\ncategories: blog\ntags: [python]\n---\n\n![Kitty](http://odzl05jxx.bkt.clouddn.com/c6dd030bf8cc75628fce3aec8216ba52.jpg?imageView2/2/w/600)\n关于如何使用Python搭建后台的方法很多，这里列举出一些实例。<!--more-->\n\n## 1. The Flask Way\n\n### 1.1 Basics\n> Flask is a very simple, but extremely flexible framework Flask使用Decorator对请求进行处理\n\n\n```Python\n#!/usr/bin/python3\n# -*- coding:utf8 -*-\n\nfrom flask import Flask\nfrom flask import request\nfrom flask import jsonify\nfrom flask import send_file\n\n# create the flask object\napp = Flask(__name__)\n\n# 处理GET请求像这样就可以了\n\n@app.route('/', methods=['GET'])\ndef handle_get():\n    return 'haha ,this is http status code 200'\n\n#处理POST请求，从request中拿东西，返回response\n@app.route('/', methods=['POST'])\ndef handle_post():\n    uid = request.form['uid'] # requets.form是一个list，从里面获取想表单的参数\n    name = request.form['name']\n    print('uid is %s ,name is %s ' % (uid, name))\n    return '200 Ok, or whatever you like'  \n\nif __name__ == '__main__':\n    app.run(port=12345, debug=True) #设置为True后，会自动检测到服务端代码更改并reload，出错了也会给client返回实际的错误堆栈， 生产环境不要打开Debug 。\n\n# 对于GET请求，获得query参数的方式\nhttp://127.0.0.1:12345/_search_user?user=111&date=190\n\n@app.route('/_search_user', methods=['GET'])\ndef query_user_profile():\n    user = request.args.get('user')\n    date = request.args.get('date')\n    print(user)\n    print(date)\n    return 'every Thing Ok'\n\n 输出\n 111\n 190   \n\n #返回json，作为API\n@app.route('/_get_current_user', methods=['GET'])\ndef get_current_user():\n    return jsonify(\n        username='Admin',\n        email='Bob@gmail.com',\n        age=18\n    )    \n\n{\n    username: 'Admin';\n    email: 'Bob@gamil.com';\n    age: 18\n}\n\n#返回复杂一点的json，或者json数组\n@app.route('/_get_user_list', methods=['GET'])\ndef get_user_list():\n    user_list = create_user_list()\n    return Response(json.dumps(user_list), mimetype='application/json')\n\n\n#生成数据\ndef create_user_list():\n    alice = {'name': 'alice', 'age': 16, 'sex': 'female'}\n    tom = {'name': 'tom', 'age': 23, 'sex': 'male'}\n    josh = {'name': 'josh', 'age': 20, 'sex': 'male'}\n    bill = {'name': 'bill', 'age': 19, 'sex': 'male'}\n    li = [alice, tom, josh, bill]\n    return li\n\n\n# 在Postman中就能获得这样的result\n[\n    {\n        \"name\": \"alice\",\n        \"age\": 16,\n        \"sex\": \"female\"\n    },\n    {\n        \"name\": \"tom\",\n        \"age\": 23,\n        \"sex\": \"male\"\n    },\n    {\n        \"name\": \"josh\",\n        \"age\": 20,\n        \"sex\": \"male\"\n    },\n    {\n        \"name\": \"bill\",\n        \"age\": 19,\n        \"sex\": \"male\"\n    }\n]\n\n# hosting static file，image,css,etc\n# 提供图片什么的\n\n@app.route('/_get_image', methods=['GET'])\ndef get_image():\n    filename = 'static/image/b1.jpg'\n    fullpath = os.path.join(os.path.curdir, filename)\n    print(filename, fullpath)\n    return send_file(fullpath, mimetype='image/jpeg')\n```\n\n我觉得Flask的官方Doc对初学者的友好度几乎是满分\n- [accessing-request-data](http://flask.pocoo.org/docs/0.12/quickstart/#accessing-request-data)\n- [cookies](http://flask.pocoo.org/docs/0.12/quickstart/#cookies)\n- [sessions](http://flask.pocoo.org/docs/0.12/quickstart/#sessions)\n- [static files](http://flask.pocoo.org/docs/0.12/quickstart/#static-files)\n所有的静态文件必须放在当前目录下的static目录中，里面可以再创建image，css,404.html等文件\n另外，如果要调试接口的话，用Postman吧，比Fiddler简单点\n返回response的时候一定要指明mime-type，或者content-type\ntext/html、text/css、application/json什么的，[详细的http-content-type表格](http://www.runoob.com/http/http-content-type.html)\n关于content-type,找到一篇[介绍](http://homeway.me/2015/07/19/understand-http-about-content-type/)\n关于Http header常用字段[理解Http Header](http://zq210wl.github.io/2014/12/30/html-http-header-analysis/)\nHttp底层TCP ,ACK 等等需要tcpcump结合wireShark抓包\n\n>下面是几个常见的Content-Type:\n1.text/html\n2.text/plain\n3.text/css\n4.text/javascript\n5.application/x-www-form-urlencoded\n6.multipart/form-data\n7.application/json\n8.application/xml\n…\n前面几个都很好理解，都是html，css，javascript的文件类型，后面四个是POST的发包方式。\n\n### 1.2 Flask BluePrints\n\n### 1.3 Flask + gevent 提高web 框架的性能\n[docs](http://flask.pocoo.org/docs/0.12/deploying/wsgi-standalone/)\n\n### 2. The Django Way\nDjango是**web framework**，不是**WebServer**\n\n\n\n## 3. Using Tornado\n\n## 4. 其他的点\n### 4.1 Web架构\n网络库上手比较快，很重要的一点是理解其在通讯中的层级，Nigix属于代理转发，Flask处理业务逻辑，Tornado处理Http底层实现，Django负责用于高效网络应用开发\n - [Django和Flask这两个框架在设计上各方面有什么优缺点？\n](https://www.zhihu.com/question/41564604)\n\n\nUrlLib，Socket这些属于Python底层的基础性的network库，属于基础的东西。\n\n### 4.2不服跑个分\n引用一篇[测评](http://www.vimer.cn/archives/2926.html)\n>可见纯框架自身的性能为:\n\n    bottle > flask > tornado > django\n\n结合实际使用:\n\n    tornado 使用了异步驱动，所以在写业务代码时如果稍有同步耗时性能就会急剧下降；\n    bottle需要自己实现的东西太多，加上之后不知道性能会怎样；\n    flask性能稍微差点，但周边的支持已经很丰富了；\n    django就不说了，性能已经没法看了，唯一的好处就是开发的架子都已经搭好，开发速度快很多\n当然这些框架不是纯粹一个功能层面上的东西，可能有所偏差。\n\n\n\n### Reference\n1. xxxx\n2. xxxx\n","slug":"2017-06-15-python-networks","published":1,"updated":"2017-07-23T10:43:10.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdniu001ybovrqs4aj4rx","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/c6dd030bf8cc75628fce3aec8216ba52.jpg?imageView2/2/w/600\" alt=\"Kitty\"><br>关于如何使用Python搭建后台的方法很多，这里列举出一些实例。<a id=\"more\"></a></p>\n<h2 id=\"1-The-Flask-Way\"><a href=\"#1-The-Flask-Way\" class=\"headerlink\" title=\"1. The Flask Way\"></a>1. The Flask Way</h2><h3 id=\"1-1-Basics\"><a href=\"#1-1-Basics\" class=\"headerlink\" title=\"1.1 Basics\"></a>1.1 Basics</h3><blockquote>\n<p>Flask is a very simple, but extremely flexible framework Flask使用Decorator对请求进行处理</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python3</div><div class=\"line\"># -*- coding:utf8 -*-</div><div class=\"line\"></div><div class=\"line\">from flask import Flask</div><div class=\"line\">from flask import request</div><div class=\"line\">from flask import jsonify</div><div class=\"line\">from flask import send_file</div><div class=\"line\"></div><div class=\"line\"># create the flask object</div><div class=\"line\">app = Flask(__name__)</div><div class=\"line\"></div><div class=\"line\"># 处理GET请求像这样就可以了</div><div class=\"line\"></div><div class=\"line\">@app.route('/', methods=['GET'])</div><div class=\"line\">def handle_get():</div><div class=\"line\">    return 'haha ,this is http status code 200'</div><div class=\"line\"></div><div class=\"line\">#处理POST请求，从request中拿东西，返回response</div><div class=\"line\">@app.route('/', methods=['POST'])</div><div class=\"line\">def handle_post():</div><div class=\"line\">    uid = request.form['uid'] # requets.form是一个list，从里面获取想表单的参数</div><div class=\"line\">    name = request.form['name']</div><div class=\"line\">    print('uid is %s ,name is %s ' % (uid, name))</div><div class=\"line\">    return '200 Ok, or whatever you like'  </div><div class=\"line\"></div><div class=\"line\">if __name__ == '__main__':</div><div class=\"line\">    app.run(port=12345, debug=True) #设置为True后，会自动检测到服务端代码更改并reload，出错了也会给client返回实际的错误堆栈， 生产环境不要打开Debug 。</div><div class=\"line\"></div><div class=\"line\"># 对于GET请求，获得query参数的方式</div><div class=\"line\">http://127.0.0.1:12345/_search_user?user=111&amp;date=190</div><div class=\"line\"></div><div class=\"line\">@app.route('/_search_user', methods=['GET'])</div><div class=\"line\">def query_user_profile():</div><div class=\"line\">    user = request.args.get('user')</div><div class=\"line\">    date = request.args.get('date')</div><div class=\"line\">    print(user)</div><div class=\"line\">    print(date)</div><div class=\"line\">    return 'every Thing Ok'</div><div class=\"line\"></div><div class=\"line\"> 输出</div><div class=\"line\"> 111</div><div class=\"line\"> 190   </div><div class=\"line\"></div><div class=\"line\"> #返回json，作为API</div><div class=\"line\">@app.route('/_get_current_user', methods=['GET'])</div><div class=\"line\">def get_current_user():</div><div class=\"line\">    return jsonify(</div><div class=\"line\">        username='Admin',</div><div class=\"line\">        email='Bob@gmail.com',</div><div class=\"line\">        age=18</div><div class=\"line\">    )    </div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    username: 'Admin';</div><div class=\"line\">    email: 'Bob@gamil.com';</div><div class=\"line\">    age: 18</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#返回复杂一点的json，或者json数组</div><div class=\"line\">@app.route('/_get_user_list', methods=['GET'])</div><div class=\"line\">def get_user_list():</div><div class=\"line\">    user_list = create_user_list()</div><div class=\"line\">    return Response(json.dumps(user_list), mimetype='application/json')</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#生成数据</div><div class=\"line\">def create_user_list():</div><div class=\"line\">    alice = &#123;'name': 'alice', 'age': 16, 'sex': 'female'&#125;</div><div class=\"line\">    tom = &#123;'name': 'tom', 'age': 23, 'sex': 'male'&#125;</div><div class=\"line\">    josh = &#123;'name': 'josh', 'age': 20, 'sex': 'male'&#125;</div><div class=\"line\">    bill = &#123;'name': 'bill', 'age': 19, 'sex': 'male'&#125;</div><div class=\"line\">    li = [alice, tom, josh, bill]</div><div class=\"line\">    return li</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 在Postman中就能获得这样的result</div><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"alice\",</div><div class=\"line\">        \"age\": 16,</div><div class=\"line\">        \"sex\": \"female\"</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"tom\",</div><div class=\"line\">        \"age\": 23,</div><div class=\"line\">        \"sex\": \"male\"</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"josh\",</div><div class=\"line\">        \"age\": 20,</div><div class=\"line\">        \"sex\": \"male\"</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"bill\",</div><div class=\"line\">        \"age\": 19,</div><div class=\"line\">        \"sex\": \"male\"</div><div class=\"line\">    &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"># hosting static file，image,css,etc</div><div class=\"line\"># 提供图片什么的</div><div class=\"line\"></div><div class=\"line\">@app.route('/_get_image', methods=['GET'])</div><div class=\"line\">def get_image():</div><div class=\"line\">    filename = 'static/image/b1.jpg'</div><div class=\"line\">    fullpath = os.path.join(os.path.curdir, filename)</div><div class=\"line\">    print(filename, fullpath)</div><div class=\"line\">    return send_file(fullpath, mimetype='image/jpeg')</div></pre></td></tr></table></figure>\n<p>我觉得Flask的官方Doc对初学者的友好度几乎是满分</p>\n<ul>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#accessing-request-data\">accessing-request-data</a></li>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#cookies\">cookies</a></li>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#sessions\">sessions</a></li>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#static-files\">static files</a><br>所有的静态文件必须放在当前目录下的static目录中，里面可以再创建image，css,404.html等文件<br>另外，如果要调试接口的话，用Postman吧，比Fiddler简单点<br>返回response的时候一定要指明mime-type，或者content-type<br>text/html、text/css、application/json什么的，<a href=\"http://www.runoob.com/http/http-content-type.html\">详细的http-content-type表格</a><br>关于content-type,找到一篇<a href=\"http://homeway.me/2015/07/19/understand-http-about-content-type/\">介绍</a><br>关于Http header常用字段<a href=\"http://zq210wl.github.io/2014/12/30/html-http-header-analysis/\">理解Http Header</a><br>Http底层TCP ,ACK 等等需要tcpcump结合wireShark抓包</li>\n</ul>\n<blockquote>\n<p>下面是几个常见的Content-Type:<br>1.text/html<br>2.text/plain<br>3.text/css<br>4.text/javascript<br>5.application/x-www-form-urlencoded<br>6.multipart/form-data<br>7.application/json<br>8.application/xml<br>…<br>前面几个都很好理解，都是html，css，javascript的文件类型，后面四个是POST的发包方式。</p>\n</blockquote>\n<h3 id=\"1-2-Flask-BluePrints\"><a href=\"#1-2-Flask-BluePrints\" class=\"headerlink\" title=\"1.2 Flask BluePrints\"></a>1.2 Flask BluePrints</h3><h3 id=\"1-3-Flask-gevent-提高web-框架的性能\"><a href=\"#1-3-Flask-gevent-提高web-框架的性能\" class=\"headerlink\" title=\"1.3 Flask + gevent 提高web 框架的性能\"></a>1.3 Flask + gevent 提高web 框架的性能</h3><p><a href=\"http://flask.pocoo.org/docs/0.12/deploying/wsgi-standalone/\">docs</a></p>\n<h3 id=\"2-The-Django-Way\"><a href=\"#2-The-Django-Way\" class=\"headerlink\" title=\"2. The Django Way\"></a>2. The Django Way</h3><p>Django是<strong>web framework</strong>，不是<strong>WebServer</strong></p>\n<h2 id=\"3-Using-Tornado\"><a href=\"#3-Using-Tornado\" class=\"headerlink\" title=\"3. Using Tornado\"></a>3. Using Tornado</h2><h2 id=\"4-其他的点\"><a href=\"#4-其他的点\" class=\"headerlink\" title=\"4. 其他的点\"></a>4. 其他的点</h2><h3 id=\"4-1-Web架构\"><a href=\"#4-1-Web架构\" class=\"headerlink\" title=\"4.1 Web架构\"></a>4.1 Web架构</h3><p>网络库上手比较快，很重要的一点是理解其在通讯中的层级，Nigix属于代理转发，Flask处理业务逻辑，Tornado处理Http底层实现，Django负责用于高效网络应用开发</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/41564604\">Django和Flask这两个框架在设计上各方面有什么优缺点？\n</a></li>\n</ul>\n<p>UrlLib，Socket这些属于Python底层的基础性的network库，属于基础的东西。</p>\n<h3 id=\"4-2不服跑个分\"><a href=\"#4-2不服跑个分\" class=\"headerlink\" title=\"4.2不服跑个分\"></a>4.2不服跑个分</h3><p>引用一篇<a href=\"http://www.vimer.cn/archives/2926.html\">测评</a></p>\n<blockquote>\n<p>可见纯框架自身的性能为:</p>\n</blockquote>\n<pre><code>bottle &gt; flask &gt; tornado &gt; django\n</code></pre><p>结合实际使用:</p>\n<pre><code>tornado 使用了异步驱动，所以在写业务代码时如果稍有同步耗时性能就会急剧下降；\nbottle需要自己实现的东西太多，加上之后不知道性能会怎样；\nflask性能稍微差点，但周边的支持已经很丰富了；\ndjango就不说了，性能已经没法看了，唯一的好处就是开发的架子都已经搭好，开发速度快很多\n</code></pre><p>当然这些框架不是纯粹一个功能层面上的东西，可能有所偏差。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li>xxxx</li>\n<li>xxxx</li>\n</ol>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/c6dd030bf8cc75628fce3aec8216ba52.jpg?imageView2/2/w/600\" alt=\"Kitty\"><br>关于如何使用Python搭建后台的方法很多，这里列举出一些实例。","more":"</p>\n<h2 id=\"1-The-Flask-Way\"><a href=\"#1-The-Flask-Way\" class=\"headerlink\" title=\"1. The Flask Way\"></a>1. The Flask Way</h2><h3 id=\"1-1-Basics\"><a href=\"#1-1-Basics\" class=\"headerlink\" title=\"1.1 Basics\"></a>1.1 Basics</h3><blockquote>\n<p>Flask is a very simple, but extremely flexible framework Flask使用Decorator对请求进行处理</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python3</div><div class=\"line\"># -*- coding:utf8 -*-</div><div class=\"line\"></div><div class=\"line\">from flask import Flask</div><div class=\"line\">from flask import request</div><div class=\"line\">from flask import jsonify</div><div class=\"line\">from flask import send_file</div><div class=\"line\"></div><div class=\"line\"># create the flask object</div><div class=\"line\">app = Flask(__name__)</div><div class=\"line\"></div><div class=\"line\"># 处理GET请求像这样就可以了</div><div class=\"line\"></div><div class=\"line\">@app.route('/', methods=['GET'])</div><div class=\"line\">def handle_get():</div><div class=\"line\">    return 'haha ,this is http status code 200'</div><div class=\"line\"></div><div class=\"line\">#处理POST请求，从request中拿东西，返回response</div><div class=\"line\">@app.route('/', methods=['POST'])</div><div class=\"line\">def handle_post():</div><div class=\"line\">    uid = request.form['uid'] # requets.form是一个list，从里面获取想表单的参数</div><div class=\"line\">    name = request.form['name']</div><div class=\"line\">    print('uid is %s ,name is %s ' % (uid, name))</div><div class=\"line\">    return '200 Ok, or whatever you like'  </div><div class=\"line\"></div><div class=\"line\">if __name__ == '__main__':</div><div class=\"line\">    app.run(port=12345, debug=True) #设置为True后，会自动检测到服务端代码更改并reload，出错了也会给client返回实际的错误堆栈， 生产环境不要打开Debug 。</div><div class=\"line\"></div><div class=\"line\"># 对于GET请求，获得query参数的方式</div><div class=\"line\">http://127.0.0.1:12345/_search_user?user=111&amp;date=190</div><div class=\"line\"></div><div class=\"line\">@app.route('/_search_user', methods=['GET'])</div><div class=\"line\">def query_user_profile():</div><div class=\"line\">    user = request.args.get('user')</div><div class=\"line\">    date = request.args.get('date')</div><div class=\"line\">    print(user)</div><div class=\"line\">    print(date)</div><div class=\"line\">    return 'every Thing Ok'</div><div class=\"line\"></div><div class=\"line\"> 输出</div><div class=\"line\"> 111</div><div class=\"line\"> 190   </div><div class=\"line\"></div><div class=\"line\"> #返回json，作为API</div><div class=\"line\">@app.route('/_get_current_user', methods=['GET'])</div><div class=\"line\">def get_current_user():</div><div class=\"line\">    return jsonify(</div><div class=\"line\">        username='Admin',</div><div class=\"line\">        email='Bob@gmail.com',</div><div class=\"line\">        age=18</div><div class=\"line\">    )    </div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    username: 'Admin';</div><div class=\"line\">    email: 'Bob@gamil.com';</div><div class=\"line\">    age: 18</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#返回复杂一点的json，或者json数组</div><div class=\"line\">@app.route('/_get_user_list', methods=['GET'])</div><div class=\"line\">def get_user_list():</div><div class=\"line\">    user_list = create_user_list()</div><div class=\"line\">    return Response(json.dumps(user_list), mimetype='application/json')</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#生成数据</div><div class=\"line\">def create_user_list():</div><div class=\"line\">    alice = &#123;'name': 'alice', 'age': 16, 'sex': 'female'&#125;</div><div class=\"line\">    tom = &#123;'name': 'tom', 'age': 23, 'sex': 'male'&#125;</div><div class=\"line\">    josh = &#123;'name': 'josh', 'age': 20, 'sex': 'male'&#125;</div><div class=\"line\">    bill = &#123;'name': 'bill', 'age': 19, 'sex': 'male'&#125;</div><div class=\"line\">    li = [alice, tom, josh, bill]</div><div class=\"line\">    return li</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 在Postman中就能获得这样的result</div><div class=\"line\">[</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"alice\",</div><div class=\"line\">        \"age\": 16,</div><div class=\"line\">        \"sex\": \"female\"</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"tom\",</div><div class=\"line\">        \"age\": 23,</div><div class=\"line\">        \"sex\": \"male\"</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"josh\",</div><div class=\"line\">        \"age\": 20,</div><div class=\"line\">        \"sex\": \"male\"</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        \"name\": \"bill\",</div><div class=\"line\">        \"age\": 19,</div><div class=\"line\">        \"sex\": \"male\"</div><div class=\"line\">    &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"># hosting static file，image,css,etc</div><div class=\"line\"># 提供图片什么的</div><div class=\"line\"></div><div class=\"line\">@app.route('/_get_image', methods=['GET'])</div><div class=\"line\">def get_image():</div><div class=\"line\">    filename = 'static/image/b1.jpg'</div><div class=\"line\">    fullpath = os.path.join(os.path.curdir, filename)</div><div class=\"line\">    print(filename, fullpath)</div><div class=\"line\">    return send_file(fullpath, mimetype='image/jpeg')</div></pre></td></tr></table></figure>\n<p>我觉得Flask的官方Doc对初学者的友好度几乎是满分</p>\n<ul>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#accessing-request-data\">accessing-request-data</a></li>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#cookies\">cookies</a></li>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#sessions\">sessions</a></li>\n<li><a href=\"http://flask.pocoo.org/docs/0.12/quickstart/#static-files\">static files</a><br>所有的静态文件必须放在当前目录下的static目录中，里面可以再创建image，css,404.html等文件<br>另外，如果要调试接口的话，用Postman吧，比Fiddler简单点<br>返回response的时候一定要指明mime-type，或者content-type<br>text/html、text/css、application/json什么的，<a href=\"http://www.runoob.com/http/http-content-type.html\">详细的http-content-type表格</a><br>关于content-type,找到一篇<a href=\"http://homeway.me/2015/07/19/understand-http-about-content-type/\">介绍</a><br>关于Http header常用字段<a href=\"http://zq210wl.github.io/2014/12/30/html-http-header-analysis/\">理解Http Header</a><br>Http底层TCP ,ACK 等等需要tcpcump结合wireShark抓包</li>\n</ul>\n<blockquote>\n<p>下面是几个常见的Content-Type:<br>1.text/html<br>2.text/plain<br>3.text/css<br>4.text/javascript<br>5.application/x-www-form-urlencoded<br>6.multipart/form-data<br>7.application/json<br>8.application/xml<br>…<br>前面几个都很好理解，都是html，css，javascript的文件类型，后面四个是POST的发包方式。</p>\n</blockquote>\n<h3 id=\"1-2-Flask-BluePrints\"><a href=\"#1-2-Flask-BluePrints\" class=\"headerlink\" title=\"1.2 Flask BluePrints\"></a>1.2 Flask BluePrints</h3><h3 id=\"1-3-Flask-gevent-提高web-框架的性能\"><a href=\"#1-3-Flask-gevent-提高web-框架的性能\" class=\"headerlink\" title=\"1.3 Flask + gevent 提高web 框架的性能\"></a>1.3 Flask + gevent 提高web 框架的性能</h3><p><a href=\"http://flask.pocoo.org/docs/0.12/deploying/wsgi-standalone/\">docs</a></p>\n<h3 id=\"2-The-Django-Way\"><a href=\"#2-The-Django-Way\" class=\"headerlink\" title=\"2. The Django Way\"></a>2. The Django Way</h3><p>Django是<strong>web framework</strong>，不是<strong>WebServer</strong></p>\n<h2 id=\"3-Using-Tornado\"><a href=\"#3-Using-Tornado\" class=\"headerlink\" title=\"3. Using Tornado\"></a>3. Using Tornado</h2><h2 id=\"4-其他的点\"><a href=\"#4-其他的点\" class=\"headerlink\" title=\"4. 其他的点\"></a>4. 其他的点</h2><h3 id=\"4-1-Web架构\"><a href=\"#4-1-Web架构\" class=\"headerlink\" title=\"4.1 Web架构\"></a>4.1 Web架构</h3><p>网络库上手比较快，很重要的一点是理解其在通讯中的层级，Nigix属于代理转发，Flask处理业务逻辑，Tornado处理Http底层实现，Django负责用于高效网络应用开发</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/41564604\">Django和Flask这两个框架在设计上各方面有什么优缺点？\n</a></li>\n</ul>\n<p>UrlLib，Socket这些属于Python底层的基础性的network库，属于基础的东西。</p>\n<h3 id=\"4-2不服跑个分\"><a href=\"#4-2不服跑个分\" class=\"headerlink\" title=\"4.2不服跑个分\"></a>4.2不服跑个分</h3><p>引用一篇<a href=\"http://www.vimer.cn/archives/2926.html\">测评</a></p>\n<blockquote>\n<p>可见纯框架自身的性能为:</p>\n</blockquote>\n<pre><code>bottle &gt; flask &gt; tornado &gt; django\n</code></pre><p>结合实际使用:</p>\n<pre><code>tornado 使用了异步驱动，所以在写业务代码时如果稍有同步耗时性能就会急剧下降；\nbottle需要自己实现的东西太多，加上之后不知道性能会怎样；\nflask性能稍微差点，但周边的支持已经很丰富了；\ndjango就不说了，性能已经没法看了，唯一的好处就是开发的架子都已经搭好，开发速度快很多\n</code></pre><p>当然这些框架不是纯粹一个功能层面上的东西，可能有所偏差。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li>xxxx</li>\n<li>xxxx</li>\n</ol>"},{"title":"For those tiny details in Java","date":"2017-06-17T13:24:48.000Z","_content":"> interesting stuff in java that don't seem to get enough pubilicity\n>\n>\n\n![landscape](http://odzl05jxx.bkt.clouddn.com/34a7d57ccabb18c69d085247cf009b22.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n1. getting the concreate class from generic types\n    ```java\n        /**\n     * Make a GET request and return a parsed object from JSON.\n     *\n     * @param url     URL of the request to make\n     * @param clazz   Relevant class object, for Gson's reflection\n     * @param headers Map of request headers\n     */\n    public GenericMoshiRequest(String url, @Nullable Class<T> clazz, Map<String, String> headers,\n                               Response.Listener<T> listener, Response.ErrorListener errorListener) {\n        super(Method.GET, url, errorListener);\n//        this.clazz = clazz;\n        Class<T> entityClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];//使用反射获得泛型对应class\n        this.clazz = entityClass;\n        this.headers = headers;\n        this.listener = listener;\n    }\n    ```\n\n2. OkHttp 默认会自动重试失败的请求\n[okhttp-is-quietly-retrying-requests-is-your-api-ready](https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace)\nOkHttp默认会对请求进行重试，具体是在RetryAndFollowUpInterceptor中进行的。\n ```java\n   RetryAndFollowUpInterceptor.java\n\n  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) { # 不停的尝试\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false; //默认不认可response成功\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;  //继续尝试\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue; //继续尝试\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) { //出现不可预料的错误，释放硬件资源，端口什么的\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n    }\n  }\n    ```\n客户端当然可以使用retryOnConnectionFailure禁止这种自动重试策略，但不建议这么做。另外，为避免减少不必要的重试请求，\nOkHttp 3.3.0 [issue](https://github.com/square/okhttp/issues/2394)\n\n> Don’t recover if we encounter a read timeout after sending the request, but do recover if we encounter a timeout building a connection\n建立连接超时可以重试(客户端到服务器的通道不可靠，当然可以重试)，连接上之后读取超时则不去重试(服务器出了问题，没有必要重试)。\n\n另外，GET方法本身是人畜无害的，Retry请求多次发起不会造成数据错误；但对于POST，涉及到写服务端写操作，最好带上GUID作为单次请求unique标示。（这是server和client之间需要协商好的protocol）\n\n3. From Java Code To Java Heap\n   A talk from IBM Engineer, talking about optimizing the memery usage for your java application.[youtube](https://www.youtube.com/watch?v=FLcXf9pO27w)\n   [ibm](https://www.ibm.com/developerworks/java/library/j-codetoheap/index.html)\n\n4. 强行更改String的内容\n  String这种东西是放在常量池里面的，所以\n  ```java\n  String a = \"hello\"\n  String b = \"hello\"\n  String c = new String(\"Hello\")\n\n  显然ab都指向了常量池，c指向了放在堆上的对象，后者也指向常量池\n  a==b!=c  \n\n  //更改这个String里面的东西\n  Field a_ = String.class.getDeclaredField(\"value\");\n        a_.setAccessible(true);\n        char[] value=(char[])a_.get(a);\n        value[3]='_';   //修改a所指向的值\n\n  这样a,b,c 的值都改掉了      \n\n  ```\n\n5. 注解\n```java\n Builder(Retrofit retrofit, Method method) {\n      this.retrofit = retrofit;\n      this.method = method;\n      this.methodAnnotations = method.getAnnotations();\n      this.parameterTypes = method.getGenericParameterTypes();\n      this.parameterAnnotationsArray = method.getParameterAnnotations();\n    }\n```\n\n如果不是看到Retrofit的源码，一般还真没机会了解到这几个方法。。\n\n6. java如何把char类型数据转成int类型数据\nString a = \"123\"\nStirng本质上就是一个char[]的包装类，1对应Asicii码的49,2对应50,3对应51.所以实质上就类似于char[] = new char{49,50,51} ;\n\n想把1,2,3分别拿出来得这么写：\n```java\nchar[] array = a.tocharArray();\nfor(i=0;i<=array.length();i++){\n  int a = Integer.parseInt(String.valueof(array.charAt(i)));//这样就能分别把1,2,3拿出来了。\n}\n```\n\n\n根据stackoverFlow的[解释](https://stackoverflow.com/questions/14342988/why-are-we-allowed-to-assign-char-to-a-int-in-java), char只是16bit的数字，也就是int（4个字节,32位）的子集。\n\n```java\nchar word = 'A' +1234 ;//编译通过\n\nchar word2 = 'A';\nword2 = word2 +1 ;//编译失败\n```\n\n[char的转换问题](https://stackoverflow.com/questions/21317631/java-char-int-conversions)\n\n7. Guava就是个Util\n","source":"_posts/2017-06-17-tiny-details-in-java.md","raw":"---\ntitle: For those tiny details in Java\ndate: 2017-06-17 21:24:48\ntags: [java]\n---\n> interesting stuff in java that don't seem to get enough pubilicity\n>\n>\n\n![landscape](http://odzl05jxx.bkt.clouddn.com/34a7d57ccabb18c69d085247cf009b22.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n1. getting the concreate class from generic types\n    ```java\n        /**\n     * Make a GET request and return a parsed object from JSON.\n     *\n     * @param url     URL of the request to make\n     * @param clazz   Relevant class object, for Gson's reflection\n     * @param headers Map of request headers\n     */\n    public GenericMoshiRequest(String url, @Nullable Class<T> clazz, Map<String, String> headers,\n                               Response.Listener<T> listener, Response.ErrorListener errorListener) {\n        super(Method.GET, url, errorListener);\n//        this.clazz = clazz;\n        Class<T> entityClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];//使用反射获得泛型对应class\n        this.clazz = entityClass;\n        this.headers = headers;\n        this.listener = listener;\n    }\n    ```\n\n2. OkHttp 默认会自动重试失败的请求\n[okhttp-is-quietly-retrying-requests-is-your-api-ready](https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace)\nOkHttp默认会对请求进行重试，具体是在RetryAndFollowUpInterceptor中进行的。\n ```java\n   RetryAndFollowUpInterceptor.java\n\n  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) { # 不停的尝试\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false; //默认不认可response成功\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;  //继续尝试\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue; //继续尝试\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) { //出现不可预料的错误，释放硬件资源，端口什么的\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n    }\n  }\n    ```\n客户端当然可以使用retryOnConnectionFailure禁止这种自动重试策略，但不建议这么做。另外，为避免减少不必要的重试请求，\nOkHttp 3.3.0 [issue](https://github.com/square/okhttp/issues/2394)\n\n> Don’t recover if we encounter a read timeout after sending the request, but do recover if we encounter a timeout building a connection\n建立连接超时可以重试(客户端到服务器的通道不可靠，当然可以重试)，连接上之后读取超时则不去重试(服务器出了问题，没有必要重试)。\n\n另外，GET方法本身是人畜无害的，Retry请求多次发起不会造成数据错误；但对于POST，涉及到写服务端写操作，最好带上GUID作为单次请求unique标示。（这是server和client之间需要协商好的protocol）\n\n3. From Java Code To Java Heap\n   A talk from IBM Engineer, talking about optimizing the memery usage for your java application.[youtube](https://www.youtube.com/watch?v=FLcXf9pO27w)\n   [ibm](https://www.ibm.com/developerworks/java/library/j-codetoheap/index.html)\n\n4. 强行更改String的内容\n  String这种东西是放在常量池里面的，所以\n  ```java\n  String a = \"hello\"\n  String b = \"hello\"\n  String c = new String(\"Hello\")\n\n  显然ab都指向了常量池，c指向了放在堆上的对象，后者也指向常量池\n  a==b!=c  \n\n  //更改这个String里面的东西\n  Field a_ = String.class.getDeclaredField(\"value\");\n        a_.setAccessible(true);\n        char[] value=(char[])a_.get(a);\n        value[3]='_';   //修改a所指向的值\n\n  这样a,b,c 的值都改掉了      \n\n  ```\n\n5. 注解\n```java\n Builder(Retrofit retrofit, Method method) {\n      this.retrofit = retrofit;\n      this.method = method;\n      this.methodAnnotations = method.getAnnotations();\n      this.parameterTypes = method.getGenericParameterTypes();\n      this.parameterAnnotationsArray = method.getParameterAnnotations();\n    }\n```\n\n如果不是看到Retrofit的源码，一般还真没机会了解到这几个方法。。\n\n6. java如何把char类型数据转成int类型数据\nString a = \"123\"\nStirng本质上就是一个char[]的包装类，1对应Asicii码的49,2对应50,3对应51.所以实质上就类似于char[] = new char{49,50,51} ;\n\n想把1,2,3分别拿出来得这么写：\n```java\nchar[] array = a.tocharArray();\nfor(i=0;i<=array.length();i++){\n  int a = Integer.parseInt(String.valueof(array.charAt(i)));//这样就能分别把1,2,3拿出来了。\n}\n```\n\n\n根据stackoverFlow的[解释](https://stackoverflow.com/questions/14342988/why-are-we-allowed-to-assign-char-to-a-int-in-java), char只是16bit的数字，也就是int（4个字节,32位）的子集。\n\n```java\nchar word = 'A' +1234 ;//编译通过\n\nchar word2 = 'A';\nword2 = word2 +1 ;//编译失败\n```\n\n[char的转换问题](https://stackoverflow.com/questions/21317631/java-char-int-conversions)\n\n7. Guava就是个Util\n","slug":"2017-06-17-tiny-details-in-java","published":1,"updated":"2017-07-23T10:43:10.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnj20021bovr6j37lb83","content":"<blockquote>\n<p>interesting stuff in java that don’t seem to get enough pubilicity</p>\n</blockquote>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/34a7d57ccabb18c69d085247cf009b22.jpg?imageView2/2/w/600\" alt=\"landscape\"></p>\n<a id=\"more\"></a>\n<ol>\n<li><p>getting the concreate class from generic types</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">        <span class=\"comment\">/**</div><div class=\"line\">     * Make a GET request and return a parsed object from JSON.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> url     URL of the request to make</div><div class=\"line\">     * <span class=\"doctag\">@param</span> clazz   Relevant class object, for Gson's reflection</div><div class=\"line\">     * <span class=\"doctag\">@param</span> headers Map of request headers</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericMoshiRequest</span><span class=\"params\">(String url, @Nullable Class&lt;T&gt; clazz, Map&lt;String, String&gt; headers,</div><div class=\"line\">                               Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(Method.GET, url, errorListener);</div><div class=\"line\"><span class=\"comment\">//        this.clazz = clazz;</span></div><div class=\"line\">        Class&lt;T&gt; entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[<span class=\"number\">0</span>];<span class=\"comment\">//使用反射获得泛型对应class</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.clazz = entityClass;</div><div class=\"line\">        <span class=\"keyword\">this</span>.headers = headers;</div><div class=\"line\">        <span class=\"keyword\">this</span>.listener = listener;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>OkHttp 默认会自动重试失败的请求<br><a href=\"https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace\">okhttp-is-quietly-retrying-requests-is-your-api-ready</a><br>OkHttp默认会对请求进行重试，具体是在RetryAndFollowUpInterceptor中进行的。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"> RetryAndFollowUpInterceptor.java</div><div class=\"line\"></div><div class=\"line\">@Override public Response intercept(Chain chain) throws IOException &#123;</div><div class=\"line\">  Request request = chain.request();</div><div class=\"line\"></div><div class=\"line\">  streamAllocation = new StreamAllocation(</div><div class=\"line\">      client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class=\"line\"></div><div class=\"line\">  int followUpCount = 0;</div><div class=\"line\">  Response priorResponse = null;</div><div class=\"line\">  while (true) &#123; # 不停的尝试</div><div class=\"line\">    if (canceled) &#123;</div><div class=\"line\">      streamAllocation.release();</div><div class=\"line\">      throw new IOException(\"Canceled\");</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Response response = null;</div><div class=\"line\">    boolean releaseConnection = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">      response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</div><div class=\"line\">      releaseConnection = false; //默认不认可response成功</div><div class=\"line\">    &#125; catch (RouteException e) &#123;</div><div class=\"line\">      // The attempt to connect via a route failed. The request will not have been sent.</div><div class=\"line\">      if (!recover(e.getLastConnectException(), false, request)) &#123;</div><div class=\"line\">        throw e.getLastConnectException();</div><div class=\"line\">      &#125;</div><div class=\"line\">      releaseConnection = false;</div><div class=\"line\">      continue;  //继续尝试</div><div class=\"line\">    &#125; catch (IOException e) &#123;</div><div class=\"line\">      // An attempt to communicate with a server failed. The request may have been sent.</div><div class=\"line\">      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</div><div class=\"line\">      if (!recover(e, requestSendStarted, request)) throw e;</div><div class=\"line\">      releaseConnection = false;</div><div class=\"line\">      continue; //继续尝试</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">      // We're throwing an unchecked exception. Release any resources.</div><div class=\"line\">      if (releaseConnection) &#123; //出现不可预料的错误，释放硬件资源，端口什么的</div><div class=\"line\">        streamAllocation.streamFailed(null);</div><div class=\"line\">        streamAllocation.release();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>客户端当然可以使用retryOnConnectionFailure禁止这种自动重试策略，但不建议这么做。另外，为避免减少不必要的重试请求，<br>OkHttp 3.3.0 <a href=\"https://github.com/square/okhttp/issues/2394\">issue</a></p>\n<blockquote>\n<p>Don’t recover if we encounter a read timeout after sending the request, but do recover if we encounter a timeout building a connection<br>建立连接超时可以重试(客户端到服务器的通道不可靠，当然可以重试)，连接上之后读取超时则不去重试(服务器出了问题，没有必要重试)。</p>\n</blockquote>\n<p>另外，GET方法本身是人畜无害的，Retry请求多次发起不会造成数据错误；但对于POST，涉及到写服务端写操作，最好带上GUID作为单次请求unique标示。（这是server和client之间需要协商好的protocol）</p>\n<ol>\n<li><p>From Java Code To Java Heap<br>A talk from IBM Engineer, talking about optimizing the memery usage for your java application.<a href=\"https://www.youtube.com/watch?v=FLcXf9pO27w\">youtube</a><br><a href=\"https://www.ibm.com/developerworks/java/library/j-codetoheap/index.html\">ibm</a></p>\n</li>\n<li><p>强行更改String的内容<br>String这种东西是放在常量池里面的，所以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">String a = <span class=\"string\">\"hello\"</span></div><div class=\"line\">String b = <span class=\"string\">\"hello\"</span></div><div class=\"line\">String c = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>)</div><div class=\"line\"></div><div class=\"line\">显然ab都指向了常量池，c指向了放在堆上的对象，后者也指向常量池</div><div class=\"line\">a==b!=c  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更改这个String里面的东西</span></div><div class=\"line\">Field a_ = String.class.getDeclaredField(<span class=\"string\">\"value\"</span>);</div><div class=\"line\">      a_.setAccessible(<span class=\"keyword\">true</span>);</div><div class=\"line\">      <span class=\"keyword\">char</span>[] value=(<span class=\"keyword\">char</span>[])a_.get(a);</div><div class=\"line\">      value[<span class=\"number\">3</span>]=<span class=\"string\">'_'</span>;   <span class=\"comment\">//修改a所指向的值</span></div><div class=\"line\"></div><div class=\"line\">这样a,b,c 的值都改掉了</div></pre></td></tr></table></figure>\n</li>\n<li><p>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Builder(Retrofit retrofit, Method method) &#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.retrofit = retrofit;</div><div class=\"line\">     <span class=\"keyword\">this</span>.method = method;</div><div class=\"line\">     <span class=\"keyword\">this</span>.methodAnnotations = method.getAnnotations();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果不是看到Retrofit的源码，一般还真没机会了解到这几个方法。。</p>\n<ol>\n<li>java如何把char类型数据转成int类型数据<br>String a = “123”<br>Stirng本质上就是一个char[]的包装类，1对应Asicii码的49,2对应50,3对应51.所以实质上就类似于char[] = new char{49,50,51} ;</li>\n</ol>\n<p>想把1,2,3分别拿出来得这么写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span>[] array = a.tocharArray();</div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;=array.length();i++)&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> a = Integer.parseInt(String.valueof(array.charAt(i)));<span class=\"comment\">//这样就能分别把1,2,3拿出来了。</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>根据stackoverFlow的<a href=\"https://stackoverflow.com/questions/14342988/why-are-we-allowed-to-assign-char-to-a-int-in-java\">解释</a>, char只是16bit的数字，也就是int（4个字节,32位）的子集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> word = <span class=\"string\">'A'</span> +<span class=\"number\">1234</span> ;<span class=\"comment\">//编译通过</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> word2 = <span class=\"string\">'A'</span>;</div><div class=\"line\">word2 = word2 +<span class=\"number\">1</span> ;<span class=\"comment\">//编译失败</span></div></pre></td></tr></table></figure>\n<p><a href=\"https://stackoverflow.com/questions/21317631/java-char-int-conversions\">char的转换问题</a></p>\n<ol>\n<li>Guava就是个Util</li>\n</ol>\n","excerpt":"<blockquote>\n<p>interesting stuff in java that don’t seem to get enough pubilicity</p>\n</blockquote>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/34a7d57ccabb18c69d085247cf009b22.jpg?imageView2/2/w/600\" alt=\"landscape\"></p>","more":"<ol>\n<li><p>getting the concreate class from generic types</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">        <span class=\"comment\">/**</div><div class=\"line\">     * Make a GET request and return a parsed object from JSON.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> url     URL of the request to make</div><div class=\"line\">     * <span class=\"doctag\">@param</span> clazz   Relevant class object, for Gson's reflection</div><div class=\"line\">     * <span class=\"doctag\">@param</span> headers Map of request headers</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericMoshiRequest</span><span class=\"params\">(String url, @Nullable Class&lt;T&gt; clazz, Map&lt;String, String&gt; headers,</div><div class=\"line\">                               Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(Method.GET, url, errorListener);</div><div class=\"line\"><span class=\"comment\">//        this.clazz = clazz;</span></div><div class=\"line\">        Class&lt;T&gt; entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[<span class=\"number\">0</span>];<span class=\"comment\">//使用反射获得泛型对应class</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.clazz = entityClass;</div><div class=\"line\">        <span class=\"keyword\">this</span>.headers = headers;</div><div class=\"line\">        <span class=\"keyword\">this</span>.listener = listener;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>OkHttp 默认会自动重试失败的请求<br><a href=\"https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace\">okhttp-is-quietly-retrying-requests-is-your-api-ready</a><br>OkHttp默认会对请求进行重试，具体是在RetryAndFollowUpInterceptor中进行的。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"> RetryAndFollowUpInterceptor.java</div><div class=\"line\"></div><div class=\"line\">@Override public Response intercept(Chain chain) throws IOException &#123;</div><div class=\"line\">  Request request = chain.request();</div><div class=\"line\"></div><div class=\"line\">  streamAllocation = new StreamAllocation(</div><div class=\"line\">      client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class=\"line\"></div><div class=\"line\">  int followUpCount = 0;</div><div class=\"line\">  Response priorResponse = null;</div><div class=\"line\">  while (true) &#123; # 不停的尝试</div><div class=\"line\">    if (canceled) &#123;</div><div class=\"line\">      streamAllocation.release();</div><div class=\"line\">      throw new IOException(\"Canceled\");</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Response response = null;</div><div class=\"line\">    boolean releaseConnection = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">      response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</div><div class=\"line\">      releaseConnection = false; //默认不认可response成功</div><div class=\"line\">    &#125; catch (RouteException e) &#123;</div><div class=\"line\">      // The attempt to connect via a route failed. The request will not have been sent.</div><div class=\"line\">      if (!recover(e.getLastConnectException(), false, request)) &#123;</div><div class=\"line\">        throw e.getLastConnectException();</div><div class=\"line\">      &#125;</div><div class=\"line\">      releaseConnection = false;</div><div class=\"line\">      continue;  //继续尝试</div><div class=\"line\">    &#125; catch (IOException e) &#123;</div><div class=\"line\">      // An attempt to communicate with a server failed. The request may have been sent.</div><div class=\"line\">      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</div><div class=\"line\">      if (!recover(e, requestSendStarted, request)) throw e;</div><div class=\"line\">      releaseConnection = false;</div><div class=\"line\">      continue; //继续尝试</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">      // We're throwing an unchecked exception. Release any resources.</div><div class=\"line\">      if (releaseConnection) &#123; //出现不可预料的错误，释放硬件资源，端口什么的</div><div class=\"line\">        streamAllocation.streamFailed(null);</div><div class=\"line\">        streamAllocation.release();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>客户端当然可以使用retryOnConnectionFailure禁止这种自动重试策略，但不建议这么做。另外，为避免减少不必要的重试请求，<br>OkHttp 3.3.0 <a href=\"https://github.com/square/okhttp/issues/2394\">issue</a></p>\n<blockquote>\n<p>Don’t recover if we encounter a read timeout after sending the request, but do recover if we encounter a timeout building a connection<br>建立连接超时可以重试(客户端到服务器的通道不可靠，当然可以重试)，连接上之后读取超时则不去重试(服务器出了问题，没有必要重试)。</p>\n</blockquote>\n<p>另外，GET方法本身是人畜无害的，Retry请求多次发起不会造成数据错误；但对于POST，涉及到写服务端写操作，最好带上GUID作为单次请求unique标示。（这是server和client之间需要协商好的protocol）</p>\n<ol>\n<li><p>From Java Code To Java Heap<br>A talk from IBM Engineer, talking about optimizing the memery usage for your java application.<a href=\"https://www.youtube.com/watch?v=FLcXf9pO27w\">youtube</a><br><a href=\"https://www.ibm.com/developerworks/java/library/j-codetoheap/index.html\">ibm</a></p>\n</li>\n<li><p>强行更改String的内容<br>String这种东西是放在常量池里面的，所以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">String a = <span class=\"string\">\"hello\"</span></div><div class=\"line\">String b = <span class=\"string\">\"hello\"</span></div><div class=\"line\">String c = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>)</div><div class=\"line\"></div><div class=\"line\">显然ab都指向了常量池，c指向了放在堆上的对象，后者也指向常量池</div><div class=\"line\">a==b!=c  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更改这个String里面的东西</span></div><div class=\"line\">Field a_ = String.class.getDeclaredField(<span class=\"string\">\"value\"</span>);</div><div class=\"line\">      a_.setAccessible(<span class=\"keyword\">true</span>);</div><div class=\"line\">      <span class=\"keyword\">char</span>[] value=(<span class=\"keyword\">char</span>[])a_.get(a);</div><div class=\"line\">      value[<span class=\"number\">3</span>]=<span class=\"string\">'_'</span>;   <span class=\"comment\">//修改a所指向的值</span></div><div class=\"line\"></div><div class=\"line\">这样a,b,c 的值都改掉了</div></pre></td></tr></table></figure>\n</li>\n<li><p>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Builder(Retrofit retrofit, Method method) &#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.retrofit = retrofit;</div><div class=\"line\">     <span class=\"keyword\">this</span>.method = method;</div><div class=\"line\">     <span class=\"keyword\">this</span>.methodAnnotations = method.getAnnotations();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果不是看到Retrofit的源码，一般还真没机会了解到这几个方法。。</p>\n<ol>\n<li>java如何把char类型数据转成int类型数据<br>String a = “123”<br>Stirng本质上就是一个char[]的包装类，1对应Asicii码的49,2对应50,3对应51.所以实质上就类似于char[] = new char{49,50,51} ;</li>\n</ol>\n<p>想把1,2,3分别拿出来得这么写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span>[] array = a.tocharArray();</div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;=array.length();i++)&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> a = Integer.parseInt(String.valueof(array.charAt(i)));<span class=\"comment\">//这样就能分别把1,2,3拿出来了。</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>根据stackoverFlow的<a href=\"https://stackoverflow.com/questions/14342988/why-are-we-allowed-to-assign-char-to-a-int-in-java\">解释</a>, char只是16bit的数字，也就是int（4个字节,32位）的子集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> word = <span class=\"string\">'A'</span> +<span class=\"number\">1234</span> ;<span class=\"comment\">//编译通过</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> word2 = <span class=\"string\">'A'</span>;</div><div class=\"line\">word2 = word2 +<span class=\"number\">1</span> ;<span class=\"comment\">//编译失败</span></div></pre></td></tr></table></figure>\n<p><a href=\"https://stackoverflow.com/questions/21317631/java-char-int-conversions\">char的转换问题</a></p>\n<ol>\n<li>Guava就是个Util</li>\n</ol>"},{"title":"在ubuntu服务器上部署flask web app","date":"2017-06-25T14:46:23.000Z","_content":"\n![](http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1. virtualenv install\n\n```bash\nsudo pip install virtualenv \nsudo virtualenv venv\nsource venv/bin/activate \nsudo pip install Flask \n\n\n# sudo python __init__.py\nsudo /var/www/FlaskApp/FlaskApp/venv/bin/python2 __init__.py\n\ndeactivate # exit\n\nWindows环境下安装virtualenv类似\n在pycharm的cmd窗口中，\n执行pip install virtualenv\nvirtualenv env #会生成一个新的ENV文件夹\ncd env /Scripts\nactivate.bat # 此时光标变成(env) >.\n退出很简单deactivate.bat即可\n\n```\n\n\n## 2. install apache2 , mysql-server... on ubuntu\n    重启apache2服务 service apache2 restart\n\n\n\n\n\n### Reference\n1. [how-to-deploy-a-flask-application-on-an-ubuntu-vps](https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-application-on-an-ubuntu-vps)","source":"_posts/2017-06-25-deploying-flask-app-on-linux-server.md","raw":"---\ntitle: 在ubuntu服务器上部署flask web app\ndate: 2017-06-25 22:46:23\ncategories: blog\ntags: [python]\n---\n\n![](http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1. virtualenv install\n\n```bash\nsudo pip install virtualenv \nsudo virtualenv venv\nsource venv/bin/activate \nsudo pip install Flask \n\n\n# sudo python __init__.py\nsudo /var/www/FlaskApp/FlaskApp/venv/bin/python2 __init__.py\n\ndeactivate # exit\n\nWindows环境下安装virtualenv类似\n在pycharm的cmd窗口中，\n执行pip install virtualenv\nvirtualenv env #会生成一个新的ENV文件夹\ncd env /Scripts\nactivate.bat # 此时光标变成(env) >.\n退出很简单deactivate.bat即可\n\n```\n\n\n## 2. install apache2 , mysql-server... on ubuntu\n    重启apache2服务 service apache2 restart\n\n\n\n\n\n### Reference\n1. [how-to-deploy-a-flask-application-on-an-ubuntu-vps](https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-application-on-an-ubuntu-vps)","slug":"2017-06-25-deploying-flask-app-on-linux-server","published":1,"updated":"2017-07-12T00:46:25.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnj70025bovr8z9w2k8y","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"1-virtualenv-install\"><a href=\"#1-virtualenv-install\" class=\"headerlink\" title=\"1. virtualenv install\"></a>1. virtualenv install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install virtualenv </div><div class=\"line\">sudo virtualenv venv</div><div class=\"line\"><span class=\"built_in\">source</span> venv/bin/activate </div><div class=\"line\">sudo pip install Flask </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># sudo python __init__.py</span></div><div class=\"line\">sudo /var/www/FlaskApp/FlaskApp/venv/bin/python2 __init__.py</div><div class=\"line\"></div><div class=\"line\">deactivate <span class=\"comment\"># exit</span></div><div class=\"line\"></div><div class=\"line\">Windows环境下安装virtualenv类似</div><div class=\"line\">在pycharm的cmd窗口中，</div><div class=\"line\">执行pip install virtualenv</div><div class=\"line\">virtualenv env <span class=\"comment\">#会生成一个新的ENV文件夹</span></div><div class=\"line\"><span class=\"built_in\">cd</span> env /Scripts</div><div class=\"line\">activate.bat <span class=\"comment\"># 此时光标变成(env) &gt;.</span></div><div class=\"line\">退出很简单deactivate.bat即可</div></pre></td></tr></table></figure>\n<h2 id=\"2-install-apache2-mysql-server…-on-ubuntu\"><a href=\"#2-install-apache2-mysql-server…-on-ubuntu\" class=\"headerlink\" title=\"2. install apache2 , mysql-server… on ubuntu\"></a>2. install apache2 , mysql-server… on ubuntu</h2><pre><code>重启apache2服务 service apache2 restart\n</code></pre><h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-application-on-an-ubuntu-vps\">how-to-deploy-a-flask-application-on-an-ubuntu-vps</a></li>\n</ol>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/ChMkJ1fAMmKIIFpWAA_5Us41gQkAAUv1QE2Pp8AD_lq599.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<h2 id=\"1-virtualenv-install\"><a href=\"#1-virtualenv-install\" class=\"headerlink\" title=\"1. virtualenv install\"></a>1. virtualenv install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install virtualenv </div><div class=\"line\">sudo virtualenv venv</div><div class=\"line\"><span class=\"built_in\">source</span> venv/bin/activate </div><div class=\"line\">sudo pip install Flask </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># sudo python __init__.py</span></div><div class=\"line\">sudo /var/www/FlaskApp/FlaskApp/venv/bin/python2 __init__.py</div><div class=\"line\"></div><div class=\"line\">deactivate <span class=\"comment\"># exit</span></div><div class=\"line\"></div><div class=\"line\">Windows环境下安装virtualenv类似</div><div class=\"line\">在pycharm的cmd窗口中，</div><div class=\"line\">执行pip install virtualenv</div><div class=\"line\">virtualenv env <span class=\"comment\">#会生成一个新的ENV文件夹</span></div><div class=\"line\"><span class=\"built_in\">cd</span> env /Scripts</div><div class=\"line\">activate.bat <span class=\"comment\"># 此时光标变成(env) &gt;.</span></div><div class=\"line\">退出很简单deactivate.bat即可</div></pre></td></tr></table></figure>\n<h2 id=\"2-install-apache2-mysql-server…-on-ubuntu\"><a href=\"#2-install-apache2-mysql-server…-on-ubuntu\" class=\"headerlink\" title=\"2. install apache2 , mysql-server… on ubuntu\"></a>2. install apache2 , mysql-server… on ubuntu</h2><pre><code>重启apache2服务 service apache2 restart\n</code></pre><h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-application-on-an-ubuntu-vps\">how-to-deploy-a-flask-application-on-an-ubuntu-vps</a></li>\n</ol>"},{"title":"Android手册","date":"2017-07-12T00:40:08.000Z","_content":"\nA Cookbook shall look like a collection of Recipes, or an index page from where dinner are made. And it keeps you sane.\n![](http://odzl05jxx.bkt.clouddn.com/Cg-4zFVJ0xGITwm_AA688WRj8n8AAXZ9wGMpd0ADr0J195.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 各个平台相关的特定的一些记录\n\n### 布局相关的点\n[theme和Style](http://haldir65.github.io/2016/10/10/theme-versus-style/)  **Dan lew**\n\n\n\n### 事件分发，动画，自定义View\n[android使用selectableItemBackground的一些坑](http://haldir65.github.io/2016/09/23/selectableItemBackground-foreground/)\n[activity transition pre and post lollipop](http://haldir65.github.io/2016/09/27/activity-transition-pre-and-post-lollipop/)\n[事件分发流程](http://haldir65.github.io/2016/10/06/touch-event-distribution/)\n[安卓坐标系常用方法](http://haldir65.github.io/2016/10/13/2016-10-13-Android-coordinate-System/)\n[android-Ultra-pull-to-refresh分析](http://haldir65.github.io/2016/10/24/2016-10-24-a-peek-on-pull-to-refresh/)\n\n\n### 内存管理\n[内存泄漏](http://haldir65.github.io/2016/09/18/android-inner-class-leak/)\n\n\n### 任务管理\n[使用Loader进行异步数据操作](http://haldir65.github.io/2016/10/15/2016-10-15-using-loader-in-android-app/)\n\n### V4包里面的东西\n[使用RecyclerView的Animation Android Dev Summit 2015](http://haldir65.github.io/2016/10/20/2016-10-20-RecyclerViewAnimationStuff/)   **yigit boyar和Chet Haase**\n[自定义LayoutManager](http://haldir65.github.io/2016/10/20/2016-10-20-write-your-own-layoutmanager/)  **Dave Smith**\n[Fragment源码解析](http://haldir65.github.io/2017/07/12/2017-07-12-fragment-decoded/)  \n\n\n\n### 底层原理\n[主线程的工作原理](http://haldir65.github.io/2016/10/12/2016-10-12-How-the-mainThread-work/) **Michael Bailey American Express, 他2016年还讲了LayoutInflater的工作原理**\n[vsync原理解释](http://djt.qq.com/article/view/987)\n[让service常驻后台的方法](http://haldir65.github.io/2016/10/20/2016-10-20-android-dirty-code/)\n//下面这些已经有人写的很好了，直接看就可以了\n[应用进程启动流程](http://blog.csdn.net/qq_23547831/article/details/51119333)\n[Launcher启动流程](http://blog.csdn.net/qq_23547831/article/details/51112031)\n[SystemServer进程启动流程](http://blog.csdn.net/qq_23547831/article/details/51105171)\n[Zygote进程启动流程](http://blog.csdn.net/qq_23547831/article/details/51104873)\n[Apk安装流程](http://blog.csdn.net/qq_23547831/article/details/51210682)\n[Activity启动流程](http://blog.csdn.net/qq_23547831/article/details/51224992)\n//这个博主写的一系列底层分析都比较清楚\n\n### 新版本适配，新特性\n[Android 7.0的适配](http://haldir65.github.io/2016/10/08/android-7-0-new-features/)\n\n### 工具方法\n[沉浸式状态栏](http://haldir65.github.io/2016/10/14/2016-10-14-Android-translucent-status-bar/)\n[replace butterKnife with databinding](http://haldir65.github.io/2016/09/22/replace-butterKnife-with-databinding/)\n\n\n\n\n## 跟java相关的\n[java集合类的实现原理](http://haldir65.github.io/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/)\n[Rxjava2的一些点](http://haldir65.github.io/2017/04/23/2017-04-23-rxjava2-for-android/) **Jake Wharton**\n[Java线程池的一些点](http://haldir65.github.io/2017/04/30/2017-04-30-concurrency-and-beyond/)\n[Retrofit源码解析](http://haldir65.github.io/2017/07/01/2017-07-01-it-began-with-a-few-bits/)\n[OkHttp和Okio源码解析](http://haldir65.github.io/2017/07/21/2017-07-21-okhttp-demisified/)\n[使用AnnotationProcessor自动生成代码](http://haldir65.github.io/2016/12/31/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor/)\n[翻译了一个印度口音的关于jvm架构的视频](http://haldir65.github.io/2017/05/24/2017-05-24-jvm-architecture/)\n\n\n\n## 工具书\n[git常用操作手册](http://haldir65.github.io/2016/09/27/git-manual/)\n[adb常用命令手册](http://haldir65.github.io/2016/12/10/2016-12-10-adb-command/)\n\n## 杂乱的点\n[java中的任何细碎的点](http://haldir65.github.io/2017/06/17/2017-06-17-tiny-details-in-java/)\n\n\n## ToDo List\nJava相关\n- [X] 画一下java的集合框架\n- [X] 基于Okio展开到OkHttp,Retrofit。\n- [X] String StringBuffer StringBuilder区别(StringBuffer很多方法都加了synchronized)\n- [ ] 一个Java Object到底占用多少内存(from java code to java heap)\n- [ ] java位运算，Collection框架中多次用到了\n- [ ] gson的原理，cache什么的，常规json解析器的原理\n- [ ] 垃圾回收器的分类及优缺点\n- [ ] ThreadLocal原理及可能的内存泄漏\n- [ ] LruCache的原理\n- [ ] Understanding Dagger2's generated code\n- [ ] HashMap和conrrentHashmap区别(分段锁)\n- [ ] 单例模式需要考虑到jvm优化的问题（为什么要写两个synchronized）\n- [ ] java类加载机制(classLoader相关的，类的加载顺序)\n- [ ] Java四种引用\n- [ ] java堆和栈的区别，如何判断堆栈上的对象死没死\n- [ ] 自己写一个一部图片加载框架，并发图像滤镜框架\n- [ ] 多线程异步断点续传框架原理,利用该原理在图片加载框架中的应用(MappedByteBuffer或者RandomAccessFile)\n- [ ] try catch finally到底会不会执行\n- [ ] 并发编程，java.util.concurrent里面的类熟练掌握，粗略了解原理\n\n\nAndroid相关\n- [X] Fragment源码解析\n- [X] Glide源码解析（写出来）\n- [ ] AppCompat源码解析\n- [ ] ContentProvider的启动过程\n- [ ] IPC，Binder原理\n- [ ] cookie存储位置(/webviewCookiesChromium.db),db存储位置\n- [ ] Binder的原理，Binder里面引用计数的原理，Binder底层为什么用红黑树\n- [ ] onSaveInstance,不仅仅是Activity,Fragment，View中也有，具体实现原理。View一定要有id\n- [ ] 热修复框架原理\n- [ ] WebView JS交互，WebView存在的[漏洞](http://www.jianshu.com/p/9f7e9ab8d2fa),通过反射可看可能存在的[安全问题](https://my.oschina.net/fengheju/blog/673629)以及[C代码](http://blog.csdn.net/xueerfei008/article/details/26750659)\n- [ ] Media相关，视频播放etc，相机，滤镜等.[Demo](https://github.com/w1123440793/VideoListDemo)\n- [ ] UI Toolkit源码解析\n    - [ ] ViewPager的原理\n    - [ ] ViewGroup，View的源码\n    - [ ] View的绘制原理\n    - [ ] ListView,RecyclerView原理,加载优化(prefetcher什么的，滑动过程中不去加载图片,我记得Glide是没有做这件事的)\n- [ ] Zygote进程启动流程\n- [ ] SystemServer进程启动流程\n- [ ] Launcher启动流程\n\n\nLinux相关\n- [ ] linux进程间通信方式有哪些（信号量这种）\n- [ ] Linux command extended\n\n网络通信\n- [ ] TCP UDP的不同 TCP三次握手，wireShark抓包,抓一个App的包，模拟请求\n- [ ] 如何维持一个长连接\n- [ ] 多线程断点续传原理，大文件下载oom问题\n- [ ] 点击一个网址底层经历哪些过程\n- [X] 一个url分为哪些组成部分,host,segment,fragment,etc\n\n\n\n数据库相关\n- [ ] MySql从入门到删库跑路\n- [ ] Realm的优点\n\n\n数据结构，算法\n- [ ] 数据结构，操作系统\n- [ ] 编码，底层二进制\n- [ ] 二分法查找，排序，冒泡，复杂度\n- [ ] 数组跟链表区别,数组跟链表排序时区别,数组跟链表排序时区别\n\n\n\n\n\n\n## 一些需要看的演讲\n[Droidcon Montreal Jake Wharton - A Few Ok Libraries](https://www.youtube.com/watch?v=WvyScM_S88c)\n[Advanced Scrolling Techniques on Android](https://www.youtube.com/watch?v=N3J4ZFiR_3Q)\n\n## 一些有名的人\n[GDE](https://developers.google.com/experts/all/technology/android)\nDianne Hackborn\n[Jesse Wilson](https://github.com/swankjesse)\n","source":"_posts/2017-07-12-android-cookbook.md","raw":"---\ntitle: Android手册\ndate: 2017-07-12 08:40:08\ntags: [android]\n---\n\nA Cookbook shall look like a collection of Recipes, or an index page from where dinner are made. And it keeps you sane.\n![](http://odzl05jxx.bkt.clouddn.com/Cg-4zFVJ0xGITwm_AA688WRj8n8AAXZ9wGMpd0ADr0J195.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 各个平台相关的特定的一些记录\n\n### 布局相关的点\n[theme和Style](http://haldir65.github.io/2016/10/10/theme-versus-style/)  **Dan lew**\n\n\n\n### 事件分发，动画，自定义View\n[android使用selectableItemBackground的一些坑](http://haldir65.github.io/2016/09/23/selectableItemBackground-foreground/)\n[activity transition pre and post lollipop](http://haldir65.github.io/2016/09/27/activity-transition-pre-and-post-lollipop/)\n[事件分发流程](http://haldir65.github.io/2016/10/06/touch-event-distribution/)\n[安卓坐标系常用方法](http://haldir65.github.io/2016/10/13/2016-10-13-Android-coordinate-System/)\n[android-Ultra-pull-to-refresh分析](http://haldir65.github.io/2016/10/24/2016-10-24-a-peek-on-pull-to-refresh/)\n\n\n### 内存管理\n[内存泄漏](http://haldir65.github.io/2016/09/18/android-inner-class-leak/)\n\n\n### 任务管理\n[使用Loader进行异步数据操作](http://haldir65.github.io/2016/10/15/2016-10-15-using-loader-in-android-app/)\n\n### V4包里面的东西\n[使用RecyclerView的Animation Android Dev Summit 2015](http://haldir65.github.io/2016/10/20/2016-10-20-RecyclerViewAnimationStuff/)   **yigit boyar和Chet Haase**\n[自定义LayoutManager](http://haldir65.github.io/2016/10/20/2016-10-20-write-your-own-layoutmanager/)  **Dave Smith**\n[Fragment源码解析](http://haldir65.github.io/2017/07/12/2017-07-12-fragment-decoded/)  \n\n\n\n### 底层原理\n[主线程的工作原理](http://haldir65.github.io/2016/10/12/2016-10-12-How-the-mainThread-work/) **Michael Bailey American Express, 他2016年还讲了LayoutInflater的工作原理**\n[vsync原理解释](http://djt.qq.com/article/view/987)\n[让service常驻后台的方法](http://haldir65.github.io/2016/10/20/2016-10-20-android-dirty-code/)\n//下面这些已经有人写的很好了，直接看就可以了\n[应用进程启动流程](http://blog.csdn.net/qq_23547831/article/details/51119333)\n[Launcher启动流程](http://blog.csdn.net/qq_23547831/article/details/51112031)\n[SystemServer进程启动流程](http://blog.csdn.net/qq_23547831/article/details/51105171)\n[Zygote进程启动流程](http://blog.csdn.net/qq_23547831/article/details/51104873)\n[Apk安装流程](http://blog.csdn.net/qq_23547831/article/details/51210682)\n[Activity启动流程](http://blog.csdn.net/qq_23547831/article/details/51224992)\n//这个博主写的一系列底层分析都比较清楚\n\n### 新版本适配，新特性\n[Android 7.0的适配](http://haldir65.github.io/2016/10/08/android-7-0-new-features/)\n\n### 工具方法\n[沉浸式状态栏](http://haldir65.github.io/2016/10/14/2016-10-14-Android-translucent-status-bar/)\n[replace butterKnife with databinding](http://haldir65.github.io/2016/09/22/replace-butterKnife-with-databinding/)\n\n\n\n\n## 跟java相关的\n[java集合类的实现原理](http://haldir65.github.io/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/)\n[Rxjava2的一些点](http://haldir65.github.io/2017/04/23/2017-04-23-rxjava2-for-android/) **Jake Wharton**\n[Java线程池的一些点](http://haldir65.github.io/2017/04/30/2017-04-30-concurrency-and-beyond/)\n[Retrofit源码解析](http://haldir65.github.io/2017/07/01/2017-07-01-it-began-with-a-few-bits/)\n[OkHttp和Okio源码解析](http://haldir65.github.io/2017/07/21/2017-07-21-okhttp-demisified/)\n[使用AnnotationProcessor自动生成代码](http://haldir65.github.io/2016/12/31/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor/)\n[翻译了一个印度口音的关于jvm架构的视频](http://haldir65.github.io/2017/05/24/2017-05-24-jvm-architecture/)\n\n\n\n## 工具书\n[git常用操作手册](http://haldir65.github.io/2016/09/27/git-manual/)\n[adb常用命令手册](http://haldir65.github.io/2016/12/10/2016-12-10-adb-command/)\n\n## 杂乱的点\n[java中的任何细碎的点](http://haldir65.github.io/2017/06/17/2017-06-17-tiny-details-in-java/)\n\n\n## ToDo List\nJava相关\n- [X] 画一下java的集合框架\n- [X] 基于Okio展开到OkHttp,Retrofit。\n- [X] String StringBuffer StringBuilder区别(StringBuffer很多方法都加了synchronized)\n- [ ] 一个Java Object到底占用多少内存(from java code to java heap)\n- [ ] java位运算，Collection框架中多次用到了\n- [ ] gson的原理，cache什么的，常规json解析器的原理\n- [ ] 垃圾回收器的分类及优缺点\n- [ ] ThreadLocal原理及可能的内存泄漏\n- [ ] LruCache的原理\n- [ ] Understanding Dagger2's generated code\n- [ ] HashMap和conrrentHashmap区别(分段锁)\n- [ ] 单例模式需要考虑到jvm优化的问题（为什么要写两个synchronized）\n- [ ] java类加载机制(classLoader相关的，类的加载顺序)\n- [ ] Java四种引用\n- [ ] java堆和栈的区别，如何判断堆栈上的对象死没死\n- [ ] 自己写一个一部图片加载框架，并发图像滤镜框架\n- [ ] 多线程异步断点续传框架原理,利用该原理在图片加载框架中的应用(MappedByteBuffer或者RandomAccessFile)\n- [ ] try catch finally到底会不会执行\n- [ ] 并发编程，java.util.concurrent里面的类熟练掌握，粗略了解原理\n\n\nAndroid相关\n- [X] Fragment源码解析\n- [X] Glide源码解析（写出来）\n- [ ] AppCompat源码解析\n- [ ] ContentProvider的启动过程\n- [ ] IPC，Binder原理\n- [ ] cookie存储位置(/webviewCookiesChromium.db),db存储位置\n- [ ] Binder的原理，Binder里面引用计数的原理，Binder底层为什么用红黑树\n- [ ] onSaveInstance,不仅仅是Activity,Fragment，View中也有，具体实现原理。View一定要有id\n- [ ] 热修复框架原理\n- [ ] WebView JS交互，WebView存在的[漏洞](http://www.jianshu.com/p/9f7e9ab8d2fa),通过反射可看可能存在的[安全问题](https://my.oschina.net/fengheju/blog/673629)以及[C代码](http://blog.csdn.net/xueerfei008/article/details/26750659)\n- [ ] Media相关，视频播放etc，相机，滤镜等.[Demo](https://github.com/w1123440793/VideoListDemo)\n- [ ] UI Toolkit源码解析\n    - [ ] ViewPager的原理\n    - [ ] ViewGroup，View的源码\n    - [ ] View的绘制原理\n    - [ ] ListView,RecyclerView原理,加载优化(prefetcher什么的，滑动过程中不去加载图片,我记得Glide是没有做这件事的)\n- [ ] Zygote进程启动流程\n- [ ] SystemServer进程启动流程\n- [ ] Launcher启动流程\n\n\nLinux相关\n- [ ] linux进程间通信方式有哪些（信号量这种）\n- [ ] Linux command extended\n\n网络通信\n- [ ] TCP UDP的不同 TCP三次握手，wireShark抓包,抓一个App的包，模拟请求\n- [ ] 如何维持一个长连接\n- [ ] 多线程断点续传原理，大文件下载oom问题\n- [ ] 点击一个网址底层经历哪些过程\n- [X] 一个url分为哪些组成部分,host,segment,fragment,etc\n\n\n\n数据库相关\n- [ ] MySql从入门到删库跑路\n- [ ] Realm的优点\n\n\n数据结构，算法\n- [ ] 数据结构，操作系统\n- [ ] 编码，底层二进制\n- [ ] 二分法查找，排序，冒泡，复杂度\n- [ ] 数组跟链表区别,数组跟链表排序时区别,数组跟链表排序时区别\n\n\n\n\n\n\n## 一些需要看的演讲\n[Droidcon Montreal Jake Wharton - A Few Ok Libraries](https://www.youtube.com/watch?v=WvyScM_S88c)\n[Advanced Scrolling Techniques on Android](https://www.youtube.com/watch?v=N3J4ZFiR_3Q)\n\n## 一些有名的人\n[GDE](https://developers.google.com/experts/all/technology/android)\nDianne Hackborn\n[Jesse Wilson](https://github.com/swankjesse)\n","slug":"2017-07-12-android-cookbook","published":1,"updated":"2017-07-23T11:01:22.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnje0028bovrtvlmibzo","content":"<p>A Cookbook shall look like a collection of Recipes, or an index page from where dinner are made. And it keeps you sane.<br><img src=\"http://odzl05jxx.bkt.clouddn.com/Cg-4zFVJ0xGITwm_AA688WRj8n8AAXZ9wGMpd0ADr0J195.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"各个平台相关的特定的一些记录\"><a href=\"#各个平台相关的特定的一些记录\" class=\"headerlink\" title=\"各个平台相关的特定的一些记录\"></a>各个平台相关的特定的一些记录</h2><h3 id=\"布局相关的点\"><a href=\"#布局相关的点\" class=\"headerlink\" title=\"布局相关的点\"></a>布局相关的点</h3><p><a href=\"http://haldir65.github.io/2016/10/10/theme-versus-style/\">theme和Style</a>  <strong>Dan lew</strong></p>\n<h3 id=\"事件分发，动画，自定义View\"><a href=\"#事件分发，动画，自定义View\" class=\"headerlink\" title=\"事件分发，动画，自定义View\"></a>事件分发，动画，自定义View</h3><p><a href=\"http://haldir65.github.io/2016/09/23/selectableItemBackground-foreground/\">android使用selectableItemBackground的一些坑</a><br><a href=\"http://haldir65.github.io/2016/09/27/activity-transition-pre-and-post-lollipop/\">activity transition pre and post lollipop</a><br><a href=\"http://haldir65.github.io/2016/10/06/touch-event-distribution/\">事件分发流程</a><br><a href=\"http://haldir65.github.io/2016/10/13/2016-10-13-Android-coordinate-System/\">安卓坐标系常用方法</a><br><a href=\"http://haldir65.github.io/2016/10/24/2016-10-24-a-peek-on-pull-to-refresh/\">android-Ultra-pull-to-refresh分析</a></p>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><p><a href=\"http://haldir65.github.io/2016/09/18/android-inner-class-leak/\">内存泄漏</a></p>\n<h3 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h3><p><a href=\"http://haldir65.github.io/2016/10/15/2016-10-15-using-loader-in-android-app/\">使用Loader进行异步数据操作</a></p>\n<h3 id=\"V4包里面的东西\"><a href=\"#V4包里面的东西\" class=\"headerlink\" title=\"V4包里面的东西\"></a>V4包里面的东西</h3><p><a href=\"http://haldir65.github.io/2016/10/20/2016-10-20-RecyclerViewAnimationStuff/\">使用RecyclerView的Animation Android Dev Summit 2015</a>   <strong>yigit boyar和Chet Haase</strong><br><a href=\"http://haldir65.github.io/2016/10/20/2016-10-20-write-your-own-layoutmanager/\">自定义LayoutManager</a>  <strong>Dave Smith</strong><br><a href=\"http://haldir65.github.io/2017/07/12/2017-07-12-fragment-decoded/\">Fragment源码解析</a>  </p>\n<h3 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h3><p><a href=\"http://haldir65.github.io/2016/10/12/2016-10-12-How-the-mainThread-work/\">主线程的工作原理</a> <strong>Michael Bailey American Express, 他2016年还讲了LayoutInflater的工作原理</strong><br><a href=\"http://djt.qq.com/article/view/987\">vsync原理解释</a><br><a href=\"http://haldir65.github.io/2016/10/20/2016-10-20-android-dirty-code/\">让service常驻后台的方法</a><br>//下面这些已经有人写的很好了，直接看就可以了<br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51119333\">应用进程启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51112031\">Launcher启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51105171\">SystemServer进程启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51104873\">Zygote进程启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51210682\">Apk安装流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51224992\">Activity启动流程</a><br>//这个博主写的一系列底层分析都比较清楚</p>\n<h3 id=\"新版本适配，新特性\"><a href=\"#新版本适配，新特性\" class=\"headerlink\" title=\"新版本适配，新特性\"></a>新版本适配，新特性</h3><p><a href=\"http://haldir65.github.io/2016/10/08/android-7-0-new-features/\">Android 7.0的适配</a></p>\n<h3 id=\"工具方法\"><a href=\"#工具方法\" class=\"headerlink\" title=\"工具方法\"></a>工具方法</h3><p><a href=\"http://haldir65.github.io/2016/10/14/2016-10-14-Android-translucent-status-bar/\">沉浸式状态栏</a><br><a href=\"http://haldir65.github.io/2016/09/22/replace-butterKnife-with-databinding/\">replace butterKnife with databinding</a></p>\n<h2 id=\"跟java相关的\"><a href=\"#跟java相关的\" class=\"headerlink\" title=\"跟java相关的\"></a>跟java相关的</h2><p><a href=\"http://haldir65.github.io/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/\">java集合类的实现原理</a><br><a href=\"http://haldir65.github.io/2017/04/23/2017-04-23-rxjava2-for-android/\">Rxjava2的一些点</a> <strong>Jake Wharton</strong><br><a href=\"http://haldir65.github.io/2017/04/30/2017-04-30-concurrency-and-beyond/\">Java线程池的一些点</a><br><a href=\"http://haldir65.github.io/2017/07/01/2017-07-01-it-began-with-a-few-bits/\">Retrofit源码解析</a><br><a href=\"http://haldir65.github.io/2017/07/21/2017-07-21-okhttp-demisified/\">OkHttp和Okio源码解析</a><br><a href=\"http://haldir65.github.io/2016/12/31/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor/\">使用AnnotationProcessor自动生成代码</a><br><a href=\"http://haldir65.github.io/2017/05/24/2017-05-24-jvm-architecture/\">翻译了一个印度口音的关于jvm架构的视频</a></p>\n<h2 id=\"工具书\"><a href=\"#工具书\" class=\"headerlink\" title=\"工具书\"></a>工具书</h2><p><a href=\"http://haldir65.github.io/2016/09/27/git-manual/\">git常用操作手册</a><br><a href=\"http://haldir65.github.io/2016/12/10/2016-12-10-adb-command/\">adb常用命令手册</a></p>\n<h2 id=\"杂乱的点\"><a href=\"#杂乱的点\" class=\"headerlink\" title=\"杂乱的点\"></a>杂乱的点</h2><p><a href=\"http://haldir65.github.io/2017/06/17/2017-06-17-tiny-details-in-java/\">java中的任何细碎的点</a></p>\n<h2 id=\"ToDo-List\"><a href=\"#ToDo-List\" class=\"headerlink\" title=\"ToDo List\"></a>ToDo List</h2><p>Java相关</p>\n<ul>\n<li>[X] 画一下java的集合框架</li>\n<li>[X] 基于Okio展开到OkHttp,Retrofit。</li>\n<li>[X] String StringBuffer StringBuilder区别(StringBuffer很多方法都加了synchronized)</li>\n<li>[ ] 一个Java Object到底占用多少内存(from java code to java heap)</li>\n<li>[ ] java位运算，Collection框架中多次用到了</li>\n<li>[ ] gson的原理，cache什么的，常规json解析器的原理</li>\n<li>[ ] 垃圾回收器的分类及优缺点</li>\n<li>[ ] ThreadLocal原理及可能的内存泄漏</li>\n<li>[ ] LruCache的原理</li>\n<li>[ ] Understanding Dagger2’s generated code</li>\n<li>[ ] HashMap和conrrentHashmap区别(分段锁)</li>\n<li>[ ] 单例模式需要考虑到jvm优化的问题（为什么要写两个synchronized）</li>\n<li>[ ] java类加载机制(classLoader相关的，类的加载顺序)</li>\n<li>[ ] Java四种引用</li>\n<li>[ ] java堆和栈的区别，如何判断堆栈上的对象死没死</li>\n<li>[ ] 自己写一个一部图片加载框架，并发图像滤镜框架</li>\n<li>[ ] 多线程异步断点续传框架原理,利用该原理在图片加载框架中的应用(MappedByteBuffer或者RandomAccessFile)</li>\n<li>[ ] try catch finally到底会不会执行</li>\n<li>[ ] 并发编程，java.util.concurrent里面的类熟练掌握，粗略了解原理</li>\n</ul>\n<p>Android相关</p>\n<ul>\n<li>[X] Fragment源码解析</li>\n<li>[X] Glide源码解析（写出来）</li>\n<li>[ ] AppCompat源码解析</li>\n<li>[ ] ContentProvider的启动过程</li>\n<li>[ ] IPC，Binder原理</li>\n<li>[ ] cookie存储位置(/webviewCookiesChromium.db),db存储位置</li>\n<li>[ ] Binder的原理，Binder里面引用计数的原理，Binder底层为什么用红黑树</li>\n<li>[ ] onSaveInstance,不仅仅是Activity,Fragment，View中也有，具体实现原理。View一定要有id</li>\n<li>[ ] 热修复框架原理</li>\n<li>[ ] WebView JS交互，WebView存在的<a href=\"http://www.jianshu.com/p/9f7e9ab8d2fa\">漏洞</a>,通过反射可看可能存在的<a href=\"https://my.oschina.net/fengheju/blog/673629\">安全问题</a>以及<a href=\"http://blog.csdn.net/xueerfei008/article/details/26750659\">C代码</a></li>\n<li>[ ] Media相关，视频播放etc，相机，滤镜等.<a href=\"https://github.com/w1123440793/VideoListDemo\">Demo</a></li>\n<li>[ ] UI Toolkit源码解析<ul>\n<li>[ ] ViewPager的原理</li>\n<li>[ ] ViewGroup，View的源码</li>\n<li>[ ] View的绘制原理</li>\n<li>[ ] ListView,RecyclerView原理,加载优化(prefetcher什么的，滑动过程中不去加载图片,我记得Glide是没有做这件事的)</li>\n</ul>\n</li>\n<li>[ ] Zygote进程启动流程</li>\n<li>[ ] SystemServer进程启动流程</li>\n<li>[ ] Launcher启动流程</li>\n</ul>\n<p>Linux相关</p>\n<ul>\n<li>[ ] linux进程间通信方式有哪些（信号量这种）</li>\n<li>[ ] Linux command extended</li>\n</ul>\n<p>网络通信</p>\n<ul>\n<li>[ ] TCP UDP的不同 TCP三次握手，wireShark抓包,抓一个App的包，模拟请求</li>\n<li>[ ] 如何维持一个长连接</li>\n<li>[ ] 多线程断点续传原理，大文件下载oom问题</li>\n<li>[ ] 点击一个网址底层经历哪些过程</li>\n<li>[X] 一个url分为哪些组成部分,host,segment,fragment,etc</li>\n</ul>\n<p>数据库相关</p>\n<ul>\n<li>[ ] MySql从入门到删库跑路</li>\n<li>[ ] Realm的优点</li>\n</ul>\n<p>数据结构，算法</p>\n<ul>\n<li>[ ] 数据结构，操作系统</li>\n<li>[ ] 编码，底层二进制</li>\n<li>[ ] 二分法查找，排序，冒泡，复杂度</li>\n<li>[ ] 数组跟链表区别,数组跟链表排序时区别,数组跟链表排序时区别</li>\n</ul>\n<h2 id=\"一些需要看的演讲\"><a href=\"#一些需要看的演讲\" class=\"headerlink\" title=\"一些需要看的演讲\"></a>一些需要看的演讲</h2><p><a href=\"https://www.youtube.com/watch?v=WvyScM_S88c\">Droidcon Montreal Jake Wharton - A Few Ok Libraries</a><br><a href=\"https://www.youtube.com/watch?v=N3J4ZFiR_3Q\">Advanced Scrolling Techniques on Android</a></p>\n<h2 id=\"一些有名的人\"><a href=\"#一些有名的人\" class=\"headerlink\" title=\"一些有名的人\"></a>一些有名的人</h2><p><a href=\"https://developers.google.com/experts/all/technology/android\">GDE</a><br>Dianne Hackborn<br><a href=\"https://github.com/swankjesse\">Jesse Wilson</a></p>\n","excerpt":"<p>A Cookbook shall look like a collection of Recipes, or an index page from where dinner are made. And it keeps you sane.<br><img src=\"http://odzl05jxx.bkt.clouddn.com/Cg-4zFVJ0xGITwm_AA688WRj8n8AAXZ9wGMpd0ADr0J195.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<h2 id=\"各个平台相关的特定的一些记录\"><a href=\"#各个平台相关的特定的一些记录\" class=\"headerlink\" title=\"各个平台相关的特定的一些记录\"></a>各个平台相关的特定的一些记录</h2><h3 id=\"布局相关的点\"><a href=\"#布局相关的点\" class=\"headerlink\" title=\"布局相关的点\"></a>布局相关的点</h3><p><a href=\"http://haldir65.github.io/2016/10/10/theme-versus-style/\">theme和Style</a>  <strong>Dan lew</strong></p>\n<h3 id=\"事件分发，动画，自定义View\"><a href=\"#事件分发，动画，自定义View\" class=\"headerlink\" title=\"事件分发，动画，自定义View\"></a>事件分发，动画，自定义View</h3><p><a href=\"http://haldir65.github.io/2016/09/23/selectableItemBackground-foreground/\">android使用selectableItemBackground的一些坑</a><br><a href=\"http://haldir65.github.io/2016/09/27/activity-transition-pre-and-post-lollipop/\">activity transition pre and post lollipop</a><br><a href=\"http://haldir65.github.io/2016/10/06/touch-event-distribution/\">事件分发流程</a><br><a href=\"http://haldir65.github.io/2016/10/13/2016-10-13-Android-coordinate-System/\">安卓坐标系常用方法</a><br><a href=\"http://haldir65.github.io/2016/10/24/2016-10-24-a-peek-on-pull-to-refresh/\">android-Ultra-pull-to-refresh分析</a></p>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><p><a href=\"http://haldir65.github.io/2016/09/18/android-inner-class-leak/\">内存泄漏</a></p>\n<h3 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h3><p><a href=\"http://haldir65.github.io/2016/10/15/2016-10-15-using-loader-in-android-app/\">使用Loader进行异步数据操作</a></p>\n<h3 id=\"V4包里面的东西\"><a href=\"#V4包里面的东西\" class=\"headerlink\" title=\"V4包里面的东西\"></a>V4包里面的东西</h3><p><a href=\"http://haldir65.github.io/2016/10/20/2016-10-20-RecyclerViewAnimationStuff/\">使用RecyclerView的Animation Android Dev Summit 2015</a>   <strong>yigit boyar和Chet Haase</strong><br><a href=\"http://haldir65.github.io/2016/10/20/2016-10-20-write-your-own-layoutmanager/\">自定义LayoutManager</a>  <strong>Dave Smith</strong><br><a href=\"http://haldir65.github.io/2017/07/12/2017-07-12-fragment-decoded/\">Fragment源码解析</a>  </p>\n<h3 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h3><p><a href=\"http://haldir65.github.io/2016/10/12/2016-10-12-How-the-mainThread-work/\">主线程的工作原理</a> <strong>Michael Bailey American Express, 他2016年还讲了LayoutInflater的工作原理</strong><br><a href=\"http://djt.qq.com/article/view/987\">vsync原理解释</a><br><a href=\"http://haldir65.github.io/2016/10/20/2016-10-20-android-dirty-code/\">让service常驻后台的方法</a><br>//下面这些已经有人写的很好了，直接看就可以了<br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51119333\">应用进程启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51112031\">Launcher启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51105171\">SystemServer进程启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51104873\">Zygote进程启动流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51210682\">Apk安装流程</a><br><a href=\"http://blog.csdn.net/qq_23547831/article/details/51224992\">Activity启动流程</a><br>//这个博主写的一系列底层分析都比较清楚</p>\n<h3 id=\"新版本适配，新特性\"><a href=\"#新版本适配，新特性\" class=\"headerlink\" title=\"新版本适配，新特性\"></a>新版本适配，新特性</h3><p><a href=\"http://haldir65.github.io/2016/10/08/android-7-0-new-features/\">Android 7.0的适配</a></p>\n<h3 id=\"工具方法\"><a href=\"#工具方法\" class=\"headerlink\" title=\"工具方法\"></a>工具方法</h3><p><a href=\"http://haldir65.github.io/2016/10/14/2016-10-14-Android-translucent-status-bar/\">沉浸式状态栏</a><br><a href=\"http://haldir65.github.io/2016/09/22/replace-butterKnife-with-databinding/\">replace butterKnife with databinding</a></p>\n<h2 id=\"跟java相关的\"><a href=\"#跟java相关的\" class=\"headerlink\" title=\"跟java相关的\"></a>跟java相关的</h2><p><a href=\"http://haldir65.github.io/2017/06/25/2017-06-12-Collections-Refuled-by-Stuart-Marks/\">java集合类的实现原理</a><br><a href=\"http://haldir65.github.io/2017/04/23/2017-04-23-rxjava2-for-android/\">Rxjava2的一些点</a> <strong>Jake Wharton</strong><br><a href=\"http://haldir65.github.io/2017/04/30/2017-04-30-concurrency-and-beyond/\">Java线程池的一些点</a><br><a href=\"http://haldir65.github.io/2017/07/01/2017-07-01-it-began-with-a-few-bits/\">Retrofit源码解析</a><br><a href=\"http://haldir65.github.io/2017/07/21/2017-07-21-okhttp-demisified/\">OkHttp和Okio源码解析</a><br><a href=\"http://haldir65.github.io/2016/12/31/2016-12-31-Eliminating-BoilPlate-AnnotationProcessor/\">使用AnnotationProcessor自动生成代码</a><br><a href=\"http://haldir65.github.io/2017/05/24/2017-05-24-jvm-architecture/\">翻译了一个印度口音的关于jvm架构的视频</a></p>\n<h2 id=\"工具书\"><a href=\"#工具书\" class=\"headerlink\" title=\"工具书\"></a>工具书</h2><p><a href=\"http://haldir65.github.io/2016/09/27/git-manual/\">git常用操作手册</a><br><a href=\"http://haldir65.github.io/2016/12/10/2016-12-10-adb-command/\">adb常用命令手册</a></p>\n<h2 id=\"杂乱的点\"><a href=\"#杂乱的点\" class=\"headerlink\" title=\"杂乱的点\"></a>杂乱的点</h2><p><a href=\"http://haldir65.github.io/2017/06/17/2017-06-17-tiny-details-in-java/\">java中的任何细碎的点</a></p>\n<h2 id=\"ToDo-List\"><a href=\"#ToDo-List\" class=\"headerlink\" title=\"ToDo List\"></a>ToDo List</h2><p>Java相关</p>\n<ul>\n<li>[X] 画一下java的集合框架</li>\n<li>[X] 基于Okio展开到OkHttp,Retrofit。</li>\n<li>[X] String StringBuffer StringBuilder区别(StringBuffer很多方法都加了synchronized)</li>\n<li>[ ] 一个Java Object到底占用多少内存(from java code to java heap)</li>\n<li>[ ] java位运算，Collection框架中多次用到了</li>\n<li>[ ] gson的原理，cache什么的，常规json解析器的原理</li>\n<li>[ ] 垃圾回收器的分类及优缺点</li>\n<li>[ ] ThreadLocal原理及可能的内存泄漏</li>\n<li>[ ] LruCache的原理</li>\n<li>[ ] Understanding Dagger2’s generated code</li>\n<li>[ ] HashMap和conrrentHashmap区别(分段锁)</li>\n<li>[ ] 单例模式需要考虑到jvm优化的问题（为什么要写两个synchronized）</li>\n<li>[ ] java类加载机制(classLoader相关的，类的加载顺序)</li>\n<li>[ ] Java四种引用</li>\n<li>[ ] java堆和栈的区别，如何判断堆栈上的对象死没死</li>\n<li>[ ] 自己写一个一部图片加载框架，并发图像滤镜框架</li>\n<li>[ ] 多线程异步断点续传框架原理,利用该原理在图片加载框架中的应用(MappedByteBuffer或者RandomAccessFile)</li>\n<li>[ ] try catch finally到底会不会执行</li>\n<li>[ ] 并发编程，java.util.concurrent里面的类熟练掌握，粗略了解原理</li>\n</ul>\n<p>Android相关</p>\n<ul>\n<li>[X] Fragment源码解析</li>\n<li>[X] Glide源码解析（写出来）</li>\n<li>[ ] AppCompat源码解析</li>\n<li>[ ] ContentProvider的启动过程</li>\n<li>[ ] IPC，Binder原理</li>\n<li>[ ] cookie存储位置(/webviewCookiesChromium.db),db存储位置</li>\n<li>[ ] Binder的原理，Binder里面引用计数的原理，Binder底层为什么用红黑树</li>\n<li>[ ] onSaveInstance,不仅仅是Activity,Fragment，View中也有，具体实现原理。View一定要有id</li>\n<li>[ ] 热修复框架原理</li>\n<li>[ ] WebView JS交互，WebView存在的<a href=\"http://www.jianshu.com/p/9f7e9ab8d2fa\">漏洞</a>,通过反射可看可能存在的<a href=\"https://my.oschina.net/fengheju/blog/673629\">安全问题</a>以及<a href=\"http://blog.csdn.net/xueerfei008/article/details/26750659\">C代码</a></li>\n<li>[ ] Media相关，视频播放etc，相机，滤镜等.<a href=\"https://github.com/w1123440793/VideoListDemo\">Demo</a></li>\n<li>[ ] UI Toolkit源码解析<ul>\n<li>[ ] ViewPager的原理</li>\n<li>[ ] ViewGroup，View的源码</li>\n<li>[ ] View的绘制原理</li>\n<li>[ ] ListView,RecyclerView原理,加载优化(prefetcher什么的，滑动过程中不去加载图片,我记得Glide是没有做这件事的)</li>\n</ul>\n</li>\n<li>[ ] Zygote进程启动流程</li>\n<li>[ ] SystemServer进程启动流程</li>\n<li>[ ] Launcher启动流程</li>\n</ul>\n<p>Linux相关</p>\n<ul>\n<li>[ ] linux进程间通信方式有哪些（信号量这种）</li>\n<li>[ ] Linux command extended</li>\n</ul>\n<p>网络通信</p>\n<ul>\n<li>[ ] TCP UDP的不同 TCP三次握手，wireShark抓包,抓一个App的包，模拟请求</li>\n<li>[ ] 如何维持一个长连接</li>\n<li>[ ] 多线程断点续传原理，大文件下载oom问题</li>\n<li>[ ] 点击一个网址底层经历哪些过程</li>\n<li>[X] 一个url分为哪些组成部分,host,segment,fragment,etc</li>\n</ul>\n<p>数据库相关</p>\n<ul>\n<li>[ ] MySql从入门到删库跑路</li>\n<li>[ ] Realm的优点</li>\n</ul>\n<p>数据结构，算法</p>\n<ul>\n<li>[ ] 数据结构，操作系统</li>\n<li>[ ] 编码，底层二进制</li>\n<li>[ ] 二分法查找，排序，冒泡，复杂度</li>\n<li>[ ] 数组跟链表区别,数组跟链表排序时区别,数组跟链表排序时区别</li>\n</ul>\n<h2 id=\"一些需要看的演讲\"><a href=\"#一些需要看的演讲\" class=\"headerlink\" title=\"一些需要看的演讲\"></a>一些需要看的演讲</h2><p><a href=\"https://www.youtube.com/watch?v=WvyScM_S88c\">Droidcon Montreal Jake Wharton - A Few Ok Libraries</a><br><a href=\"https://www.youtube.com/watch?v=N3J4ZFiR_3Q\">Advanced Scrolling Techniques on Android</a></p>\n<h2 id=\"一些有名的人\"><a href=\"#一些有名的人\" class=\"headerlink\" title=\"一些有名的人\"></a>一些有名的人</h2><p><a href=\"https://developers.google.com/experts/all/technology/android\">GDE</a><br>Dianne Hackborn<br><a href=\"https://github.com/swankjesse\">Jesse Wilson</a></p>"},{"title":"Retrofit源码阅读笔记","date":"2017-07-01T15:03:00.000Z","_content":"\n### This is gonna be nasty...... TL;DR\n![](http://odzl05jxx.bkt.clouddn.com/d653491fb55bec754b8471aa6a3f6eed.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n### 1. Retrofit\n\n#### 1.1 使用方法\nRetrofit本身并不局限于Andriod平台，java应用也可以用来和服务器沟通。\nRetrofit一般的用法看上去很简单\n```java\n public interface GitHub {\n    @GET(\"/repos/{owner}/{repo}/contributors\")\n    Call<List<Contributor>> contributors(\n        @Path(\"owner\") String owner,\n        @Path(\"repo\") String repo);\n  }\n\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(API_URL)   // end_point\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n\n    // Create an instance of our GitHub API interface.\n    GitHub github = retrofit.create(GitHub.class);\n\n    // Create a call instance for looking up Retrofit contributors.\n    Call<List<Contributor>> call = github.contributors(\"square\", \"retrofit\");\n\n    // Fetch and print a list of the contributors to the library.\n    List<Contributor> contributors = call.execute().body();\n    for (Contributor contributor : contributors) {\n      System.out.println(contributor.login + \" (\" + contributor.contributions + \")\");\n    }\n\n```\n关键来看这段 retroft.create ,重点都在这里面。关键的代码就在这三行里面了\n\n\n>ServiceMethod serviceMethod = loadServiceMethod(method);\nOkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);\nreturn serviceMethod.callAdapter.adapt(okHttpCall);\n\n### 1.2 第一个方法以及ServiceMethod的创建\nloadServiceMethod(Method)会查找invoke的时候会查找methodCache中有没有这个方法，没有的话调用Builder方法创建一个ServiceMethod实例并放入cahce。看一看这个Builder的构造函数 ，基本上就是把Builder中的参数引用赋值给ServiceMethod实例。\n\nresult = new ServiceMethod.Builder(this, method).build();\n```java\n public Builder(Retrofit retrofit, Method method) {\n      this.retrofit = retrofit; //client创建retrofit时可以设定一些属性\n      this.method = method;\n      this.methodAnnotations = method.getAnnotations();\n      this.parameterTypes = method.getGenericParameterTypes();\n      this.parameterAnnotationsArray = method.getParameterAnnotations();\n    }\n```\n\n```java\n根据ServiceMethod的变量名基本上能够猜到各自的用处，比如httpMethod（GET、POST）,\ncontentType（MimeType）\n public ServiceMethod build() {\n        // 1.创建callAdapter,调用retrofit对象设定的callAdapter,例如RxjavAdapter,注意这里面的实现是便利retrofit对象的adapterFactories，找到一个就返回。找不到的话会丢出来一个IllegalArgumentException\n      callAdapter = createCallAdapter();\n       //callAdapter的作用 就是将retrofit.Call的Call转成一个T。例如上面就是把Call<List<Contributor>>转成一个List<Contributor>，这个过程是上面提到的最重要的三个方法中的第三部 adapt（okHttpCall）。可以认为是拿着一个已经创建好的okHttp的Call去做事情，在适当的时候将网络返回结果转成用户事先定义好的respose类型。\n        //这一步返回一个java.lang.reflect.Type ，就个class的基本作用家就是根据泛型来确定response的class。\n      responseType = callAdapter.responseType();\n        //2.创建用于respnse和Request的converter。\n      responseConverter = createResponseConverter();\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation); //这里面就是把@GET变成\"GET\"这个String，表示当前方法是一个GET请求\n      }\n      int parameterCount = parameterAnnotationsArray.length;\n      //3.创建ParameterHandler\n      parameterHandlers = new ParameterHandler<?>[parameterCount];\n      for (int p = 0; p < parameterCount; p++) {\n        Type parameterType = parameterTypes[p];\n        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];\n        if (parameterAnnotations == null) {\n          throw parameterError(p, \"No Retrofit annotation found.\");\n        }\n        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);\n        //关键看这个方法\n         private ParameterHandler<?> parseParameter(int p, Type parameterType, Annotation[] annotations)\n         第一个参数表示当前的数组index\n         第二个参数表示想要的Response类型\n         第三个参数表示该方法上的注解，就是@那些东西\n         接下来就是调用 private ParameterHandler<?> parseParameterAnnotation(\n        int p, Type type, Annotation[] annotations, Annotation annotation)方法来判断各种Http方法，这一段代码有300多行。。。。看完有助于掌握Http协议。\n      }\n      return new ServiceMethod<>(this);\n    }\n}\n```\n\n\n关键是这三个方法，Buider在这个过程中完成了一些变量的赋值\n```java\n1. createCallAdapter  --->  retrofit.callAdapter(returnType, annotations); 从adapterFactories(显然可以有多个)中遍历，找到了一个就返回。已经实现的的有三种**策略**，DefaultCallAdapterFactory、ExecutorCallAdapterFactory和RxjavaCallAdapterFactory。显然用户可以在创建retrofit实例的过程中install自己的callAdapter实现。\n再次强调这个CallAdater的作用，就是将Retrofit的Call adpt成对应的Response class的实例。\n\n2. createResponseConverter --->  retrofit.responseBodyConverter(responseType, annotations);\nRetrofit2.Converter<F, T> (from和To，我猜的)\n\nConvert objects to and from their representation in HTTP. Instances are created by {@linkplain\n * Factory a factory} which is {@linkplain Retrofit.Builder#addConverterFactory(Factory) installed}\n * into the {@link Retrofit} instance.\n\n从retrofit对象的converterFactories（可以有多个，原因在于server有时候会返回json，有时候会返回protocolBuffer，有时候返回xml，response回来的时候会一个个问，这一点jake Wharton多次提到过）中遍历，找到一个就返回。确切的说，是找到一个能够处理的。\n\n\n\n3. 创建parameterHandlers\n应该可以猜到，这一步就是把用户定义的注解转换成发起网络请求时需要带上的参数\nprivate ParameterHandler<?> parseParameterAnnotation(\n        int p, Type type, Annotation[] annotations, Annotation annotation)方法随便展开一点，关注第三个参数和第四个参数\n\n例如        \n public interface GitHub {\n    @GET(\"/repos/{owner}/{repo}/contributors\")\n    Call<List<Contributor>> contributors(\n        @Path(\"owner\") String owner,\n        @Path(\"repo\") String repo);\n  }\n\nServiceMethod走到这一步，annotations就表示 @Path(\"owner\") String owner。注意这里的@PATH是注解类，可以把它当成一个wrapper，这里面就调用了path.value()。\n\nelse if (annotation instanceof Path) {\n        Path path = (Path) annotation;\n        String name = path.value(); // 调用该方法时传入的String\n        validatePathName(p, name);\n        Converter<?, String> converter = retrofit.stringConverter(type, annotations);  \n        return new ParameterHandler.Path<>(name, converter, path.encoded());\n      }\nParameterHandler.Path<>在ParameterHandler这个类里面，看一下结构![](http://odzl05jxx.bkt.clouddn.com/ParameterHandlers.JPG)\nPath这个class中关键的方法apply:\n @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {\n      builder.addPathParam(name, valueConverter.convert(value), encoded);\n    }\n\n再往下走：\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\napply这个方法会在构建Request时由RequestBilder调用，以上面的实例为例子，name就是\"owner\" ,value就是调用该方法时传进来的值，其实就只是Stirng.replace()方法。\n到这里，Buidler已经完成了\n- 准备callAdapter，\n- createResponseConverter\n- 和填充parameterHandlers数组的任务\n直接new一个ServiceMethod出来就好了\n\nServiceMethod(Builder<T> builder) {\n    this.callFactory = builder.retrofit.callFactory();  // okhttp3.Call.Factory\n    this.callAdapter = builder.callAdapter; //\n    this.baseUrl = builder.retrofit.baseUrl(); //这个就是\n    this.responseConverter = builder.responseConverter; // GsonConverter\n    this.httpMethod = builder.httpMethod; //@GET\n    this.relativeUrl = builder.relativeUrl; //@Path\n    this.headers = builder.headers; //@Header\n    this.contentType = builder.contentType;  //application/json这种\n    this.hasBody = builder.hasBody;\n    this.isFormEncoded = builder.isFormEncoded;\n    this.isMultipart = builder.isMultipart;\n    this.parameterHandlers = builder.parameterHandlers;\n  }\n\n上面最重要的三个方法讲完了第一个。  \n```\n\n\n### 1.3 第二个方法和OkHttpCall\n第二个方法:\n OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n\nOkHttpCall的成员变量：\nokhttp3.Call rawCall //用于发起请求\nServiceMethod<T, ?> serviceMethod;  //这就是刚才实例化的serviceMethod对象\n这个类相对简单，主要看execute方法\n\n```java\n @Override public Response<T> execute() throws IOException {\n    okhttp3.Call call;\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already executed.\");\n      executed = true;\n      call = rawCall;\n      if (call == null) {\n        try {\n          call = rawCall = createRawCall();\n        } catch (IOException | RuntimeException e) {\n        }\n      }\n    }\n    return parseResponse(call.execute()); //建立连接，发起请求，解析response都在这里了（都在一条线程上）。execute是okHttp的方法。\n  }\n```\n还记得最简单的Demo吗，同步执行网络请求\nCall<List<Contributor>> call = github.contributors(\"square\", \"retrofit\");\nList<Contributor> contributors = call.execute().body();\n这也是Retrofit2.Call.execute方法最终就是走到了这里\n\ncreateRawCall方法\n```java\n okhttp3.Request request = serviceMethod.toRequest(args);\n okhttp3.Call call = serviceMethod.callFactory.newCall(request);\n    if (call == null) {\n      throw new NullPointerException(\"Call.Factory returned null.\");\n    }\n    return call;\n```\nparseRespnse的实现\n```java\n  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {\n    ResponseBody rawBody = rawResponse.body(); //有用的信息在这里\n    // Remove the body's source (the only stateful object) so we can pass the response along.\n    rawResponse = rawResponse.newBuilder()\n        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))\n        .build(); //根据服务器返回的contentType和contentLength创建一个新的response用于检测200\n\n    int code = rawResponse.code();\n    if (code < 200 || code >= 300) {\n      try {\n        // Buffer the entire body to avoid future I/O.\n        ResponseBody bufferedBody = Utils.buffer(rawBody);\n        return Response.error(bufferedBody, rawResponse); //创建一个body为null的Retrofit2.Response\n      } finally {\n        rawBody.close();\n      }\n    }\n\n    if (code == 204 || code == 205) {\n      rawBody.close();\n      return Response.success(null, rawResponse);\n    }\n\n    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);\n    try {\n      T body = serviceMethod.toResponse(catchingBody); //调用ServiceMethod的responseConverter去转换，前面说过，responseConverter是在builder初始化的时候根据策略，从Retrofit的converterFactories中遍历，找到了就返回。\n      return Response.success(body, rawResponse); //返回创建一个body为定义好的数据类型的Retrofit2.Response，一般情况下，调用Response.body()就能得到所要的实体数据。\n    } catch (RuntimeException e) {\n      // If the underlying source threw an exception, propagate that rather than indicating it was\n      // a runtime exception.\n      catchingBody.throwIfCaught();\n      throw e;\n    }\n  }\n```\n这里可以得知，Retrofit对于状态码的处理，1XX和3XX以上全部走到error中\n\n\nexecute是同步方法，enqueue是异步请求的方法，底层其实就调用了OkHttp.Call.enqueue()，所以说Retrofit本身并不负责创建网络请求，线程调度。只做了parseRespnse的方法，另外，OkHttp和Retrofit本身并不负责把Response推到主线程上，Android 平台可能要注意。\n\n### 1.4 第三个方法和AdapterFactory\nreturn serviceMethod.callAdapter.adapt(okHttpCall); //这个return需要的是Object,涉及到动态代理，可以无视。\n\n回头看一下serviceMethod的createCallAdapter方法，就是从retrofit对象的adapterFactories中一个个遍历：\n\n> CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this)；\n\n找到之后就返回，默认的实现有DefaultCallAdapterFactory和ExecutorCallAdapterFactory以及RxjavaCallAdapterFactory。\n\n```java\n在DefaultCallAdapterFactory中的处理方式是\n\n return new CallAdapter<Call<?>>() {\n      @Override public Type responseType() {\n        return responseType;\n      }\n\n      @Override public <R> Call<R> adapt(Call<R> call) {\n        return call;\n      }\n    };\n\n\nExecutorCallAdapterFactory的处理方式是\n\n\n return new CallAdapter<Object, Call<?>>() {\n      @Override public Type responseType() {\n        return responseType;\n      }\n\n      @Override public Call<Object> adapt(Call<Object> call) {\n        return new ExecutorCallbackCall<>(callbackExecutor, call);\n      }\n    };\n```\n\n\n其实就是将callback丢到一个线程池callbackExecutor中，这个线程池可以通过Retrofit创建的时候配置，简单来说就是response会在这个线程池中回调。\n\n RxjavaCallAdapterFactory的做法是\n```java\n @Override\n  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n    Class<?> rawType = getRawType(returnType);\n    String canonicalName = rawType.getCanonicalName();\n    boolean isSingle = \"rx.Single\".equals(canonicalName); //直接看包名。。。。。\n    boolean isCompletable = \"rx.Completable\".equals(canonicalName);\n    if (rawType != Observable.class && !isSingle && !isCompletable) {\n      return null;\n    }\n    if (!isCompletable && !(returnType instanceof ParameterizedType)) {\n      String name = isSingle ? \"Single\" : \"Observable\";\n      throw new IllegalStateException(name + \" return type must be parameterized\"\n          + \" as \" + name + \"<Foo> or \" + name + \"<? extends Foo>\");\n    }\n\n    if (isCompletable) {\n      // Add Completable-converter wrapper from a separate class. This defers classloading such that\n      // regular Observable operation can be leveraged without relying on this unstable RxJava API.\n      // Note that this has to be done separately since Completable doesn't have a parametrized\n      // type.\n      return CompletableHelper.createCallAdapter(scheduler);\n    }\n\n    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType, scheduler);\n    if (isSingle) {\n      // Add Single-converter wrapper from a separate class. This defers classloading such that\n      // regular Observable operation can be leveraged without relying on this unstable RxJava API.\n      return SingleHelper.makeSingle(callAdapter);\n    }\n    return callAdapter;\n}\n```\n\n\n### 1.5 使用Retrofit的best practices\n\n到这里，retrofit的工作流程就通过三个方法讲完了，接下来根据jake wharton的talk [making retrofit work for you](https://www.youtube.com/watch?v=t34AQlblSeE)来讲几个best practice。\n\n#### 1.5.1 end point 不一样怎么办\n默认情况下，如果不指定client,每一次都会创建一个新的OkHttpClient，这样做就丧失了disk caching,connection pooling等优势。\n\n![endpoint](http://odzl05jxx.bkt.clouddn.com/different_end_point.JPG)    \n\n所以需要提取出一个OkHttpClient,解决方式很简单\n![](http://odzl05jxx.bkt.clouddn.com/different_end_point_teh_right_way.JPG)\n\n#### 1.5.2 不要创建多个HttpClient\n\nshallow copy\n```java\nOkHttpClient client = new OkHttpClient();\n\nOkHttpClient clientFoo = client.newBuilder().addInterceptor(new FooInterceptor()).build()\n\nOkHttpClient clientBar = client.newBuilder().readTimeOut(20,SECONDS)\n.writeTimeOut(20,SECONDS).build()\n```\n\n#### 1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\n一般可能会想到在OkHttp的Interceptor中去判断url然后手动加上header，一种更好的解决方式是，假定所有的API都需要加Header，对于登录和忘记密码的Api,这样写\n```java\n@POST(\"/login\")\n@Headers(\"No-Authentication: true\")\nCall<User> login(@Body LoginRequest request)\n```\n//这个header对于server是不可见的，现在在Interceptor中，\n只要判断request.header(\"No-Authentication\")==null 即表示该接口需要加上header。\n所以，对于特定接口的筛选可以，采用这种方式。\n\n#### 1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个\n\naddConverterFactory，和之前的创建两个httpclient一样，人们也很容易创建两个解析器。解决方法也很实在，提取出来公用即可。\n![](http://odzl05jxx.bkt.clouddn.com/creating%20two%20convertors.JPG)\n\n\n#### 1.5.5 addConverterFactory可以调用多次\n假如一个接口返回json，一个接口返回proto。不要试图创建多个retrofit实例。这样就可以了\n![](http://odzl05jxx.bkt.clouddn.com/different_response.JPG)\n\n底层的原理是这样的。\nUser是Proto,Friend是Json。 Proto都extends一个protoType class，所以只要看下是否 instanceof proto就可以了。这一切都是在serviceMethod创建过程中判断的。这里顺序很重要。由于gson基本能够序列化一切，所以gson总是会认为自己可以成功。所以要把protoConverter放在前面。\n GsonConverterFactory, SimpleXmlConverterFactory converters , they say yes to everyThing. 所以如果出现这种情况怎么办？\n 首先定义自己的注解\n ```java\n @interface Xml {}\n @interface Json {}\n\n interface Service{\n    @GET(\"/User\") @Xml\n    Call<User> user(); // User是XML\n\n    @GET(\"/Friends\") @Json\n    Call<Friends> friends();  //Friends是Json\n }\n\nclass XmlOrJsonConverterFactroy extend Converter.Factory{\n    final Converter.Factory xml = ///;\n    final Converter.Factory json = //....;\n\n    @override\n    public Converter<ResponseBody,?> responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit){\n        // annotations就包含了刚才我们添加的注解\n        for (Annotation annotation : annotations){\n            if(annotation.getClass == Xml.class){\n                return xml.reponseBodyConverter(type,annotations,retrofit);\n            }else if(annotation.getClass == Json.class){\n                // json\n            }\n            return null; 都不是。 会去找下一个Converter..\n        }\n    }\n}\n[AnnotatedConverterFactory用于自定义类型](https://github.com/square/retrofit/blob/master/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java)\n```\n\n#### 1.5.6 服务器返回的数据中包括一些metaData\n使用delegate的方式去除这些metadata，只获取想要的response实体对象\n![](http://odzl05jxx.bkt.clouddn.com/delegaet_converters.JPG)\n但这些metaData是有用的。。怎么处理\n可以在convert中集中处理自定义错误码。\n\n#### 1.5.7 和Rxjava配合使用\nCallAdapterFactory和ConverterFactory类似，也可以自定义，所以这样可以直接将所有的Observable返回到主线程\n\n![](http://odzl05jxx.bkt.clouddn.com/always_observe_on_mian_thread.JPG)\n\n\n所以，Retrofit就是将HttpClient、Converter和CallAdapter这三样职能结合起来，又提供了足够的定制化。\n\n\n\n\n\n### 2. OkHttp\n\n\n### 3. A few 'ok' libraries\nwhy moshi ? why Retrofit call can be clone cheap？\nwhy SinkedSource?\nwhy protolBuffer cost less ?\n\n\n\n### Ref\n1. [Paisy解析Retrofit](https://blog.piasy.com/2016/06/25/Understand-Retrofit/)\n2. [open-sourse-projetc解析Retrofit](https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit)\n3. [Making Retrofit Work For You by Jake Wharton](https://www.youtube.com/watch?v=t34AQlblSeE)\n","source":"_posts/2017-07-01-it-began-with-a-few-bits.md","raw":"---\ntitle: Retrofit源码阅读笔记\ndate: 2017-07-01 23:03:00\ntags:\n   - Retrofit\n   - OkHttp\n   - Okio\n---\n\n### This is gonna be nasty...... TL;DR\n![](http://odzl05jxx.bkt.clouddn.com/d653491fb55bec754b8471aa6a3f6eed.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n### 1. Retrofit\n\n#### 1.1 使用方法\nRetrofit本身并不局限于Andriod平台，java应用也可以用来和服务器沟通。\nRetrofit一般的用法看上去很简单\n```java\n public interface GitHub {\n    @GET(\"/repos/{owner}/{repo}/contributors\")\n    Call<List<Contributor>> contributors(\n        @Path(\"owner\") String owner,\n        @Path(\"repo\") String repo);\n  }\n\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(API_URL)   // end_point\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n\n    // Create an instance of our GitHub API interface.\n    GitHub github = retrofit.create(GitHub.class);\n\n    // Create a call instance for looking up Retrofit contributors.\n    Call<List<Contributor>> call = github.contributors(\"square\", \"retrofit\");\n\n    // Fetch and print a list of the contributors to the library.\n    List<Contributor> contributors = call.execute().body();\n    for (Contributor contributor : contributors) {\n      System.out.println(contributor.login + \" (\" + contributor.contributions + \")\");\n    }\n\n```\n关键来看这段 retroft.create ,重点都在这里面。关键的代码就在这三行里面了\n\n\n>ServiceMethod serviceMethod = loadServiceMethod(method);\nOkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);\nreturn serviceMethod.callAdapter.adapt(okHttpCall);\n\n### 1.2 第一个方法以及ServiceMethod的创建\nloadServiceMethod(Method)会查找invoke的时候会查找methodCache中有没有这个方法，没有的话调用Builder方法创建一个ServiceMethod实例并放入cahce。看一看这个Builder的构造函数 ，基本上就是把Builder中的参数引用赋值给ServiceMethod实例。\n\nresult = new ServiceMethod.Builder(this, method).build();\n```java\n public Builder(Retrofit retrofit, Method method) {\n      this.retrofit = retrofit; //client创建retrofit时可以设定一些属性\n      this.method = method;\n      this.methodAnnotations = method.getAnnotations();\n      this.parameterTypes = method.getGenericParameterTypes();\n      this.parameterAnnotationsArray = method.getParameterAnnotations();\n    }\n```\n\n```java\n根据ServiceMethod的变量名基本上能够猜到各自的用处，比如httpMethod（GET、POST）,\ncontentType（MimeType）\n public ServiceMethod build() {\n        // 1.创建callAdapter,调用retrofit对象设定的callAdapter,例如RxjavAdapter,注意这里面的实现是便利retrofit对象的adapterFactories，找到一个就返回。找不到的话会丢出来一个IllegalArgumentException\n      callAdapter = createCallAdapter();\n       //callAdapter的作用 就是将retrofit.Call的Call转成一个T。例如上面就是把Call<List<Contributor>>转成一个List<Contributor>，这个过程是上面提到的最重要的三个方法中的第三部 adapt（okHttpCall）。可以认为是拿着一个已经创建好的okHttp的Call去做事情，在适当的时候将网络返回结果转成用户事先定义好的respose类型。\n        //这一步返回一个java.lang.reflect.Type ，就个class的基本作用家就是根据泛型来确定response的class。\n      responseType = callAdapter.responseType();\n        //2.创建用于respnse和Request的converter。\n      responseConverter = createResponseConverter();\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation); //这里面就是把@GET变成\"GET\"这个String，表示当前方法是一个GET请求\n      }\n      int parameterCount = parameterAnnotationsArray.length;\n      //3.创建ParameterHandler\n      parameterHandlers = new ParameterHandler<?>[parameterCount];\n      for (int p = 0; p < parameterCount; p++) {\n        Type parameterType = parameterTypes[p];\n        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];\n        if (parameterAnnotations == null) {\n          throw parameterError(p, \"No Retrofit annotation found.\");\n        }\n        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);\n        //关键看这个方法\n         private ParameterHandler<?> parseParameter(int p, Type parameterType, Annotation[] annotations)\n         第一个参数表示当前的数组index\n         第二个参数表示想要的Response类型\n         第三个参数表示该方法上的注解，就是@那些东西\n         接下来就是调用 private ParameterHandler<?> parseParameterAnnotation(\n        int p, Type type, Annotation[] annotations, Annotation annotation)方法来判断各种Http方法，这一段代码有300多行。。。。看完有助于掌握Http协议。\n      }\n      return new ServiceMethod<>(this);\n    }\n}\n```\n\n\n关键是这三个方法，Buider在这个过程中完成了一些变量的赋值\n```java\n1. createCallAdapter  --->  retrofit.callAdapter(returnType, annotations); 从adapterFactories(显然可以有多个)中遍历，找到了一个就返回。已经实现的的有三种**策略**，DefaultCallAdapterFactory、ExecutorCallAdapterFactory和RxjavaCallAdapterFactory。显然用户可以在创建retrofit实例的过程中install自己的callAdapter实现。\n再次强调这个CallAdater的作用，就是将Retrofit的Call adpt成对应的Response class的实例。\n\n2. createResponseConverter --->  retrofit.responseBodyConverter(responseType, annotations);\nRetrofit2.Converter<F, T> (from和To，我猜的)\n\nConvert objects to and from their representation in HTTP. Instances are created by {@linkplain\n * Factory a factory} which is {@linkplain Retrofit.Builder#addConverterFactory(Factory) installed}\n * into the {@link Retrofit} instance.\n\n从retrofit对象的converterFactories（可以有多个，原因在于server有时候会返回json，有时候会返回protocolBuffer，有时候返回xml，response回来的时候会一个个问，这一点jake Wharton多次提到过）中遍历，找到一个就返回。确切的说，是找到一个能够处理的。\n\n\n\n3. 创建parameterHandlers\n应该可以猜到，这一步就是把用户定义的注解转换成发起网络请求时需要带上的参数\nprivate ParameterHandler<?> parseParameterAnnotation(\n        int p, Type type, Annotation[] annotations, Annotation annotation)方法随便展开一点，关注第三个参数和第四个参数\n\n例如        \n public interface GitHub {\n    @GET(\"/repos/{owner}/{repo}/contributors\")\n    Call<List<Contributor>> contributors(\n        @Path(\"owner\") String owner,\n        @Path(\"repo\") String repo);\n  }\n\nServiceMethod走到这一步，annotations就表示 @Path(\"owner\") String owner。注意这里的@PATH是注解类，可以把它当成一个wrapper，这里面就调用了path.value()。\n\nelse if (annotation instanceof Path) {\n        Path path = (Path) annotation;\n        String name = path.value(); // 调用该方法时传入的String\n        validatePathName(p, name);\n        Converter<?, String> converter = retrofit.stringConverter(type, annotations);  \n        return new ParameterHandler.Path<>(name, converter, path.encoded());\n      }\nParameterHandler.Path<>在ParameterHandler这个类里面，看一下结构![](http://odzl05jxx.bkt.clouddn.com/ParameterHandlers.JPG)\nPath这个class中关键的方法apply:\n @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {\n      builder.addPathParam(name, valueConverter.convert(value), encoded);\n    }\n\n再往下走：\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\napply这个方法会在构建Request时由RequestBilder调用，以上面的实例为例子，name就是\"owner\" ,value就是调用该方法时传进来的值，其实就只是Stirng.replace()方法。\n到这里，Buidler已经完成了\n- 准备callAdapter，\n- createResponseConverter\n- 和填充parameterHandlers数组的任务\n直接new一个ServiceMethod出来就好了\n\nServiceMethod(Builder<T> builder) {\n    this.callFactory = builder.retrofit.callFactory();  // okhttp3.Call.Factory\n    this.callAdapter = builder.callAdapter; //\n    this.baseUrl = builder.retrofit.baseUrl(); //这个就是\n    this.responseConverter = builder.responseConverter; // GsonConverter\n    this.httpMethod = builder.httpMethod; //@GET\n    this.relativeUrl = builder.relativeUrl; //@Path\n    this.headers = builder.headers; //@Header\n    this.contentType = builder.contentType;  //application/json这种\n    this.hasBody = builder.hasBody;\n    this.isFormEncoded = builder.isFormEncoded;\n    this.isMultipart = builder.isMultipart;\n    this.parameterHandlers = builder.parameterHandlers;\n  }\n\n上面最重要的三个方法讲完了第一个。  \n```\n\n\n### 1.3 第二个方法和OkHttpCall\n第二个方法:\n OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n\nOkHttpCall的成员变量：\nokhttp3.Call rawCall //用于发起请求\nServiceMethod<T, ?> serviceMethod;  //这就是刚才实例化的serviceMethod对象\n这个类相对简单，主要看execute方法\n\n```java\n @Override public Response<T> execute() throws IOException {\n    okhttp3.Call call;\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already executed.\");\n      executed = true;\n      call = rawCall;\n      if (call == null) {\n        try {\n          call = rawCall = createRawCall();\n        } catch (IOException | RuntimeException e) {\n        }\n      }\n    }\n    return parseResponse(call.execute()); //建立连接，发起请求，解析response都在这里了（都在一条线程上）。execute是okHttp的方法。\n  }\n```\n还记得最简单的Demo吗，同步执行网络请求\nCall<List<Contributor>> call = github.contributors(\"square\", \"retrofit\");\nList<Contributor> contributors = call.execute().body();\n这也是Retrofit2.Call.execute方法最终就是走到了这里\n\ncreateRawCall方法\n```java\n okhttp3.Request request = serviceMethod.toRequest(args);\n okhttp3.Call call = serviceMethod.callFactory.newCall(request);\n    if (call == null) {\n      throw new NullPointerException(\"Call.Factory returned null.\");\n    }\n    return call;\n```\nparseRespnse的实现\n```java\n  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {\n    ResponseBody rawBody = rawResponse.body(); //有用的信息在这里\n    // Remove the body's source (the only stateful object) so we can pass the response along.\n    rawResponse = rawResponse.newBuilder()\n        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))\n        .build(); //根据服务器返回的contentType和contentLength创建一个新的response用于检测200\n\n    int code = rawResponse.code();\n    if (code < 200 || code >= 300) {\n      try {\n        // Buffer the entire body to avoid future I/O.\n        ResponseBody bufferedBody = Utils.buffer(rawBody);\n        return Response.error(bufferedBody, rawResponse); //创建一个body为null的Retrofit2.Response\n      } finally {\n        rawBody.close();\n      }\n    }\n\n    if (code == 204 || code == 205) {\n      rawBody.close();\n      return Response.success(null, rawResponse);\n    }\n\n    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);\n    try {\n      T body = serviceMethod.toResponse(catchingBody); //调用ServiceMethod的responseConverter去转换，前面说过，responseConverter是在builder初始化的时候根据策略，从Retrofit的converterFactories中遍历，找到了就返回。\n      return Response.success(body, rawResponse); //返回创建一个body为定义好的数据类型的Retrofit2.Response，一般情况下，调用Response.body()就能得到所要的实体数据。\n    } catch (RuntimeException e) {\n      // If the underlying source threw an exception, propagate that rather than indicating it was\n      // a runtime exception.\n      catchingBody.throwIfCaught();\n      throw e;\n    }\n  }\n```\n这里可以得知，Retrofit对于状态码的处理，1XX和3XX以上全部走到error中\n\n\nexecute是同步方法，enqueue是异步请求的方法，底层其实就调用了OkHttp.Call.enqueue()，所以说Retrofit本身并不负责创建网络请求，线程调度。只做了parseRespnse的方法，另外，OkHttp和Retrofit本身并不负责把Response推到主线程上，Android 平台可能要注意。\n\n### 1.4 第三个方法和AdapterFactory\nreturn serviceMethod.callAdapter.adapt(okHttpCall); //这个return需要的是Object,涉及到动态代理，可以无视。\n\n回头看一下serviceMethod的createCallAdapter方法，就是从retrofit对象的adapterFactories中一个个遍历：\n\n> CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this)；\n\n找到之后就返回，默认的实现有DefaultCallAdapterFactory和ExecutorCallAdapterFactory以及RxjavaCallAdapterFactory。\n\n```java\n在DefaultCallAdapterFactory中的处理方式是\n\n return new CallAdapter<Call<?>>() {\n      @Override public Type responseType() {\n        return responseType;\n      }\n\n      @Override public <R> Call<R> adapt(Call<R> call) {\n        return call;\n      }\n    };\n\n\nExecutorCallAdapterFactory的处理方式是\n\n\n return new CallAdapter<Object, Call<?>>() {\n      @Override public Type responseType() {\n        return responseType;\n      }\n\n      @Override public Call<Object> adapt(Call<Object> call) {\n        return new ExecutorCallbackCall<>(callbackExecutor, call);\n      }\n    };\n```\n\n\n其实就是将callback丢到一个线程池callbackExecutor中，这个线程池可以通过Retrofit创建的时候配置，简单来说就是response会在这个线程池中回调。\n\n RxjavaCallAdapterFactory的做法是\n```java\n @Override\n  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n    Class<?> rawType = getRawType(returnType);\n    String canonicalName = rawType.getCanonicalName();\n    boolean isSingle = \"rx.Single\".equals(canonicalName); //直接看包名。。。。。\n    boolean isCompletable = \"rx.Completable\".equals(canonicalName);\n    if (rawType != Observable.class && !isSingle && !isCompletable) {\n      return null;\n    }\n    if (!isCompletable && !(returnType instanceof ParameterizedType)) {\n      String name = isSingle ? \"Single\" : \"Observable\";\n      throw new IllegalStateException(name + \" return type must be parameterized\"\n          + \" as \" + name + \"<Foo> or \" + name + \"<? extends Foo>\");\n    }\n\n    if (isCompletable) {\n      // Add Completable-converter wrapper from a separate class. This defers classloading such that\n      // regular Observable operation can be leveraged without relying on this unstable RxJava API.\n      // Note that this has to be done separately since Completable doesn't have a parametrized\n      // type.\n      return CompletableHelper.createCallAdapter(scheduler);\n    }\n\n    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType, scheduler);\n    if (isSingle) {\n      // Add Single-converter wrapper from a separate class. This defers classloading such that\n      // regular Observable operation can be leveraged without relying on this unstable RxJava API.\n      return SingleHelper.makeSingle(callAdapter);\n    }\n    return callAdapter;\n}\n```\n\n\n### 1.5 使用Retrofit的best practices\n\n到这里，retrofit的工作流程就通过三个方法讲完了，接下来根据jake wharton的talk [making retrofit work for you](https://www.youtube.com/watch?v=t34AQlblSeE)来讲几个best practice。\n\n#### 1.5.1 end point 不一样怎么办\n默认情况下，如果不指定client,每一次都会创建一个新的OkHttpClient，这样做就丧失了disk caching,connection pooling等优势。\n\n![endpoint](http://odzl05jxx.bkt.clouddn.com/different_end_point.JPG)    \n\n所以需要提取出一个OkHttpClient,解决方式很简单\n![](http://odzl05jxx.bkt.clouddn.com/different_end_point_teh_right_way.JPG)\n\n#### 1.5.2 不要创建多个HttpClient\n\nshallow copy\n```java\nOkHttpClient client = new OkHttpClient();\n\nOkHttpClient clientFoo = client.newBuilder().addInterceptor(new FooInterceptor()).build()\n\nOkHttpClient clientBar = client.newBuilder().readTimeOut(20,SECONDS)\n.writeTimeOut(20,SECONDS).build()\n```\n\n#### 1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\n一般可能会想到在OkHttp的Interceptor中去判断url然后手动加上header，一种更好的解决方式是，假定所有的API都需要加Header，对于登录和忘记密码的Api,这样写\n```java\n@POST(\"/login\")\n@Headers(\"No-Authentication: true\")\nCall<User> login(@Body LoginRequest request)\n```\n//这个header对于server是不可见的，现在在Interceptor中，\n只要判断request.header(\"No-Authentication\")==null 即表示该接口需要加上header。\n所以，对于特定接口的筛选可以，采用这种方式。\n\n#### 1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个\n\naddConverterFactory，和之前的创建两个httpclient一样，人们也很容易创建两个解析器。解决方法也很实在，提取出来公用即可。\n![](http://odzl05jxx.bkt.clouddn.com/creating%20two%20convertors.JPG)\n\n\n#### 1.5.5 addConverterFactory可以调用多次\n假如一个接口返回json，一个接口返回proto。不要试图创建多个retrofit实例。这样就可以了\n![](http://odzl05jxx.bkt.clouddn.com/different_response.JPG)\n\n底层的原理是这样的。\nUser是Proto,Friend是Json。 Proto都extends一个protoType class，所以只要看下是否 instanceof proto就可以了。这一切都是在serviceMethod创建过程中判断的。这里顺序很重要。由于gson基本能够序列化一切，所以gson总是会认为自己可以成功。所以要把protoConverter放在前面。\n GsonConverterFactory, SimpleXmlConverterFactory converters , they say yes to everyThing. 所以如果出现这种情况怎么办？\n 首先定义自己的注解\n ```java\n @interface Xml {}\n @interface Json {}\n\n interface Service{\n    @GET(\"/User\") @Xml\n    Call<User> user(); // User是XML\n\n    @GET(\"/Friends\") @Json\n    Call<Friends> friends();  //Friends是Json\n }\n\nclass XmlOrJsonConverterFactroy extend Converter.Factory{\n    final Converter.Factory xml = ///;\n    final Converter.Factory json = //....;\n\n    @override\n    public Converter<ResponseBody,?> responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit){\n        // annotations就包含了刚才我们添加的注解\n        for (Annotation annotation : annotations){\n            if(annotation.getClass == Xml.class){\n                return xml.reponseBodyConverter(type,annotations,retrofit);\n            }else if(annotation.getClass == Json.class){\n                // json\n            }\n            return null; 都不是。 会去找下一个Converter..\n        }\n    }\n}\n[AnnotatedConverterFactory用于自定义类型](https://github.com/square/retrofit/blob/master/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java)\n```\n\n#### 1.5.6 服务器返回的数据中包括一些metaData\n使用delegate的方式去除这些metadata，只获取想要的response实体对象\n![](http://odzl05jxx.bkt.clouddn.com/delegaet_converters.JPG)\n但这些metaData是有用的。。怎么处理\n可以在convert中集中处理自定义错误码。\n\n#### 1.5.7 和Rxjava配合使用\nCallAdapterFactory和ConverterFactory类似，也可以自定义，所以这样可以直接将所有的Observable返回到主线程\n\n![](http://odzl05jxx.bkt.clouddn.com/always_observe_on_mian_thread.JPG)\n\n\n所以，Retrofit就是将HttpClient、Converter和CallAdapter这三样职能结合起来，又提供了足够的定制化。\n\n\n\n\n\n### 2. OkHttp\n\n\n### 3. A few 'ok' libraries\nwhy moshi ? why Retrofit call can be clone cheap？\nwhy SinkedSource?\nwhy protolBuffer cost less ?\n\n\n\n### Ref\n1. [Paisy解析Retrofit](https://blog.piasy.com/2016/06/25/Understand-Retrofit/)\n2. [open-sourse-projetc解析Retrofit](https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit)\n3. [Making Retrofit Work For You by Jake Wharton](https://www.youtube.com/watch?v=t34AQlblSeE)\n","slug":"2017-07-01-it-began-with-a-few-bits","published":1,"updated":"2017-07-23T10:43:10.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnjj002bbovr9v5nho8z","content":"<h3 id=\"This-is-gonna-be-nasty……-TL-DR\"><a href=\"#This-is-gonna-be-nasty……-TL-DR\" class=\"headerlink\" title=\"This is gonna be nasty…… TL;DR\"></a>This is gonna be nasty…… TL;DR</h3><p><img src=\"http://odzl05jxx.bkt.clouddn.com/d653491fb55bec754b8471aa6a3f6eed.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-Retrofit\"><a href=\"#1-Retrofit\" class=\"headerlink\" title=\"1. Retrofit\"></a>1. Retrofit</h3><h4 id=\"1-1-使用方法\"><a href=\"#1-1-使用方法\" class=\"headerlink\" title=\"1.1 使用方法\"></a>1.1 使用方法</h4><p>Retrofit本身并不局限于Andriod平台，java应用也可以用来和服务器沟通。<br>Retrofit一般的用法看上去很简单<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHub</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\"</span>)</div><div class=\"line\">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</div><div class=\"line\">        <span class=\"meta\">@Path</span>(<span class=\"string\">\"owner\"</span>) String owner,</div><div class=\"line\">        <span class=\"meta\">@Path</span>(<span class=\"string\">\"repo\"</span>) String repo);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</div><div class=\"line\">        .baseUrl(API_URL)   <span class=\"comment\">// end_point</span></div><div class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Create an instance of our GitHub API interface.</span></div><div class=\"line\">    GitHub github = retrofit.create(GitHub.class);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Create a call instance for looking up Retrofit contributors.</span></div><div class=\"line\">    Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class=\"string\">\"square\"</span>, <span class=\"string\">\"retrofit\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Fetch and print a list of the contributors to the library.</span></div><div class=\"line\">    List&lt;Contributor&gt; contributors = call.execute().body();</div><div class=\"line\">    <span class=\"keyword\">for</span> (Contributor contributor : contributors) &#123;</div><div class=\"line\">      System.out.println(contributor.login + <span class=\"string\">\" (\"</span> + contributor.contributions + <span class=\"string\">\")\"</span>);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>关键来看这段 retroft.create ,重点都在这里面。关键的代码就在这三行里面了</p>\n<blockquote>\n<p>ServiceMethod serviceMethod = loadServiceMethod(method);<br>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);<br>return serviceMethod.callAdapter.adapt(okHttpCall);</p>\n</blockquote>\n<h3 id=\"1-2-第一个方法以及ServiceMethod的创建\"><a href=\"#1-2-第一个方法以及ServiceMethod的创建\" class=\"headerlink\" title=\"1.2 第一个方法以及ServiceMethod的创建\"></a>1.2 第一个方法以及ServiceMethod的创建</h3><p>loadServiceMethod(Method)会查找invoke的时候会查找methodCache中有没有这个方法，没有的话调用Builder方法创建一个ServiceMethod实例并放入cahce。看一看这个Builder的构造函数 ，基本上就是把Builder中的参数引用赋值给ServiceMethod实例。</p>\n<p>result = new ServiceMethod.Builder(this, method).build();<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.retrofit = retrofit; <span class=\"comment\">//client创建retrofit时可以设定一些属性</span></div><div class=\"line\">     <span class=\"keyword\">this</span>.method = method;</div><div class=\"line\">     <span class=\"keyword\">this</span>.methodAnnotations = method.getAnnotations();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据ServiceMethod的变量名基本上能够猜到各自的用处，比如httpMethod（GET、POST）,</div><div class=\"line\">contentType（MimeType）</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> ServiceMethod <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 1.创建callAdapter,调用retrofit对象设定的callAdapter,例如RxjavAdapter,注意这里面的实现是便利retrofit对象的adapterFactories，找到一个就返回。找不到的话会丢出来一个IllegalArgumentException</span></div><div class=\"line\">      callAdapter = createCallAdapter();</div><div class=\"line\">       <span class=\"comment\">//callAdapter的作用 就是将retrofit.Call的Call转成一个T。例如上面就是把Call&lt;List&lt;Contributor&gt;&gt;转成一个List&lt;Contributor&gt;，这个过程是上面提到的最重要的三个方法中的第三部 adapt（okHttpCall）。可以认为是拿着一个已经创建好的okHttp的Call去做事情，在适当的时候将网络返回结果转成用户事先定义好的respose类型。</span></div><div class=\"line\">        <span class=\"comment\">//这一步返回一个java.lang.reflect.Type ，就个class的基本作用家就是根据泛型来确定response的class。</span></div><div class=\"line\">      responseType = callAdapter.responseType();</div><div class=\"line\">        <span class=\"comment\">//2.创建用于respnse和Request的converter。</span></div><div class=\"line\">      responseConverter = createResponseConverter();</div><div class=\"line\">      <span class=\"keyword\">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class=\"line\">        parseMethodAnnotation(annotation); <span class=\"comment\">//这里面就是把@GET变成\"GET\"这个String，表示当前方法是一个GET请求</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class=\"line\">      <span class=\"comment\">//3.创建ParameterHandler</span></div><div class=\"line\">      parameterHandlers = <span class=\"keyword\">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>; p &lt; parameterCount; p++) &#123;</div><div class=\"line\">        Type parameterType = parameterTypes[p];</div><div class=\"line\">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class=\"line\">        <span class=\"keyword\">if</span> (parameterAnnotations == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">throw</span> parameterError(p, <span class=\"string\">\"No Retrofit annotation found.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class=\"line\">        <span class=\"comment\">//关键看这个方法</span></div><div class=\"line\">         <span class=\"keyword\">private</span> ParameterHandler&lt;?&gt; parseParameter(<span class=\"keyword\">int</span> p, Type parameterType, Annotation[] annotations)</div><div class=\"line\">         第一个参数表示当前的数组index</div><div class=\"line\">         第二个参数表示想要的Response类型</div><div class=\"line\">         第三个参数表示该方法上的注解，就是@那些东西</div><div class=\"line\">         接下来就是调用 <span class=\"keyword\">private</span> ParameterHandler&lt;?&gt; parseParameterAnnotation(</div><div class=\"line\">        <span class=\"keyword\">int</span> p, Type type, Annotation[] annotations, Annotation annotation)方法来判断各种Http方法，这一段代码有<span class=\"number\">300</span>多行。。。。看完有助于掌握Http协议。</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServiceMethod&lt;&gt;(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关键是这三个方法，Buider在这个过程中完成了一些变量的赋值<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. createCallAdapter  ---&gt;  retrofit.callAdapter(returnType, annotations); 从adapterFactories(显然可以有多个)中遍历，找到了一个就返回。已经实现的的有三种**策略**，DefaultCallAdapterFactory、ExecutorCallAdapterFactory和RxjavaCallAdapterFactory。显然用户可以在创建retrofit实例的过程中install自己的callAdapter实现。</div><div class=\"line\">再次强调这个CallAdater的作用，就是将Retrofit的Call adpt成对应的Response class的实例。</div><div class=\"line\"></div><div class=\"line\">2. createResponseConverter ---&gt;  retrofit.responseBodyConverter(responseType, annotations);</div><div class=\"line\">Retrofit2.Converter&lt;F, T&gt; (from和To，我猜的)</div><div class=\"line\"></div><div class=\"line\">Convert objects to and from their representation in HTTP. Instances are created by &#123;@linkplain</div><div class=\"line\"> * Factory a factory&#125; which is &#123;@linkplain Retrofit.Builder#addConverterFactory(Factory) installed&#125;</div><div class=\"line\"> * into the &#123;@link Retrofit&#125; instance.</div><div class=\"line\"></div><div class=\"line\">从retrofit对象的converterFactories（可以有多个，原因在于server有时候会返回json，有时候会返回protocolBuffer，有时候返回xml，response回来的时候会一个个问，这一点jake Wharton多次提到过）中遍历，找到一个就返回。确切的说，是找到一个能够处理的。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">3. 创建parameterHandlers</div><div class=\"line\">应该可以猜到，这一步就是把用户定义的注解转换成发起网络请求时需要带上的参数</div><div class=\"line\">private ParameterHandler&lt;?&gt; parseParameterAnnotation(</div><div class=\"line\">        int p, Type type, Annotation[] annotations, Annotation annotation)方法随便展开一点，关注第三个参数和第四个参数</div><div class=\"line\"></div><div class=\"line\">例如        </div><div class=\"line\"> public interface GitHub &#123;</div><div class=\"line\">    @GET(\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\")</div><div class=\"line\">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</div><div class=\"line\">        @Path(\"owner\") String owner,</div><div class=\"line\">        @Path(\"repo\") String repo);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">ServiceMethod走到这一步，annotations就表示 @Path(\"owner\") String owner。注意这里的@PATH是注解类，可以把它当成一个wrapper，这里面就调用了path.value()。</div><div class=\"line\"></div><div class=\"line\">else if (annotation instanceof Path) &#123;</div><div class=\"line\">        Path path = (Path) annotation;</div><div class=\"line\">        String name = path.value(); // 调用该方法时传入的String</div><div class=\"line\">        validatePathName(p, name);</div><div class=\"line\">        Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations);  </div><div class=\"line\">        return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded());</div><div class=\"line\">      &#125;</div><div class=\"line\">ParameterHandler.Path&lt;&gt;在ParameterHandler这个类里面，看一下结构![](http://odzl05jxx.bkt.clouddn.com/ParameterHandlers.JPG)</div><div class=\"line\">Path这个class中关键的方法apply:</div><div class=\"line\"> @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException &#123;</div><div class=\"line\">      builder.addPathParam(name, valueConverter.convert(value), encoded);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">再往下走：</div><div class=\"line\">    relativeUrl = relativeUrl.replace(\"&#123;\" + name + \"&#125;\", canonicalizeForPath(value, encoded));</div><div class=\"line\">apply这个方法会在构建Request时由RequestBilder调用，以上面的实例为例子，name就是\"owner\" ,value就是调用该方法时传进来的值，其实就只是Stirng.replace()方法。</div><div class=\"line\">到这里，Buidler已经完成了</div><div class=\"line\">- 准备callAdapter，</div><div class=\"line\">- createResponseConverter</div><div class=\"line\">- 和填充parameterHandlers数组的任务</div><div class=\"line\">直接new一个ServiceMethod出来就好了</div><div class=\"line\"></div><div class=\"line\">ServiceMethod(Builder&lt;T&gt; builder) &#123;</div><div class=\"line\">    this.callFactory = builder.retrofit.callFactory();  // okhttp3.Call.Factory</div><div class=\"line\">    this.callAdapter = builder.callAdapter; //</div><div class=\"line\">    this.baseUrl = builder.retrofit.baseUrl(); //这个就是</div><div class=\"line\">    this.responseConverter = builder.responseConverter; // GsonConverter</div><div class=\"line\">    this.httpMethod = builder.httpMethod; //@GET</div><div class=\"line\">    this.relativeUrl = builder.relativeUrl; //@Path</div><div class=\"line\">    this.headers = builder.headers; //@Header</div><div class=\"line\">    this.contentType = builder.contentType;  //application/json这种</div><div class=\"line\">    this.hasBody = builder.hasBody;</div><div class=\"line\">    this.isFormEncoded = builder.isFormEncoded;</div><div class=\"line\">    this.isMultipart = builder.isMultipart;</div><div class=\"line\">    this.parameterHandlers = builder.parameterHandlers;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">上面最重要的三个方法讲完了第一个。</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-第二个方法和OkHttpCall\"><a href=\"#1-3-第二个方法和OkHttpCall\" class=\"headerlink\" title=\"1.3 第二个方法和OkHttpCall\"></a>1.3 第二个方法和OkHttpCall</h3><p>第二个方法:<br> OkHttpCall<Object> okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</p>\n<p>OkHttpCall的成员变量：<br>okhttp3.Call rawCall //用于发起请求<br>ServiceMethod<T, ?> serviceMethod;  //这就是刚才实例化的serviceMethod对象<br>这个类相对简单，主要看execute方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response&lt;T&gt; <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">   okhttp3.Call call;</div><div class=\"line\">   <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already executed.\"</span>);</div><div class=\"line\">     executed = <span class=\"keyword\">true</span>;</div><div class=\"line\">     call = rawCall;</div><div class=\"line\">     <span class=\"keyword\">if</span> (call == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         call = rawCall = createRawCall();</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException | RuntimeException e) &#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> parseResponse(call.execute()); <span class=\"comment\">//建立连接，发起请求，解析response都在这里了（都在一条线程上）。execute是okHttp的方法。</span></div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>还记得最简单的Demo吗，同步执行网络请求<br>Call<List<Contributor>&gt; call = github.contributors(“square”, “retrofit”);<br>List<Contributor> contributors = call.execute().body();<br>这也是Retrofit2.Call.execute方法最终就是走到了这里</p>\n<p>createRawCall方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">okhttp3.Request request = serviceMethod.toRequest(args);</div><div class=\"line\">okhttp3.Call call = serviceMethod.callFactory.newCall(request);</div><div class=\"line\">   <span class=\"keyword\">if</span> (call == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Call.Factory returned null.\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> call;</div></pre></td></tr></table></figure></p>\n<p>parseRespnse的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Response&lt;T&gt; <span class=\"title\">parseResponse</span><span class=\"params\">(okhttp3.Response rawResponse)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">  ResponseBody rawBody = rawResponse.body(); <span class=\"comment\">//有用的信息在这里</span></div><div class=\"line\">  <span class=\"comment\">// Remove the body's source (the only stateful object) so we can pass the response along.</span></div><div class=\"line\">  rawResponse = rawResponse.newBuilder()</div><div class=\"line\">      .body(<span class=\"keyword\">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class=\"line\">      .build(); <span class=\"comment\">//根据服务器返回的contentType和contentLength创建一个新的response用于检测200</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">int</span> code = rawResponse.code();</div><div class=\"line\">  <span class=\"keyword\">if</span> (code &lt; <span class=\"number\">200</span> || code &gt;= <span class=\"number\">300</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// Buffer the entire body to avoid future I/O.</span></div><div class=\"line\">      ResponseBody bufferedBody = Utils.buffer(rawBody);</div><div class=\"line\">      <span class=\"keyword\">return</span> Response.error(bufferedBody, rawResponse); <span class=\"comment\">//创建一个body为null的Retrofit2.Response</span></div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      rawBody.close();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &#123;</div><div class=\"line\">    rawBody.close();</div><div class=\"line\">    <span class=\"keyword\">return</span> Response.success(<span class=\"keyword\">null</span>, rawResponse);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  ExceptionCatchingRequestBody catchingBody = <span class=\"keyword\">new</span> ExceptionCatchingRequestBody(rawBody);</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    T body = serviceMethod.toResponse(catchingBody); <span class=\"comment\">//调用ServiceMethod的responseConverter去转换，前面说过，responseConverter是在builder初始化的时候根据策略，从Retrofit的converterFactories中遍历，找到了就返回。</span></div><div class=\"line\">    <span class=\"keyword\">return</span> Response.success(body, rawResponse); <span class=\"comment\">//返回创建一个body为定义好的数据类型的Retrofit2.Response，一般情况下，调用Response.body()就能得到所要的实体数据。</span></div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// If the underlying source threw an exception, propagate that rather than indicating it was</span></div><div class=\"line\">    <span class=\"comment\">// a runtime exception.</span></div><div class=\"line\">    catchingBody.throwIfCaught();</div><div class=\"line\">    <span class=\"keyword\">throw</span> e;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里可以得知，Retrofit对于状态码的处理，1XX和3XX以上全部走到error中</p>\n<p>execute是同步方法，enqueue是异步请求的方法，底层其实就调用了OkHttp.Call.enqueue()，所以说Retrofit本身并不负责创建网络请求，线程调度。只做了parseRespnse的方法，另外，OkHttp和Retrofit本身并不负责把Response推到主线程上，Android 平台可能要注意。</p>\n<h3 id=\"1-4-第三个方法和AdapterFactory\"><a href=\"#1-4-第三个方法和AdapterFactory\" class=\"headerlink\" title=\"1.4 第三个方法和AdapterFactory\"></a>1.4 第三个方法和AdapterFactory</h3><p>return serviceMethod.callAdapter.adapt(okHttpCall); //这个return需要的是Object,涉及到动态代理，可以无视。</p>\n<p>回头看一下serviceMethod的createCallAdapter方法，就是从retrofit对象的adapterFactories中一个个遍历：</p>\n<blockquote>\n<p>CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this)；</p>\n</blockquote>\n<p>找到之后就返回，默认的实现有DefaultCallAdapterFactory和ExecutorCallAdapterFactory以及RxjavaCallAdapterFactory。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">在DefaultCallAdapterFactory中的处理方式是</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> responseType;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">Call&lt;R&gt; <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> call;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">ExecutorCallAdapterFactory的处理方式是</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> responseType;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call&lt;Object&gt; <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>其实就是将callback丢到一个线程池callbackExecutor中，这个线程池可以通过Retrofit创建的时候配置，简单来说就是response会在这个线程池中回调。</p>\n<p> RxjavaCallAdapterFactory的做法是<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"keyword\">public</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">    Class&lt;?&gt; rawType = getRawType(returnType);</div><div class=\"line\">    String canonicalName = rawType.getCanonicalName();</div><div class=\"line\">    <span class=\"keyword\">boolean</span> isSingle = <span class=\"string\">\"rx.Single\"</span>.equals(canonicalName); <span class=\"comment\">//直接看包名。。。。。</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> isCompletable = <span class=\"string\">\"rx.Completable\"</span>.equals(canonicalName);</div><div class=\"line\">    <span class=\"keyword\">if</span> (rawType != Observable.class &amp;&amp; !isSingle &amp;&amp; !isCompletable) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isCompletable &amp;&amp; !(returnType <span class=\"keyword\">instanceof</span> ParameterizedType)) &#123;</div><div class=\"line\">      String name = isSingle ? <span class=\"string\">\"Single\"</span> : <span class=\"string\">\"Observable\"</span>;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(name + <span class=\"string\">\" return type must be parameterized\"</span></div><div class=\"line\">          + <span class=\"string\">\" as \"</span> + name + <span class=\"string\">\"&lt;Foo&gt; or \"</span> + name + <span class=\"string\">\"&lt;? extends Foo&gt;\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (isCompletable) &#123;</div><div class=\"line\">      <span class=\"comment\">// Add Completable-converter wrapper from a separate class. This defers classloading such that</span></div><div class=\"line\">      <span class=\"comment\">// regular Observable operation can be leveraged without relying on this unstable RxJava API.</span></div><div class=\"line\">      <span class=\"comment\">// Note that this has to be done separately since Completable doesn't have a parametrized</span></div><div class=\"line\">      <span class=\"comment\">// type.</span></div><div class=\"line\">      <span class=\"keyword\">return</span> CompletableHelper.createCallAdapter(scheduler);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    CallAdapter&lt;Observable&lt;?&gt;&gt; callAdapter = getCallAdapter(returnType, scheduler);</div><div class=\"line\">    <span class=\"keyword\">if</span> (isSingle) &#123;</div><div class=\"line\">      <span class=\"comment\">// Add Single-converter wrapper from a separate class. This defers classloading such that</span></div><div class=\"line\">      <span class=\"comment\">// regular Observable operation can be leveraged without relying on this unstable RxJava API.</span></div><div class=\"line\">      <span class=\"keyword\">return</span> SingleHelper.makeSingle(callAdapter);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> callAdapter;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-5-使用Retrofit的best-practices\"><a href=\"#1-5-使用Retrofit的best-practices\" class=\"headerlink\" title=\"1.5 使用Retrofit的best practices\"></a>1.5 使用Retrofit的best practices</h3><p>到这里，retrofit的工作流程就通过三个方法讲完了，接下来根据jake wharton的talk <a href=\"https://www.youtube.com/watch?v=t34AQlblSeE\">making retrofit work for you</a>来讲几个best practice。</p>\n<h4 id=\"1-5-1-end-point-不一样怎么办\"><a href=\"#1-5-1-end-point-不一样怎么办\" class=\"headerlink\" title=\"1.5.1 end point 不一样怎么办\"></a>1.5.1 end point 不一样怎么办</h4><p>默认情况下，如果不指定client,每一次都会创建一个新的OkHttpClient，这样做就丧失了disk caching,connection pooling等优势。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/different_end_point.JPG\" alt=\"endpoint\">    </p>\n<p>所以需要提取出一个OkHttpClient,解决方式很简单<br><img src=\"http://odzl05jxx.bkt.clouddn.com/different_end_point_teh_right_way.JPG\" alt=\"\"></p>\n<h4 id=\"1-5-2-不要创建多个HttpClient\"><a href=\"#1-5-2-不要创建多个HttpClient\" class=\"headerlink\" title=\"1.5.2 不要创建多个HttpClient\"></a>1.5.2 不要创建多个HttpClient</h4><p>shallow copy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient();</div><div class=\"line\"></div><div class=\"line\">OkHttpClient clientFoo = client.newBuilder().addInterceptor(<span class=\"keyword\">new</span> FooInterceptor()).build()</div><div class=\"line\"></div><div class=\"line\">OkHttpClient clientBar = client.newBuilder().readTimeOut(<span class=\"number\">20</span>,SECONDS)</div><div class=\"line\">.writeTimeOut(<span class=\"number\">20</span>,SECONDS).build()</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-5-3-有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\"><a href=\"#1-5-3-有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\" class=\"headerlink\" title=\"1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\"></a>1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）</h4><p>一般可能会想到在OkHttp的Interceptor中去判断url然后手动加上header，一种更好的解决方式是，假定所有的API都需要加Header，对于登录和忘记密码的Api,这样写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@POST</span>(<span class=\"string\">\"/login\"</span>)</div><div class=\"line\"><span class=\"meta\">@Headers</span>(<span class=\"string\">\"No-Authentication: true\"</span>)</div><div class=\"line\"><span class=\"function\">Call&lt;User&gt; <span class=\"title\">login</span><span class=\"params\">(@Body LoginRequest request)</span></span></div></pre></td></tr></table></figure></p>\n<p>//这个header对于server是不可见的，现在在Interceptor中，<br>只要判断request.header(“No-Authentication”)==null 即表示该接口需要加上header。<br>所以，对于特定接口的筛选可以，采用这种方式。</p>\n<h4 id=\"1-5-4-Converters将byte变成java对象，底层的解析器不要创建多个\"><a href=\"#1-5-4-Converters将byte变成java对象，底层的解析器不要创建多个\" class=\"headerlink\" title=\"1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个\"></a>1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个</h4><p>addConverterFactory，和之前的创建两个httpclient一样，人们也很容易创建两个解析器。解决方法也很实在，提取出来公用即可。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/creating%20two%20convertors.JPG\" alt=\"\"></p>\n<h4 id=\"1-5-5-addConverterFactory可以调用多次\"><a href=\"#1-5-5-addConverterFactory可以调用多次\" class=\"headerlink\" title=\"1.5.5 addConverterFactory可以调用多次\"></a>1.5.5 addConverterFactory可以调用多次</h4><p>假如一个接口返回json，一个接口返回proto。不要试图创建多个retrofit实例。这样就可以了<br><img src=\"http://odzl05jxx.bkt.clouddn.com/different_response.JPG\" alt=\"\"></p>\n<p>底层的原理是这样的。<br>User是Proto,Friend是Json。 Proto都extends一个protoType class，所以只要看下是否 instanceof proto就可以了。这一切都是在serviceMethod创建过程中判断的。这里顺序很重要。由于gson基本能够序列化一切，所以gson总是会认为自己可以成功。所以要把protoConverter放在前面。<br> GsonConverterFactory, SimpleXmlConverterFactory converters , they say yes to everyThing. 所以如果出现这种情况怎么办？<br> 首先定义自己的注解<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"meta\">@interface</span> Xml &#123;&#125;</div><div class=\"line\"> <span class=\"meta\">@interface</span> Json &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Service</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/User\"</span>) <span class=\"meta\">@Xml</span></div><div class=\"line\">    <span class=\"function\">Call&lt;User&gt; <span class=\"title\">user</span><span class=\"params\">()</span></span>; <span class=\"comment\">// User是XML</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/Friends\"</span>) <span class=\"meta\">@Json</span></div><div class=\"line\">    <span class=\"function\">Call&lt;Friends&gt; <span class=\"title\">friends</span><span class=\"params\">()</span></span>;  <span class=\"comment\">//Friends是Json</span></div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XmlOrJsonConverterFactroy</span> <span class=\"title\">extend</span> <span class=\"title\">Converter</span>.<span class=\"title\">Factory</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Converter.Factory xml = <span class=\"comment\">///;</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Converter.Factory json = <span class=\"comment\">//....;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody,?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit)&#123;</div><div class=\"line\">        <span class=\"comment\">// annotations就包含了刚才我们添加的注解</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Annotation annotation : annotations)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(annotation.getClass == Xml.class)&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> xml.reponseBodyConverter(type,annotations,retrofit);</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(annotation.getClass == Json.class)&#123;</div><div class=\"line\">                <span class=\"comment\">// json</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; 都不是。 会去找下一个Converter..</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">[AnnotatedConverterFactory用于自定义类型](https:<span class=\"comment\">//github.com/square/retrofit/blob/master/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java)</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"1-5-6-服务器返回的数据中包括一些metaData\"><a href=\"#1-5-6-服务器返回的数据中包括一些metaData\" class=\"headerlink\" title=\"1.5.6 服务器返回的数据中包括一些metaData\"></a>1.5.6 服务器返回的数据中包括一些metaData</h4><p>使用delegate的方式去除这些metadata，只获取想要的response实体对象<br><img src=\"http://odzl05jxx.bkt.clouddn.com/delegaet_converters.JPG\" alt=\"\"><br>但这些metaData是有用的。。怎么处理<br>可以在convert中集中处理自定义错误码。</p>\n<h4 id=\"1-5-7-和Rxjava配合使用\"><a href=\"#1-5-7-和Rxjava配合使用\" class=\"headerlink\" title=\"1.5.7 和Rxjava配合使用\"></a>1.5.7 和Rxjava配合使用</h4><p>CallAdapterFactory和ConverterFactory类似，也可以自定义，所以这样可以直接将所有的Observable返回到主线程</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/always_observe_on_mian_thread.JPG\" alt=\"\"></p>\n<p>所以，Retrofit就是将HttpClient、Converter和CallAdapter这三样职能结合起来，又提供了足够的定制化。</p>\n<h3 id=\"2-OkHttp\"><a href=\"#2-OkHttp\" class=\"headerlink\" title=\"2. OkHttp\"></a>2. OkHttp</h3><h3 id=\"3-A-few-‘ok’-libraries\"><a href=\"#3-A-few-‘ok’-libraries\" class=\"headerlink\" title=\"3. A few ‘ok’ libraries\"></a>3. A few ‘ok’ libraries</h3><p>why moshi ? why Retrofit call can be clone cheap？<br>why SinkedSource?<br>why protolBuffer cost less ?</p>\n<h3 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h3><ol>\n<li><a href=\"https://blog.piasy.com/2016/06/25/Understand-Retrofit/\">Paisy解析Retrofit</a></li>\n<li><a href=\"https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit\">open-sourse-projetc解析Retrofit</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=t34AQlblSeE\">Making Retrofit Work For You by Jake Wharton</a></li>\n</ol>\n","excerpt":"<h3 id=\"This-is-gonna-be-nasty……-TL-DR\"><a href=\"#This-is-gonna-be-nasty……-TL-DR\" class=\"headerlink\" title=\"This is gonna be nasty…… TL;DR\"></a>This is gonna be nasty…… TL;DR</h3><p><img src=\"http://odzl05jxx.bkt.clouddn.com/d653491fb55bec754b8471aa6a3f6eed.jpg?imageView2/2/w/600\" alt=\"\"></p>","more":"<h3 id=\"1-Retrofit\"><a href=\"#1-Retrofit\" class=\"headerlink\" title=\"1. Retrofit\"></a>1. Retrofit</h3><h4 id=\"1-1-使用方法\"><a href=\"#1-1-使用方法\" class=\"headerlink\" title=\"1.1 使用方法\"></a>1.1 使用方法</h4><p>Retrofit本身并不局限于Andriod平台，java应用也可以用来和服务器沟通。<br>Retrofit一般的用法看上去很简单<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHub</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\"</span>)</div><div class=\"line\">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</div><div class=\"line\">        <span class=\"meta\">@Path</span>(<span class=\"string\">\"owner\"</span>) String owner,</div><div class=\"line\">        <span class=\"meta\">@Path</span>(<span class=\"string\">\"repo\"</span>) String repo);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</div><div class=\"line\">        .baseUrl(API_URL)   <span class=\"comment\">// end_point</span></div><div class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Create an instance of our GitHub API interface.</span></div><div class=\"line\">    GitHub github = retrofit.create(GitHub.class);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Create a call instance for looking up Retrofit contributors.</span></div><div class=\"line\">    Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class=\"string\">\"square\"</span>, <span class=\"string\">\"retrofit\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Fetch and print a list of the contributors to the library.</span></div><div class=\"line\">    List&lt;Contributor&gt; contributors = call.execute().body();</div><div class=\"line\">    <span class=\"keyword\">for</span> (Contributor contributor : contributors) &#123;</div><div class=\"line\">      System.out.println(contributor.login + <span class=\"string\">\" (\"</span> + contributor.contributions + <span class=\"string\">\")\"</span>);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>关键来看这段 retroft.create ,重点都在这里面。关键的代码就在这三行里面了</p>\n<blockquote>\n<p>ServiceMethod serviceMethod = loadServiceMethod(method);<br>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);<br>return serviceMethod.callAdapter.adapt(okHttpCall);</p>\n</blockquote>\n<h3 id=\"1-2-第一个方法以及ServiceMethod的创建\"><a href=\"#1-2-第一个方法以及ServiceMethod的创建\" class=\"headerlink\" title=\"1.2 第一个方法以及ServiceMethod的创建\"></a>1.2 第一个方法以及ServiceMethod的创建</h3><p>loadServiceMethod(Method)会查找invoke的时候会查找methodCache中有没有这个方法，没有的话调用Builder方法创建一个ServiceMethod实例并放入cahce。看一看这个Builder的构造函数 ，基本上就是把Builder中的参数引用赋值给ServiceMethod实例。</p>\n<p>result = new ServiceMethod.Builder(this, method).build();<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.retrofit = retrofit; <span class=\"comment\">//client创建retrofit时可以设定一些属性</span></div><div class=\"line\">     <span class=\"keyword\">this</span>.method = method;</div><div class=\"line\">     <span class=\"keyword\">this</span>.methodAnnotations = method.getAnnotations();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class=\"line\">     <span class=\"keyword\">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据ServiceMethod的变量名基本上能够猜到各自的用处，比如httpMethod（GET、POST）,</div><div class=\"line\">contentType（MimeType）</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> ServiceMethod <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 1.创建callAdapter,调用retrofit对象设定的callAdapter,例如RxjavAdapter,注意这里面的实现是便利retrofit对象的adapterFactories，找到一个就返回。找不到的话会丢出来一个IllegalArgumentException</span></div><div class=\"line\">      callAdapter = createCallAdapter();</div><div class=\"line\">       <span class=\"comment\">//callAdapter的作用 就是将retrofit.Call的Call转成一个T。例如上面就是把Call&lt;List&lt;Contributor&gt;&gt;转成一个List&lt;Contributor&gt;，这个过程是上面提到的最重要的三个方法中的第三部 adapt（okHttpCall）。可以认为是拿着一个已经创建好的okHttp的Call去做事情，在适当的时候将网络返回结果转成用户事先定义好的respose类型。</span></div><div class=\"line\">        <span class=\"comment\">//这一步返回一个java.lang.reflect.Type ，就个class的基本作用家就是根据泛型来确定response的class。</span></div><div class=\"line\">      responseType = callAdapter.responseType();</div><div class=\"line\">        <span class=\"comment\">//2.创建用于respnse和Request的converter。</span></div><div class=\"line\">      responseConverter = createResponseConverter();</div><div class=\"line\">      <span class=\"keyword\">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class=\"line\">        parseMethodAnnotation(annotation); <span class=\"comment\">//这里面就是把@GET变成\"GET\"这个String，表示当前方法是一个GET请求</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class=\"line\">      <span class=\"comment\">//3.创建ParameterHandler</span></div><div class=\"line\">      parameterHandlers = <span class=\"keyword\">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>; p &lt; parameterCount; p++) &#123;</div><div class=\"line\">        Type parameterType = parameterTypes[p];</div><div class=\"line\">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class=\"line\">        <span class=\"keyword\">if</span> (parameterAnnotations == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">throw</span> parameterError(p, <span class=\"string\">\"No Retrofit annotation found.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class=\"line\">        <span class=\"comment\">//关键看这个方法</span></div><div class=\"line\">         <span class=\"keyword\">private</span> ParameterHandler&lt;?&gt; parseParameter(<span class=\"keyword\">int</span> p, Type parameterType, Annotation[] annotations)</div><div class=\"line\">         第一个参数表示当前的数组index</div><div class=\"line\">         第二个参数表示想要的Response类型</div><div class=\"line\">         第三个参数表示该方法上的注解，就是@那些东西</div><div class=\"line\">         接下来就是调用 <span class=\"keyword\">private</span> ParameterHandler&lt;?&gt; parseParameterAnnotation(</div><div class=\"line\">        <span class=\"keyword\">int</span> p, Type type, Annotation[] annotations, Annotation annotation)方法来判断各种Http方法，这一段代码有<span class=\"number\">300</span>多行。。。。看完有助于掌握Http协议。</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServiceMethod&lt;&gt;(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关键是这三个方法，Buider在这个过程中完成了一些变量的赋值<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. createCallAdapter  ---&gt;  retrofit.callAdapter(returnType, annotations); 从adapterFactories(显然可以有多个)中遍历，找到了一个就返回。已经实现的的有三种**策略**，DefaultCallAdapterFactory、ExecutorCallAdapterFactory和RxjavaCallAdapterFactory。显然用户可以在创建retrofit实例的过程中install自己的callAdapter实现。</div><div class=\"line\">再次强调这个CallAdater的作用，就是将Retrofit的Call adpt成对应的Response class的实例。</div><div class=\"line\"></div><div class=\"line\">2. createResponseConverter ---&gt;  retrofit.responseBodyConverter(responseType, annotations);</div><div class=\"line\">Retrofit2.Converter&lt;F, T&gt; (from和To，我猜的)</div><div class=\"line\"></div><div class=\"line\">Convert objects to and from their representation in HTTP. Instances are created by &#123;@linkplain</div><div class=\"line\"> * Factory a factory&#125; which is &#123;@linkplain Retrofit.Builder#addConverterFactory(Factory) installed&#125;</div><div class=\"line\"> * into the &#123;@link Retrofit&#125; instance.</div><div class=\"line\"></div><div class=\"line\">从retrofit对象的converterFactories（可以有多个，原因在于server有时候会返回json，有时候会返回protocolBuffer，有时候返回xml，response回来的时候会一个个问，这一点jake Wharton多次提到过）中遍历，找到一个就返回。确切的说，是找到一个能够处理的。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">3. 创建parameterHandlers</div><div class=\"line\">应该可以猜到，这一步就是把用户定义的注解转换成发起网络请求时需要带上的参数</div><div class=\"line\">private ParameterHandler&lt;?&gt; parseParameterAnnotation(</div><div class=\"line\">        int p, Type type, Annotation[] annotations, Annotation annotation)方法随便展开一点，关注第三个参数和第四个参数</div><div class=\"line\"></div><div class=\"line\">例如        </div><div class=\"line\"> public interface GitHub &#123;</div><div class=\"line\">    @GET(\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\")</div><div class=\"line\">    Call&lt;List&lt;Contributor&gt;&gt; contributors(</div><div class=\"line\">        @Path(\"owner\") String owner,</div><div class=\"line\">        @Path(\"repo\") String repo);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">ServiceMethod走到这一步，annotations就表示 @Path(\"owner\") String owner。注意这里的@PATH是注解类，可以把它当成一个wrapper，这里面就调用了path.value()。</div><div class=\"line\"></div><div class=\"line\">else if (annotation instanceof Path) &#123;</div><div class=\"line\">        Path path = (Path) annotation;</div><div class=\"line\">        String name = path.value(); // 调用该方法时传入的String</div><div class=\"line\">        validatePathName(p, name);</div><div class=\"line\">        Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations);  </div><div class=\"line\">        return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded());</div><div class=\"line\">      &#125;</div><div class=\"line\">ParameterHandler.Path&lt;&gt;在ParameterHandler这个类里面，看一下结构![](http://odzl05jxx.bkt.clouddn.com/ParameterHandlers.JPG)</div><div class=\"line\">Path这个class中关键的方法apply:</div><div class=\"line\"> @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException &#123;</div><div class=\"line\">      builder.addPathParam(name, valueConverter.convert(value), encoded);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">再往下走：</div><div class=\"line\">    relativeUrl = relativeUrl.replace(\"&#123;\" + name + \"&#125;\", canonicalizeForPath(value, encoded));</div><div class=\"line\">apply这个方法会在构建Request时由RequestBilder调用，以上面的实例为例子，name就是\"owner\" ,value就是调用该方法时传进来的值，其实就只是Stirng.replace()方法。</div><div class=\"line\">到这里，Buidler已经完成了</div><div class=\"line\">- 准备callAdapter，</div><div class=\"line\">- createResponseConverter</div><div class=\"line\">- 和填充parameterHandlers数组的任务</div><div class=\"line\">直接new一个ServiceMethod出来就好了</div><div class=\"line\"></div><div class=\"line\">ServiceMethod(Builder&lt;T&gt; builder) &#123;</div><div class=\"line\">    this.callFactory = builder.retrofit.callFactory();  // okhttp3.Call.Factory</div><div class=\"line\">    this.callAdapter = builder.callAdapter; //</div><div class=\"line\">    this.baseUrl = builder.retrofit.baseUrl(); //这个就是</div><div class=\"line\">    this.responseConverter = builder.responseConverter; // GsonConverter</div><div class=\"line\">    this.httpMethod = builder.httpMethod; //@GET</div><div class=\"line\">    this.relativeUrl = builder.relativeUrl; //@Path</div><div class=\"line\">    this.headers = builder.headers; //@Header</div><div class=\"line\">    this.contentType = builder.contentType;  //application/json这种</div><div class=\"line\">    this.hasBody = builder.hasBody;</div><div class=\"line\">    this.isFormEncoded = builder.isFormEncoded;</div><div class=\"line\">    this.isMultipart = builder.isMultipart;</div><div class=\"line\">    this.parameterHandlers = builder.parameterHandlers;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">上面最重要的三个方法讲完了第一个。</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-第二个方法和OkHttpCall\"><a href=\"#1-3-第二个方法和OkHttpCall\" class=\"headerlink\" title=\"1.3 第二个方法和OkHttpCall\"></a>1.3 第二个方法和OkHttpCall</h3><p>第二个方法:<br> OkHttpCall<Object> okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</p>\n<p>OkHttpCall的成员变量：<br>okhttp3.Call rawCall //用于发起请求<br>ServiceMethod<T, ?> serviceMethod;  //这就是刚才实例化的serviceMethod对象<br>这个类相对简单，主要看execute方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response&lt;T&gt; <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">   okhttp3.Call call;</div><div class=\"line\">   <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already executed.\"</span>);</div><div class=\"line\">     executed = <span class=\"keyword\">true</span>;</div><div class=\"line\">     call = rawCall;</div><div class=\"line\">     <span class=\"keyword\">if</span> (call == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         call = rawCall = createRawCall();</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException | RuntimeException e) &#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> parseResponse(call.execute()); <span class=\"comment\">//建立连接，发起请求，解析response都在这里了（都在一条线程上）。execute是okHttp的方法。</span></div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>还记得最简单的Demo吗，同步执行网络请求<br>Call<List<Contributor>&gt; call = github.contributors(“square”, “retrofit”);<br>List<Contributor> contributors = call.execute().body();<br>这也是Retrofit2.Call.execute方法最终就是走到了这里</p>\n<p>createRawCall方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">okhttp3.Request request = serviceMethod.toRequest(args);</div><div class=\"line\">okhttp3.Call call = serviceMethod.callFactory.newCall(request);</div><div class=\"line\">   <span class=\"keyword\">if</span> (call == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Call.Factory returned null.\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> call;</div></pre></td></tr></table></figure></p>\n<p>parseRespnse的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Response&lt;T&gt; <span class=\"title\">parseResponse</span><span class=\"params\">(okhttp3.Response rawResponse)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">  ResponseBody rawBody = rawResponse.body(); <span class=\"comment\">//有用的信息在这里</span></div><div class=\"line\">  <span class=\"comment\">// Remove the body's source (the only stateful object) so we can pass the response along.</span></div><div class=\"line\">  rawResponse = rawResponse.newBuilder()</div><div class=\"line\">      .body(<span class=\"keyword\">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class=\"line\">      .build(); <span class=\"comment\">//根据服务器返回的contentType和contentLength创建一个新的response用于检测200</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">int</span> code = rawResponse.code();</div><div class=\"line\">  <span class=\"keyword\">if</span> (code &lt; <span class=\"number\">200</span> || code &gt;= <span class=\"number\">300</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// Buffer the entire body to avoid future I/O.</span></div><div class=\"line\">      ResponseBody bufferedBody = Utils.buffer(rawBody);</div><div class=\"line\">      <span class=\"keyword\">return</span> Response.error(bufferedBody, rawResponse); <span class=\"comment\">//创建一个body为null的Retrofit2.Response</span></div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      rawBody.close();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &#123;</div><div class=\"line\">    rawBody.close();</div><div class=\"line\">    <span class=\"keyword\">return</span> Response.success(<span class=\"keyword\">null</span>, rawResponse);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  ExceptionCatchingRequestBody catchingBody = <span class=\"keyword\">new</span> ExceptionCatchingRequestBody(rawBody);</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    T body = serviceMethod.toResponse(catchingBody); <span class=\"comment\">//调用ServiceMethod的responseConverter去转换，前面说过，responseConverter是在builder初始化的时候根据策略，从Retrofit的converterFactories中遍历，找到了就返回。</span></div><div class=\"line\">    <span class=\"keyword\">return</span> Response.success(body, rawResponse); <span class=\"comment\">//返回创建一个body为定义好的数据类型的Retrofit2.Response，一般情况下，调用Response.body()就能得到所要的实体数据。</span></div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// If the underlying source threw an exception, propagate that rather than indicating it was</span></div><div class=\"line\">    <span class=\"comment\">// a runtime exception.</span></div><div class=\"line\">    catchingBody.throwIfCaught();</div><div class=\"line\">    <span class=\"keyword\">throw</span> e;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里可以得知，Retrofit对于状态码的处理，1XX和3XX以上全部走到error中</p>\n<p>execute是同步方法，enqueue是异步请求的方法，底层其实就调用了OkHttp.Call.enqueue()，所以说Retrofit本身并不负责创建网络请求，线程调度。只做了parseRespnse的方法，另外，OkHttp和Retrofit本身并不负责把Response推到主线程上，Android 平台可能要注意。</p>\n<h3 id=\"1-4-第三个方法和AdapterFactory\"><a href=\"#1-4-第三个方法和AdapterFactory\" class=\"headerlink\" title=\"1.4 第三个方法和AdapterFactory\"></a>1.4 第三个方法和AdapterFactory</h3><p>return serviceMethod.callAdapter.adapt(okHttpCall); //这个return需要的是Object,涉及到动态代理，可以无视。</p>\n<p>回头看一下serviceMethod的createCallAdapter方法，就是从retrofit对象的adapterFactories中一个个遍历：</p>\n<blockquote>\n<p>CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this)；</p>\n</blockquote>\n<p>找到之后就返回，默认的实现有DefaultCallAdapterFactory和ExecutorCallAdapterFactory以及RxjavaCallAdapterFactory。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">在DefaultCallAdapterFactory中的处理方式是</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> responseType;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">Call&lt;R&gt; <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> call;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">ExecutorCallAdapterFactory的处理方式是</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> responseType;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call&lt;Object&gt; <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>其实就是将callback丢到一个线程池callbackExecutor中，这个线程池可以通过Retrofit创建的时候配置，简单来说就是response会在这个线程池中回调。</p>\n<p> RxjavaCallAdapterFactory的做法是<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"keyword\">public</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">    Class&lt;?&gt; rawType = getRawType(returnType);</div><div class=\"line\">    String canonicalName = rawType.getCanonicalName();</div><div class=\"line\">    <span class=\"keyword\">boolean</span> isSingle = <span class=\"string\">\"rx.Single\"</span>.equals(canonicalName); <span class=\"comment\">//直接看包名。。。。。</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> isCompletable = <span class=\"string\">\"rx.Completable\"</span>.equals(canonicalName);</div><div class=\"line\">    <span class=\"keyword\">if</span> (rawType != Observable.class &amp;&amp; !isSingle &amp;&amp; !isCompletable) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isCompletable &amp;&amp; !(returnType <span class=\"keyword\">instanceof</span> ParameterizedType)) &#123;</div><div class=\"line\">      String name = isSingle ? <span class=\"string\">\"Single\"</span> : <span class=\"string\">\"Observable\"</span>;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(name + <span class=\"string\">\" return type must be parameterized\"</span></div><div class=\"line\">          + <span class=\"string\">\" as \"</span> + name + <span class=\"string\">\"&lt;Foo&gt; or \"</span> + name + <span class=\"string\">\"&lt;? extends Foo&gt;\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (isCompletable) &#123;</div><div class=\"line\">      <span class=\"comment\">// Add Completable-converter wrapper from a separate class. This defers classloading such that</span></div><div class=\"line\">      <span class=\"comment\">// regular Observable operation can be leveraged without relying on this unstable RxJava API.</span></div><div class=\"line\">      <span class=\"comment\">// Note that this has to be done separately since Completable doesn't have a parametrized</span></div><div class=\"line\">      <span class=\"comment\">// type.</span></div><div class=\"line\">      <span class=\"keyword\">return</span> CompletableHelper.createCallAdapter(scheduler);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    CallAdapter&lt;Observable&lt;?&gt;&gt; callAdapter = getCallAdapter(returnType, scheduler);</div><div class=\"line\">    <span class=\"keyword\">if</span> (isSingle) &#123;</div><div class=\"line\">      <span class=\"comment\">// Add Single-converter wrapper from a separate class. This defers classloading such that</span></div><div class=\"line\">      <span class=\"comment\">// regular Observable operation can be leveraged without relying on this unstable RxJava API.</span></div><div class=\"line\">      <span class=\"keyword\">return</span> SingleHelper.makeSingle(callAdapter);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> callAdapter;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-5-使用Retrofit的best-practices\"><a href=\"#1-5-使用Retrofit的best-practices\" class=\"headerlink\" title=\"1.5 使用Retrofit的best practices\"></a>1.5 使用Retrofit的best practices</h3><p>到这里，retrofit的工作流程就通过三个方法讲完了，接下来根据jake wharton的talk <a href=\"https://www.youtube.com/watch?v=t34AQlblSeE\">making retrofit work for you</a>来讲几个best practice。</p>\n<h4 id=\"1-5-1-end-point-不一样怎么办\"><a href=\"#1-5-1-end-point-不一样怎么办\" class=\"headerlink\" title=\"1.5.1 end point 不一样怎么办\"></a>1.5.1 end point 不一样怎么办</h4><p>默认情况下，如果不指定client,每一次都会创建一个新的OkHttpClient，这样做就丧失了disk caching,connection pooling等优势。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/different_end_point.JPG\" alt=\"endpoint\">    </p>\n<p>所以需要提取出一个OkHttpClient,解决方式很简单<br><img src=\"http://odzl05jxx.bkt.clouddn.com/different_end_point_teh_right_way.JPG\" alt=\"\"></p>\n<h4 id=\"1-5-2-不要创建多个HttpClient\"><a href=\"#1-5-2-不要创建多个HttpClient\" class=\"headerlink\" title=\"1.5.2 不要创建多个HttpClient\"></a>1.5.2 不要创建多个HttpClient</h4><p>shallow copy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient();</div><div class=\"line\"></div><div class=\"line\">OkHttpClient clientFoo = client.newBuilder().addInterceptor(<span class=\"keyword\">new</span> FooInterceptor()).build()</div><div class=\"line\"></div><div class=\"line\">OkHttpClient clientBar = client.newBuilder().readTimeOut(<span class=\"number\">20</span>,SECONDS)</div><div class=\"line\">.writeTimeOut(<span class=\"number\">20</span>,SECONDS).build()</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-5-3-有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\"><a href=\"#1-5-3-有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\" class=\"headerlink\" title=\"1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）\"></a>1.5.3 有的接口需要认证（加Header），有的不需要（比如登录，忘记密码）</h4><p>一般可能会想到在OkHttp的Interceptor中去判断url然后手动加上header，一种更好的解决方式是，假定所有的API都需要加Header，对于登录和忘记密码的Api,这样写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@POST</span>(<span class=\"string\">\"/login\"</span>)</div><div class=\"line\"><span class=\"meta\">@Headers</span>(<span class=\"string\">\"No-Authentication: true\"</span>)</div><div class=\"line\"><span class=\"function\">Call&lt;User&gt; <span class=\"title\">login</span><span class=\"params\">(@Body LoginRequest request)</span></span></div></pre></td></tr></table></figure></p>\n<p>//这个header对于server是不可见的，现在在Interceptor中，<br>只要判断request.header(“No-Authentication”)==null 即表示该接口需要加上header。<br>所以，对于特定接口的筛选可以，采用这种方式。</p>\n<h4 id=\"1-5-4-Converters将byte变成java对象，底层的解析器不要创建多个\"><a href=\"#1-5-4-Converters将byte变成java对象，底层的解析器不要创建多个\" class=\"headerlink\" title=\"1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个\"></a>1.5.4 Converters将byte变成java对象，底层的解析器不要创建多个</h4><p>addConverterFactory，和之前的创建两个httpclient一样，人们也很容易创建两个解析器。解决方法也很实在，提取出来公用即可。<br><img src=\"http://odzl05jxx.bkt.clouddn.com/creating%20two%20convertors.JPG\" alt=\"\"></p>\n<h4 id=\"1-5-5-addConverterFactory可以调用多次\"><a href=\"#1-5-5-addConverterFactory可以调用多次\" class=\"headerlink\" title=\"1.5.5 addConverterFactory可以调用多次\"></a>1.5.5 addConverterFactory可以调用多次</h4><p>假如一个接口返回json，一个接口返回proto。不要试图创建多个retrofit实例。这样就可以了<br><img src=\"http://odzl05jxx.bkt.clouddn.com/different_response.JPG\" alt=\"\"></p>\n<p>底层的原理是这样的。<br>User是Proto,Friend是Json。 Proto都extends一个protoType class，所以只要看下是否 instanceof proto就可以了。这一切都是在serviceMethod创建过程中判断的。这里顺序很重要。由于gson基本能够序列化一切，所以gson总是会认为自己可以成功。所以要把protoConverter放在前面。<br> GsonConverterFactory, SimpleXmlConverterFactory converters , they say yes to everyThing. 所以如果出现这种情况怎么办？<br> 首先定义自己的注解<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"meta\">@interface</span> Xml &#123;&#125;</div><div class=\"line\"> <span class=\"meta\">@interface</span> Json &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Service</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/User\"</span>) <span class=\"meta\">@Xml</span></div><div class=\"line\">    <span class=\"function\">Call&lt;User&gt; <span class=\"title\">user</span><span class=\"params\">()</span></span>; <span class=\"comment\">// User是XML</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/Friends\"</span>) <span class=\"meta\">@Json</span></div><div class=\"line\">    <span class=\"function\">Call&lt;Friends&gt; <span class=\"title\">friends</span><span class=\"params\">()</span></span>;  <span class=\"comment\">//Friends是Json</span></div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XmlOrJsonConverterFactroy</span> <span class=\"title\">extend</span> <span class=\"title\">Converter</span>.<span class=\"title\">Factory</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Converter.Factory xml = <span class=\"comment\">///;</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Converter.Factory json = <span class=\"comment\">//....;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody,?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit)&#123;</div><div class=\"line\">        <span class=\"comment\">// annotations就包含了刚才我们添加的注解</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Annotation annotation : annotations)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(annotation.getClass == Xml.class)&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> xml.reponseBodyConverter(type,annotations,retrofit);</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(annotation.getClass == Json.class)&#123;</div><div class=\"line\">                <span class=\"comment\">// json</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; 都不是。 会去找下一个Converter..</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">[AnnotatedConverterFactory用于自定义类型](https:<span class=\"comment\">//github.com/square/retrofit/blob/master/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java)</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"1-5-6-服务器返回的数据中包括一些metaData\"><a href=\"#1-5-6-服务器返回的数据中包括一些metaData\" class=\"headerlink\" title=\"1.5.6 服务器返回的数据中包括一些metaData\"></a>1.5.6 服务器返回的数据中包括一些metaData</h4><p>使用delegate的方式去除这些metadata，只获取想要的response实体对象<br><img src=\"http://odzl05jxx.bkt.clouddn.com/delegaet_converters.JPG\" alt=\"\"><br>但这些metaData是有用的。。怎么处理<br>可以在convert中集中处理自定义错误码。</p>\n<h4 id=\"1-5-7-和Rxjava配合使用\"><a href=\"#1-5-7-和Rxjava配合使用\" class=\"headerlink\" title=\"1.5.7 和Rxjava配合使用\"></a>1.5.7 和Rxjava配合使用</h4><p>CallAdapterFactory和ConverterFactory类似，也可以自定义，所以这样可以直接将所有的Observable返回到主线程</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/always_observe_on_mian_thread.JPG\" alt=\"\"></p>\n<p>所以，Retrofit就是将HttpClient、Converter和CallAdapter这三样职能结合起来，又提供了足够的定制化。</p>\n<h3 id=\"2-OkHttp\"><a href=\"#2-OkHttp\" class=\"headerlink\" title=\"2. OkHttp\"></a>2. OkHttp</h3><h3 id=\"3-A-few-‘ok’-libraries\"><a href=\"#3-A-few-‘ok’-libraries\" class=\"headerlink\" title=\"3. A few ‘ok’ libraries\"></a>3. A few ‘ok’ libraries</h3><p>why moshi ? why Retrofit call can be clone cheap？<br>why SinkedSource?<br>why protolBuffer cost less ?</p>\n<h3 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h3><ol>\n<li><a href=\"https://blog.piasy.com/2016/06/25/Understand-Retrofit/\">Paisy解析Retrofit</a></li>\n<li><a href=\"https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit\">open-sourse-projetc解析Retrofit</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=t34AQlblSeE\">Making Retrofit Work For You by Jake Wharton</a></li>\n</ol>"},{"title":"2017-07-12-scrapy-notes","date":"2017-07-12T00:37:55.000Z","_content":"\n## Scrappy框架学习\n首先建议安装virtualenv，在env中进行操作。\n\n![](http://odzl05jxx.bkt.clouddn.com/u=3180342558,2746910171&fm=214&gp=0.jpg?imageView2/2/w/600)\n\n<!--more-->\npip install Scrappy 报错\n# error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\": http://landinghub.visualstudio.com/visual-cpp-build-tools\n解决办法是安装vs,4个GB左右。。。。\n\n\n\n以下开始在命令行中操作：\n安装完毕后，首先创建scrapy 项目\n>scrapy startproject tutorial #创建一个project。会生成一个tutorial的文件夹，在tutorial/spiders文件夹中新建一个quotes_spider.py\n\n参考[Scrapy教程](http://cuiqingcai.com/3952.html/2)\n```python\nimport scrapy\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n\n    def start_requests(self):\n        urls = [\n            'http://quotes.toscrape.com/page/1/',\n            'http://quotes.toscrape.com/page/2/',\n        ]\n        for url in urls:\n            yield scrapy.Request(url=url, callback=self.parse) \n     #这个callback就是response拉下来之后的解析过程 \n     #下面的这个做法只是把response写到一个文件中，通常还可以使用css或者xpath解析获得相应值。\n\n    def parse(self, response):\n        page = response.url.split(\"/\")[-2]\n        filename = 'quotes-%s.html' % page\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n        self.log('Saved file %s' % filename)\n```\n\n> scrapy crawl quotes #开始爬quotes.toscrape.com的内容,需要切换到tutorial文件夹下\n\n>scrapy shell 'http://quotes.toscrape.com/page/1/' #从Response中提取所需的值  \n\n输入就能得到大致这样的交互\n```\n>>> response.css('title::text').extract()\n['Quotes to Scrape']\n```\n由于没有安装vc2014，只能在virtualenv中运行,pycharm中也是显示scrapy没有安装。只能用命令行运行。想要看具体的值需要这样\n```python\n>>> response.css('title::text').extract_first()\n'Quotes to Scrape'\n\n>>> response.css('title::text').re(r'Quotes.*') #这里是正则了\n['Quotes to Scrape']\n\n#或者使用xpath\n>>> response.xpath('//title/text()').extract_first()\n'Quotes to Scrape'\n```\n\n处理登录请求，afterLogin\n网站登录多数需要提交一个表单（Dict）\n> formadata = {'userName':  'Bob','pwd'：123456}\n中间件(MiddleWare)的作用\nCookie，UserAgent处理 setting.py中设置需要的参数，Cookie默认是接受的\nPipeLine是用来持久化的，中间件用于处理Cookie,Ajax等，rules用于筛选需要跟进的url\n\n\n\n## 2. MongoDB存储","source":"_posts/2017-07-12-scrapy-notes.md","raw":"---\ntitle: 2017-07-12-scrapy-notes\ndate: 2017-07-12 08:37:55\ntags: [python]\n---\n\n## Scrappy框架学习\n首先建议安装virtualenv，在env中进行操作。\n\n![](http://odzl05jxx.bkt.clouddn.com/u=3180342558,2746910171&fm=214&gp=0.jpg?imageView2/2/w/600)\n\n<!--more-->\npip install Scrappy 报错\n# error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\": http://landinghub.visualstudio.com/visual-cpp-build-tools\n解决办法是安装vs,4个GB左右。。。。\n\n\n\n以下开始在命令行中操作：\n安装完毕后，首先创建scrapy 项目\n>scrapy startproject tutorial #创建一个project。会生成一个tutorial的文件夹，在tutorial/spiders文件夹中新建一个quotes_spider.py\n\n参考[Scrapy教程](http://cuiqingcai.com/3952.html/2)\n```python\nimport scrapy\nclass QuotesSpider(scrapy.Spider):\n    name = \"quotes\"\n\n    def start_requests(self):\n        urls = [\n            'http://quotes.toscrape.com/page/1/',\n            'http://quotes.toscrape.com/page/2/',\n        ]\n        for url in urls:\n            yield scrapy.Request(url=url, callback=self.parse) \n     #这个callback就是response拉下来之后的解析过程 \n     #下面的这个做法只是把response写到一个文件中，通常还可以使用css或者xpath解析获得相应值。\n\n    def parse(self, response):\n        page = response.url.split(\"/\")[-2]\n        filename = 'quotes-%s.html' % page\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n        self.log('Saved file %s' % filename)\n```\n\n> scrapy crawl quotes #开始爬quotes.toscrape.com的内容,需要切换到tutorial文件夹下\n\n>scrapy shell 'http://quotes.toscrape.com/page/1/' #从Response中提取所需的值  \n\n输入就能得到大致这样的交互\n```\n>>> response.css('title::text').extract()\n['Quotes to Scrape']\n```\n由于没有安装vc2014，只能在virtualenv中运行,pycharm中也是显示scrapy没有安装。只能用命令行运行。想要看具体的值需要这样\n```python\n>>> response.css('title::text').extract_first()\n'Quotes to Scrape'\n\n>>> response.css('title::text').re(r'Quotes.*') #这里是正则了\n['Quotes to Scrape']\n\n#或者使用xpath\n>>> response.xpath('//title/text()').extract_first()\n'Quotes to Scrape'\n```\n\n处理登录请求，afterLogin\n网站登录多数需要提交一个表单（Dict）\n> formadata = {'userName':  'Bob','pwd'：123456}\n中间件(MiddleWare)的作用\nCookie，UserAgent处理 setting.py中设置需要的参数，Cookie默认是接受的\nPipeLine是用来持久化的，中间件用于处理Cookie,Ajax等，rules用于筛选需要跟进的url\n\n\n\n## 2. MongoDB存储","slug":"2017-07-12-scrapy-notes","published":1,"updated":"2017-07-20T16:01:31.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnjo002fbovrdwig0wvk","content":"<h2 id=\"Scrappy框架学习\"><a href=\"#Scrappy框架学习\" class=\"headerlink\" title=\"Scrappy框架学习\"></a>Scrappy框架学习</h2><p>首先建议安装virtualenv，在env中进行操作。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/u=3180342558,2746910171&amp;fm=214&amp;gp=0.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>pip install Scrappy 报错</p>\n<h1 id=\"error-Microsoft-Visual-C-14-0-is-required-Get-it-with-“Microsoft-Visual-C-Build-Tools”-http-landinghub-visualstudio-com-visual-cpp-build-tools\"><a href=\"#error-Microsoft-Visual-C-14-0-is-required-Get-it-with-“Microsoft-Visual-C-Build-Tools”-http-landinghub-visualstudio-com-visual-cpp-build-tools\" class=\"headerlink\" title=\"error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”: http://landinghub.visualstudio.com/visual-cpp-build-tools\"></a>error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”: <a href=\"http://landinghub.visualstudio.com/visual-cpp-build-tools\">http://landinghub.visualstudio.com/visual-cpp-build-tools</a></h1><p>解决办法是安装vs,4个GB左右。。。。</p>\n<p>以下开始在命令行中操作：<br>安装完毕后，首先创建scrapy 项目</p>\n<blockquote>\n<p>scrapy startproject tutorial #创建一个project。会生成一个tutorial的文件夹，在tutorial/spiders文件夹中新建一个quotes_spider.py</p>\n</blockquote>\n<p>参考<a href=\"http://cuiqingcai.com/3952.html/2\">Scrapy教程</a><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> scrapy</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></div><div class=\"line\">    name = <span class=\"string\">\"quotes\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_requests</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        urls = [</div><div class=\"line\">            <span class=\"string\">'http://quotes.toscrape.com/page/1/'</span>,</div><div class=\"line\">            <span class=\"string\">'http://quotes.toscrape.com/page/2/'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">        <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> urls:</div><div class=\"line\">            <span class=\"keyword\">yield</span> scrapy.Request(url=url, callback=self.parse) </div><div class=\"line\">     <span class=\"comment\">#这个callback就是response拉下来之后的解析过程 </span></div><div class=\"line\">     <span class=\"comment\">#下面的这个做法只是把response写到一个文件中，通常还可以使用css或者xpath解析获得相应值。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></div><div class=\"line\">        page = response.url.split(<span class=\"string\">\"/\"</span>)[<span class=\"number\">-2</span>]</div><div class=\"line\">        filename = <span class=\"string\">'quotes-%s.html'</span> % page</div><div class=\"line\">        <span class=\"keyword\">with</span> open(filename, <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            f.write(response.body)</div><div class=\"line\">        self.log(<span class=\"string\">'Saved file %s'</span> % filename)</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>scrapy crawl quotes #开始爬quotes.toscrape.com的内容,需要切换到tutorial文件夹下</p>\n<p>scrapy shell ‘<a href=\"http://quotes.toscrape.com/page/1/\">http://quotes.toscrape.com/page/1/</a>‘ #从Response中提取所需的值  </p>\n</blockquote>\n<p>输入就能得到大致这样的交互<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; response.css(&apos;title::text&apos;).extract()</div><div class=\"line\">[&apos;Quotes to Scrape&apos;]</div></pre></td></tr></table></figure></p>\n<p>由于没有安装vc2014，只能在virtualenv中运行,pycharm中也是显示scrapy没有安装。只能用命令行运行。想要看具体的值需要这样<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.css(<span class=\"string\">'title::text'</span>).extract_first()</div><div class=\"line\"><span class=\"string\">'Quotes to Scrape'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.css(<span class=\"string\">'title::text'</span>).re(<span class=\"string\">r'Quotes.*'</span>) <span class=\"comment\">#这里是正则了</span></div><div class=\"line\">[<span class=\"string\">'Quotes to Scrape'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#或者使用xpath</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.xpath(<span class=\"string\">'//title/text()'</span>).extract_first()</div><div class=\"line\"><span class=\"string\">'Quotes to Scrape'</span></div></pre></td></tr></table></figure></p>\n<p>处理登录请求，afterLogin<br>网站登录多数需要提交一个表单（Dict）</p>\n<blockquote>\n<p>formadata = {‘userName’:  ‘Bob’,’pwd’：123456}<br>中间件(MiddleWare)的作用<br>Cookie，UserAgent处理 setting.py中设置需要的参数，Cookie默认是接受的<br>PipeLine是用来持久化的，中间件用于处理Cookie,Ajax等，rules用于筛选需要跟进的url</p>\n</blockquote>\n<h2 id=\"2-MongoDB存储\"><a href=\"#2-MongoDB存储\" class=\"headerlink\" title=\"2. MongoDB存储\"></a>2. MongoDB存储</h2>","excerpt":"<h2 id=\"Scrappy框架学习\"><a href=\"#Scrappy框架学习\" class=\"headerlink\" title=\"Scrappy框架学习\"></a>Scrappy框架学习</h2><p>首先建议安装virtualenv，在env中进行操作。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/u=3180342558,2746910171&amp;fm=214&amp;gp=0.jpg?imageView2/2/w/600\" alt=\"\"></p>","more":"<p>pip install Scrappy 报错</p>\n<h1 id=\"error-Microsoft-Visual-C-14-0-is-required-Get-it-with-“Microsoft-Visual-C-Build-Tools”-http-landinghub-visualstudio-com-visual-cpp-build-tools\"><a href=\"#error-Microsoft-Visual-C-14-0-is-required-Get-it-with-“Microsoft-Visual-C-Build-Tools”-http-landinghub-visualstudio-com-visual-cpp-build-tools\" class=\"headerlink\" title=\"error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”: http://landinghub.visualstudio.com/visual-cpp-build-tools\"></a>error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”: <a href=\"http://landinghub.visualstudio.com/visual-cpp-build-tools\">http://landinghub.visualstudio.com/visual-cpp-build-tools</a></h1><p>解决办法是安装vs,4个GB左右。。。。</p>\n<p>以下开始在命令行中操作：<br>安装完毕后，首先创建scrapy 项目</p>\n<blockquote>\n<p>scrapy startproject tutorial #创建一个project。会生成一个tutorial的文件夹，在tutorial/spiders文件夹中新建一个quotes_spider.py</p>\n</blockquote>\n<p>参考<a href=\"http://cuiqingcai.com/3952.html/2\">Scrapy教程</a><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> scrapy</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></div><div class=\"line\">    name = <span class=\"string\">\"quotes\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_requests</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        urls = [</div><div class=\"line\">            <span class=\"string\">'http://quotes.toscrape.com/page/1/'</span>,</div><div class=\"line\">            <span class=\"string\">'http://quotes.toscrape.com/page/2/'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">        <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> urls:</div><div class=\"line\">            <span class=\"keyword\">yield</span> scrapy.Request(url=url, callback=self.parse) </div><div class=\"line\">     <span class=\"comment\">#这个callback就是response拉下来之后的解析过程 </span></div><div class=\"line\">     <span class=\"comment\">#下面的这个做法只是把response写到一个文件中，通常还可以使用css或者xpath解析获得相应值。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></div><div class=\"line\">        page = response.url.split(<span class=\"string\">\"/\"</span>)[<span class=\"number\">-2</span>]</div><div class=\"line\">        filename = <span class=\"string\">'quotes-%s.html'</span> % page</div><div class=\"line\">        <span class=\"keyword\">with</span> open(filename, <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">            f.write(response.body)</div><div class=\"line\">        self.log(<span class=\"string\">'Saved file %s'</span> % filename)</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>scrapy crawl quotes #开始爬quotes.toscrape.com的内容,需要切换到tutorial文件夹下</p>\n<p>scrapy shell ‘<a href=\"http://quotes.toscrape.com/page/1/\">http://quotes.toscrape.com/page/1/</a>‘ #从Response中提取所需的值  </p>\n</blockquote>\n<p>输入就能得到大致这样的交互<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; response.css(&apos;title::text&apos;).extract()</div><div class=\"line\">[&apos;Quotes to Scrape&apos;]</div></pre></td></tr></table></figure></p>\n<p>由于没有安装vc2014，只能在virtualenv中运行,pycharm中也是显示scrapy没有安装。只能用命令行运行。想要看具体的值需要这样<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.css(<span class=\"string\">'title::text'</span>).extract_first()</div><div class=\"line\"><span class=\"string\">'Quotes to Scrape'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.css(<span class=\"string\">'title::text'</span>).re(<span class=\"string\">r'Quotes.*'</span>) <span class=\"comment\">#这里是正则了</span></div><div class=\"line\">[<span class=\"string\">'Quotes to Scrape'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#或者使用xpath</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>response.xpath(<span class=\"string\">'//title/text()'</span>).extract_first()</div><div class=\"line\"><span class=\"string\">'Quotes to Scrape'</span></div></pre></td></tr></table></figure></p>\n<p>处理登录请求，afterLogin<br>网站登录多数需要提交一个表单（Dict）</p>\n<blockquote>\n<p>formadata = {‘userName’:  ‘Bob’,’pwd’：123456}<br>中间件(MiddleWare)的作用<br>Cookie，UserAgent处理 setting.py中设置需要的参数，Cookie默认是接受的<br>PipeLine是用来持久化的，中间件用于处理Cookie,Ajax等，rules用于筛选需要跟进的url</p>\n</blockquote>\n<h2 id=\"2-MongoDB存储\"><a href=\"#2-MongoDB存储\" class=\"headerlink\" title=\"2. MongoDB存储\"></a>2. MongoDB存储</h2>"},{"title":"linux常用命令扩展","date":"2017-06-18T08:51:49.000Z","_content":"> 一些linux的常用命令，linux环境下运行server ,bash的语法\n>  \n\n![](http://odzl05jxx.bkt.clouddn.com/ChMkJ1gq00WIXw_GAA47r_8gjqgAAXxJAH8qOMADjvH566.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n1. 常用软件安装\n[utorrent](http://blog.topspeedsnail.com/archives/5752)\napache,mysql\n\n2. 环境变量怎么改\n平时在shell中输入sudo XXX ,系统是如何知道怎么执行这条指令的呢。首先，可以查看which XXX ，用于查找某项指令对应的文件的位置。而像sudo这种都放在PATH位置，系统会在几个关键位置查找sudo命令。用户本身完全可以创建一个叫做sudo的文件chmod+X ，然后运行这个sudo。\n```\n查看PATH : echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games (注意，系统是按照这个顺序找的，如果在第一个目录下找到一个叫sudo的东西，就会直接执行了，所以这里是有潜在的危险的)\n看下哪个命令对应的位置在哪里\nwhich XXXk\n比如sudo 就放在 /usr/bin/sudo\n```\n\n> $PATH\n环境变量修改在~./bashrc或者 ~./profile里面\n具体来说，比如要把/etc/apache/bin目录添加到PATH中\nPATH=$PATH:/etc/apache/bin  #只对本次回话有效\n或者  PATH=$PATH:/etc/apache/bin #在~./bashrc或者~./profile里面添加这句话\n\n3. alias设置\nvi 中输入 /XXX 可以搜索\nvi ~/.bashrc \n添加 alias yourcommand='ls -alr' \n重开session即可生效\n\n4. \n\n\n","source":"_posts/2017-06-18-linux-commands-extended.md","raw":"---\ntitle: linux常用命令扩展\ndate: 2017-06-18 16:51:49\ncategories: blog\ntags: \n  - linux\n---\n> 一些linux的常用命令，linux环境下运行server ,bash的语法\n>  \n\n![](http://odzl05jxx.bkt.clouddn.com/ChMkJ1gq00WIXw_GAA47r_8gjqgAAXxJAH8qOMADjvH566.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n1. 常用软件安装\n[utorrent](http://blog.topspeedsnail.com/archives/5752)\napache,mysql\n\n2. 环境变量怎么改\n平时在shell中输入sudo XXX ,系统是如何知道怎么执行这条指令的呢。首先，可以查看which XXX ，用于查找某项指令对应的文件的位置。而像sudo这种都放在PATH位置，系统会在几个关键位置查找sudo命令。用户本身完全可以创建一个叫做sudo的文件chmod+X ，然后运行这个sudo。\n```\n查看PATH : echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games (注意，系统是按照这个顺序找的，如果在第一个目录下找到一个叫sudo的东西，就会直接执行了，所以这里是有潜在的危险的)\n看下哪个命令对应的位置在哪里\nwhich XXXk\n比如sudo 就放在 /usr/bin/sudo\n```\n\n> $PATH\n环境变量修改在~./bashrc或者 ~./profile里面\n具体来说，比如要把/etc/apache/bin目录添加到PATH中\nPATH=$PATH:/etc/apache/bin  #只对本次回话有效\n或者  PATH=$PATH:/etc/apache/bin #在~./bashrc或者~./profile里面添加这句话\n\n3. alias设置\nvi 中输入 /XXX 可以搜索\nvi ~/.bashrc \n添加 alias yourcommand='ls -alr' \n重开session即可生效\n\n4. \n\n\n","slug":"2017-06-18-linux-commands-extended","published":1,"updated":"2017-07-08T15:01:38.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnjt002hbovrx0hr12kk","content":"<blockquote>\n<p>一些linux的常用命令，linux环境下运行server ,bash的语法</p>\n</blockquote>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/ChMkJ1gq00WIXw_GAA47r_8gjqgAAXxJAH8qOMADjvH566.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<a id=\"more\"></a>\n<ol>\n<li><p>常用软件安装<br><a href=\"http://blog.topspeedsnail.com/archives/5752\">utorrent</a><br>apache,mysql</p>\n</li>\n<li><p>环境变量怎么改<br>平时在shell中输入sudo XXX ,系统是如何知道怎么执行这条指令的呢。首先，可以查看which XXX ，用于查找某项指令对应的文件的位置。而像sudo这种都放在PATH位置，系统会在几个关键位置查找sudo命令。用户本身完全可以创建一个叫做sudo的文件chmod+X ，然后运行这个sudo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">查看PATH : echo $PATH</div><div class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games (注意，系统是按照这个顺序找的，如果在第一个目录下找到一个叫sudo的东西，就会直接执行了，所以这里是有潜在的危险的)</div><div class=\"line\">看下哪个命令对应的位置在哪里</div><div class=\"line\">which XXXk</div><div class=\"line\">比如sudo 就放在 /usr/bin/sudo</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>$PATH<br>环境变量修改在~./bashrc或者 ~./profile里面<br>具体来说，比如要把/etc/apache/bin目录添加到PATH中<br>PATH=$PATH:/etc/apache/bin  #只对本次回话有效<br>或者  PATH=$PATH:/etc/apache/bin #在~./bashrc或者~./profile里面添加这句话</p>\n</blockquote>\n<ol>\n<li><p>alias设置<br>vi 中输入 /XXX 可以搜索<br>vi ~/.bashrc<br>添加 alias yourcommand=’ls -alr’<br>重开session即可生效</p>\n</li>\n<li></li>\n</ol>\n","excerpt":"<blockquote>\n<p>一些linux的常用命令，linux环境下运行server ,bash的语法</p>\n</blockquote>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/ChMkJ1gq00WIXw_GAA47r_8gjqgAAXxJAH8qOMADjvH566.jpg?imageView2/2/w/600\" alt=\"\"></p>","more":"<ol>\n<li><p>常用软件安装<br><a href=\"http://blog.topspeedsnail.com/archives/5752\">utorrent</a><br>apache,mysql</p>\n</li>\n<li><p>环境变量怎么改<br>平时在shell中输入sudo XXX ,系统是如何知道怎么执行这条指令的呢。首先，可以查看which XXX ，用于查找某项指令对应的文件的位置。而像sudo这种都放在PATH位置，系统会在几个关键位置查找sudo命令。用户本身完全可以创建一个叫做sudo的文件chmod+X ，然后运行这个sudo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">查看PATH : echo $PATH</div><div class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games (注意，系统是按照这个顺序找的，如果在第一个目录下找到一个叫sudo的东西，就会直接执行了，所以这里是有潜在的危险的)</div><div class=\"line\">看下哪个命令对应的位置在哪里</div><div class=\"line\">which XXXk</div><div class=\"line\">比如sudo 就放在 /usr/bin/sudo</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>$PATH<br>环境变量修改在~./bashrc或者 ~./profile里面<br>具体来说，比如要把/etc/apache/bin目录添加到PATH中<br>PATH=$PATH:/etc/apache/bin  #只对本次回话有效<br>或者  PATH=$PATH:/etc/apache/bin #在~./bashrc或者~./profile里面添加这句话</p>\n</blockquote>\n<ol>\n<li><p>alias设置<br>vi 中输入 /XXX 可以搜索<br>vi ~/.bashrc<br>添加 alias yourcommand=’ls -alr’<br>重开session即可生效</p>\n</li>\n<li></li>\n</ol>"},{"title":"Fragment源码解析记录(supportLibrary 25.3.0)","date":"2017-07-12T00:37:23.000Z","_content":"\nWe been told Fragment itself should only trust official docs, the implementation detail are prone to any change any time, don't count on it!\n![](http://odzl05jxx.bkt.clouddn.com/2009528111321773591934.jpg?imageView2/2/w/600)\n<!--more-->\n\nFragment源码解析（support Library 25.3.0），不要以为看了源码就可以不鸟官方文档了，源码的内容经常变，只有官方的文档才是可靠的，谷歌保证会实现的效果。\n\n## 1. 概述\nFragment的核心类有这几个:\n\n> FragmentManager, FragmentTransaction, Fragment。而事实上前两个都是抽象类，\n>FragmentManager的实现类是FragmentManagerImpl，FragmentTransaction的实现类是BackStackRecord\n\n从日常使用Fragment的方式开始:\n```java\n((FragmentActivity) mActivity).getSupportFragmentManager()\n                    .beginTransaction().add(R.id.containerViewId,fragment).commit();\n```\n\n\n\n### 2.FragmentTransaction只是将动作添加到一个队列中了\nbeginTransaction获取了一个FragmentTransaction实例，来看add方法的实现:\n```java\n    @Override\n    public FragmentTransaction add(Fragment fragment, String tag) {\n        doAddOp(0, fragment, tag, OP_ADD);\n        return this;\n    }\n\n    @Override\n    public FragmentTransaction add(int containerViewId, Fragment fragment) {\n        doAddOp(containerViewId, fragment, null, OP_ADD);\n        return this;\n    }\n\n    @Override\n    public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) {\n        doAddOp(containerViewId, fragment, tag, OP_ADD);\n        return this;\n    }\n```\n\n不管是通过id还是Tag添加，都是调用同一个方法，传参不同而已\n```java\n    private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) {\n    //省略部分代码\n        fragment.mFragmentManager = mManager;\n        if (tag != null) {\n            fragment.mTag = tag;\n        }\n        //注意，进入这个方法的时候fragment已经实例化了，只是其中的回调方法还没有开始调用\n        if (containerViewId != 0) {\n            fragment.mContainerId = fragment.mFragmentId = containerViewId;\n        }\n\n        Op op = new Op();\n        op.cmd = opcmd; //这个cmd很重要，代表了是show、hide、add、remove等这些东西\n        op.fragment = fragment;\n        addOp(op);\n    }\n\n    //所有可能的操作细节都包含在这里面了。注意，这是线性的！\n    static final int OP_NULL = 0;\n    static final int OP_ADD = 1;\n    static final int OP_REPLACE = 2;\n    static final int OP_REMOVE = 3;\n    static final int OP_HIDE = 4;\n    static final int OP_SHOW = 5;\n    static final int OP_DETACH = 6;\n    static final int OP_ATTACH = 7;\n\n    //这个OP包装了了每一次操作的具体细节。\n    static final class Op {\n        int cmd;\n        Fragment fragment;\n        int enterAnim;\n        int exitAnim;\n        int popEnterAnim;\n        int popExitAnim;\n    }\n\n      void addOp(Op op) {\n        mOps.add(op); //往一个普通的ArrayList中添加一个op\n        op.enterAnim = mEnterAnim;\n        op.exitAnim = mExitAnim;\n        op.popEnterAnim = mPopEnterAnim;\n        op.popExitAnim = mPopExitAnim;\n    }\n\n```\n\n\n## 3.通过FragmentTransaction.commit执行操作\nFragmentFransaction只是将所有操作保留到一次Transaction的一个任务队列(ArrayList)中了。真正的执行需要提交事务，这和数据库的事务很像。\n```java\n    @Override\n    public int commit() {\n        return commitInternal(false);\n    }\n\n    @Override\n    public int commitAllowingStateLoss() {\n        return commitInternal(true);\n    }\n\n//上面两个函数的返回值 Returns the identifier of this transaction's back stack entry, if addToBackStack(String)} had been called.  Otherwise, returns a negative number. 如果调用过addToBackStack的话，返回这次操作在操作栈上的标识符。否则返回负数。\n\n int commitInternal(boolean allowStateLoss) {\n        if (mCommitted) throw new IllegalStateException(\"commit already called\");\n        if (FragmentManagerImpl.DEBUG) {\n            Log.v(TAG, \"Commit: \" + this);\n            LogWriter logw = new LogWriter(TAG);\n            PrintWriter pw = new PrintWriter(logw);\n            dump(\"  \", null, pw, null);\n            pw.close();\n        }\n        mCommitted = true;\n        if (mAddToBackStack) {//如果调用过addToBackStack，这个值就为true，否则为false\n            mIndex = mManager.allocBackStackIndex(this);// 将BackStackRecord添加到一个ArrayList的尾部，List不存在则创建\n        } else {\n            mIndex = -1;\n        }\n        mManager.enqueueAction(this, allowStateLoss); // 这里就是调用FragmnetManager的方法，添加到FragmentManager的mPendingActions中，并scheduleCommit（通过FragmnetHostCallBack往主线程post一条runnable）\n        return mIndex; //返回的就是本次事务的mIndex\n    }\n\n\n       // FragmentManagerImpl\n      /**这里就是被推送到主线程的runnable，注意，这里是异步的\n     * Only call from main thread!\n     */\n    public boolean execPendingActions() {\n        ensureExecReady(true);\n\n        boolean didSomething = false;\n        //这里就是不断的从mPendingAction中查找待执行的操作\n        while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) {\n            mExecutingActions = true;\n            try {\n                optimizeAndExecuteOps(mTmpRecords, mTmpIsPop); //从方法名大致能猜到这里是执行操作的地方,两个参数，第一个是待执行的操作的List，一个是对应每项操作是pop还push(出栈还是入栈)\n            } finally {\n                cleanupExec();\n            }\n            didSomething = true;\n        }\n\n        doPendingDeferredStart();\n\n        return didSomething;\n    }\n\n private void optimizeAndExecuteOps(ArrayList<BackStackRecord> records,\n            ArrayList<Boolean> isRecordPop) {\n    }\n随后调用了executeOpsTogether方法，接着调用\n        executeOps(records, isRecordPop, startIndex, endIndex);\n最终又走到了BackStackRecord的方法里面\n\n   /**\n     * Reverses the execution of the operations within this transaction. The Fragment states will\n     * only be modified if optimizations are not allowed.\n     *\n     * @param moveToState {@code true} if added fragments should be moved to their final state\n     *                    in unoptimized transactions\n     */\n    void executePopOps(boolean moveToState) {\n        for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) { //倒序执行,每一个ops包含了对一个Fragment的指令，遍历所有的ops\n            final Op op = mOps.get(opNum);\n            Fragment f = op.fragment;\n            f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition), mTransitionStyle);\n            switch (op.cmd) {\n                //这些操作全部只是设置一些变量的值，暂时还没到UI更改，具体的UI操作在moveToState里面\n                case OP_ADD:\n                    f.setNextAnim(op.popExitAnim);\n                    mManager.removeFragment(f);  //从FragmentManager的mAdded中移除该fragment，fragment的mAdded = false,mRemoving = true;\n                    break;\n                case OP_REMOVE:\n                    f.setNextAnim(op.popEnterAnim);\n                    mManager.addFragment(f, false);\n                    /** addFragment里面有这么一段  \n       if (mAdded.contains(fragment)) {\n                throw new IllegalStateException(\"Fragment already added: \" + fragment); //就是简单的判断下List中是否存在，如果在一个Fragment已经added的情况下再去add，就会出现这种错误\n            }**/\n                    break;\n                case OP_HIDE:\n                    f.setNextAnim(op.popEnterAnim);\n                    mManager.showFragment(f);\n                    // 只是将fragment的mHidden设置为false了\n                    break;\n                case OP_SHOW:\n                    f.setNextAnim(op.popExitAnim);\n                    mManager.hideFragment(f);\n                    // 只是将fragment的mHidden设置为true了\n                    break;\n                case OP_DETACH:\n                    f.setNextAnim(op.popEnterAnim);\n                    mManager.attachFragment(f);\n                    //和attach差不多，也是设定了一些标志位\n                    break;\n                case OP_ATTACH:\n                    f.setNextAnim(op.popExitAnim);\n                    mManager.detachFragment(f);\n                    // mFragment.mDetached = false,这里判断了manager.mAdded.contains(mFragment)，会抛出异常Fragment already added!如果正常的话把mFragment添加到mAdded里面\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown cmd: \" + op.cmd);\n            }\n           if (!mAllowOptimization && op.cmd != OP_ADD) {\n                mManager.moveFragmentToExpectedState(f);\n            }\n        }\n         if (!mAllowOptimization) {\n            // Added fragments are added at the end to comply with prior behavior.\n            mManager.moveToState(mManager.mCurState, true);\n        }\n    }        \n\n```\n通常我们都是在主线程往Manager添加Transaction，不过从这里看来，添加Transaction只是添加了一份BackStackRecord，最终执行还是在主线程上做的。\n很直观的看到这里 调用了manager的removeFragment、showFragment等方法.随便挑两个\n```java\n// FragmentManagerImpl.java\n public void addFragment(Fragment fragment, boolean moveToStateNow) {\n        if (mAdded == null) {\n            mAdded = new ArrayList<Fragment>();\n        }\n        makeActive(fragment);\n        if (!fragment.mDetached) {\n            if (mAdded.contains(fragment)) {\n                throw new IllegalStateException(\"Fragment already added: \" + fragment);\n            }\n            mAdded.add(fragment);\n            fragment.mAdded = true; // 记得fragment.isAdded()方法吗，在这里被设置的\n            fragment.mRemoving = false;\n            if (fragment.mView == null) {\n                fragment.mHiddenChanged = false;\n            }\n            if (fragment.mHasMenu && fragment.mMenuVisible) {\n                mNeedMenuInvalidate = true;\n            }\n            if (moveToStateNow) {\n                moveToState(fragment);\n            }\n        }\n    }\n\n        // show的方法异常简单\n       /**\n     * Marks a fragment as shown to be later animated in with\n     * {@link #completeShowHideFragment(Fragment)}.\n     *\n     * @param fragment The fragment to be shown.\n     */\n    public void showFragment(Fragment fragment) {\n        if (fragment.mHidden) {\n            fragment.mHidden = false; //这里只是设置一下标志位\n            // Toggle hidden changed so that if a fragment goes through show/hide/show\n            // it doesn't go through the animation.\n            fragment.mHiddenChanged = !fragment.mHiddenChanged;\n        }\n    }\n\n```\n\n接下里就是FragmentManager的MoveToState方法了，非常长\n先记住Fragment的几个状态，这些都是Adam powell说过的，这是线性的，moveToState方法也是这样走的，不会跳过中间某个state\n>   static final int INITIALIZING = 0;     // Not yet created.\n    static final int CREATED = 1;          // Created.\n    static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.\n    static final int STOPPED = 3;          // Fully created, not started.\n    static final int STARTED = 4;          // Created and started, not resumed.\n    static final int RESUMED = 5;          // Created started and resumed.\n\nmoveToState的方法比较长，删掉一些不必要的，重点关注Fragment的那些生命周期回调是什么时候被调用的。建议看源码，我这里删除了很多还有一大坨。\n```java\n// FragmentImpl.java\n    void moveToState(Fragment f, int newState, int transit, int transitionStyle,\n            boolean keepActive) {\n//Fragment的state将提高，例如从ACTIVITY_CREATED到ACTIVITYCREATED\n        if (f.mState < newState) {\n            switch (f.mState) {\n                case Fragment.INITIALIZING://尚未初始化\n                    if (f.mSavedFragmentState != null) {\n                      //从SavedState中获取各个View的状态，尝试恢复View的状态\n                    }\n                    f.mHost = mHost; //从这一刻开始,getActivity，getContext，isAdded等和Activity相关的方法都有正确的返回\n\n                    f.mCalled = false; //这个mCalled是为了避免子类忘记调用super方法的\n                    f.onAttach(mHost.getContext()); // onAttach就是在这里调用的\n                    if (f.mParentFragment == null) {\n                        mHost.onAttachFragment(f);//mHost其实就是Activity\n                    } else {\n                        f.mParentFragment.onAttachFragment(f); //这个是ChildFragment的情况\n                    }\n                    dispatchOnFragmentAttached(f, mHost.getContext(), false);\n\n                    if (!f.mRetaining) {\n                        f.performCreate(f.mSavedFragmentState); //这里面调用了onCreate回调，同时STATE变成CREATED\n                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);\n                    } else {\n                        f.restoreChildFragmentState(f.mSavedFragmentState);\n                        f.mState = Fragment.CREATED;\n                    }\n                    f.mRetaining = false;\n                    if (f.mFromLayout) {//写在XML里面的，直接在从INITIALIZING到CREATED的过程中把performCreateView和onViewCreated走一遍\n                    }\n                case Fragment.CREATED:\n                    if (newState > Fragment.CREATED) {\n                        if (!f.mFromLayout) { //不是写在xml标签中的Fragment\n                            ViewGroup container = null;\n                            if (f.mContainerId != 0) {\n                                container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);\n                            }\n                            f.mContainer = container;\n                            f.mView = f.performCreateView(f.getLayoutInflater(\n                                    f.mSavedFragmentState), container, f.mSavedFragmentState);// onCreateView回调\n                            if (f.mView != null) {\n                                f.mInnerView = f.mView;\n                                if (container != null) {\n                                    container.addView(f.mView);//所以Fragment本质上只是addView到Container里\n                                }\n                                if (f.mHidden) { //hide就只是设置Visibility这么简单，这mHdidden是在上面的showFragment里面设置的\n                                    f.mView.setVisibility(View.GONE);\n                                }\n                                f.onViewCreated(f.mView, f.mSavedFragmentState);// 又是回调,onViewCreated确实是在onCreatedView之后立马添加的\n                                dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,\n                                        false);\n                                // Only animate the view if it is visible. This is done after\n                                // dispatchOnFragmentViewCreated in case visibility is changed\n                                f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)\n                                        && f.mContainer != null;\n                            } else {\n                                f.mInnerView = null;\n                            }\n                        }\n                        //随后马上就调用到了onActivityCreated了，同一个Message中\n                        f.performActivityCreated(f.mSavedFragmentState);\n                        dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);\n                        if (f.mView != null) {\n                            f.restoreViewState(f.mSavedFragmentState);\n                        }\n                        f.mSavedFragmentState = null;\n                    }\n                case Fragment.ACTIVITY_CREATED:\n                    if (newState > Fragment.ACTIVITY_CREATED) {\n                        f.mState = Fragment.STOPPED;\n                    }\n                case Fragment.STOPPED:\n                    if (newState > Fragment.STOPPED) {\n                        if (DEBUG) Log.v(TAG, \"moveto STARTED: \" + f);\n                        f.performStart(); //随后开始onStart\n                        dispatchOnFragmentStarted(f, false);\n                    }\n                case Fragment.STARTED:\n                    if (newState > Fragment.STARTED) {\n                        if (DEBUG) Log.v(TAG, \"moveto RESUMED: \" + f);\n                        f.performResume(); //onResume\n                        dispatchOnFragmentResumed(f, false);\n                        f.mSavedFragmentState = null;\n                        f.mSavedViewState = null;\n                    }\n            }\n        } else if (f.mState > newState) { //Fragment的STATE降低\n            switch (f.mState) {\n                case Fragment.RESUMED:\n                    if (newState < Fragment.RESUMED) {\n                        f.performPause(); //onPause\n                        dispatchOnFragmentPaused(f, false);\n                    }\n                case Fragment.STARTED:\n                    if (newState < Fragment.STARTED) {\n                        f.performStop();//调用onStop,state变成STOPPED\n                        dispatchOnFragmentStopped(f, false);\n                    }\n                case Fragment.STOPPED:\n                    if (newState < Fragment.STOPPED) {\n                        f.performReallyStop();//不调用回调，状态变成ACTIVITY_CREATED\n                    }\n                case Fragment.ACTIVITY_CREATED:\n                    if (newState < Fragment.ACTIVITY_CREATED) {\n                        f.performDestroyView(); //状态变成CREATED，调用onDestoryView。最后收尾调用                            f.mContainer.removeView(f.mView);//引用置空\n                        dispatchOnFragmentViewDestroyed(f, false);\n                        if (f.mView != null && f.mContainer != null) {\n                            f.mContainer.removeView(f.mView);\n                        }\n                        f.mContainer = null;\n                        f.mView = null;\n                        f.mInnerView = null;\n                    }\n                case Fragment.CREATED:\n                    if (newState < Fragment.CREATED) {\n                            if (DEBUG) Log.v(TAG, \"movefrom CREATED: \" + f);\n                            if (!f.mRetaining) {\n                                f.performDestroy();\n                                dispatchOnFragmentDestroyed(f, false);\n                            } else {\n                                f.mState = Fragment.INITIALIZING;\n                            }\n\n                            f.performDetach();\n                            dispatchOnFragmentDetached(f, false);\n                            if (!keepActive) {\n                                if (!f.mRetaining) {\n                                    makeInactive(f);\n                                } else {\n                                    f.mHost = null; //Fragment可以在Activity挂了之后接着存在，这里只是避免内存泄漏，那个方法叫做setRetainState好像\n                                    f.mParentFragment = null;\n                                    f.mFragmentManager = null;\n                                }\n                            }\n\n                    }\n            }\n        }\n    }\n\n```\nmoveToState的方法很长，基本上可以分为state升高和state降低来看：\n1. state升高的过程中：\n  -  onAttach是第一个回调，这里面给Fragment的mHost赋值；(响应Fragment.CREATED信号)\n  -  onCreateView,onViewCreated是在一个方法里进行的，本质上调用的是mContainer.addView方法。随后立即调用onActivityCreated方法(响应Fragment.ACTIVITY_CREATED方法)\n  - onStart是第三个回调，onStart文档明确表示该方法调用时Fragment已经对用户可见。文档同时说明该方法和Activity的onStart方法挂钩，原理是FragmentActivity的onStart中调用了mFragments.dispatchStart()方法。\n2. Fragment和Activity生命周期挂钩\n  - FragmentActivity的onCreate中调用了FragmentManager的dispatchCreate方法，发出Fragment.CREATED信号\n  - FragmentActivity的onStart中先调用了dispatchActivityCreated方法（发出ACTIVITY_CREATED信号），随后调用dispatchStart（发出Fragment.STARTED信号）\n  - FragmentActivity的onResume中用Handler发送了一个Message，对应mFragments.dispatchResume(Fragment.RESUMED信号);FragmentActivity的onPostResume中也调用了dispatchResume方法，不过moveToState方法最后已经判断了newState> currentState。\n  - onPause和onStop和onDestoryView也差不多。注意，DestoryView实质只是将Fragment的mView从container中移除，设置mView为null，mContainer为null;onDestory先于onDetach调用\n3. FragmentActivity中的dispatchActivityCreated和dispatchFragmentStarted写在一个方法里，区别是onActivityCreated先于onStart调用且只会被调用一次。所以onActivityCreated存在的意义不过是为了帮助区分是初次start还是后面多次的start（Activity的onStart会被多次调用）\n4. state降低的过程其实也差不多，我也懒得分析了。之前以为detach和attch方法很特殊，其实只是从FragmentManager的mAdded中移除该Fragment，并设置fragment.mAdded = false.\n5. 从一个state到另一个state基本的步骤就是fragment.performXXX，然后dispatchXXX，这里面顺手把state设置一下\n\n\nFragmentManager的核心方法应该就是这个moveToState方法了。到此，commit分析结束。说一下几个不建议使用的方法\n**executePendingTransactions** 看了下，这个方法里面没有异步方法，别的就不清楚了。据说是将所有的Transaction全部执行掉，首先这里面有一大堆操作，会堵住主线程，其次，这个方法里面涉及到各个状态的判断，很混乱。\n\n**commitAllowingStateLoss** 这个方法和commit的唯一区别是调用一个可能会抛出异常的方法，后面还是post了一个pendingAction,还是异步的。所以很多人纷纷调用commitAllowingStateLoss方法。然而，这个方法存在是有其意义的。安卓本身就是个异步的系统。Activity的onSaveInstanceState随时可能会被调用，调用之后所有有id的View的onSaveInstanceState都被调用了。这个时候再去尝试做任何操作都可能会重新对已经保存了状态的View造成影响。Activity重新恢复的时候会把saveState中的的UI快照恢复，这一次的操作就会造成恢复的时候不是保存时的效果.allowStateLoss的字面意思很清楚了，就是系统不保证此后View的状态能够正确被恢复。\n\n```java\nprivate void checkStateLoss() {\n       if (mStateSaved) {\n           throw new IllegalStateException(\n                   \"Can not perform this action after onSaveInstanceState\");\n       }\n       if (mNoTransactionsBecause != null) {\n           throw new IllegalStateException(\n                   \"Can not perform this action inside of \" + mNoTransactionsBecause);\n       }\n   }\n```\n\n**commitNow** 注意24.2 之后Google添加了一个单独的commitNow方法，这一点Adam Powell在2016年的IO上特别提到过。\n内部执行了mTmpRecords(临时操作)，由于只是一项操作，外加里面还对这一次操作进行了优化，所以直接同步执行了。该方法不允许addToBackStack，因为这实质上等同于在所有pendingAction中插队。由于是同步执行，该方法保证方法返回之后，所有的Fragment都能处于所预期的state。\n\n```java\n @Override\n    public void commitNow() {\n        disallowAddToBackStack();\n        mManager.execSingleAction(this, false);\n    }\n\n  @Override\n  public void commitNowAllowingStateLoss() {\n      disallowAddToBackStack();\n      mManager.execSingleAction(this, true);\n  }\n```\n\n**commitNowAllowingStateLoss** 和commitAllowingStateLoss一样的道理，开发者可能不经意在Activity保存了状态之后调用该方法，这违背了状态保存和恢复的原则。但还是开了个后门，前提是不保证UI恢复的时候出现非预期的表现。allowStateLoss的方法照说不应该调用，如果不调用这个方法的话，使用commitNow，而不是commit + executePendingTransactions。 同时，commitNow之前检查下mStateSaved是否是true,具体来说Activity的onStop和onSaveInstanceState调用之后这个值都会为true。\n\n关于Activity的onSaveInstanceState什么时候会调用，找到比较好的[解释](http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html)。 记住，旋转屏幕的时候一定会调用的。\n\n\n\n## 4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\n这两个类行数都不超过300行，非常简单，只是通过调用FragmentManager的相应方法实现展示View的功能。\n\n## 5. Fragment的一些不常用的API\nattach,detach,FragmentLifecycleCallbacks,commitNow，setAllowOptimization(26.0.0又被deprecated了)\nonCreateView这个名字是怎么来的，其实是在dispatchFragmentsOnCreateView里面调用的。Activity实现了onCreateView(LayoutInflater定义的，会在getSytemService返回LayoutInflater时调用，获取系统服务毕竟是一个异步过程)。\n\n\n## 6. 关于Glide是如何实现生命周期绑定的\nFragment本身提供了生命周期监听回调\n```java\nregisterFragmentLifecycleCallbacks 25.1.0\nunregisterFragmentLifecycleCallbacks 25.1.0\n\naddOnBackStackChangedListener 22.2.0\nremoveOnBackStackChangedListener 22.2.0\n```\nGlide的做法是写了一个**SupportRequestManagerFragment** 在这个Fragment的构造函数里放了一个ActivityFragmentLifecycle\n [参考](http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD)\n 在这个Fragment的onStart，OnStop等方法里面调用该lifeCycle的onStart,onStop等回调(lifeCycle是接口，由RequestManager实现)\n 关键代码\n ```java\n if (current == null) {\n                current = new RequestManagerFragment();\n                pendingRequestManagerFragments.put(fm, current);\n                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n                handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();\n            }\n ```\n 所以经常会在Debug的时候看到FragmentManager里面有个\"com.bumptech.glide.manager\"的Fragment。这个Fragemnt没有实现onCreateView，所以直接返回null。Fragment本身是可以不带View的。\n\n\n\n## 7. 总结\nFragment的一些生命周期还是需要跟Activity的生命周期一起看，大部分是异步操作。FragmentManager类似一个管理者，也是一个容器，在Activity的生命周期中顺手实现了容器中元素所要求的UI状态。Fragment本质上是一个View的Controllers，通过FragmentManger和FragmentActivity的生命周期挂钩，并自动做好View的状态保存和恢复。具体的UI展示无非是addView，setVisibility等常规的方法，也正因为这样，support包里的Fragment才能做到3.0以下的适配。日常开发中，Fragment能够将原本堆在Activity中的逻辑承载过来,以异步的方式减轻主线程的压力，对外提供了获取(onViewCreated)，操作(Transaction)，销毁(onDestoryView)这些业务对象的回调方法。由于Android本身就是异步的系统，系统随时(asynchronous)可能会对Fragment的资源进行更改，开发者的代码也随时(asynchronous)会对这些资源进行操作。由于存在这种无法改变的'并发'现状，Fragment不得不为保证资源的一致性而主动抛出一些错误。本文有意忽略掉了一些transition动画(使用了hardwareLayer)和Loader加载的细节，希望能够对日常开发有点帮助。\n\n\n## Reference\n1. [Fragment的onAttach和onDetach什么时候会调用](http://stackoverflow.com/questions/9156406/whats-the-difference-between-detaching-a-fragment-and-removing-it)\n2. [Glide是怎么跟生命周期挂钩的](http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD)\n3. [Activity的onSaveInstanceState什么时候会调用](http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html)\n4. [Activity-LifeCycle](https://developer.android.com/guide/components/activities/activity-lifecycle.html)\n5. [Fragments文档](https://developer.android.com/guide/components/fragments.html)不要依赖Implementation Detail,源码随时会变，官方的文档才是值得依赖的。\n","source":"_posts/2017-07-12-fragment-decoded.md","raw":"---\ntitle: Fragment源码解析记录(supportLibrary 25.3.0)\ndate: 2017-07-12 08:37:23\ntags: [android]\n---\n\nWe been told Fragment itself should only trust official docs, the implementation detail are prone to any change any time, don't count on it!\n![](http://odzl05jxx.bkt.clouddn.com/2009528111321773591934.jpg?imageView2/2/w/600)\n<!--more-->\n\nFragment源码解析（support Library 25.3.0），不要以为看了源码就可以不鸟官方文档了，源码的内容经常变，只有官方的文档才是可靠的，谷歌保证会实现的效果。\n\n## 1. 概述\nFragment的核心类有这几个:\n\n> FragmentManager, FragmentTransaction, Fragment。而事实上前两个都是抽象类，\n>FragmentManager的实现类是FragmentManagerImpl，FragmentTransaction的实现类是BackStackRecord\n\n从日常使用Fragment的方式开始:\n```java\n((FragmentActivity) mActivity).getSupportFragmentManager()\n                    .beginTransaction().add(R.id.containerViewId,fragment).commit();\n```\n\n\n\n### 2.FragmentTransaction只是将动作添加到一个队列中了\nbeginTransaction获取了一个FragmentTransaction实例，来看add方法的实现:\n```java\n    @Override\n    public FragmentTransaction add(Fragment fragment, String tag) {\n        doAddOp(0, fragment, tag, OP_ADD);\n        return this;\n    }\n\n    @Override\n    public FragmentTransaction add(int containerViewId, Fragment fragment) {\n        doAddOp(containerViewId, fragment, null, OP_ADD);\n        return this;\n    }\n\n    @Override\n    public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) {\n        doAddOp(containerViewId, fragment, tag, OP_ADD);\n        return this;\n    }\n```\n\n不管是通过id还是Tag添加，都是调用同一个方法，传参不同而已\n```java\n    private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) {\n    //省略部分代码\n        fragment.mFragmentManager = mManager;\n        if (tag != null) {\n            fragment.mTag = tag;\n        }\n        //注意，进入这个方法的时候fragment已经实例化了，只是其中的回调方法还没有开始调用\n        if (containerViewId != 0) {\n            fragment.mContainerId = fragment.mFragmentId = containerViewId;\n        }\n\n        Op op = new Op();\n        op.cmd = opcmd; //这个cmd很重要，代表了是show、hide、add、remove等这些东西\n        op.fragment = fragment;\n        addOp(op);\n    }\n\n    //所有可能的操作细节都包含在这里面了。注意，这是线性的！\n    static final int OP_NULL = 0;\n    static final int OP_ADD = 1;\n    static final int OP_REPLACE = 2;\n    static final int OP_REMOVE = 3;\n    static final int OP_HIDE = 4;\n    static final int OP_SHOW = 5;\n    static final int OP_DETACH = 6;\n    static final int OP_ATTACH = 7;\n\n    //这个OP包装了了每一次操作的具体细节。\n    static final class Op {\n        int cmd;\n        Fragment fragment;\n        int enterAnim;\n        int exitAnim;\n        int popEnterAnim;\n        int popExitAnim;\n    }\n\n      void addOp(Op op) {\n        mOps.add(op); //往一个普通的ArrayList中添加一个op\n        op.enterAnim = mEnterAnim;\n        op.exitAnim = mExitAnim;\n        op.popEnterAnim = mPopEnterAnim;\n        op.popExitAnim = mPopExitAnim;\n    }\n\n```\n\n\n## 3.通过FragmentTransaction.commit执行操作\nFragmentFransaction只是将所有操作保留到一次Transaction的一个任务队列(ArrayList)中了。真正的执行需要提交事务，这和数据库的事务很像。\n```java\n    @Override\n    public int commit() {\n        return commitInternal(false);\n    }\n\n    @Override\n    public int commitAllowingStateLoss() {\n        return commitInternal(true);\n    }\n\n//上面两个函数的返回值 Returns the identifier of this transaction's back stack entry, if addToBackStack(String)} had been called.  Otherwise, returns a negative number. 如果调用过addToBackStack的话，返回这次操作在操作栈上的标识符。否则返回负数。\n\n int commitInternal(boolean allowStateLoss) {\n        if (mCommitted) throw new IllegalStateException(\"commit already called\");\n        if (FragmentManagerImpl.DEBUG) {\n            Log.v(TAG, \"Commit: \" + this);\n            LogWriter logw = new LogWriter(TAG);\n            PrintWriter pw = new PrintWriter(logw);\n            dump(\"  \", null, pw, null);\n            pw.close();\n        }\n        mCommitted = true;\n        if (mAddToBackStack) {//如果调用过addToBackStack，这个值就为true，否则为false\n            mIndex = mManager.allocBackStackIndex(this);// 将BackStackRecord添加到一个ArrayList的尾部，List不存在则创建\n        } else {\n            mIndex = -1;\n        }\n        mManager.enqueueAction(this, allowStateLoss); // 这里就是调用FragmnetManager的方法，添加到FragmentManager的mPendingActions中，并scheduleCommit（通过FragmnetHostCallBack往主线程post一条runnable）\n        return mIndex; //返回的就是本次事务的mIndex\n    }\n\n\n       // FragmentManagerImpl\n      /**这里就是被推送到主线程的runnable，注意，这里是异步的\n     * Only call from main thread!\n     */\n    public boolean execPendingActions() {\n        ensureExecReady(true);\n\n        boolean didSomething = false;\n        //这里就是不断的从mPendingAction中查找待执行的操作\n        while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) {\n            mExecutingActions = true;\n            try {\n                optimizeAndExecuteOps(mTmpRecords, mTmpIsPop); //从方法名大致能猜到这里是执行操作的地方,两个参数，第一个是待执行的操作的List，一个是对应每项操作是pop还push(出栈还是入栈)\n            } finally {\n                cleanupExec();\n            }\n            didSomething = true;\n        }\n\n        doPendingDeferredStart();\n\n        return didSomething;\n    }\n\n private void optimizeAndExecuteOps(ArrayList<BackStackRecord> records,\n            ArrayList<Boolean> isRecordPop) {\n    }\n随后调用了executeOpsTogether方法，接着调用\n        executeOps(records, isRecordPop, startIndex, endIndex);\n最终又走到了BackStackRecord的方法里面\n\n   /**\n     * Reverses the execution of the operations within this transaction. The Fragment states will\n     * only be modified if optimizations are not allowed.\n     *\n     * @param moveToState {@code true} if added fragments should be moved to their final state\n     *                    in unoptimized transactions\n     */\n    void executePopOps(boolean moveToState) {\n        for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) { //倒序执行,每一个ops包含了对一个Fragment的指令，遍历所有的ops\n            final Op op = mOps.get(opNum);\n            Fragment f = op.fragment;\n            f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition), mTransitionStyle);\n            switch (op.cmd) {\n                //这些操作全部只是设置一些变量的值，暂时还没到UI更改，具体的UI操作在moveToState里面\n                case OP_ADD:\n                    f.setNextAnim(op.popExitAnim);\n                    mManager.removeFragment(f);  //从FragmentManager的mAdded中移除该fragment，fragment的mAdded = false,mRemoving = true;\n                    break;\n                case OP_REMOVE:\n                    f.setNextAnim(op.popEnterAnim);\n                    mManager.addFragment(f, false);\n                    /** addFragment里面有这么一段  \n       if (mAdded.contains(fragment)) {\n                throw new IllegalStateException(\"Fragment already added: \" + fragment); //就是简单的判断下List中是否存在，如果在一个Fragment已经added的情况下再去add，就会出现这种错误\n            }**/\n                    break;\n                case OP_HIDE:\n                    f.setNextAnim(op.popEnterAnim);\n                    mManager.showFragment(f);\n                    // 只是将fragment的mHidden设置为false了\n                    break;\n                case OP_SHOW:\n                    f.setNextAnim(op.popExitAnim);\n                    mManager.hideFragment(f);\n                    // 只是将fragment的mHidden设置为true了\n                    break;\n                case OP_DETACH:\n                    f.setNextAnim(op.popEnterAnim);\n                    mManager.attachFragment(f);\n                    //和attach差不多，也是设定了一些标志位\n                    break;\n                case OP_ATTACH:\n                    f.setNextAnim(op.popExitAnim);\n                    mManager.detachFragment(f);\n                    // mFragment.mDetached = false,这里判断了manager.mAdded.contains(mFragment)，会抛出异常Fragment already added!如果正常的话把mFragment添加到mAdded里面\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown cmd: \" + op.cmd);\n            }\n           if (!mAllowOptimization && op.cmd != OP_ADD) {\n                mManager.moveFragmentToExpectedState(f);\n            }\n        }\n         if (!mAllowOptimization) {\n            // Added fragments are added at the end to comply with prior behavior.\n            mManager.moveToState(mManager.mCurState, true);\n        }\n    }        \n\n```\n通常我们都是在主线程往Manager添加Transaction，不过从这里看来，添加Transaction只是添加了一份BackStackRecord，最终执行还是在主线程上做的。\n很直观的看到这里 调用了manager的removeFragment、showFragment等方法.随便挑两个\n```java\n// FragmentManagerImpl.java\n public void addFragment(Fragment fragment, boolean moveToStateNow) {\n        if (mAdded == null) {\n            mAdded = new ArrayList<Fragment>();\n        }\n        makeActive(fragment);\n        if (!fragment.mDetached) {\n            if (mAdded.contains(fragment)) {\n                throw new IllegalStateException(\"Fragment already added: \" + fragment);\n            }\n            mAdded.add(fragment);\n            fragment.mAdded = true; // 记得fragment.isAdded()方法吗，在这里被设置的\n            fragment.mRemoving = false;\n            if (fragment.mView == null) {\n                fragment.mHiddenChanged = false;\n            }\n            if (fragment.mHasMenu && fragment.mMenuVisible) {\n                mNeedMenuInvalidate = true;\n            }\n            if (moveToStateNow) {\n                moveToState(fragment);\n            }\n        }\n    }\n\n        // show的方法异常简单\n       /**\n     * Marks a fragment as shown to be later animated in with\n     * {@link #completeShowHideFragment(Fragment)}.\n     *\n     * @param fragment The fragment to be shown.\n     */\n    public void showFragment(Fragment fragment) {\n        if (fragment.mHidden) {\n            fragment.mHidden = false; //这里只是设置一下标志位\n            // Toggle hidden changed so that if a fragment goes through show/hide/show\n            // it doesn't go through the animation.\n            fragment.mHiddenChanged = !fragment.mHiddenChanged;\n        }\n    }\n\n```\n\n接下里就是FragmentManager的MoveToState方法了，非常长\n先记住Fragment的几个状态，这些都是Adam powell说过的，这是线性的，moveToState方法也是这样走的，不会跳过中间某个state\n>   static final int INITIALIZING = 0;     // Not yet created.\n    static final int CREATED = 1;          // Created.\n    static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.\n    static final int STOPPED = 3;          // Fully created, not started.\n    static final int STARTED = 4;          // Created and started, not resumed.\n    static final int RESUMED = 5;          // Created started and resumed.\n\nmoveToState的方法比较长，删掉一些不必要的，重点关注Fragment的那些生命周期回调是什么时候被调用的。建议看源码，我这里删除了很多还有一大坨。\n```java\n// FragmentImpl.java\n    void moveToState(Fragment f, int newState, int transit, int transitionStyle,\n            boolean keepActive) {\n//Fragment的state将提高，例如从ACTIVITY_CREATED到ACTIVITYCREATED\n        if (f.mState < newState) {\n            switch (f.mState) {\n                case Fragment.INITIALIZING://尚未初始化\n                    if (f.mSavedFragmentState != null) {\n                      //从SavedState中获取各个View的状态，尝试恢复View的状态\n                    }\n                    f.mHost = mHost; //从这一刻开始,getActivity，getContext，isAdded等和Activity相关的方法都有正确的返回\n\n                    f.mCalled = false; //这个mCalled是为了避免子类忘记调用super方法的\n                    f.onAttach(mHost.getContext()); // onAttach就是在这里调用的\n                    if (f.mParentFragment == null) {\n                        mHost.onAttachFragment(f);//mHost其实就是Activity\n                    } else {\n                        f.mParentFragment.onAttachFragment(f); //这个是ChildFragment的情况\n                    }\n                    dispatchOnFragmentAttached(f, mHost.getContext(), false);\n\n                    if (!f.mRetaining) {\n                        f.performCreate(f.mSavedFragmentState); //这里面调用了onCreate回调，同时STATE变成CREATED\n                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);\n                    } else {\n                        f.restoreChildFragmentState(f.mSavedFragmentState);\n                        f.mState = Fragment.CREATED;\n                    }\n                    f.mRetaining = false;\n                    if (f.mFromLayout) {//写在XML里面的，直接在从INITIALIZING到CREATED的过程中把performCreateView和onViewCreated走一遍\n                    }\n                case Fragment.CREATED:\n                    if (newState > Fragment.CREATED) {\n                        if (!f.mFromLayout) { //不是写在xml标签中的Fragment\n                            ViewGroup container = null;\n                            if (f.mContainerId != 0) {\n                                container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);\n                            }\n                            f.mContainer = container;\n                            f.mView = f.performCreateView(f.getLayoutInflater(\n                                    f.mSavedFragmentState), container, f.mSavedFragmentState);// onCreateView回调\n                            if (f.mView != null) {\n                                f.mInnerView = f.mView;\n                                if (container != null) {\n                                    container.addView(f.mView);//所以Fragment本质上只是addView到Container里\n                                }\n                                if (f.mHidden) { //hide就只是设置Visibility这么简单，这mHdidden是在上面的showFragment里面设置的\n                                    f.mView.setVisibility(View.GONE);\n                                }\n                                f.onViewCreated(f.mView, f.mSavedFragmentState);// 又是回调,onViewCreated确实是在onCreatedView之后立马添加的\n                                dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,\n                                        false);\n                                // Only animate the view if it is visible. This is done after\n                                // dispatchOnFragmentViewCreated in case visibility is changed\n                                f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)\n                                        && f.mContainer != null;\n                            } else {\n                                f.mInnerView = null;\n                            }\n                        }\n                        //随后马上就调用到了onActivityCreated了，同一个Message中\n                        f.performActivityCreated(f.mSavedFragmentState);\n                        dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);\n                        if (f.mView != null) {\n                            f.restoreViewState(f.mSavedFragmentState);\n                        }\n                        f.mSavedFragmentState = null;\n                    }\n                case Fragment.ACTIVITY_CREATED:\n                    if (newState > Fragment.ACTIVITY_CREATED) {\n                        f.mState = Fragment.STOPPED;\n                    }\n                case Fragment.STOPPED:\n                    if (newState > Fragment.STOPPED) {\n                        if (DEBUG) Log.v(TAG, \"moveto STARTED: \" + f);\n                        f.performStart(); //随后开始onStart\n                        dispatchOnFragmentStarted(f, false);\n                    }\n                case Fragment.STARTED:\n                    if (newState > Fragment.STARTED) {\n                        if (DEBUG) Log.v(TAG, \"moveto RESUMED: \" + f);\n                        f.performResume(); //onResume\n                        dispatchOnFragmentResumed(f, false);\n                        f.mSavedFragmentState = null;\n                        f.mSavedViewState = null;\n                    }\n            }\n        } else if (f.mState > newState) { //Fragment的STATE降低\n            switch (f.mState) {\n                case Fragment.RESUMED:\n                    if (newState < Fragment.RESUMED) {\n                        f.performPause(); //onPause\n                        dispatchOnFragmentPaused(f, false);\n                    }\n                case Fragment.STARTED:\n                    if (newState < Fragment.STARTED) {\n                        f.performStop();//调用onStop,state变成STOPPED\n                        dispatchOnFragmentStopped(f, false);\n                    }\n                case Fragment.STOPPED:\n                    if (newState < Fragment.STOPPED) {\n                        f.performReallyStop();//不调用回调，状态变成ACTIVITY_CREATED\n                    }\n                case Fragment.ACTIVITY_CREATED:\n                    if (newState < Fragment.ACTIVITY_CREATED) {\n                        f.performDestroyView(); //状态变成CREATED，调用onDestoryView。最后收尾调用                            f.mContainer.removeView(f.mView);//引用置空\n                        dispatchOnFragmentViewDestroyed(f, false);\n                        if (f.mView != null && f.mContainer != null) {\n                            f.mContainer.removeView(f.mView);\n                        }\n                        f.mContainer = null;\n                        f.mView = null;\n                        f.mInnerView = null;\n                    }\n                case Fragment.CREATED:\n                    if (newState < Fragment.CREATED) {\n                            if (DEBUG) Log.v(TAG, \"movefrom CREATED: \" + f);\n                            if (!f.mRetaining) {\n                                f.performDestroy();\n                                dispatchOnFragmentDestroyed(f, false);\n                            } else {\n                                f.mState = Fragment.INITIALIZING;\n                            }\n\n                            f.performDetach();\n                            dispatchOnFragmentDetached(f, false);\n                            if (!keepActive) {\n                                if (!f.mRetaining) {\n                                    makeInactive(f);\n                                } else {\n                                    f.mHost = null; //Fragment可以在Activity挂了之后接着存在，这里只是避免内存泄漏，那个方法叫做setRetainState好像\n                                    f.mParentFragment = null;\n                                    f.mFragmentManager = null;\n                                }\n                            }\n\n                    }\n            }\n        }\n    }\n\n```\nmoveToState的方法很长，基本上可以分为state升高和state降低来看：\n1. state升高的过程中：\n  -  onAttach是第一个回调，这里面给Fragment的mHost赋值；(响应Fragment.CREATED信号)\n  -  onCreateView,onViewCreated是在一个方法里进行的，本质上调用的是mContainer.addView方法。随后立即调用onActivityCreated方法(响应Fragment.ACTIVITY_CREATED方法)\n  - onStart是第三个回调，onStart文档明确表示该方法调用时Fragment已经对用户可见。文档同时说明该方法和Activity的onStart方法挂钩，原理是FragmentActivity的onStart中调用了mFragments.dispatchStart()方法。\n2. Fragment和Activity生命周期挂钩\n  - FragmentActivity的onCreate中调用了FragmentManager的dispatchCreate方法，发出Fragment.CREATED信号\n  - FragmentActivity的onStart中先调用了dispatchActivityCreated方法（发出ACTIVITY_CREATED信号），随后调用dispatchStart（发出Fragment.STARTED信号）\n  - FragmentActivity的onResume中用Handler发送了一个Message，对应mFragments.dispatchResume(Fragment.RESUMED信号);FragmentActivity的onPostResume中也调用了dispatchResume方法，不过moveToState方法最后已经判断了newState> currentState。\n  - onPause和onStop和onDestoryView也差不多。注意，DestoryView实质只是将Fragment的mView从container中移除，设置mView为null，mContainer为null;onDestory先于onDetach调用\n3. FragmentActivity中的dispatchActivityCreated和dispatchFragmentStarted写在一个方法里，区别是onActivityCreated先于onStart调用且只会被调用一次。所以onActivityCreated存在的意义不过是为了帮助区分是初次start还是后面多次的start（Activity的onStart会被多次调用）\n4. state降低的过程其实也差不多，我也懒得分析了。之前以为detach和attch方法很特殊，其实只是从FragmentManager的mAdded中移除该Fragment，并设置fragment.mAdded = false.\n5. 从一个state到另一个state基本的步骤就是fragment.performXXX，然后dispatchXXX，这里面顺手把state设置一下\n\n\nFragmentManager的核心方法应该就是这个moveToState方法了。到此，commit分析结束。说一下几个不建议使用的方法\n**executePendingTransactions** 看了下，这个方法里面没有异步方法，别的就不清楚了。据说是将所有的Transaction全部执行掉，首先这里面有一大堆操作，会堵住主线程，其次，这个方法里面涉及到各个状态的判断，很混乱。\n\n**commitAllowingStateLoss** 这个方法和commit的唯一区别是调用一个可能会抛出异常的方法，后面还是post了一个pendingAction,还是异步的。所以很多人纷纷调用commitAllowingStateLoss方法。然而，这个方法存在是有其意义的。安卓本身就是个异步的系统。Activity的onSaveInstanceState随时可能会被调用，调用之后所有有id的View的onSaveInstanceState都被调用了。这个时候再去尝试做任何操作都可能会重新对已经保存了状态的View造成影响。Activity重新恢复的时候会把saveState中的的UI快照恢复，这一次的操作就会造成恢复的时候不是保存时的效果.allowStateLoss的字面意思很清楚了，就是系统不保证此后View的状态能够正确被恢复。\n\n```java\nprivate void checkStateLoss() {\n       if (mStateSaved) {\n           throw new IllegalStateException(\n                   \"Can not perform this action after onSaveInstanceState\");\n       }\n       if (mNoTransactionsBecause != null) {\n           throw new IllegalStateException(\n                   \"Can not perform this action inside of \" + mNoTransactionsBecause);\n       }\n   }\n```\n\n**commitNow** 注意24.2 之后Google添加了一个单独的commitNow方法，这一点Adam Powell在2016年的IO上特别提到过。\n内部执行了mTmpRecords(临时操作)，由于只是一项操作，外加里面还对这一次操作进行了优化，所以直接同步执行了。该方法不允许addToBackStack，因为这实质上等同于在所有pendingAction中插队。由于是同步执行，该方法保证方法返回之后，所有的Fragment都能处于所预期的state。\n\n```java\n @Override\n    public void commitNow() {\n        disallowAddToBackStack();\n        mManager.execSingleAction(this, false);\n    }\n\n  @Override\n  public void commitNowAllowingStateLoss() {\n      disallowAddToBackStack();\n      mManager.execSingleAction(this, true);\n  }\n```\n\n**commitNowAllowingStateLoss** 和commitAllowingStateLoss一样的道理，开发者可能不经意在Activity保存了状态之后调用该方法，这违背了状态保存和恢复的原则。但还是开了个后门，前提是不保证UI恢复的时候出现非预期的表现。allowStateLoss的方法照说不应该调用，如果不调用这个方法的话，使用commitNow，而不是commit + executePendingTransactions。 同时，commitNow之前检查下mStateSaved是否是true,具体来说Activity的onStop和onSaveInstanceState调用之后这个值都会为true。\n\n关于Activity的onSaveInstanceState什么时候会调用，找到比较好的[解释](http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html)。 记住，旋转屏幕的时候一定会调用的。\n\n\n\n## 4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\n这两个类行数都不超过300行，非常简单，只是通过调用FragmentManager的相应方法实现展示View的功能。\n\n## 5. Fragment的一些不常用的API\nattach,detach,FragmentLifecycleCallbacks,commitNow，setAllowOptimization(26.0.0又被deprecated了)\nonCreateView这个名字是怎么来的，其实是在dispatchFragmentsOnCreateView里面调用的。Activity实现了onCreateView(LayoutInflater定义的，会在getSytemService返回LayoutInflater时调用，获取系统服务毕竟是一个异步过程)。\n\n\n## 6. 关于Glide是如何实现生命周期绑定的\nFragment本身提供了生命周期监听回调\n```java\nregisterFragmentLifecycleCallbacks 25.1.0\nunregisterFragmentLifecycleCallbacks 25.1.0\n\naddOnBackStackChangedListener 22.2.0\nremoveOnBackStackChangedListener 22.2.0\n```\nGlide的做法是写了一个**SupportRequestManagerFragment** 在这个Fragment的构造函数里放了一个ActivityFragmentLifecycle\n [参考](http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD)\n 在这个Fragment的onStart，OnStop等方法里面调用该lifeCycle的onStart,onStop等回调(lifeCycle是接口，由RequestManager实现)\n 关键代码\n ```java\n if (current == null) {\n                current = new RequestManagerFragment();\n                pendingRequestManagerFragments.put(fm, current);\n                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n                handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();\n            }\n ```\n 所以经常会在Debug的时候看到FragmentManager里面有个\"com.bumptech.glide.manager\"的Fragment。这个Fragemnt没有实现onCreateView，所以直接返回null。Fragment本身是可以不带View的。\n\n\n\n## 7. 总结\nFragment的一些生命周期还是需要跟Activity的生命周期一起看，大部分是异步操作。FragmentManager类似一个管理者，也是一个容器，在Activity的生命周期中顺手实现了容器中元素所要求的UI状态。Fragment本质上是一个View的Controllers，通过FragmentManger和FragmentActivity的生命周期挂钩，并自动做好View的状态保存和恢复。具体的UI展示无非是addView，setVisibility等常规的方法，也正因为这样，support包里的Fragment才能做到3.0以下的适配。日常开发中，Fragment能够将原本堆在Activity中的逻辑承载过来,以异步的方式减轻主线程的压力，对外提供了获取(onViewCreated)，操作(Transaction)，销毁(onDestoryView)这些业务对象的回调方法。由于Android本身就是异步的系统，系统随时(asynchronous)可能会对Fragment的资源进行更改，开发者的代码也随时(asynchronous)会对这些资源进行操作。由于存在这种无法改变的'并发'现状，Fragment不得不为保证资源的一致性而主动抛出一些错误。本文有意忽略掉了一些transition动画(使用了hardwareLayer)和Loader加载的细节，希望能够对日常开发有点帮助。\n\n\n## Reference\n1. [Fragment的onAttach和onDetach什么时候会调用](http://stackoverflow.com/questions/9156406/whats-the-difference-between-detaching-a-fragment-and-removing-it)\n2. [Glide是怎么跟生命周期挂钩的](http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD)\n3. [Activity的onSaveInstanceState什么时候会调用](http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html)\n4. [Activity-LifeCycle](https://developer.android.com/guide/components/activities/activity-lifecycle.html)\n5. [Fragments文档](https://developer.android.com/guide/components/fragments.html)不要依赖Implementation Detail,源码随时会变，官方的文档才是值得依赖的。\n","slug":"2017-07-12-fragment-decoded","published":1,"updated":"2017-07-20T15:19:39.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnjx002kbovruwupxm4j","content":"<p>We been told Fragment itself should only trust official docs, the implementation detail are prone to any change any time, don’t count on it!<br><img src=\"http://odzl05jxx.bkt.clouddn.com/2009528111321773591934.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<p>Fragment源码解析（support Library 25.3.0），不要以为看了源码就可以不鸟官方文档了，源码的内容经常变，只有官方的文档才是可靠的，谷歌保证会实现的效果。</p>\n<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>Fragment的核心类有这几个:</p>\n<blockquote>\n<p>FragmentManager, FragmentTransaction, Fragment。而事实上前两个都是抽象类，<br>FragmentManager的实现类是FragmentManagerImpl，FragmentTransaction的实现类是BackStackRecord</p>\n</blockquote>\n<p>从日常使用Fragment的方式开始:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">((FragmentActivity) mActivity).getSupportFragmentManager()</div><div class=\"line\">                    .beginTransaction().add(R.id.containerViewId,fragment).commit();</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-FragmentTransaction只是将动作添加到一个队列中了\"><a href=\"#2-FragmentTransaction只是将动作添加到一个队列中了\" class=\"headerlink\" title=\"2.FragmentTransaction只是将动作添加到一个队列中了\"></a>2.FragmentTransaction只是将动作添加到一个队列中了</h3><p>beginTransaction获取了一个FragmentTransaction实例，来看add方法的实现:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(Fragment fragment, String tag)</span> </span>&#123;</div><div class=\"line\">    doAddOp(<span class=\"number\">0</span>, fragment, tag, OP_ADD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment)</span> </span>&#123;</div><div class=\"line\">    doAddOp(containerViewId, fragment, <span class=\"keyword\">null</span>, OP_ADD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</div><div class=\"line\">    doAddOp(containerViewId, fragment, tag, OP_ADD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管是通过id还是Tag添加，都是调用同一个方法，传参不同而已<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAddOp</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag, <span class=\"keyword\">int</span> opcmd)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//省略部分代码</span></div><div class=\"line\">    fragment.mFragmentManager = mManager;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tag != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        fragment.mTag = tag;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//注意，进入这个方法的时候fragment已经实例化了，只是其中的回调方法还没有开始调用</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (containerViewId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Op op = <span class=\"keyword\">new</span> Op();</div><div class=\"line\">    op.cmd = opcmd; <span class=\"comment\">//这个cmd很重要，代表了是show、hide、add、remove等这些东西</span></div><div class=\"line\">    op.fragment = fragment;</div><div class=\"line\">    addOp(op);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//所有可能的操作细节都包含在这里面了。注意，这是线性的！</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_NULL = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_ADD = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_REPLACE = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_REMOVE = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_HIDE = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_SHOW = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_DETACH = <span class=\"number\">6</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_ATTACH = <span class=\"number\">7</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//这个OP包装了了每一次操作的具体细节。</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Op</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> cmd;</div><div class=\"line\">    Fragment fragment;</div><div class=\"line\">    <span class=\"keyword\">int</span> enterAnim;</div><div class=\"line\">    <span class=\"keyword\">int</span> exitAnim;</div><div class=\"line\">    <span class=\"keyword\">int</span> popEnterAnim;</div><div class=\"line\">    <span class=\"keyword\">int</span> popExitAnim;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addOp</span><span class=\"params\">(Op op)</span> </span>&#123;</div><div class=\"line\">    mOps.add(op); <span class=\"comment\">//往一个普通的ArrayList中添加一个op</span></div><div class=\"line\">    op.enterAnim = mEnterAnim;</div><div class=\"line\">    op.exitAnim = mExitAnim;</div><div class=\"line\">    op.popEnterAnim = mPopEnterAnim;</div><div class=\"line\">    op.popExitAnim = mPopExitAnim;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-通过FragmentTransaction-commit执行操作\"><a href=\"#3-通过FragmentTransaction-commit执行操作\" class=\"headerlink\" title=\"3.通过FragmentTransaction.commit执行操作\"></a>3.通过FragmentTransaction.commit执行操作</h2><p>FragmentFransaction只是将所有操作保留到一次Transaction的一个任务队列(ArrayList)中了。真正的执行需要提交事务，这和数据库的事务很像。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">commit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> commitInternal(<span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">commitAllowingStateLoss</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> commitInternal(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//上面两个函数的返回值 Returns the identifier of this transaction's back stack entry, if addToBackStack(String)&#125; had been called.  Otherwise, returns a negative number. 如果调用过addToBackStack的话，返回这次操作在操作栈上的标识符。否则返回负数。</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">commitInternal</span><span class=\"params\">(<span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mCommitted) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"commit already called\"</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</div><div class=\"line\">            Log.v(TAG, <span class=\"string\">\"Commit: \"</span> + <span class=\"keyword\">this</span>);</div><div class=\"line\">            LogWriter logw = <span class=\"keyword\">new</span> LogWriter(TAG);</div><div class=\"line\">            PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(logw);</div><div class=\"line\">            dump(<span class=\"string\">\"  \"</span>, <span class=\"keyword\">null</span>, pw, <span class=\"keyword\">null</span>);</div><div class=\"line\">            pw.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mCommitted = <span class=\"keyword\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mAddToBackStack) &#123;<span class=\"comment\">//如果调用过addToBackStack，这个值就为true，否则为false</span></div><div class=\"line\">            mIndex = mManager.allocBackStackIndex(<span class=\"keyword\">this</span>);<span class=\"comment\">// 将BackStackRecord添加到一个ArrayList的尾部，List不存在则创建</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mIndex = -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mManager.enqueueAction(<span class=\"keyword\">this</span>, allowStateLoss); <span class=\"comment\">// 这里就是调用FragmnetManager的方法，添加到FragmentManager的mPendingActions中，并scheduleCommit（通过FragmnetHostCallBack往主线程post一条runnable）</span></div><div class=\"line\">        <span class=\"keyword\">return</span> mIndex; <span class=\"comment\">//返回的就是本次事务的mIndex</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// FragmentManagerImpl</span></div><div class=\"line\">      <span class=\"comment\">/**这里就是被推送到主线程的runnable，注意，这里是异步的</div><div class=\"line\">     * Only call from main thread!</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">execPendingActions</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        ensureExecReady(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"comment\">//这里就是不断的从mPendingAction中查找待执行的操作</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123;</div><div class=\"line\">            mExecutingActions = <span class=\"keyword\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                optimizeAndExecuteOps(mTmpRecords, mTmpIsPop); <span class=\"comment\">//从方法名大致能猜到这里是执行操作的地方,两个参数，第一个是待执行的操作的List，一个是对应每项操作是pop还push(出栈还是入栈)</span></div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                cleanupExec();</div><div class=\"line\">            &#125;</div><div class=\"line\">            didSomething = <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        doPendingDeferredStart();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> didSomething;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">optimizeAndExecuteOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</div><div class=\"line\">            ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">随后调用了executeOpsTogether方法，接着调用</div><div class=\"line\">        executeOps(records, isRecordPop, startIndex, endIndex);</div><div class=\"line\">最终又走到了BackStackRecord的方法里面</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">     * Reverses the execution of the operations within this transaction. The Fragment states will</div><div class=\"line\">     * only be modified if optimizations are not allowed.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> moveToState &#123;<span class=\"doctag\">@code</span> true&#125; if added fragments should be moved to their final state</div><div class=\"line\">     *                    in unoptimized transactions</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executePopOps</span><span class=\"params\">(<span class=\"keyword\">boolean</span> moveToState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opNum = mOps.size() - <span class=\"number\">1</span>; opNum &gt;= <span class=\"number\">0</span>; opNum--) &#123; <span class=\"comment\">//倒序执行,每一个ops包含了对一个Fragment的指令，遍历所有的ops</span></div><div class=\"line\">            <span class=\"keyword\">final</span> Op op = mOps.get(opNum);</div><div class=\"line\">            Fragment f = op.fragment;</div><div class=\"line\">            f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition), mTransitionStyle);</div><div class=\"line\">            <span class=\"keyword\">switch</span> (op.cmd) &#123;</div><div class=\"line\">                <span class=\"comment\">//这些操作全部只是设置一些变量的值，暂时还没到UI更改，具体的UI操作在moveToState里面</span></div><div class=\"line\">                <span class=\"keyword\">case</span> OP_ADD:</div><div class=\"line\">                    f.setNextAnim(op.popExitAnim);</div><div class=\"line\">                    mManager.removeFragment(f);  <span class=\"comment\">//从FragmentManager的mAdded中移除该fragment，fragment的mAdded = false,mRemoving = true;</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_REMOVE:</div><div class=\"line\">                    f.setNextAnim(op.popEnterAnim);</div><div class=\"line\">                    mManager.addFragment(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    <span class=\"comment\">/** addFragment里面有这么一段  </div><div class=\"line\">       if (mAdded.contains(fragment)) &#123;</div><div class=\"line\">                throw new IllegalStateException(\"Fragment already added: \" + fragment); //就是简单的判断下List中是否存在，如果在一个Fragment已经added的情况下再去add，就会出现这种错误</div><div class=\"line\">            &#125;**/</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_HIDE:</div><div class=\"line\">                    f.setNextAnim(op.popEnterAnim);</div><div class=\"line\">                    mManager.showFragment(f);</div><div class=\"line\">                    <span class=\"comment\">// 只是将fragment的mHidden设置为false了</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_SHOW:</div><div class=\"line\">                    f.setNextAnim(op.popExitAnim);</div><div class=\"line\">                    mManager.hideFragment(f);</div><div class=\"line\">                    <span class=\"comment\">// 只是将fragment的mHidden设置为true了</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_DETACH:</div><div class=\"line\">                    f.setNextAnim(op.popEnterAnim);</div><div class=\"line\">                    mManager.attachFragment(f);</div><div class=\"line\">                    <span class=\"comment\">//和attach差不多，也是设定了一些标志位</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_ATTACH:</div><div class=\"line\">                    f.setNextAnim(op.popExitAnim);</div><div class=\"line\">                    mManager.detachFragment(f);</div><div class=\"line\">                    <span class=\"comment\">// mFragment.mDetached = false,这里判断了manager.mAdded.contains(mFragment)，会抛出异常Fragment already added!如果正常的话把mFragment添加到mAdded里面</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">default</span>:</div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown cmd: \"</span> + op.cmd);</div><div class=\"line\">            &#125;</div><div class=\"line\">           <span class=\"keyword\">if</span> (!mAllowOptimization &amp;&amp; op.cmd != OP_ADD) &#123;</div><div class=\"line\">                mManager.moveFragmentToExpectedState(f);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">         <span class=\"keyword\">if</span> (!mAllowOptimization) &#123;</div><div class=\"line\">            <span class=\"comment\">// Added fragments are added at the end to comply with prior behavior.</span></div><div class=\"line\">            mManager.moveToState(mManager.mCurState, <span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>通常我们都是在主线程往Manager添加Transaction，不过从这里看来，添加Transaction只是添加了一份BackStackRecord，最终执行还是在主线程上做的。<br>很直观的看到这里 调用了manager的removeFragment、showFragment等方法.随便挑两个<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// FragmentManagerImpl.java</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFragment</span><span class=\"params\">(Fragment fragment, <span class=\"keyword\">boolean</span> moveToStateNow)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mAdded == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mAdded = <span class=\"keyword\">new</span> ArrayList&lt;Fragment&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        makeActive(fragment);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fragment already added: \"</span> + fragment);</div><div class=\"line\">            &#125;</div><div class=\"line\">            mAdded.add(fragment);</div><div class=\"line\">            fragment.mAdded = <span class=\"keyword\">true</span>; <span class=\"comment\">// 记得fragment.isAdded()方法吗，在这里被设置的</span></div><div class=\"line\">            fragment.mRemoving = <span class=\"keyword\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (fragment.mView == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                fragment.mHiddenChanged = <span class=\"keyword\">false</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</div><div class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (moveToStateNow) &#123;</div><div class=\"line\">                moveToState(fragment);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// show的方法异常简单</span></div><div class=\"line\">       <span class=\"comment\">/**</div><div class=\"line\">     * Marks a fragment as shown to be later animated in with</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (fragment.mHidden) &#123;</div><div class=\"line\">            fragment.mHidden = <span class=\"keyword\">false</span>; <span class=\"comment\">//这里只是设置一下标志位</span></div><div class=\"line\">            <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></div><div class=\"line\">            <span class=\"comment\">// it doesn't go through the animation.</span></div><div class=\"line\">            fragment.mHiddenChanged = !fragment.mHiddenChanged;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>接下里就是FragmentManager的MoveToState方法了，非常长<br>先记住Fragment的几个状态，这些都是Adam powell说过的，这是线性的，moveToState方法也是这样走的，不会跳过中间某个state</p>\n<blockquote>\n<p>  static final int INITIALIZING = 0;     // Not yet created.<br>    static final int CREATED = 1;          // Created.<br>    static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.<br>    static final int STOPPED = 3;          // Fully created, not started.<br>    static final int STARTED = 4;          // Created and started, not resumed.<br>    static final int RESUMED = 5;          // Created started and resumed.</p>\n</blockquote>\n<p>moveToState的方法比较长，删掉一些不必要的，重点关注Fragment的那些生命周期回调是什么时候被调用的。建议看源码，我这里删除了很多还有一大坨。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// FragmentImpl.java</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(Fragment f, <span class=\"keyword\">int</span> newState, <span class=\"keyword\">int</span> transit, <span class=\"keyword\">int</span> transitionStyle,</div><div class=\"line\">            <span class=\"keyword\">boolean</span> keepActive)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//Fragment的state将提高，例如从ACTIVITY_CREATED到ACTIVITYCREATED</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (f.mState &lt; newState) &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> (f.mState) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.INITIALIZING:<span class=\"comment\">//尚未初始化</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (f.mSavedFragmentState != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                      <span class=\"comment\">//从SavedState中获取各个View的状态，尝试恢复View的状态</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                    f.mHost = mHost; <span class=\"comment\">//从这一刻开始,getActivity，getContext，isAdded等和Activity相关的方法都有正确的返回</span></div><div class=\"line\"></div><div class=\"line\">                    f.mCalled = <span class=\"keyword\">false</span>; <span class=\"comment\">//这个mCalled是为了避免子类忘记调用super方法的</span></div><div class=\"line\">                    f.onAttach(mHost.getContext()); <span class=\"comment\">// onAttach就是在这里调用的</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (f.mParentFragment == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        mHost.onAttachFragment(f);<span class=\"comment\">//mHost其实就是Activity</span></div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        f.mParentFragment.onAttachFragment(f); <span class=\"comment\">//这个是ChildFragment的情况</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                    dispatchOnFragmentAttached(f, mHost.getContext(), <span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">if</span> (!f.mRetaining) &#123;</div><div class=\"line\">                        f.performCreate(f.mSavedFragmentState); <span class=\"comment\">//这里面调用了onCreate回调，同时STATE变成CREATED</span></div><div class=\"line\">                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        f.restoreChildFragmentState(f.mSavedFragmentState);</div><div class=\"line\">                        f.mState = Fragment.CREATED;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    f.mRetaining = <span class=\"keyword\">false</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (f.mFromLayout) &#123;<span class=\"comment\">//写在XML里面的，直接在从INITIALIZING到CREATED的过程中把performCreateView和onViewCreated走一遍</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.CREATED) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (!f.mFromLayout) &#123; <span class=\"comment\">//不是写在xml标签中的Fragment</span></div><div class=\"line\">                            ViewGroup container = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            <span class=\"keyword\">if</span> (f.mContainerId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                                container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            f.mContainer = container;</div><div class=\"line\">                            f.mView = f.performCreateView(f.getLayoutInflater(</div><div class=\"line\">                                    f.mSavedFragmentState), container, f.mSavedFragmentState);<span class=\"comment\">// onCreateView回调</span></div><div class=\"line\">                            <span class=\"keyword\">if</span> (f.mView != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                f.mInnerView = f.mView;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (container != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                    container.addView(f.mView);<span class=\"comment\">//所以Fragment本质上只是addView到Container里</span></div><div class=\"line\">                                &#125;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (f.mHidden) &#123; <span class=\"comment\">//hide就只是设置Visibility这么简单，这mHdidden是在上面的showFragment里面设置的</span></div><div class=\"line\">                                    f.mView.setVisibility(View.GONE);</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                f.onViewCreated(f.mView, f.mSavedFragmentState);<span class=\"comment\">// 又是回调,onViewCreated确实是在onCreatedView之后立马添加的</span></div><div class=\"line\">                                dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,</div><div class=\"line\">                                        <span class=\"keyword\">false</span>);</div><div class=\"line\">                                <span class=\"comment\">// Only animate the view if it is visible. This is done after</span></div><div class=\"line\">                                <span class=\"comment\">// dispatchOnFragmentViewCreated in case visibility is changed</span></div><div class=\"line\">                                f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)</div><div class=\"line\">                                        &amp;&amp; f.mContainer != <span class=\"keyword\">null</span>;</div><div class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                f.mInnerView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        <span class=\"comment\">//随后马上就调用到了onActivityCreated了，同一个Message中</span></div><div class=\"line\">                        f.performActivityCreated(f.mSavedFragmentState);</div><div class=\"line\">                        dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, <span class=\"keyword\">false</span>);</div><div class=\"line\">                        <span class=\"keyword\">if</span> (f.mView != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            f.restoreViewState(f.mSavedFragmentState);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        f.mSavedFragmentState = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</div><div class=\"line\">                        f.mState = Fragment.STOPPED;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STOPPED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.STOPPED) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"moveto STARTED: \"</span> + f);</div><div class=\"line\">                        f.performStart(); <span class=\"comment\">//随后开始onStart</span></div><div class=\"line\">                        dispatchOnFragmentStarted(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STARTED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.STARTED) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"moveto RESUMED: \"</span> + f);</div><div class=\"line\">                        f.performResume(); <span class=\"comment\">//onResume</span></div><div class=\"line\">                        dispatchOnFragmentResumed(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                        f.mSavedFragmentState = <span class=\"keyword\">null</span>;</div><div class=\"line\">                        f.mSavedViewState = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f.mState &gt; newState) &#123; <span class=\"comment\">//Fragment的STATE降低</span></div><div class=\"line\">            <span class=\"keyword\">switch</span> (f.mState) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.RESUMED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.RESUMED) &#123;</div><div class=\"line\">                        f.performPause(); <span class=\"comment\">//onPause</span></div><div class=\"line\">                        dispatchOnFragmentPaused(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STARTED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.STARTED) &#123;</div><div class=\"line\">                        f.performStop();<span class=\"comment\">//调用onStop,state变成STOPPED</span></div><div class=\"line\">                        dispatchOnFragmentStopped(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STOPPED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.STOPPED) &#123;</div><div class=\"line\">                        f.performReallyStop();<span class=\"comment\">//不调用回调，状态变成ACTIVITY_CREATED</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</div><div class=\"line\">                        f.performDestroyView(); <span class=\"comment\">//状态变成CREATED，调用onDestoryView。最后收尾调用                            f.mContainer.removeView(f.mView);//引用置空</span></div><div class=\"line\">                        dispatchOnFragmentViewDestroyed(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                        <span class=\"keyword\">if</span> (f.mView != <span class=\"keyword\">null</span> &amp;&amp; f.mContainer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            f.mContainer.removeView(f.mView);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        f.mContainer = <span class=\"keyword\">null</span>;</div><div class=\"line\">                        f.mView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                        f.mInnerView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.CREATED) &#123;</div><div class=\"line\">                            <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"movefrom CREATED: \"</span> + f);</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!f.mRetaining) &#123;</div><div class=\"line\">                                f.performDestroy();</div><div class=\"line\">                                dispatchOnFragmentDestroyed(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                f.mState = Fragment.INITIALIZING;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            f.performDetach();</div><div class=\"line\">                            dispatchOnFragmentDetached(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!keepActive) &#123;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (!f.mRetaining) &#123;</div><div class=\"line\">                                    makeInactive(f);</div><div class=\"line\">                                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                    f.mHost = <span class=\"keyword\">null</span>; <span class=\"comment\">//Fragment可以在Activity挂了之后接着存在，这里只是避免内存泄漏，那个方法叫做setRetainState好像</span></div><div class=\"line\">                                    f.mParentFragment = <span class=\"keyword\">null</span>;</div><div class=\"line\">                                    f.mFragmentManager = <span class=\"keyword\">null</span>;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                    &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>moveToState的方法很长，基本上可以分为state升高和state降低来看：</p>\n<ol>\n<li>state升高的过程中：<ul>\n<li>onAttach是第一个回调，这里面给Fragment的mHost赋值；(响应Fragment.CREATED信号)</li>\n<li>onCreateView,onViewCreated是在一个方法里进行的，本质上调用的是mContainer.addView方法。随后立即调用onActivityCreated方法(响应Fragment.ACTIVITY_CREATED方法)</li>\n<li>onStart是第三个回调，onStart文档明确表示该方法调用时Fragment已经对用户可见。文档同时说明该方法和Activity的onStart方法挂钩，原理是FragmentActivity的onStart中调用了mFragments.dispatchStart()方法。</li>\n</ul>\n</li>\n<li>Fragment和Activity生命周期挂钩<ul>\n<li>FragmentActivity的onCreate中调用了FragmentManager的dispatchCreate方法，发出Fragment.CREATED信号</li>\n<li>FragmentActivity的onStart中先调用了dispatchActivityCreated方法（发出ACTIVITY_CREATED信号），随后调用dispatchStart（发出Fragment.STARTED信号）</li>\n<li>FragmentActivity的onResume中用Handler发送了一个Message，对应mFragments.dispatchResume(Fragment.RESUMED信号);FragmentActivity的onPostResume中也调用了dispatchResume方法，不过moveToState方法最后已经判断了newState&gt; currentState。</li>\n<li>onPause和onStop和onDestoryView也差不多。注意，DestoryView实质只是将Fragment的mView从container中移除，设置mView为null，mContainer为null;onDestory先于onDetach调用</li>\n</ul>\n</li>\n<li>FragmentActivity中的dispatchActivityCreated和dispatchFragmentStarted写在一个方法里，区别是onActivityCreated先于onStart调用且只会被调用一次。所以onActivityCreated存在的意义不过是为了帮助区分是初次start还是后面多次的start（Activity的onStart会被多次调用）</li>\n<li>state降低的过程其实也差不多，我也懒得分析了。之前以为detach和attch方法很特殊，其实只是从FragmentManager的mAdded中移除该Fragment，并设置fragment.mAdded = false.</li>\n<li>从一个state到另一个state基本的步骤就是fragment.performXXX，然后dispatchXXX，这里面顺手把state设置一下</li>\n</ol>\n<p>FragmentManager的核心方法应该就是这个moveToState方法了。到此，commit分析结束。说一下几个不建议使用的方法<br><strong>executePendingTransactions</strong> 看了下，这个方法里面没有异步方法，别的就不清楚了。据说是将所有的Transaction全部执行掉，首先这里面有一大堆操作，会堵住主线程，其次，这个方法里面涉及到各个状态的判断，很混乱。</p>\n<p><strong>commitAllowingStateLoss</strong> 这个方法和commit的唯一区别是调用一个可能会抛出异常的方法，后面还是post了一个pendingAction,还是异步的。所以很多人纷纷调用commitAllowingStateLoss方法。然而，这个方法存在是有其意义的。安卓本身就是个异步的系统。Activity的onSaveInstanceState随时可能会被调用，调用之后所有有id的View的onSaveInstanceState都被调用了。这个时候再去尝试做任何操作都可能会重新对已经保存了状态的View造成影响。Activity重新恢复的时候会把saveState中的的UI快照恢复，这一次的操作就会造成恢复的时候不是保存时的效果.allowStateLoss的字面意思很清楚了，就是系统不保证此后View的状态能够正确被恢复。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkStateLoss</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mStateSaved) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                   <span class=\"string\">\"Can not perform this action after onSaveInstanceState\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mNoTransactionsBecause != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                   <span class=\"string\">\"Can not perform this action inside of \"</span> + mNoTransactionsBecause);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p><strong>commitNow</strong> 注意24.2 之后Google添加了一个单独的commitNow方法，这一点Adam Powell在2016年的IO上特别提到过。<br>内部执行了mTmpRecords(临时操作)，由于只是一项操作，外加里面还对这一次操作进行了优化，所以直接同步执行了。该方法不允许addToBackStack，因为这实质上等同于在所有pendingAction中插队。由于是同步执行，该方法保证方法返回之后，所有的Fragment都能处于所预期的state。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commitNow</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       disallowAddToBackStack();</div><div class=\"line\">       mManager.execSingleAction(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commitNowAllowingStateLoss</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     disallowAddToBackStack();</div><div class=\"line\">     mManager.execSingleAction(<span class=\"keyword\">this</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p><strong>commitNowAllowingStateLoss</strong> 和commitAllowingStateLoss一样的道理，开发者可能不经意在Activity保存了状态之后调用该方法，这违背了状态保存和恢复的原则。但还是开了个后门，前提是不保证UI恢复的时候出现非预期的表现。allowStateLoss的方法照说不应该调用，如果不调用这个方法的话，使用commitNow，而不是commit + executePendingTransactions。 同时，commitNow之前检查下mStateSaved是否是true,具体来说Activity的onStop和onSaveInstanceState调用之后这个值都会为true。</p>\n<p>关于Activity的onSaveInstanceState什么时候会调用，找到比较好的<a href=\"http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html\">解释</a>。 记住，旋转屏幕的时候一定会调用的。</p>\n<h2 id=\"4-现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\"><a href=\"#4-现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\" class=\"headerlink\" title=\"4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\"></a>4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter</h2><p>这两个类行数都不超过300行，非常简单，只是通过调用FragmentManager的相应方法实现展示View的功能。</p>\n<h2 id=\"5-Fragment的一些不常用的API\"><a href=\"#5-Fragment的一些不常用的API\" class=\"headerlink\" title=\"5. Fragment的一些不常用的API\"></a>5. Fragment的一些不常用的API</h2><p>attach,detach,FragmentLifecycleCallbacks,commitNow，setAllowOptimization(26.0.0又被deprecated了)<br>onCreateView这个名字是怎么来的，其实是在dispatchFragmentsOnCreateView里面调用的。Activity实现了onCreateView(LayoutInflater定义的，会在getSytemService返回LayoutInflater时调用，获取系统服务毕竟是一个异步过程)。</p>\n<h2 id=\"6-关于Glide是如何实现生命周期绑定的\"><a href=\"#6-关于Glide是如何实现生命周期绑定的\" class=\"headerlink\" title=\"6. 关于Glide是如何实现生命周期绑定的\"></a>6. 关于Glide是如何实现生命周期绑定的</h2><p>Fragment本身提供了生命周期监听回调<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">registerFragmentLifecycleCallbacks <span class=\"number\">25.1</span>.0</div><div class=\"line\">unregisterFragmentLifecycleCallbacks <span class=\"number\">25.1</span>.0</div><div class=\"line\"></div><div class=\"line\">addOnBackStackChangedListener <span class=\"number\">22.2</span>.0</div><div class=\"line\">removeOnBackStackChangedListener <span class=\"number\">22.2</span>.0</div></pre></td></tr></table></figure></p>\n<p>Glide的做法是写了一个<strong>SupportRequestManagerFragment</strong> 在这个Fragment的构造函数里放了一个ActivityFragmentLifecycle<br> <a href=\"http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD\">参考</a><br> 在这个Fragment的onStart，OnStop等方法里面调用该lifeCycle的onStart,onStop等回调(lifeCycle是接口，由RequestManager实现)<br> 关键代码<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               current = <span class=\"keyword\">new</span> RequestManagerFragment();</div><div class=\"line\">               pendingRequestManagerFragments.put(fm, current);</div><div class=\"line\">               fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class=\"line\">               handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p> 所以经常会在Debug的时候看到FragmentManager里面有个”com.bumptech.glide.manager”的Fragment。这个Fragemnt没有实现onCreateView，所以直接返回null。Fragment本身是可以不带View的。</p>\n<h2 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h2><p>Fragment的一些生命周期还是需要跟Activity的生命周期一起看，大部分是异步操作。FragmentManager类似一个管理者，也是一个容器，在Activity的生命周期中顺手实现了容器中元素所要求的UI状态。Fragment本质上是一个View的Controllers，通过FragmentManger和FragmentActivity的生命周期挂钩，并自动做好View的状态保存和恢复。具体的UI展示无非是addView，setVisibility等常规的方法，也正因为这样，support包里的Fragment才能做到3.0以下的适配。日常开发中，Fragment能够将原本堆在Activity中的逻辑承载过来,以异步的方式减轻主线程的压力，对外提供了获取(onViewCreated)，操作(Transaction)，销毁(onDestoryView)这些业务对象的回调方法。由于Android本身就是异步的系统，系统随时(asynchronous)可能会对Fragment的资源进行更改，开发者的代码也随时(asynchronous)会对这些资源进行操作。由于存在这种无法改变的’并发’现状，Fragment不得不为保证资源的一致性而主动抛出一些错误。本文有意忽略掉了一些transition动画(使用了hardwareLayer)和Loader加载的细节，希望能够对日常开发有点帮助。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"http://stackoverflow.com/questions/9156406/whats-the-difference-between-detaching-a-fragment-and-removing-it\">Fragment的onAttach和onDetach什么时候会调用</a></li>\n<li><a href=\"http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD\">Glide是怎么跟生命周期挂钩的</a></li>\n<li><a href=\"http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html\">Activity的onSaveInstanceState什么时候会调用</a></li>\n<li><a href=\"https://developer.android.com/guide/components/activities/activity-lifecycle.html\">Activity-LifeCycle</a></li>\n<li><a href=\"https://developer.android.com/guide/components/fragments.html\">Fragments文档</a>不要依赖Implementation Detail,源码随时会变，官方的文档才是值得依赖的。</li>\n</ol>\n","excerpt":"<p>We been told Fragment itself should only trust official docs, the implementation detail are prone to any change any time, don’t count on it!<br><img src=\"http://odzl05jxx.bkt.clouddn.com/2009528111321773591934.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<p>Fragment源码解析（support Library 25.3.0），不要以为看了源码就可以不鸟官方文档了，源码的内容经常变，只有官方的文档才是可靠的，谷歌保证会实现的效果。</p>\n<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>Fragment的核心类有这几个:</p>\n<blockquote>\n<p>FragmentManager, FragmentTransaction, Fragment。而事实上前两个都是抽象类，<br>FragmentManager的实现类是FragmentManagerImpl，FragmentTransaction的实现类是BackStackRecord</p>\n</blockquote>\n<p>从日常使用Fragment的方式开始:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">((FragmentActivity) mActivity).getSupportFragmentManager()</div><div class=\"line\">                    .beginTransaction().add(R.id.containerViewId,fragment).commit();</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-FragmentTransaction只是将动作添加到一个队列中了\"><a href=\"#2-FragmentTransaction只是将动作添加到一个队列中了\" class=\"headerlink\" title=\"2.FragmentTransaction只是将动作添加到一个队列中了\"></a>2.FragmentTransaction只是将动作添加到一个队列中了</h3><p>beginTransaction获取了一个FragmentTransaction实例，来看add方法的实现:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(Fragment fragment, String tag)</span> </span>&#123;</div><div class=\"line\">    doAddOp(<span class=\"number\">0</span>, fragment, tag, OP_ADD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment)</span> </span>&#123;</div><div class=\"line\">    doAddOp(containerViewId, fragment, <span class=\"keyword\">null</span>, OP_ADD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</div><div class=\"line\">    doAddOp(containerViewId, fragment, tag, OP_ADD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管是通过id还是Tag添加，都是调用同一个方法，传参不同而已<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAddOp</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag, <span class=\"keyword\">int</span> opcmd)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//省略部分代码</span></div><div class=\"line\">    fragment.mFragmentManager = mManager;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tag != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        fragment.mTag = tag;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//注意，进入这个方法的时候fragment已经实例化了，只是其中的回调方法还没有开始调用</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (containerViewId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Op op = <span class=\"keyword\">new</span> Op();</div><div class=\"line\">    op.cmd = opcmd; <span class=\"comment\">//这个cmd很重要，代表了是show、hide、add、remove等这些东西</span></div><div class=\"line\">    op.fragment = fragment;</div><div class=\"line\">    addOp(op);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//所有可能的操作细节都包含在这里面了。注意，这是线性的！</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_NULL = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_ADD = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_REPLACE = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_REMOVE = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_HIDE = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_SHOW = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_DETACH = <span class=\"number\">6</span>;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OP_ATTACH = <span class=\"number\">7</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//这个OP包装了了每一次操作的具体细节。</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Op</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> cmd;</div><div class=\"line\">    Fragment fragment;</div><div class=\"line\">    <span class=\"keyword\">int</span> enterAnim;</div><div class=\"line\">    <span class=\"keyword\">int</span> exitAnim;</div><div class=\"line\">    <span class=\"keyword\">int</span> popEnterAnim;</div><div class=\"line\">    <span class=\"keyword\">int</span> popExitAnim;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addOp</span><span class=\"params\">(Op op)</span> </span>&#123;</div><div class=\"line\">    mOps.add(op); <span class=\"comment\">//往一个普通的ArrayList中添加一个op</span></div><div class=\"line\">    op.enterAnim = mEnterAnim;</div><div class=\"line\">    op.exitAnim = mExitAnim;</div><div class=\"line\">    op.popEnterAnim = mPopEnterAnim;</div><div class=\"line\">    op.popExitAnim = mPopExitAnim;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-通过FragmentTransaction-commit执行操作\"><a href=\"#3-通过FragmentTransaction-commit执行操作\" class=\"headerlink\" title=\"3.通过FragmentTransaction.commit执行操作\"></a>3.通过FragmentTransaction.commit执行操作</h2><p>FragmentFransaction只是将所有操作保留到一次Transaction的一个任务队列(ArrayList)中了。真正的执行需要提交事务，这和数据库的事务很像。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">commit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> commitInternal(<span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">commitAllowingStateLoss</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> commitInternal(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//上面两个函数的返回值 Returns the identifier of this transaction's back stack entry, if addToBackStack(String)&#125; had been called.  Otherwise, returns a negative number. 如果调用过addToBackStack的话，返回这次操作在操作栈上的标识符。否则返回负数。</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">commitInternal</span><span class=\"params\">(<span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mCommitted) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"commit already called\"</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</div><div class=\"line\">            Log.v(TAG, <span class=\"string\">\"Commit: \"</span> + <span class=\"keyword\">this</span>);</div><div class=\"line\">            LogWriter logw = <span class=\"keyword\">new</span> LogWriter(TAG);</div><div class=\"line\">            PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(logw);</div><div class=\"line\">            dump(<span class=\"string\">\"  \"</span>, <span class=\"keyword\">null</span>, pw, <span class=\"keyword\">null</span>);</div><div class=\"line\">            pw.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mCommitted = <span class=\"keyword\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mAddToBackStack) &#123;<span class=\"comment\">//如果调用过addToBackStack，这个值就为true，否则为false</span></div><div class=\"line\">            mIndex = mManager.allocBackStackIndex(<span class=\"keyword\">this</span>);<span class=\"comment\">// 将BackStackRecord添加到一个ArrayList的尾部，List不存在则创建</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mIndex = -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mManager.enqueueAction(<span class=\"keyword\">this</span>, allowStateLoss); <span class=\"comment\">// 这里就是调用FragmnetManager的方法，添加到FragmentManager的mPendingActions中，并scheduleCommit（通过FragmnetHostCallBack往主线程post一条runnable）</span></div><div class=\"line\">        <span class=\"keyword\">return</span> mIndex; <span class=\"comment\">//返回的就是本次事务的mIndex</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// FragmentManagerImpl</span></div><div class=\"line\">      <span class=\"comment\">/**这里就是被推送到主线程的runnable，注意，这里是异步的</div><div class=\"line\">     * Only call from main thread!</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">execPendingActions</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        ensureExecReady(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"comment\">//这里就是不断的从mPendingAction中查找待执行的操作</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123;</div><div class=\"line\">            mExecutingActions = <span class=\"keyword\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                optimizeAndExecuteOps(mTmpRecords, mTmpIsPop); <span class=\"comment\">//从方法名大致能猜到这里是执行操作的地方,两个参数，第一个是待执行的操作的List，一个是对应每项操作是pop还push(出栈还是入栈)</span></div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                cleanupExec();</div><div class=\"line\">            &#125;</div><div class=\"line\">            didSomething = <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        doPendingDeferredStart();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> didSomething;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">optimizeAndExecuteOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</div><div class=\"line\">            ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">随后调用了executeOpsTogether方法，接着调用</div><div class=\"line\">        executeOps(records, isRecordPop, startIndex, endIndex);</div><div class=\"line\">最终又走到了BackStackRecord的方法里面</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">     * Reverses the execution of the operations within this transaction. The Fragment states will</div><div class=\"line\">     * only be modified if optimizations are not allowed.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> moveToState &#123;<span class=\"doctag\">@code</span> true&#125; if added fragments should be moved to their final state</div><div class=\"line\">     *                    in unoptimized transactions</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executePopOps</span><span class=\"params\">(<span class=\"keyword\">boolean</span> moveToState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opNum = mOps.size() - <span class=\"number\">1</span>; opNum &gt;= <span class=\"number\">0</span>; opNum--) &#123; <span class=\"comment\">//倒序执行,每一个ops包含了对一个Fragment的指令，遍历所有的ops</span></div><div class=\"line\">            <span class=\"keyword\">final</span> Op op = mOps.get(opNum);</div><div class=\"line\">            Fragment f = op.fragment;</div><div class=\"line\">            f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition), mTransitionStyle);</div><div class=\"line\">            <span class=\"keyword\">switch</span> (op.cmd) &#123;</div><div class=\"line\">                <span class=\"comment\">//这些操作全部只是设置一些变量的值，暂时还没到UI更改，具体的UI操作在moveToState里面</span></div><div class=\"line\">                <span class=\"keyword\">case</span> OP_ADD:</div><div class=\"line\">                    f.setNextAnim(op.popExitAnim);</div><div class=\"line\">                    mManager.removeFragment(f);  <span class=\"comment\">//从FragmentManager的mAdded中移除该fragment，fragment的mAdded = false,mRemoving = true;</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_REMOVE:</div><div class=\"line\">                    f.setNextAnim(op.popEnterAnim);</div><div class=\"line\">                    mManager.addFragment(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    <span class=\"comment\">/** addFragment里面有这么一段  </div><div class=\"line\">       if (mAdded.contains(fragment)) &#123;</div><div class=\"line\">                throw new IllegalStateException(\"Fragment already added: \" + fragment); //就是简单的判断下List中是否存在，如果在一个Fragment已经added的情况下再去add，就会出现这种错误</div><div class=\"line\">            &#125;**/</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_HIDE:</div><div class=\"line\">                    f.setNextAnim(op.popEnterAnim);</div><div class=\"line\">                    mManager.showFragment(f);</div><div class=\"line\">                    <span class=\"comment\">// 只是将fragment的mHidden设置为false了</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_SHOW:</div><div class=\"line\">                    f.setNextAnim(op.popExitAnim);</div><div class=\"line\">                    mManager.hideFragment(f);</div><div class=\"line\">                    <span class=\"comment\">// 只是将fragment的mHidden设置为true了</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_DETACH:</div><div class=\"line\">                    f.setNextAnim(op.popEnterAnim);</div><div class=\"line\">                    mManager.attachFragment(f);</div><div class=\"line\">                    <span class=\"comment\">//和attach差不多，也是设定了一些标志位</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> OP_ATTACH:</div><div class=\"line\">                    f.setNextAnim(op.popExitAnim);</div><div class=\"line\">                    mManager.detachFragment(f);</div><div class=\"line\">                    <span class=\"comment\">// mFragment.mDetached = false,这里判断了manager.mAdded.contains(mFragment)，会抛出异常Fragment already added!如果正常的话把mFragment添加到mAdded里面</span></div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">default</span>:</div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown cmd: \"</span> + op.cmd);</div><div class=\"line\">            &#125;</div><div class=\"line\">           <span class=\"keyword\">if</span> (!mAllowOptimization &amp;&amp; op.cmd != OP_ADD) &#123;</div><div class=\"line\">                mManager.moveFragmentToExpectedState(f);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">         <span class=\"keyword\">if</span> (!mAllowOptimization) &#123;</div><div class=\"line\">            <span class=\"comment\">// Added fragments are added at the end to comply with prior behavior.</span></div><div class=\"line\">            mManager.moveToState(mManager.mCurState, <span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>通常我们都是在主线程往Manager添加Transaction，不过从这里看来，添加Transaction只是添加了一份BackStackRecord，最终执行还是在主线程上做的。<br>很直观的看到这里 调用了manager的removeFragment、showFragment等方法.随便挑两个<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// FragmentManagerImpl.java</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFragment</span><span class=\"params\">(Fragment fragment, <span class=\"keyword\">boolean</span> moveToStateNow)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mAdded == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mAdded = <span class=\"keyword\">new</span> ArrayList&lt;Fragment&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        makeActive(fragment);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fragment already added: \"</span> + fragment);</div><div class=\"line\">            &#125;</div><div class=\"line\">            mAdded.add(fragment);</div><div class=\"line\">            fragment.mAdded = <span class=\"keyword\">true</span>; <span class=\"comment\">// 记得fragment.isAdded()方法吗，在这里被设置的</span></div><div class=\"line\">            fragment.mRemoving = <span class=\"keyword\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (fragment.mView == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                fragment.mHiddenChanged = <span class=\"keyword\">false</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</div><div class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (moveToStateNow) &#123;</div><div class=\"line\">                moveToState(fragment);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// show的方法异常简单</span></div><div class=\"line\">       <span class=\"comment\">/**</div><div class=\"line\">     * Marks a fragment as shown to be later animated in with</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (fragment.mHidden) &#123;</div><div class=\"line\">            fragment.mHidden = <span class=\"keyword\">false</span>; <span class=\"comment\">//这里只是设置一下标志位</span></div><div class=\"line\">            <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></div><div class=\"line\">            <span class=\"comment\">// it doesn't go through the animation.</span></div><div class=\"line\">            fragment.mHiddenChanged = !fragment.mHiddenChanged;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>接下里就是FragmentManager的MoveToState方法了，非常长<br>先记住Fragment的几个状态，这些都是Adam powell说过的，这是线性的，moveToState方法也是这样走的，不会跳过中间某个state</p>\n<blockquote>\n<p>  static final int INITIALIZING = 0;     // Not yet created.<br>    static final int CREATED = 1;          // Created.<br>    static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.<br>    static final int STOPPED = 3;          // Fully created, not started.<br>    static final int STARTED = 4;          // Created and started, not resumed.<br>    static final int RESUMED = 5;          // Created started and resumed.</p>\n</blockquote>\n<p>moveToState的方法比较长，删掉一些不必要的，重点关注Fragment的那些生命周期回调是什么时候被调用的。建议看源码，我这里删除了很多还有一大坨。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// FragmentImpl.java</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(Fragment f, <span class=\"keyword\">int</span> newState, <span class=\"keyword\">int</span> transit, <span class=\"keyword\">int</span> transitionStyle,</div><div class=\"line\">            <span class=\"keyword\">boolean</span> keepActive)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//Fragment的state将提高，例如从ACTIVITY_CREATED到ACTIVITYCREATED</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (f.mState &lt; newState) &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> (f.mState) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.INITIALIZING:<span class=\"comment\">//尚未初始化</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (f.mSavedFragmentState != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                      <span class=\"comment\">//从SavedState中获取各个View的状态，尝试恢复View的状态</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                    f.mHost = mHost; <span class=\"comment\">//从这一刻开始,getActivity，getContext，isAdded等和Activity相关的方法都有正确的返回</span></div><div class=\"line\"></div><div class=\"line\">                    f.mCalled = <span class=\"keyword\">false</span>; <span class=\"comment\">//这个mCalled是为了避免子类忘记调用super方法的</span></div><div class=\"line\">                    f.onAttach(mHost.getContext()); <span class=\"comment\">// onAttach就是在这里调用的</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (f.mParentFragment == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        mHost.onAttachFragment(f);<span class=\"comment\">//mHost其实就是Activity</span></div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        f.mParentFragment.onAttachFragment(f); <span class=\"comment\">//这个是ChildFragment的情况</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                    dispatchOnFragmentAttached(f, mHost.getContext(), <span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">if</span> (!f.mRetaining) &#123;</div><div class=\"line\">                        f.performCreate(f.mSavedFragmentState); <span class=\"comment\">//这里面调用了onCreate回调，同时STATE变成CREATED</span></div><div class=\"line\">                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        f.restoreChildFragmentState(f.mSavedFragmentState);</div><div class=\"line\">                        f.mState = Fragment.CREATED;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    f.mRetaining = <span class=\"keyword\">false</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (f.mFromLayout) &#123;<span class=\"comment\">//写在XML里面的，直接在从INITIALIZING到CREATED的过程中把performCreateView和onViewCreated走一遍</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.CREATED) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (!f.mFromLayout) &#123; <span class=\"comment\">//不是写在xml标签中的Fragment</span></div><div class=\"line\">                            ViewGroup container = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            <span class=\"keyword\">if</span> (f.mContainerId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                                container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            f.mContainer = container;</div><div class=\"line\">                            f.mView = f.performCreateView(f.getLayoutInflater(</div><div class=\"line\">                                    f.mSavedFragmentState), container, f.mSavedFragmentState);<span class=\"comment\">// onCreateView回调</span></div><div class=\"line\">                            <span class=\"keyword\">if</span> (f.mView != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                f.mInnerView = f.mView;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (container != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                    container.addView(f.mView);<span class=\"comment\">//所以Fragment本质上只是addView到Container里</span></div><div class=\"line\">                                &#125;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (f.mHidden) &#123; <span class=\"comment\">//hide就只是设置Visibility这么简单，这mHdidden是在上面的showFragment里面设置的</span></div><div class=\"line\">                                    f.mView.setVisibility(View.GONE);</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                f.onViewCreated(f.mView, f.mSavedFragmentState);<span class=\"comment\">// 又是回调,onViewCreated确实是在onCreatedView之后立马添加的</span></div><div class=\"line\">                                dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,</div><div class=\"line\">                                        <span class=\"keyword\">false</span>);</div><div class=\"line\">                                <span class=\"comment\">// Only animate the view if it is visible. This is done after</span></div><div class=\"line\">                                <span class=\"comment\">// dispatchOnFragmentViewCreated in case visibility is changed</span></div><div class=\"line\">                                f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)</div><div class=\"line\">                                        &amp;&amp; f.mContainer != <span class=\"keyword\">null</span>;</div><div class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                f.mInnerView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        <span class=\"comment\">//随后马上就调用到了onActivityCreated了，同一个Message中</span></div><div class=\"line\">                        f.performActivityCreated(f.mSavedFragmentState);</div><div class=\"line\">                        dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, <span class=\"keyword\">false</span>);</div><div class=\"line\">                        <span class=\"keyword\">if</span> (f.mView != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            f.restoreViewState(f.mSavedFragmentState);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        f.mSavedFragmentState = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</div><div class=\"line\">                        f.mState = Fragment.STOPPED;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STOPPED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.STOPPED) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"moveto STARTED: \"</span> + f);</div><div class=\"line\">                        f.performStart(); <span class=\"comment\">//随后开始onStart</span></div><div class=\"line\">                        dispatchOnFragmentStarted(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STARTED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &gt; Fragment.STARTED) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"moveto RESUMED: \"</span> + f);</div><div class=\"line\">                        f.performResume(); <span class=\"comment\">//onResume</span></div><div class=\"line\">                        dispatchOnFragmentResumed(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                        f.mSavedFragmentState = <span class=\"keyword\">null</span>;</div><div class=\"line\">                        f.mSavedViewState = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f.mState &gt; newState) &#123; <span class=\"comment\">//Fragment的STATE降低</span></div><div class=\"line\">            <span class=\"keyword\">switch</span> (f.mState) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.RESUMED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.RESUMED) &#123;</div><div class=\"line\">                        f.performPause(); <span class=\"comment\">//onPause</span></div><div class=\"line\">                        dispatchOnFragmentPaused(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STARTED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.STARTED) &#123;</div><div class=\"line\">                        f.performStop();<span class=\"comment\">//调用onStop,state变成STOPPED</span></div><div class=\"line\">                        dispatchOnFragmentStopped(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.STOPPED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.STOPPED) &#123;</div><div class=\"line\">                        f.performReallyStop();<span class=\"comment\">//不调用回调，状态变成ACTIVITY_CREATED</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</div><div class=\"line\">                        f.performDestroyView(); <span class=\"comment\">//状态变成CREATED，调用onDestoryView。最后收尾调用                            f.mContainer.removeView(f.mView);//引用置空</span></div><div class=\"line\">                        dispatchOnFragmentViewDestroyed(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                        <span class=\"keyword\">if</span> (f.mView != <span class=\"keyword\">null</span> &amp;&amp; f.mContainer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            f.mContainer.removeView(f.mView);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        f.mContainer = <span class=\"keyword\">null</span>;</div><div class=\"line\">                        f.mView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                        f.mInnerView = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> Fragment.CREATED:</div><div class=\"line\">                    <span class=\"keyword\">if</span> (newState &lt; Fragment.CREATED) &#123;</div><div class=\"line\">                            <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"movefrom CREATED: \"</span> + f);</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!f.mRetaining) &#123;</div><div class=\"line\">                                f.performDestroy();</div><div class=\"line\">                                dispatchOnFragmentDestroyed(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                f.mState = Fragment.INITIALIZING;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            f.performDetach();</div><div class=\"line\">                            dispatchOnFragmentDetached(f, <span class=\"keyword\">false</span>);</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!keepActive) &#123;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (!f.mRetaining) &#123;</div><div class=\"line\">                                    makeInactive(f);</div><div class=\"line\">                                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                    f.mHost = <span class=\"keyword\">null</span>; <span class=\"comment\">//Fragment可以在Activity挂了之后接着存在，这里只是避免内存泄漏，那个方法叫做setRetainState好像</span></div><div class=\"line\">                                    f.mParentFragment = <span class=\"keyword\">null</span>;</div><div class=\"line\">                                    f.mFragmentManager = <span class=\"keyword\">null</span>;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                    &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>moveToState的方法很长，基本上可以分为state升高和state降低来看：</p>\n<ol>\n<li>state升高的过程中：<ul>\n<li>onAttach是第一个回调，这里面给Fragment的mHost赋值；(响应Fragment.CREATED信号)</li>\n<li>onCreateView,onViewCreated是在一个方法里进行的，本质上调用的是mContainer.addView方法。随后立即调用onActivityCreated方法(响应Fragment.ACTIVITY_CREATED方法)</li>\n<li>onStart是第三个回调，onStart文档明确表示该方法调用时Fragment已经对用户可见。文档同时说明该方法和Activity的onStart方法挂钩，原理是FragmentActivity的onStart中调用了mFragments.dispatchStart()方法。</li>\n</ul>\n</li>\n<li>Fragment和Activity生命周期挂钩<ul>\n<li>FragmentActivity的onCreate中调用了FragmentManager的dispatchCreate方法，发出Fragment.CREATED信号</li>\n<li>FragmentActivity的onStart中先调用了dispatchActivityCreated方法（发出ACTIVITY_CREATED信号），随后调用dispatchStart（发出Fragment.STARTED信号）</li>\n<li>FragmentActivity的onResume中用Handler发送了一个Message，对应mFragments.dispatchResume(Fragment.RESUMED信号);FragmentActivity的onPostResume中也调用了dispatchResume方法，不过moveToState方法最后已经判断了newState&gt; currentState。</li>\n<li>onPause和onStop和onDestoryView也差不多。注意，DestoryView实质只是将Fragment的mView从container中移除，设置mView为null，mContainer为null;onDestory先于onDetach调用</li>\n</ul>\n</li>\n<li>FragmentActivity中的dispatchActivityCreated和dispatchFragmentStarted写在一个方法里，区别是onActivityCreated先于onStart调用且只会被调用一次。所以onActivityCreated存在的意义不过是为了帮助区分是初次start还是后面多次的start（Activity的onStart会被多次调用）</li>\n<li>state降低的过程其实也差不多，我也懒得分析了。之前以为detach和attch方法很特殊，其实只是从FragmentManager的mAdded中移除该Fragment，并设置fragment.mAdded = false.</li>\n<li>从一个state到另一个state基本的步骤就是fragment.performXXX，然后dispatchXXX，这里面顺手把state设置一下</li>\n</ol>\n<p>FragmentManager的核心方法应该就是这个moveToState方法了。到此，commit分析结束。说一下几个不建议使用的方法<br><strong>executePendingTransactions</strong> 看了下，这个方法里面没有异步方法，别的就不清楚了。据说是将所有的Transaction全部执行掉，首先这里面有一大堆操作，会堵住主线程，其次，这个方法里面涉及到各个状态的判断，很混乱。</p>\n<p><strong>commitAllowingStateLoss</strong> 这个方法和commit的唯一区别是调用一个可能会抛出异常的方法，后面还是post了一个pendingAction,还是异步的。所以很多人纷纷调用commitAllowingStateLoss方法。然而，这个方法存在是有其意义的。安卓本身就是个异步的系统。Activity的onSaveInstanceState随时可能会被调用，调用之后所有有id的View的onSaveInstanceState都被调用了。这个时候再去尝试做任何操作都可能会重新对已经保存了状态的View造成影响。Activity重新恢复的时候会把saveState中的的UI快照恢复，这一次的操作就会造成恢复的时候不是保存时的效果.allowStateLoss的字面意思很清楚了，就是系统不保证此后View的状态能够正确被恢复。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkStateLoss</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mStateSaved) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                   <span class=\"string\">\"Can not perform this action after onSaveInstanceState\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mNoTransactionsBecause != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                   <span class=\"string\">\"Can not perform this action inside of \"</span> + mNoTransactionsBecause);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p><strong>commitNow</strong> 注意24.2 之后Google添加了一个单独的commitNow方法，这一点Adam Powell在2016年的IO上特别提到过。<br>内部执行了mTmpRecords(临时操作)，由于只是一项操作，外加里面还对这一次操作进行了优化，所以直接同步执行了。该方法不允许addToBackStack，因为这实质上等同于在所有pendingAction中插队。由于是同步执行，该方法保证方法返回之后，所有的Fragment都能处于所预期的state。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commitNow</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       disallowAddToBackStack();</div><div class=\"line\">       mManager.execSingleAction(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commitNowAllowingStateLoss</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     disallowAddToBackStack();</div><div class=\"line\">     mManager.execSingleAction(<span class=\"keyword\">this</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p><strong>commitNowAllowingStateLoss</strong> 和commitAllowingStateLoss一样的道理，开发者可能不经意在Activity保存了状态之后调用该方法，这违背了状态保存和恢复的原则。但还是开了个后门，前提是不保证UI恢复的时候出现非预期的表现。allowStateLoss的方法照说不应该调用，如果不调用这个方法的话，使用commitNow，而不是commit + executePendingTransactions。 同时，commitNow之前检查下mStateSaved是否是true,具体来说Activity的onStop和onSaveInstanceState调用之后这个值都会为true。</p>\n<p>关于Activity的onSaveInstanceState什么时候会调用，找到比较好的<a href=\"http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html\">解释</a>。 记住，旋转屏幕的时候一定会调用的。</p>\n<h2 id=\"4-现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\"><a href=\"#4-现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\" class=\"headerlink\" title=\"4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter\"></a>4. 现在再来看FragmentPagerAdapter和FragmentStatePagerAdapter</h2><p>这两个类行数都不超过300行，非常简单，只是通过调用FragmentManager的相应方法实现展示View的功能。</p>\n<h2 id=\"5-Fragment的一些不常用的API\"><a href=\"#5-Fragment的一些不常用的API\" class=\"headerlink\" title=\"5. Fragment的一些不常用的API\"></a>5. Fragment的一些不常用的API</h2><p>attach,detach,FragmentLifecycleCallbacks,commitNow，setAllowOptimization(26.0.0又被deprecated了)<br>onCreateView这个名字是怎么来的，其实是在dispatchFragmentsOnCreateView里面调用的。Activity实现了onCreateView(LayoutInflater定义的，会在getSytemService返回LayoutInflater时调用，获取系统服务毕竟是一个异步过程)。</p>\n<h2 id=\"6-关于Glide是如何实现生命周期绑定的\"><a href=\"#6-关于Glide是如何实现生命周期绑定的\" class=\"headerlink\" title=\"6. 关于Glide是如何实现生命周期绑定的\"></a>6. 关于Glide是如何实现生命周期绑定的</h2><p>Fragment本身提供了生命周期监听回调<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">registerFragmentLifecycleCallbacks <span class=\"number\">25.1</span>.0</div><div class=\"line\">unregisterFragmentLifecycleCallbacks <span class=\"number\">25.1</span>.0</div><div class=\"line\"></div><div class=\"line\">addOnBackStackChangedListener <span class=\"number\">22.2</span>.0</div><div class=\"line\">removeOnBackStackChangedListener <span class=\"number\">22.2</span>.0</div></pre></td></tr></table></figure></p>\n<p>Glide的做法是写了一个<strong>SupportRequestManagerFragment</strong> 在这个Fragment的构造函数里放了一个ActivityFragmentLifecycle<br> <a href=\"http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD\">参考</a><br> 在这个Fragment的onStart，OnStop等方法里面调用该lifeCycle的onStart,onStop等回调(lifeCycle是接口，由RequestManager实现)<br> 关键代码<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               current = <span class=\"keyword\">new</span> RequestManagerFragment();</div><div class=\"line\">               pendingRequestManagerFragments.put(fm, current);</div><div class=\"line\">               fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class=\"line\">               handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p> 所以经常会在Debug的时候看到FragmentManager里面有个”com.bumptech.glide.manager”的Fragment。这个Fragemnt没有实现onCreateView，所以直接返回null。Fragment本身是可以不带View的。</p>\n<h2 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h2><p>Fragment的一些生命周期还是需要跟Activity的生命周期一起看，大部分是异步操作。FragmentManager类似一个管理者，也是一个容器，在Activity的生命周期中顺手实现了容器中元素所要求的UI状态。Fragment本质上是一个View的Controllers，通过FragmentManger和FragmentActivity的生命周期挂钩，并自动做好View的状态保存和恢复。具体的UI展示无非是addView，setVisibility等常规的方法，也正因为这样，support包里的Fragment才能做到3.0以下的适配。日常开发中，Fragment能够将原本堆在Activity中的逻辑承载过来,以异步的方式减轻主线程的压力，对外提供了获取(onViewCreated)，操作(Transaction)，销毁(onDestoryView)这些业务对象的回调方法。由于Android本身就是异步的系统，系统随时(asynchronous)可能会对Fragment的资源进行更改，开发者的代码也随时(asynchronous)会对这些资源进行操作。由于存在这种无法改变的’并发’现状，Fragment不得不为保证资源的一致性而主动抛出一些错误。本文有意忽略掉了一些transition动画(使用了hardwareLayer)和Loader加载的细节，希望能够对日常开发有点帮助。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"http://stackoverflow.com/questions/9156406/whats-the-difference-between-detaching-a-fragment-and-removing-it\">Fragment的onAttach和onDetach什么时候会调用</a></li>\n<li><a href=\"http://blog.leanote.com/post/qq-tank/Glide%E4%B8%AD\">Glide是怎么跟生命周期挂钩的</a></li>\n<li><a href=\"http://www.cnblogs.com/heiguy/archive/2010/10/30/1865239.html\">Activity的onSaveInstanceState什么时候会调用</a></li>\n<li><a href=\"https://developer.android.com/guide/components/activities/activity-lifecycle.html\">Activity-LifeCycle</a></li>\n<li><a href=\"https://developer.android.com/guide/components/fragments.html\">Fragments文档</a>不要依赖Implementation Detail,源码随时会变，官方的文档才是值得依赖的。</li>\n</ol>"},{"title":"从glide源码到图片加载框架设计思路","date":"2017-07-20T16:13:02.000Z","_content":"\nglide的源码几个月前曾经拜读过，大致了解了其异步加载的实现原理。图片加载和网络请求很类似，就像当初看Volley，从一个Request --->  CacheDispatch  ---> NetworkDispatcher  ---->  ResponseDeliver。优秀的轮子不仅执行效率高，同时具备高的扩展性。读懂源码其实只是第一步，往下应该是利用框架提供的扩展方案，再往后应该就是能够独立设计出一套类似的框架了。\n\n\n![](http://odzl05jxx.bkt.clouddn.com/a11f41e0b1df95212c71920b3959cd72.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1. 使用入门\n印象中最早接触Glide是在cheesequare中，顿时发现，原来加载图片可以这么简单，之后的开发过程中总会对Glide有所偏倚。接近两年之后再来过一遍源码，希望能够回答那个“如果让你来设计一个图片加载框架，你会怎么设计？”的问题。\n使用方式很简单\n\n```java\n  Glide.with(activity)\n                .load(R.drawable.image_id)\n                .into(mImageView);\n\n```\n\n来看这里面做了什么：\n\n```java\n       public RequestManager get(FragmentActivity activity) {\n        if (Util.isOnBackgroundThread()) {\n            return get(activity.getApplicationContext());\n        } else {\n            assertNotDestroyed(activity);\n            FragmentManager fm = activity.getSupportFragmentManager();\n            return supportFragmentGet(activity, fm);\n        }\n    }\n\n\n    SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) {\n        SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(\n            FRAGMENT_TAG);\n        if (current == null) {\n            current = pendingSupportRequestManagerFragments.get(fm);\n            if (current == null) {\n                current = new SupportRequestManagerFragment();\n                pendingSupportRequestManagerFragments.put(fm, current);\n                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n                handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n            }\n        }\n        return current;\n    }\n\n```\n\nwith方法只是返回了一个RequestManager，with方法可以接受Fragemnt,Activity以及Context等.以上面的activity为例，supportFragmentGet方法只是通过FragmentActivity的supportFragmentManager去findFragmentByTag，这个Tag叫做：“com.bumptech.glide.manager”，所以一般在Debug的时候，去SupportFragmentManager里面查找，有时候能够看到一个这样的Fragment。这个方法里面就是查找这样的一个Fragment，甚至我们自己也可以FindFragmentByTag去调用这个Fragment的方法(这是一个Public的class)然后从这个Fragemnt里面获得RequestManager成员变量（没有就new一个并set）。可以看出，一个Fragment只有一个RequestManager，Fragment主要是为了跟Activity生命周期挂钩的。这里有必要讲一下为什么要写两次current ==null，findFragmentByTag并不会在commitAllowingStateLoss之后就会返回添加的Fragment，只是往主线程的MessageQueue里面丢了一个消息，这个消息执行完毕之后才findFragmentByTag才不为空。这里用Handler丢一条消息，这条消息肯定要排在之前那条消息之后才被执行，所以才有这样一个Pendingmap的设计。当然到这里，最重要的还是Glide是通过commit了一个特殊的Fragment来实现生命周期监听。\n具体来看：SupportRequestManagerFragment中\n\n```java\n  @Override\n    public void onStart() {\n        super.onStart();\n        lifecycle.onStart();\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        lifecycle.onStop();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        lifecycle.onDestroy();\n    }\n```\n\n而对应到LifeCycle的各个方法：\n\n```java\n void onStart() {\n        isStarted = true;\n        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {\n            lifecycleListener.onStart();\n        }\n    }\n\n    void onStop() {\n        isStarted = false;\n        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {\n            lifecycleListener.onStop();\n        }\n    }\n\n    void onDestroy() {\n        isDestroyed = true;\n        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {\n            lifecycleListener.onDestroy();\n        }\n    }\n```\n就是把内部维护的一个集合一个个拿出来调用响应生命周期的方法。\n而这个LifeCycleListener就是上面创建RequestManager时(构造函数传进来了fragment的lifeCycle)添加的。RequestManager还默认添加了一个ConnectivityMonitor，主要作用就是在生命周期的onStart注册了一个ConnectivityManager.CONNECTIVITY_ACTION的BroadCastReceiver，在onStop的时候unRegister，在网络状态变化的时候调用RequestManager的RequestTracker成员变量的restartRequet。\n\n\n小结：\n- 在有权限(android.permission.ACCESS_NETWORK_STATE)的情况下，Glide已经做好了有网-> 断网-> 有网的恢复请求。另外，Android 7.0虽说不再发送ConnectivityManager.CONNECTIVITY_ACTION这个广播，但对于前台应用，动态注册的Receiver还是能够收到，Glide由于是在OnStart注册的，所以完全没问题。\n- 在一个Activity中，RequestManager只要一个，其实开发者自己保留下来也没什么问题\n\n\n## 2. RequestManager调度请求\n\n来看下这个RequestManager的成员变量\n\n```java\npublic class RequestManager implements LifecycleListener {\n    private final Context context;\n    private final Lifecycle lifecycle;\n    private final RequestManagerTreeNode treeNode;\n    private final RequestTracker requestTracker;\n    private final Glide glide; //全局只有一个，控制线程池，用Application的Context创建的\n    private final OptionsApplier optionsApplier;\n    private DefaultOptions options;\n\n    }\n\n\n    class OptionsApplier {\n\n        public <A, X extends GenericRequestBuilder<A, ?, ?, ?>> X apply(X builder) {\n            if (options != null) {\n                options.apply(builder);\n            }\n            return builder;\n        }\n    }\n\n```\n上面这个泛型写的非常绕，OptionApplier的意思就是，如果用户提供了一些定制(存在options里面)，就给一些定制的选择。一般这个options为null。\n\n\n\n\n### 2.1 各种Type的Request\n\nGlide的RequestManager可以接受各种各样的来源\n\n```java\n   public DrawableTypeRequest<Integer> load(Integer resourceId) {\n        return (DrawableTypeRequest<Integer>) fromResource().load(resourceId);\n    }\n\n     public DrawableTypeRequest<byte[]> load(byte[] model) {\n        return (DrawableTypeRequest<byte[]>) fromBytes().load(model);\n    }\n\n      public DrawableTypeRequest<File> load(File file) {\n        return (DrawableTypeRequest<File>) fromFile().load(file);\n    }\n\n//上述方法都调用到了\n     private <T> DrawableTypeRequest<T> loadGeneric(Class<T> modelClass) {\n        ModelLoader<T, InputStream> streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);\n        ModelLoader<T, ParcelFileDescriptor> fileDescriptorModelLoader =\n                Glide.buildFileDescriptorModelLoader(modelClass, context);\n        if (modelClass != null && streamModelLoader == null && fileDescriptorModelLoader == null) {\n            throw new IllegalArgumentException(\"Unknown type \" + modelClass + \". You must provide a Model of a type for\"\n                    + \" which there is a registered ModelLoader, if you are using a custom model, you must first call\"\n                    + \" Glide#register with a ModelLoaderFactory for your custom model class\");\n        }\n\n        return optionsApplier.apply(\n                new DrawableTypeRequest<T>(modelClass, streamModelLoader, fileDescriptorModelLoader, context,\n                        glide, requestTracker, lifecycle, optionsApplier));\n    }\n\n```\n\nDrawableTypeRequest接受一个泛型，可以是String(网络路径)，File(本地文件),Integer（资源文件）。所以最终返回的DrawableTypeRequet里面装的可能是String.class，Integer.class也可能是File.class。\n比较难懂的是 streamModelLoader和fileDescriptorModelLoader的创建.\n\n```java\npublic interface ModelLoader<T, Y> {\n    DataFetcher<Y> getResourceFetcher(T model, int width, int height);\n}\n```\nModelLoader其实就是只有一个方法的接口，例如with(File)会传一个File.class进来，返回的streamModelLoader的T就是File，Y就是InputStream。\nModelLoader<T, Y>负责提供DataFetcher<Y>，T是数据源，可以是File,Resourse，url等等。Y用于描述类型，本地的就使用ParcelFileDescriptor（记得FileDescriptor属于Native的东西），网络上的就使用InputStream.\nT和Y的组合可能有很多种，Cache在Glide(全局唯一)的loaderFactory（成员变量）的一个HashMap(没用ConcurrentHashMap是因为buildModelLoader方法加锁了)中。所以这份缓存也是全局唯一的。\nT和Y的一一对应其实是在Glide的构造函数里面写好的：\n\n```java\n\n        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());\n        register(File.class, InputStream.class, new StreamFileLoader.Factory());\n        register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());\n        register(int.class, InputStream.class, new StreamResourceLoader.Factory());\n        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());\n        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());\n        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());\n        register(String.class, InputStream.class, new StreamStringLoader.Factory());\n        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());\n        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());\n        register(URL.class, InputStream.class, new StreamUrlLoader.Factory());\n        register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory());\n        register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory());\n```\n左边有很多种，右边只可能是InputStream或者ParcelFileDescriptor。\n\n### 2.2 Request的继承关系\n\n```\n public class DrawableTypeRequest<ModelType> extends DrawableRequestBuilder<ModelType> implements DownloadOptions\n public class DrawableRequestBuilder<ModelType>\n        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>\n        implements BitmapOptions, DrawableOptions \n public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> implements Cloneable        \n```\n\n记住这个ModelType就是Glide.with(context).load(XXX) 里面传进去的Object的Class，例如File.class，那么\n上面其实就是创建了一个DrawableTypeRequest，泛型是File ，构造函数一层层往上调用，DrawableRequestBuilder这一层调用了crossFade方法，即默认会有一个crossFade的效果，默认用的是DrawableCrossFadeFactory。注意这里把属于RequestManager的RequestTracker也传进来了。\n- Glide.with(context).load(XX)到目前为止只是返回了一个DrawableTypeRequest<ModelType> 的实例。(还在主线程)\n\n## 2.3 小节\nGlide.with返回一个RequestManger，每个Activity只会有一个RequestManager\nload方法返回了一个DrawableTypeRequest<T>，这个T可能是File,String,Interger等。\n到目前为止还只是构建一个Request。\n\n## 3. DrawableRequestBuilder的into方法\nGlide的最后一个调用方法是into()，也是最终分发请求的方法\n\nDrawableRequestBuilder\n```java\n @Override\n    public Target<GlideDrawable> into(ImageView view) {\n        return super.into(view);\n    }\n\n\n    public Target<TranscodeType> into(ImageView view) {\n        Util.assertMainThread();//还是在主线程对不对\n        if (view == null) {\n            throw new IllegalArgumentException(\"You must pass in a non null View\");\n        }\n\n        if (!isTransformationSet && view.getScaleType() != null) {\n            switch (view.getScaleType()) {\n                case CENTER_CROP:\n                    applyCenterCrop();\n                    break;\n                case FIT_CENTER:\n                case FIT_START:\n                case FIT_END:\n                    applyFitCenter();\n                    break;\n                //$CASES-OMITTED$\n                default:\n                    // Do nothing.\n            }\n        }\n\n        return into(glide.buildImageViewTarget(view, transcodeClass));\n        //这个into接收一个Target的子类的实例，而Target又继承自LifeCycleListener\n        //这个TranscodeClass是每一个Request创建的时候从构造函数传进来的。\n       \n    }\n\n\n //transcodeclass可能是GlideDrawable.class，也可能是Bitmap.class也可能是Drawable.class\n     @SuppressWarnings(\"unchecked\")\n    public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {\n        if (GlideDrawable.class.isAssignableFrom(clazz)) { //isAssignableFrom表示左边的class是否是右边class一个类或者父类，应该和instaceof倒过来。\n            return (Target<Z>) new GlideDrawableImageViewTarget(view);\n        } else if (Bitmap.class.equals(clazz)) {\n            return (Target<Z>) new BitmapImageViewTarget(view);\n        } else if (Drawable.class.isAssignableFrom(clazz)) {\n            return (Target<Z>) new DrawableImageViewTarget(view);\n        } else {\n            throw new IllegalArgumentException(\"Unhandled class: \" + clazz\n                    + \", try .as*(Class).transcode(ResourceTranscoder)\");\n        }\n    }\n\n```\nGlideDrawableImageViewTarget、BitmapImageViewTarget以及DrawableImageViewTarget全部继承自ImageViewTarget，后者继承自ViewTarget,再继承自BaseTarget，再 implements Target。一层层继承下来，GlideDrawableImageViewTarget等三个子类中都有一个Request，一个T extents View(看来不一定是ImageView)\n\n\n\n### 3.1 以GlideDrawableImageViewTarget为例\n```java\npublic class GlideDrawableImageViewTarget extends ImageViewTarget<GlideDrawable> {\n    private static final float SQUARE_RATIO_MARGIN = 0.05f;\n    private int maxLoopCount;\n    private GlideDrawable resource; \n    }\n```\nGlideDrawable是一个继承自Drawable的抽象类，添加了isAnimated(),setLoopCount以及由于实现了isAnimated所需要的三个方法(start,stop,isRunning)。子类必须实现这五个抽象方法。\n\nGlideDrawableImageViewTarget往上走\n```java\npublic abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z> implements GlideAnimation.ViewAdapter{\n\n}\n```\n\n接着往上找父类\n\n```java\npublic abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {\n    private static final String TAG = \"ViewTarget\";\n    private static boolean isTagUsedAtLeastOnce = false;\n    private static Integer tagId = null;\n\n    protected final T view;\n    private final SizeDeterminer sizeDeterminer;\n\n}\n```\n\n看下文档：A base Target for loading android.graphics.Bitmaps into Views that provides default implementations for most most methods and can determine the size of views using a android.view.ViewTreeObserver.OnDrawListener\nTo detect View} reuse in android.widget.ListView or any android.view.ViewGroup that reuses views, this class uses the View setTag(Object) method to store some metadata so that if a view is reused, any previous loads or resources from previous loads can be cancelled or reused.\n Any calls to View setTag(Object)on a View given to this class will result in excessive allocations and\n and/or IllegalArgumentExceptions. If you must call View#setTag(Object)on a view, consider  using BaseTarget or SimpleTarget instead.\n\n- 翻译一下，ViewTarget提供了将Bitmap 加载进View的大部分方法的基本实现，并且添加了onPreDrawListener以获得View的尺寸，对于Resuse View的场景，通过setTag来取消被滑出屏幕的View的request的加载。\n\n既然提供了大部分方法的默认实现，那么一定有方法没实现，其实就是\nprotected void setResource(Z resource)啦。\n这个Z可能是Bitmap,GlideDrawable或者Drawable。直接拿来setImageBitmap或者setImageDrawable就可以了，这个方法其实在是解码完成之后了。\n\n关键是default implementation是怎么实现的以及这些方法在父类中的调用时机。\nViewTarget的构造函数传进来一个View的子类，同时创建一个SizeDeterminer（只是通过onPreDrawListener获得View的宽和高）。\n\n再往上找父类\n```java\npublic abstract class BaseTarget<Z> implements Target<Z> { //添加了一个Request成员变量，为Target中的一些方法提供了空实现，比如onLoadStarted，onLoadXXX等\n\n    private Request request;\n\n    }\n```\n\n到这里，还只是配置资源要加载进的对象，我倾向于把Target看成一个资源加载完毕的中转者，它管理了View（也可以没有View）和Request，在外部调用Target.onLoadStarted等方法是，调用View(如果有的话)的xxx方法。\n\n### 3.2任务分发\n```java\n    public <Y extends Target<TranscodeType>> Y into(Y target) {\n        Util.assertMainThread(); //还在主线程上\n        Request previous = target.getRequest();\n\n        if (previous != null) { //每一个Target都只有一个Request，用于清除之前的请求\n            previous.clear();\n            requestTracker.removeRequest(previous);\n            previous.recycle();\n        }\n\n        Request request = buildRequest(target);\n        target.setRequest(request);\n        lifecycle.addListener(target);\n        requestTracker.runRequest(request);\n\n        return target; //这里返回Target的好处在于可以接着链式调用，上面只是添加到任务队列，真正被处理还得等到下一帧(onPreDraw调用时)，所以这里还可以接着对这个Target进行配置\n    }\n```\n注意 requestTracker.runRequest(request)方法\nGenericRequest.java\n```java\n  /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void begin() {\n        startTime = LogTime.getLogTime();\n        if (model == null) {\n            onException(null);\n            return;\n        }\n\n        status = Status.WAITING_FOR_SIZE;\n        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n            onSizeReady(overrideWidth, overrideHeight);\n        } else {\n            target.getSize(this); //这个方法其实就等于挂了个钩子在onPreDraw中调用，onPreDraw时会调用onSizeReady。\n        }\n\n        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {\n            target.onLoadStarted(getPlaceholderDrawable());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n        }\n    }\n```\nonSizeReady才是真正开始干活的时机，理由也很充分。解码Bitmap必须要知道需要多大的尺寸，否则也是白搭。\nGenericRequest.java\n```java\n   /**\n     * A callback method that should never be invoked directly.\n     */ \n    @Override\n    public void onSizeReady(int width, int height) {\n        \n        if (status != Status.WAITING_FOR_SIZE) {\n            return;\n        }\n        status = Status.RUNNING;\n\n        width = Math.round(sizeMultiplier * width); //这个sizeMultiplier可以通过链式调用配置\n        height = Math.round(sizeMultiplier * height);\n\n        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n            \n        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n        loadedFromMemoryCache = true;\n        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,\n                priority, isMemoryCacheable, diskCacheStrategy, this);\n        loadedFromMemoryCache = resource != null;\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n        }\n    }\n```\n\n\n### 3.3 缓存查找\n开始查找缓存是engine.load开始的，找到了就调用Callback的onResourceReady\nEngine.java\n```java\n    public <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n            DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n            Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n        Util.assertMainThread(); //还是在主线程上\n        long startTime = LogTime.getLogTime();\n\n        final String id = fetcher.getId();//如果是个网络图片，返回网络url，类似这种\n        EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n                loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n                transcoder, loadProvider.getSourceEncoder());\n\n        EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n        //EngineResource内部wrap了真正的Resource，并使用一个int acquire表示当前正在占用资源的使用者数。当这个数为0的时候可以release。\n        if (cached != null) {\n            cb.onResourceReady(cached);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n            }\n            return null;\n        }\n\n        EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n        if (active != null) {\n            cb.onResourceReady(active);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n            }\n            return null;\n        }\n\n        EngineJob current = jobs.get(key);\n        if (current != null) {\n            current.addCallback(cb);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Added to existing load\", startTime, key);\n            }\n            return new LoadStatus(cb, current);\n        }\n\n        EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n        DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n                transcoder, diskCacheProvider, diskCacheStrategy, priority);\n        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n        jobs.put(key, engineJob);\n        engineJob.addCallback(cb);\n        engineJob.start(runnable);\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Started new load\", startTime, key);\n        }\n        return new LoadStatus(cb, engineJob);\n    }\n```\n\nEngine先去Cache里面查找，找到了直接调用ResourceCallback(GenericRequest)的onResourceReady(EngineResource<?> resource)，注意这个EngineResource里面包装了一个Resource，主要是为了引用计数。\n\n Engine的loadFromCache(key, isMemoryCacheable)是第一步，从成员变量cache中获取。找到了就挪到activeResources里面。\n Engine.java\n ```java\n public class Engine implements EngineJobListener,\n        MemoryCache.ResourceRemovedListener,\n        EngineResource.ResourceListener {\n    private static final String TAG = \"Engine\";\n    private final Map<Key, EngineJob> jobs;\n    private final EngineKeyFactory keyFactory;\n    private final MemoryCache cache;\n    private final EngineJobFactory engineJobFactory;\n    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;\n    private final ResourceRecycler resourceRecycler;\n    private final LazyDiskCacheProvider diskCacheProvider;\n\n}\n ```\n\n如果在MemoryCache这个Lru里面没找到，就调用loadFromActiveResources，从activeResources里面找到。\n\n**所以这里已经出现两层缓存了，先去Lru(内存)找，再去activeResources(HashMap)里面找。缓存都是放在Enginel里面的，全局只有一份**\n\n缓存里面的Value都是EngineResource。\n\n\n这个MemoryCache是一个LruCache，大小是在MemorySizeCalculator中获得的，\n对于一般的设备，activityManager.getMemoryClass() * 1024 * 1024获得每个App能够使用的Size,乘以0.4。\n```java\n MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) {\n        this.context = context;\n        final int maxSize = getMaxSize(activityManager);\n\n        final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()\n                * BYTES_PER_ARGB_8888_PIXEL; //算出占满整个屏幕的一张图的大小\n\n        int targetPoolSize = screenSize * BITMAP_POOL_TARGET_SCREENS; //乘以4就是bitmappool的大小\n        int targetMemoryCacheSize = screenSize * MEMORY_CACHE_TARGET_SCREENS;\n        //乘以2就是MemoryCache的大小\n\n        if (targetMemoryCacheSize + targetPoolSize <= maxSize) {\n            memoryCacheSize = targetMemoryCacheSize;\n            bitmapPoolSize = targetPoolSize;\n        } else { //这里判断了BitmapPool和MemoryCache的大小之和不能超出应用可以使用的内存大小的0.4倍。\n            int part = Math.round((float) maxSize / (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));\n            memoryCacheSize = part * MEMORY_CACHE_TARGET_SCREENS;\n            bitmapPoolSize = part * BITMAP_POOL_TARGET_SCREENS;\n        }\n    }\n```\n所以缓存的大小综合考虑了屏幕分辨率和内存大小。只要屏幕像素不是特别高，一般都会走到第一步。\n\n\n### 小结\n- ViewTarget里面有一个 T extends View，可见Glide不只适用于ImageView。\n- BaseTarget里带了一个private Request，其子类可以通过getRequest获得。\n- 对于ListView等可以快速滑动的View，如果某一个View被滑出屏幕外，自动取消请求(通过setTagId实现)\n- \"You must not call setTag() on a view Glide is targeting\" setTag可能会崩，原因\n- GenericRequestBuilder的obtainRequest内部使用了一个ArrayDeque来obtain Request。这样Request实例不会多次创建，回收是在request.recycle里面做的。\n\n\n\n### 4. 离开主线程，提交任务到线程池\n如果上面两层缓存都没找到，去jobs里找看下有没有已经加入队列的EngineJob\n记住上面有两层缓存\n\n\n来看后面提交任务这几段\n```java\n EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n        DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n                transcoder, diskCacheProvider, diskCacheStrategy, priority);\n        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n        jobs.put(key, engineJob);\n        engineJob.addCallback(cb);\n        engineJob.start(runnable); //往diskCacheService提交了一个Runnable\n\nclass EngineJob implements EngineRunnable.EngineRunnableManager {\n    private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();\n    private static final Handler MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper(), new MainThreadCallback());\n\n    private static final int MSG_COMPLETE = 1;\n    private static final int MSG_EXCEPTION = 2;\n\n    private final List<ResourceCallback> cbs = new ArrayList<ResourceCallback>();\n    private final EngineResourceFactory engineResourceFactory;\n    private final EngineJobListener listener;\n    private final Key key;\n    private final ExecutorService diskCacheService; //线程池\n    private final ExecutorService sourceService; //线程池\n    private final boolean isCacheable;\n\n    private boolean isCancelled;\n    // Either resource or exception (particularly exception) may be returned to us null, so use booleans to track if\n    // we've received them instead of relying on them to be non-null. See issue #180.\n    private Resource<?> resource;\n    private boolean hasResource;\n    private Exception exception;\n    private boolean hasException;\n    // A set of callbacks that are removed while we're notifying other callbacks of a change in status.\n    private Set<ResourceCallback> ignoredCallbacks;\n    private EngineRunnable engineRunnable;\n    private EngineResource<?> engineResource;\n\n    private volatile Future<?> future;\n}\n\n\n```\nEngineJob是通过Factory创建的，创建时会传两个线程池进来。一个管DiskCache,一个管Source获取。初始化是在Glide.createGlide里面做的：\n```java\nif (sourceService == null) {\n            final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());\n            sourceService = new FifoPriorityThreadPoolExecutor(cores);\n        }\n        if (diskCacheService == null) {\n            diskCacheService = new FifoPriorityThreadPoolExecutor(1);\n        }\n```\n在外部没有提供线程池的情况下，DiskCache一个线程池就好了，SourceService的大小为当前cpu可用核心数，还是比较高效的。\n上面是往DiskCacheService提交了一个EngineRunable，这个Runnable的run里面主要是decodeFromCache和DecodeFroSource，分别代表从**磁盘缓存**获取和从数据源获取。\n首先会调用decodeFromCache，一层层往下找，如果没找到的话会调用onLoadFailed方法，并将任务提交给SourceService，去获取资源。\n\n\n### 4.1 CacheService这个线程池的工作以及第三层缓存的出现\n**注意这里出现了第三层缓存** \n```\n File cacheFile = diskCacheProvider.getDiskCache().get(key);\n```\n\n这一层缓存是给DiskCache的线程池查找用的，查找的时候分为从Result中查找和从Source中查找，其实查找的目的地都是那个DiskCache，Resul是用ResultKey去找的，Source是用ResultKey.getOriginalKey去查找的。物理位置都放在那个磁盘目录下。\n\n另外在DecodeJob的cacheAndDecodeSourceData方法里，存的只是origin(因为用的是origin Key)，然后再拿着originKey去磁盘找，找出来decode。\n\nDecodeFromCache又包括两步decodeResultFromCache和decodeSourceFromCache，这就让人想到Glide的DiskCacheStrategy分为Result和Source，即可以缓存decode结果也可以缓存decode之前的source。前提是在上面的diskCacheProvider.getDiskCache().get(key)方法里面找到了CachedFile。这个路径在InternalCacheDiskCacheFactory里面写了具体的路径\n\n```java\n public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName, int diskCacheSize) {\n        super(new CacheDirectoryGetter() {\n            @Override\n            public File getCacheDirectory() {\n                File cacheDirectory = context.getCacheDir();\n                if (cacheDirectory == null) {\n                    return null;\n                }\n                if (diskCacheName != null) {\n                    return new File(cacheDirectory, diskCacheName);\n                    //就是context.getCacheDir+\"image_manager_disk_cache\"\n                    //默认上限是250MB\n                    //由于这个Cache放在CacheDir里面，其他应用拿不到\n                }\n                return cacheDirectory;\n            }\n        }, diskCacheSize);\n    }\n```\n注意无论是decodeResultFromCache还是decodeSourceFromCache里都有类似的一段：\n```java\nResource<T> transformed = loadFromCache(resultKey);\nResource<Z> result = transcode(transformed); ///把一种资源转成另一种资源，比如把Bitmap的Resource转成一个ByteResource\n```\n\n\n\n### 4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现\n```java\n   private Resource<T> decodeFromSourceData(A data) throws IOException {\n        final Resource<T> decoded;\n        if (diskCacheStrategy.cacheSource()) {\n            decoded = cacheAndDecodeSourceData(data);\n        } else {\n            long startTime = LogTime.getLogTime();\n            decoded = loadProvider.getSourceDecoder().decode(data, width, height); // 这里面放进BitmapPool了\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Decoded from source\", startTime);\n            }\n        }\n        return decoded;\n    }\n```\n\n**第四层缓存出现。。。**\nDecodeFromSource也是类似，判断是否允许Cache，通过DataFetcher获取数据这个数据可能是InputStream，也可能是ImageVideoWrapper。。。总之是一个可以提供数据的来源。如果可以Cache的话，先把数据写到lru里面，然后从lru里面取出来，从Source decode成想要的数据类型。\n例如从Stream转成Bitmap是这么干的\nStreamBitmapDecoder.java\n```java\n @Override\n    public Resource<Bitmap> decode(InputStream source, int width, int height) {\n        Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);\n        return BitmapResource.obtain(bitmap, bitmapPool);\n    }\n```\n顺便还放进了LruBitmapPool（又一个实现了lru算法的缓存），Bitmap存在一个LruPoolStrategy接口实例的GroupedLinkedMap中。\n\n\n### 4.3 回到主线程\nEngineRunnable的run方法跑在子线程，在run的最后就是用一个handler推到主线程了。有可能是从CacheService这个线程池里面的线程推过去的，也可能是SourceSevice这个线程池里面推过去的。\n\nonResourceReady最终会走到GenericRequest的onResourceReady方法里\n```\n  private void onResourceReady(Resource<?> resource, R result) {\n\n        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,\n                isFirstResource)) {\n            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);\n            target.onResourceReady(result, animation); //注意这句话就可以了\n        }\n    }\n\n```\n最终会调到ImageViewTarget,AppWidgetTarget等Target（持有Request和View,View可能没有），这时候，直接调用ImageView.setImagBitmap等方法就可以了。\n图片设置完毕。\n\n### 5. Glide除了普通的加载方法，还能用什么比较有意思的玩法\n\n\n## 来一些不拘一格的加载图片的方法\n### 使用Application的Context,不跟生命周期走\n\n## 小结\n\n\n## 参考","source":"_posts/2017-07-21-glide-decoded.md","raw":"---\ntitle: 从glide源码到图片加载框架设计思路\ndate: 2017-07-21 00:13:02\ntags: [android]\n---\n\nglide的源码几个月前曾经拜读过，大致了解了其异步加载的实现原理。图片加载和网络请求很类似，就像当初看Volley，从一个Request --->  CacheDispatch  ---> NetworkDispatcher  ---->  ResponseDeliver。优秀的轮子不仅执行效率高，同时具备高的扩展性。读懂源码其实只是第一步，往下应该是利用框架提供的扩展方案，再往后应该就是能够独立设计出一套类似的框架了。\n\n\n![](http://odzl05jxx.bkt.clouddn.com/a11f41e0b1df95212c71920b3959cd72.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1. 使用入门\n印象中最早接触Glide是在cheesequare中，顿时发现，原来加载图片可以这么简单，之后的开发过程中总会对Glide有所偏倚。接近两年之后再来过一遍源码，希望能够回答那个“如果让你来设计一个图片加载框架，你会怎么设计？”的问题。\n使用方式很简单\n\n```java\n  Glide.with(activity)\n                .load(R.drawable.image_id)\n                .into(mImageView);\n\n```\n\n来看这里面做了什么：\n\n```java\n       public RequestManager get(FragmentActivity activity) {\n        if (Util.isOnBackgroundThread()) {\n            return get(activity.getApplicationContext());\n        } else {\n            assertNotDestroyed(activity);\n            FragmentManager fm = activity.getSupportFragmentManager();\n            return supportFragmentGet(activity, fm);\n        }\n    }\n\n\n    SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) {\n        SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(\n            FRAGMENT_TAG);\n        if (current == null) {\n            current = pendingSupportRequestManagerFragments.get(fm);\n            if (current == null) {\n                current = new SupportRequestManagerFragment();\n                pendingSupportRequestManagerFragments.put(fm, current);\n                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n                handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n            }\n        }\n        return current;\n    }\n\n```\n\nwith方法只是返回了一个RequestManager，with方法可以接受Fragemnt,Activity以及Context等.以上面的activity为例，supportFragmentGet方法只是通过FragmentActivity的supportFragmentManager去findFragmentByTag，这个Tag叫做：“com.bumptech.glide.manager”，所以一般在Debug的时候，去SupportFragmentManager里面查找，有时候能够看到一个这样的Fragment。这个方法里面就是查找这样的一个Fragment，甚至我们自己也可以FindFragmentByTag去调用这个Fragment的方法(这是一个Public的class)然后从这个Fragemnt里面获得RequestManager成员变量（没有就new一个并set）。可以看出，一个Fragment只有一个RequestManager，Fragment主要是为了跟Activity生命周期挂钩的。这里有必要讲一下为什么要写两次current ==null，findFragmentByTag并不会在commitAllowingStateLoss之后就会返回添加的Fragment，只是往主线程的MessageQueue里面丢了一个消息，这个消息执行完毕之后才findFragmentByTag才不为空。这里用Handler丢一条消息，这条消息肯定要排在之前那条消息之后才被执行，所以才有这样一个Pendingmap的设计。当然到这里，最重要的还是Glide是通过commit了一个特殊的Fragment来实现生命周期监听。\n具体来看：SupportRequestManagerFragment中\n\n```java\n  @Override\n    public void onStart() {\n        super.onStart();\n        lifecycle.onStart();\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        lifecycle.onStop();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        lifecycle.onDestroy();\n    }\n```\n\n而对应到LifeCycle的各个方法：\n\n```java\n void onStart() {\n        isStarted = true;\n        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {\n            lifecycleListener.onStart();\n        }\n    }\n\n    void onStop() {\n        isStarted = false;\n        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {\n            lifecycleListener.onStop();\n        }\n    }\n\n    void onDestroy() {\n        isDestroyed = true;\n        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {\n            lifecycleListener.onDestroy();\n        }\n    }\n```\n就是把内部维护的一个集合一个个拿出来调用响应生命周期的方法。\n而这个LifeCycleListener就是上面创建RequestManager时(构造函数传进来了fragment的lifeCycle)添加的。RequestManager还默认添加了一个ConnectivityMonitor，主要作用就是在生命周期的onStart注册了一个ConnectivityManager.CONNECTIVITY_ACTION的BroadCastReceiver，在onStop的时候unRegister，在网络状态变化的时候调用RequestManager的RequestTracker成员变量的restartRequet。\n\n\n小结：\n- 在有权限(android.permission.ACCESS_NETWORK_STATE)的情况下，Glide已经做好了有网-> 断网-> 有网的恢复请求。另外，Android 7.0虽说不再发送ConnectivityManager.CONNECTIVITY_ACTION这个广播，但对于前台应用，动态注册的Receiver还是能够收到，Glide由于是在OnStart注册的，所以完全没问题。\n- 在一个Activity中，RequestManager只要一个，其实开发者自己保留下来也没什么问题\n\n\n## 2. RequestManager调度请求\n\n来看下这个RequestManager的成员变量\n\n```java\npublic class RequestManager implements LifecycleListener {\n    private final Context context;\n    private final Lifecycle lifecycle;\n    private final RequestManagerTreeNode treeNode;\n    private final RequestTracker requestTracker;\n    private final Glide glide; //全局只有一个，控制线程池，用Application的Context创建的\n    private final OptionsApplier optionsApplier;\n    private DefaultOptions options;\n\n    }\n\n\n    class OptionsApplier {\n\n        public <A, X extends GenericRequestBuilder<A, ?, ?, ?>> X apply(X builder) {\n            if (options != null) {\n                options.apply(builder);\n            }\n            return builder;\n        }\n    }\n\n```\n上面这个泛型写的非常绕，OptionApplier的意思就是，如果用户提供了一些定制(存在options里面)，就给一些定制的选择。一般这个options为null。\n\n\n\n\n### 2.1 各种Type的Request\n\nGlide的RequestManager可以接受各种各样的来源\n\n```java\n   public DrawableTypeRequest<Integer> load(Integer resourceId) {\n        return (DrawableTypeRequest<Integer>) fromResource().load(resourceId);\n    }\n\n     public DrawableTypeRequest<byte[]> load(byte[] model) {\n        return (DrawableTypeRequest<byte[]>) fromBytes().load(model);\n    }\n\n      public DrawableTypeRequest<File> load(File file) {\n        return (DrawableTypeRequest<File>) fromFile().load(file);\n    }\n\n//上述方法都调用到了\n     private <T> DrawableTypeRequest<T> loadGeneric(Class<T> modelClass) {\n        ModelLoader<T, InputStream> streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);\n        ModelLoader<T, ParcelFileDescriptor> fileDescriptorModelLoader =\n                Glide.buildFileDescriptorModelLoader(modelClass, context);\n        if (modelClass != null && streamModelLoader == null && fileDescriptorModelLoader == null) {\n            throw new IllegalArgumentException(\"Unknown type \" + modelClass + \". You must provide a Model of a type for\"\n                    + \" which there is a registered ModelLoader, if you are using a custom model, you must first call\"\n                    + \" Glide#register with a ModelLoaderFactory for your custom model class\");\n        }\n\n        return optionsApplier.apply(\n                new DrawableTypeRequest<T>(modelClass, streamModelLoader, fileDescriptorModelLoader, context,\n                        glide, requestTracker, lifecycle, optionsApplier));\n    }\n\n```\n\nDrawableTypeRequest接受一个泛型，可以是String(网络路径)，File(本地文件),Integer（资源文件）。所以最终返回的DrawableTypeRequet里面装的可能是String.class，Integer.class也可能是File.class。\n比较难懂的是 streamModelLoader和fileDescriptorModelLoader的创建.\n\n```java\npublic interface ModelLoader<T, Y> {\n    DataFetcher<Y> getResourceFetcher(T model, int width, int height);\n}\n```\nModelLoader其实就是只有一个方法的接口，例如with(File)会传一个File.class进来，返回的streamModelLoader的T就是File，Y就是InputStream。\nModelLoader<T, Y>负责提供DataFetcher<Y>，T是数据源，可以是File,Resourse，url等等。Y用于描述类型，本地的就使用ParcelFileDescriptor（记得FileDescriptor属于Native的东西），网络上的就使用InputStream.\nT和Y的组合可能有很多种，Cache在Glide(全局唯一)的loaderFactory（成员变量）的一个HashMap(没用ConcurrentHashMap是因为buildModelLoader方法加锁了)中。所以这份缓存也是全局唯一的。\nT和Y的一一对应其实是在Glide的构造函数里面写好的：\n\n```java\n\n        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());\n        register(File.class, InputStream.class, new StreamFileLoader.Factory());\n        register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());\n        register(int.class, InputStream.class, new StreamResourceLoader.Factory());\n        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());\n        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());\n        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());\n        register(String.class, InputStream.class, new StreamStringLoader.Factory());\n        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());\n        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());\n        register(URL.class, InputStream.class, new StreamUrlLoader.Factory());\n        register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory());\n        register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory());\n```\n左边有很多种，右边只可能是InputStream或者ParcelFileDescriptor。\n\n### 2.2 Request的继承关系\n\n```\n public class DrawableTypeRequest<ModelType> extends DrawableRequestBuilder<ModelType> implements DownloadOptions\n public class DrawableRequestBuilder<ModelType>\n        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>\n        implements BitmapOptions, DrawableOptions \n public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> implements Cloneable        \n```\n\n记住这个ModelType就是Glide.with(context).load(XXX) 里面传进去的Object的Class，例如File.class，那么\n上面其实就是创建了一个DrawableTypeRequest，泛型是File ，构造函数一层层往上调用，DrawableRequestBuilder这一层调用了crossFade方法，即默认会有一个crossFade的效果，默认用的是DrawableCrossFadeFactory。注意这里把属于RequestManager的RequestTracker也传进来了。\n- Glide.with(context).load(XX)到目前为止只是返回了一个DrawableTypeRequest<ModelType> 的实例。(还在主线程)\n\n## 2.3 小节\nGlide.with返回一个RequestManger，每个Activity只会有一个RequestManager\nload方法返回了一个DrawableTypeRequest<T>，这个T可能是File,String,Interger等。\n到目前为止还只是构建一个Request。\n\n## 3. DrawableRequestBuilder的into方法\nGlide的最后一个调用方法是into()，也是最终分发请求的方法\n\nDrawableRequestBuilder\n```java\n @Override\n    public Target<GlideDrawable> into(ImageView view) {\n        return super.into(view);\n    }\n\n\n    public Target<TranscodeType> into(ImageView view) {\n        Util.assertMainThread();//还是在主线程对不对\n        if (view == null) {\n            throw new IllegalArgumentException(\"You must pass in a non null View\");\n        }\n\n        if (!isTransformationSet && view.getScaleType() != null) {\n            switch (view.getScaleType()) {\n                case CENTER_CROP:\n                    applyCenterCrop();\n                    break;\n                case FIT_CENTER:\n                case FIT_START:\n                case FIT_END:\n                    applyFitCenter();\n                    break;\n                //$CASES-OMITTED$\n                default:\n                    // Do nothing.\n            }\n        }\n\n        return into(glide.buildImageViewTarget(view, transcodeClass));\n        //这个into接收一个Target的子类的实例，而Target又继承自LifeCycleListener\n        //这个TranscodeClass是每一个Request创建的时候从构造函数传进来的。\n       \n    }\n\n\n //transcodeclass可能是GlideDrawable.class，也可能是Bitmap.class也可能是Drawable.class\n     @SuppressWarnings(\"unchecked\")\n    public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {\n        if (GlideDrawable.class.isAssignableFrom(clazz)) { //isAssignableFrom表示左边的class是否是右边class一个类或者父类，应该和instaceof倒过来。\n            return (Target<Z>) new GlideDrawableImageViewTarget(view);\n        } else if (Bitmap.class.equals(clazz)) {\n            return (Target<Z>) new BitmapImageViewTarget(view);\n        } else if (Drawable.class.isAssignableFrom(clazz)) {\n            return (Target<Z>) new DrawableImageViewTarget(view);\n        } else {\n            throw new IllegalArgumentException(\"Unhandled class: \" + clazz\n                    + \", try .as*(Class).transcode(ResourceTranscoder)\");\n        }\n    }\n\n```\nGlideDrawableImageViewTarget、BitmapImageViewTarget以及DrawableImageViewTarget全部继承自ImageViewTarget，后者继承自ViewTarget,再继承自BaseTarget，再 implements Target。一层层继承下来，GlideDrawableImageViewTarget等三个子类中都有一个Request，一个T extents View(看来不一定是ImageView)\n\n\n\n### 3.1 以GlideDrawableImageViewTarget为例\n```java\npublic class GlideDrawableImageViewTarget extends ImageViewTarget<GlideDrawable> {\n    private static final float SQUARE_RATIO_MARGIN = 0.05f;\n    private int maxLoopCount;\n    private GlideDrawable resource; \n    }\n```\nGlideDrawable是一个继承自Drawable的抽象类，添加了isAnimated(),setLoopCount以及由于实现了isAnimated所需要的三个方法(start,stop,isRunning)。子类必须实现这五个抽象方法。\n\nGlideDrawableImageViewTarget往上走\n```java\npublic abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z> implements GlideAnimation.ViewAdapter{\n\n}\n```\n\n接着往上找父类\n\n```java\npublic abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {\n    private static final String TAG = \"ViewTarget\";\n    private static boolean isTagUsedAtLeastOnce = false;\n    private static Integer tagId = null;\n\n    protected final T view;\n    private final SizeDeterminer sizeDeterminer;\n\n}\n```\n\n看下文档：A base Target for loading android.graphics.Bitmaps into Views that provides default implementations for most most methods and can determine the size of views using a android.view.ViewTreeObserver.OnDrawListener\nTo detect View} reuse in android.widget.ListView or any android.view.ViewGroup that reuses views, this class uses the View setTag(Object) method to store some metadata so that if a view is reused, any previous loads or resources from previous loads can be cancelled or reused.\n Any calls to View setTag(Object)on a View given to this class will result in excessive allocations and\n and/or IllegalArgumentExceptions. If you must call View#setTag(Object)on a view, consider  using BaseTarget or SimpleTarget instead.\n\n- 翻译一下，ViewTarget提供了将Bitmap 加载进View的大部分方法的基本实现，并且添加了onPreDrawListener以获得View的尺寸，对于Resuse View的场景，通过setTag来取消被滑出屏幕的View的request的加载。\n\n既然提供了大部分方法的默认实现，那么一定有方法没实现，其实就是\nprotected void setResource(Z resource)啦。\n这个Z可能是Bitmap,GlideDrawable或者Drawable。直接拿来setImageBitmap或者setImageDrawable就可以了，这个方法其实在是解码完成之后了。\n\n关键是default implementation是怎么实现的以及这些方法在父类中的调用时机。\nViewTarget的构造函数传进来一个View的子类，同时创建一个SizeDeterminer（只是通过onPreDrawListener获得View的宽和高）。\n\n再往上找父类\n```java\npublic abstract class BaseTarget<Z> implements Target<Z> { //添加了一个Request成员变量，为Target中的一些方法提供了空实现，比如onLoadStarted，onLoadXXX等\n\n    private Request request;\n\n    }\n```\n\n到这里，还只是配置资源要加载进的对象，我倾向于把Target看成一个资源加载完毕的中转者，它管理了View（也可以没有View）和Request，在外部调用Target.onLoadStarted等方法是，调用View(如果有的话)的xxx方法。\n\n### 3.2任务分发\n```java\n    public <Y extends Target<TranscodeType>> Y into(Y target) {\n        Util.assertMainThread(); //还在主线程上\n        Request previous = target.getRequest();\n\n        if (previous != null) { //每一个Target都只有一个Request，用于清除之前的请求\n            previous.clear();\n            requestTracker.removeRequest(previous);\n            previous.recycle();\n        }\n\n        Request request = buildRequest(target);\n        target.setRequest(request);\n        lifecycle.addListener(target);\n        requestTracker.runRequest(request);\n\n        return target; //这里返回Target的好处在于可以接着链式调用，上面只是添加到任务队列，真正被处理还得等到下一帧(onPreDraw调用时)，所以这里还可以接着对这个Target进行配置\n    }\n```\n注意 requestTracker.runRequest(request)方法\nGenericRequest.java\n```java\n  /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void begin() {\n        startTime = LogTime.getLogTime();\n        if (model == null) {\n            onException(null);\n            return;\n        }\n\n        status = Status.WAITING_FOR_SIZE;\n        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n            onSizeReady(overrideWidth, overrideHeight);\n        } else {\n            target.getSize(this); //这个方法其实就等于挂了个钩子在onPreDraw中调用，onPreDraw时会调用onSizeReady。\n        }\n\n        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {\n            target.onLoadStarted(getPlaceholderDrawable());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n        }\n    }\n```\nonSizeReady才是真正开始干活的时机，理由也很充分。解码Bitmap必须要知道需要多大的尺寸，否则也是白搭。\nGenericRequest.java\n```java\n   /**\n     * A callback method that should never be invoked directly.\n     */ \n    @Override\n    public void onSizeReady(int width, int height) {\n        \n        if (status != Status.WAITING_FOR_SIZE) {\n            return;\n        }\n        status = Status.RUNNING;\n\n        width = Math.round(sizeMultiplier * width); //这个sizeMultiplier可以通过链式调用配置\n        height = Math.round(sizeMultiplier * height);\n\n        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n            \n        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n        loadedFromMemoryCache = true;\n        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,\n                priority, isMemoryCacheable, diskCacheStrategy, this);\n        loadedFromMemoryCache = resource != null;\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n        }\n    }\n```\n\n\n### 3.3 缓存查找\n开始查找缓存是engine.load开始的，找到了就调用Callback的onResourceReady\nEngine.java\n```java\n    public <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n            DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n            Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n        Util.assertMainThread(); //还是在主线程上\n        long startTime = LogTime.getLogTime();\n\n        final String id = fetcher.getId();//如果是个网络图片，返回网络url，类似这种\n        EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n                loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n                transcoder, loadProvider.getSourceEncoder());\n\n        EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n        //EngineResource内部wrap了真正的Resource，并使用一个int acquire表示当前正在占用资源的使用者数。当这个数为0的时候可以release。\n        if (cached != null) {\n            cb.onResourceReady(cached);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n            }\n            return null;\n        }\n\n        EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n        if (active != null) {\n            cb.onResourceReady(active);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n            }\n            return null;\n        }\n\n        EngineJob current = jobs.get(key);\n        if (current != null) {\n            current.addCallback(cb);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Added to existing load\", startTime, key);\n            }\n            return new LoadStatus(cb, current);\n        }\n\n        EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n        DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n                transcoder, diskCacheProvider, diskCacheStrategy, priority);\n        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n        jobs.put(key, engineJob);\n        engineJob.addCallback(cb);\n        engineJob.start(runnable);\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Started new load\", startTime, key);\n        }\n        return new LoadStatus(cb, engineJob);\n    }\n```\n\nEngine先去Cache里面查找，找到了直接调用ResourceCallback(GenericRequest)的onResourceReady(EngineResource<?> resource)，注意这个EngineResource里面包装了一个Resource，主要是为了引用计数。\n\n Engine的loadFromCache(key, isMemoryCacheable)是第一步，从成员变量cache中获取。找到了就挪到activeResources里面。\n Engine.java\n ```java\n public class Engine implements EngineJobListener,\n        MemoryCache.ResourceRemovedListener,\n        EngineResource.ResourceListener {\n    private static final String TAG = \"Engine\";\n    private final Map<Key, EngineJob> jobs;\n    private final EngineKeyFactory keyFactory;\n    private final MemoryCache cache;\n    private final EngineJobFactory engineJobFactory;\n    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;\n    private final ResourceRecycler resourceRecycler;\n    private final LazyDiskCacheProvider diskCacheProvider;\n\n}\n ```\n\n如果在MemoryCache这个Lru里面没找到，就调用loadFromActiveResources，从activeResources里面找到。\n\n**所以这里已经出现两层缓存了，先去Lru(内存)找，再去activeResources(HashMap)里面找。缓存都是放在Enginel里面的，全局只有一份**\n\n缓存里面的Value都是EngineResource。\n\n\n这个MemoryCache是一个LruCache，大小是在MemorySizeCalculator中获得的，\n对于一般的设备，activityManager.getMemoryClass() * 1024 * 1024获得每个App能够使用的Size,乘以0.4。\n```java\n MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) {\n        this.context = context;\n        final int maxSize = getMaxSize(activityManager);\n\n        final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()\n                * BYTES_PER_ARGB_8888_PIXEL; //算出占满整个屏幕的一张图的大小\n\n        int targetPoolSize = screenSize * BITMAP_POOL_TARGET_SCREENS; //乘以4就是bitmappool的大小\n        int targetMemoryCacheSize = screenSize * MEMORY_CACHE_TARGET_SCREENS;\n        //乘以2就是MemoryCache的大小\n\n        if (targetMemoryCacheSize + targetPoolSize <= maxSize) {\n            memoryCacheSize = targetMemoryCacheSize;\n            bitmapPoolSize = targetPoolSize;\n        } else { //这里判断了BitmapPool和MemoryCache的大小之和不能超出应用可以使用的内存大小的0.4倍。\n            int part = Math.round((float) maxSize / (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));\n            memoryCacheSize = part * MEMORY_CACHE_TARGET_SCREENS;\n            bitmapPoolSize = part * BITMAP_POOL_TARGET_SCREENS;\n        }\n    }\n```\n所以缓存的大小综合考虑了屏幕分辨率和内存大小。只要屏幕像素不是特别高，一般都会走到第一步。\n\n\n### 小结\n- ViewTarget里面有一个 T extends View，可见Glide不只适用于ImageView。\n- BaseTarget里带了一个private Request，其子类可以通过getRequest获得。\n- 对于ListView等可以快速滑动的View，如果某一个View被滑出屏幕外，自动取消请求(通过setTagId实现)\n- \"You must not call setTag() on a view Glide is targeting\" setTag可能会崩，原因\n- GenericRequestBuilder的obtainRequest内部使用了一个ArrayDeque来obtain Request。这样Request实例不会多次创建，回收是在request.recycle里面做的。\n\n\n\n### 4. 离开主线程，提交任务到线程池\n如果上面两层缓存都没找到，去jobs里找看下有没有已经加入队列的EngineJob\n记住上面有两层缓存\n\n\n来看后面提交任务这几段\n```java\n EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n        DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n                transcoder, diskCacheProvider, diskCacheStrategy, priority);\n        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n        jobs.put(key, engineJob);\n        engineJob.addCallback(cb);\n        engineJob.start(runnable); //往diskCacheService提交了一个Runnable\n\nclass EngineJob implements EngineRunnable.EngineRunnableManager {\n    private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();\n    private static final Handler MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper(), new MainThreadCallback());\n\n    private static final int MSG_COMPLETE = 1;\n    private static final int MSG_EXCEPTION = 2;\n\n    private final List<ResourceCallback> cbs = new ArrayList<ResourceCallback>();\n    private final EngineResourceFactory engineResourceFactory;\n    private final EngineJobListener listener;\n    private final Key key;\n    private final ExecutorService diskCacheService; //线程池\n    private final ExecutorService sourceService; //线程池\n    private final boolean isCacheable;\n\n    private boolean isCancelled;\n    // Either resource or exception (particularly exception) may be returned to us null, so use booleans to track if\n    // we've received them instead of relying on them to be non-null. See issue #180.\n    private Resource<?> resource;\n    private boolean hasResource;\n    private Exception exception;\n    private boolean hasException;\n    // A set of callbacks that are removed while we're notifying other callbacks of a change in status.\n    private Set<ResourceCallback> ignoredCallbacks;\n    private EngineRunnable engineRunnable;\n    private EngineResource<?> engineResource;\n\n    private volatile Future<?> future;\n}\n\n\n```\nEngineJob是通过Factory创建的，创建时会传两个线程池进来。一个管DiskCache,一个管Source获取。初始化是在Glide.createGlide里面做的：\n```java\nif (sourceService == null) {\n            final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());\n            sourceService = new FifoPriorityThreadPoolExecutor(cores);\n        }\n        if (diskCacheService == null) {\n            diskCacheService = new FifoPriorityThreadPoolExecutor(1);\n        }\n```\n在外部没有提供线程池的情况下，DiskCache一个线程池就好了，SourceService的大小为当前cpu可用核心数，还是比较高效的。\n上面是往DiskCacheService提交了一个EngineRunable，这个Runnable的run里面主要是decodeFromCache和DecodeFroSource，分别代表从**磁盘缓存**获取和从数据源获取。\n首先会调用decodeFromCache，一层层往下找，如果没找到的话会调用onLoadFailed方法，并将任务提交给SourceService，去获取资源。\n\n\n### 4.1 CacheService这个线程池的工作以及第三层缓存的出现\n**注意这里出现了第三层缓存** \n```\n File cacheFile = diskCacheProvider.getDiskCache().get(key);\n```\n\n这一层缓存是给DiskCache的线程池查找用的，查找的时候分为从Result中查找和从Source中查找，其实查找的目的地都是那个DiskCache，Resul是用ResultKey去找的，Source是用ResultKey.getOriginalKey去查找的。物理位置都放在那个磁盘目录下。\n\n另外在DecodeJob的cacheAndDecodeSourceData方法里，存的只是origin(因为用的是origin Key)，然后再拿着originKey去磁盘找，找出来decode。\n\nDecodeFromCache又包括两步decodeResultFromCache和decodeSourceFromCache，这就让人想到Glide的DiskCacheStrategy分为Result和Source，即可以缓存decode结果也可以缓存decode之前的source。前提是在上面的diskCacheProvider.getDiskCache().get(key)方法里面找到了CachedFile。这个路径在InternalCacheDiskCacheFactory里面写了具体的路径\n\n```java\n public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName, int diskCacheSize) {\n        super(new CacheDirectoryGetter() {\n            @Override\n            public File getCacheDirectory() {\n                File cacheDirectory = context.getCacheDir();\n                if (cacheDirectory == null) {\n                    return null;\n                }\n                if (diskCacheName != null) {\n                    return new File(cacheDirectory, diskCacheName);\n                    //就是context.getCacheDir+\"image_manager_disk_cache\"\n                    //默认上限是250MB\n                    //由于这个Cache放在CacheDir里面，其他应用拿不到\n                }\n                return cacheDirectory;\n            }\n        }, diskCacheSize);\n    }\n```\n注意无论是decodeResultFromCache还是decodeSourceFromCache里都有类似的一段：\n```java\nResource<T> transformed = loadFromCache(resultKey);\nResource<Z> result = transcode(transformed); ///把一种资源转成另一种资源，比如把Bitmap的Resource转成一个ByteResource\n```\n\n\n\n### 4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现\n```java\n   private Resource<T> decodeFromSourceData(A data) throws IOException {\n        final Resource<T> decoded;\n        if (diskCacheStrategy.cacheSource()) {\n            decoded = cacheAndDecodeSourceData(data);\n        } else {\n            long startTime = LogTime.getLogTime();\n            decoded = loadProvider.getSourceDecoder().decode(data, width, height); // 这里面放进BitmapPool了\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                logWithTimeAndKey(\"Decoded from source\", startTime);\n            }\n        }\n        return decoded;\n    }\n```\n\n**第四层缓存出现。。。**\nDecodeFromSource也是类似，判断是否允许Cache，通过DataFetcher获取数据这个数据可能是InputStream，也可能是ImageVideoWrapper。。。总之是一个可以提供数据的来源。如果可以Cache的话，先把数据写到lru里面，然后从lru里面取出来，从Source decode成想要的数据类型。\n例如从Stream转成Bitmap是这么干的\nStreamBitmapDecoder.java\n```java\n @Override\n    public Resource<Bitmap> decode(InputStream source, int width, int height) {\n        Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);\n        return BitmapResource.obtain(bitmap, bitmapPool);\n    }\n```\n顺便还放进了LruBitmapPool（又一个实现了lru算法的缓存），Bitmap存在一个LruPoolStrategy接口实例的GroupedLinkedMap中。\n\n\n### 4.3 回到主线程\nEngineRunnable的run方法跑在子线程，在run的最后就是用一个handler推到主线程了。有可能是从CacheService这个线程池里面的线程推过去的，也可能是SourceSevice这个线程池里面推过去的。\n\nonResourceReady最终会走到GenericRequest的onResourceReady方法里\n```\n  private void onResourceReady(Resource<?> resource, R result) {\n\n        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,\n                isFirstResource)) {\n            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);\n            target.onResourceReady(result, animation); //注意这句话就可以了\n        }\n    }\n\n```\n最终会调到ImageViewTarget,AppWidgetTarget等Target（持有Request和View,View可能没有），这时候，直接调用ImageView.setImagBitmap等方法就可以了。\n图片设置完毕。\n\n### 5. Glide除了普通的加载方法，还能用什么比较有意思的玩法\n\n\n## 来一些不拘一格的加载图片的方法\n### 使用Application的Context,不跟生命周期走\n\n## 小结\n\n\n## 参考","slug":"2017-07-21-glide-decoded","published":1,"updated":"2017-07-29T05:41:23.814Z","_id":"cj5gmdnk3002mbovrbaimiw1m","comments":1,"layout":"post","photos":[],"link":"","content":"<p>glide的源码几个月前曾经拜读过，大致了解了其异步加载的实现原理。图片加载和网络请求很类似，就像当初看Volley，从一个Request —&gt;  CacheDispatch  —&gt; NetworkDispatcher  —-&gt;  ResponseDeliver。优秀的轮子不仅执行效率高，同时具备高的扩展性。读懂源码其实只是第一步，往下应该是利用框架提供的扩展方案，再往后应该就是能够独立设计出一套类似的框架了。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/a11f41e0b1df95212c71920b3959cd72.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"1-使用入门\"><a href=\"#1-使用入门\" class=\"headerlink\" title=\"1. 使用入门\"></a>1. 使用入门</h2><p>印象中最早接触Glide是在cheesequare中，顿时发现，原来加载图片可以这么简单，之后的开发过程中总会对Glide有所偏倚。接近两年之后再来过一遍源码，希望能够回答那个“如果让你来设计一个图片加载框架，你会怎么设计？”的问题。<br>使用方式很简单</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(activity)</div><div class=\"line\">              .load(R.drawable.image_id)</div><div class=\"line\">              .into(mImageView);</div></pre></td></tr></table></figure>\n<p>来看这里面做了什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Util.isOnBackgroundThread()) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> get(activity.getApplicationContext());</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        assertNotDestroyed(activity);</div><div class=\"line\">        FragmentManager fm = activity.getSupportFragmentManager();</div><div class=\"line\">        <span class=\"keyword\">return</span> supportFragmentGet(activity, fm);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">SupportRequestManagerFragment <span class=\"title\">getSupportRequestManagerFragment</span><span class=\"params\">(<span class=\"keyword\">final</span> FragmentManager fm)</span> </span>&#123;</div><div class=\"line\">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(</div><div class=\"line\">        FRAGMENT_TAG);</div><div class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        current = pendingSupportRequestManagerFragments.get(fm);</div><div class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            current = <span class=\"keyword\">new</span> SupportRequestManagerFragment();</div><div class=\"line\">            pendingSupportRequestManagerFragments.put(fm, current);</div><div class=\"line\">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class=\"line\">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> current;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>with方法只是返回了一个RequestManager，with方法可以接受Fragemnt,Activity以及Context等.以上面的activity为例，supportFragmentGet方法只是通过FragmentActivity的supportFragmentManager去findFragmentByTag，这个Tag叫做：“com.bumptech.glide.manager”，所以一般在Debug的时候，去SupportFragmentManager里面查找，有时候能够看到一个这样的Fragment。这个方法里面就是查找这样的一个Fragment，甚至我们自己也可以FindFragmentByTag去调用这个Fragment的方法(这是一个Public的class)然后从这个Fragemnt里面获得RequestManager成员变量（没有就new一个并set）。可以看出，一个Fragment只有一个RequestManager，Fragment主要是为了跟Activity生命周期挂钩的。这里有必要讲一下为什么要写两次current ==null，findFragmentByTag并不会在commitAllowingStateLoss之后就会返回添加的Fragment，只是往主线程的MessageQueue里面丢了一个消息，这个消息执行完毕之后才findFragmentByTag才不为空。这里用Handler丢一条消息，这条消息肯定要排在之前那条消息之后才被执行，所以才有这样一个Pendingmap的设计。当然到这里，最重要的还是Glide是通过commit了一个特殊的Fragment来实现生命周期监听。<br>具体来看：SupportRequestManagerFragment中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">      lifecycle.onStart();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">      lifecycle.onStop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">      lifecycle.onDestroy();</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>而对应到LifeCycle的各个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       isStarted = <span class=\"keyword\">true</span>;</div><div class=\"line\">       <span class=\"keyword\">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class=\"line\">           lifecycleListener.onStart();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       isStarted = <span class=\"keyword\">false</span>;</div><div class=\"line\">       <span class=\"keyword\">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class=\"line\">           lifecycleListener.onStop();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       isDestroyed = <span class=\"keyword\">true</span>;</div><div class=\"line\">       <span class=\"keyword\">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class=\"line\">           lifecycleListener.onDestroy();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>就是把内部维护的一个集合一个个拿出来调用响应生命周期的方法。<br>而这个LifeCycleListener就是上面创建RequestManager时(构造函数传进来了fragment的lifeCycle)添加的。RequestManager还默认添加了一个ConnectivityMonitor，主要作用就是在生命周期的onStart注册了一个ConnectivityManager.CONNECTIVITY_ACTION的BroadCastReceiver，在onStop的时候unRegister，在网络状态变化的时候调用RequestManager的RequestTracker成员变量的restartRequet。</p>\n<p>小结：</p>\n<ul>\n<li>在有权限(android.permission.ACCESS_NETWORK_STATE)的情况下，Glide已经做好了有网-&gt; 断网-&gt; 有网的恢复请求。另外，Android 7.0虽说不再发送ConnectivityManager.CONNECTIVITY_ACTION这个广播，但对于前台应用，动态注册的Receiver还是能够收到，Glide由于是在OnStart注册的，所以完全没问题。</li>\n<li>在一个Activity中，RequestManager只要一个，其实开发者自己保留下来也没什么问题</li>\n</ul>\n<h2 id=\"2-RequestManager调度请求\"><a href=\"#2-RequestManager调度请求\" class=\"headerlink\" title=\"2. RequestManager调度请求\"></a>2. RequestManager调度请求</h2><p>来看下这个RequestManager的成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleListener</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Context context;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lifecycle lifecycle;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestManagerTreeNode treeNode;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestTracker requestTracker;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Glide glide; <span class=\"comment\">//全局只有一个，控制线程池，用Application的Context创建的</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OptionsApplier optionsApplier;</div><div class=\"line\">    <span class=\"keyword\">private</span> DefaultOptions options;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OptionsApplier</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> &lt;A, X extends GenericRequestBuilder&lt;A, ?, ?, ?&gt;&gt; <span class=\"function\">X <span class=\"title\">apply</span><span class=\"params\">(X builder)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                options.apply(builder);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> builder;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>上面这个泛型写的非常绕，OptionApplier的意思就是，如果用户提供了一些定制(存在options里面)，就给一些定制的选择。一般这个options为null。</p>\n<h3 id=\"2-1-各种Type的Request\"><a href=\"#2-1-各种Type的Request\" class=\"headerlink\" title=\"2.1 各种Type的Request\"></a>2.1 各种Type的Request</h3><p>Glide的RequestManager可以接受各种各样的来源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;Integer&gt; <span class=\"title\">load</span><span class=\"params\">(Integer resourceId)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;Integer&gt;) fromResource().load(resourceId);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">public</span> DrawableTypeRequest&lt;<span class=\"keyword\">byte</span>[]&gt; load(<span class=\"keyword\">byte</span>[] model) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;<span class=\"keyword\">byte</span>[]&gt;) fromBytes().load(model);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;File&gt; <span class=\"title\">load</span><span class=\"params\">(File file)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;File&gt;) fromFile().load(file);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//上述方法都调用到了</span></div><div class=\"line\">     <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">DrawableTypeRequest&lt;T&gt; <span class=\"title\">loadGeneric</span><span class=\"params\">(Class&lt;T&gt; modelClass)</span> </span>&#123;</div><div class=\"line\">        ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);</div><div class=\"line\">        ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =</div><div class=\"line\">                Glide.buildFileDescriptorModelLoader(modelClass, context);</div><div class=\"line\">        <span class=\"keyword\">if</span> (modelClass != <span class=\"keyword\">null</span> &amp;&amp; streamModelLoader == <span class=\"keyword\">null</span> &amp;&amp; fileDescriptorModelLoader == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown type \"</span> + modelClass + <span class=\"string\">\". You must provide a Model of a type for\"</span></div><div class=\"line\">                    + <span class=\"string\">\" which there is a registered ModelLoader, if you are using a custom model, you must first call\"</span></div><div class=\"line\">                    + <span class=\"string\">\" Glide#register with a ModelLoaderFactory for your custom model class\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> optionsApplier.apply(</div><div class=\"line\">                <span class=\"keyword\">new</span> DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</div><div class=\"line\">                        glide, requestTracker, lifecycle, optionsApplier));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>DrawableTypeRequest接受一个泛型，可以是String(网络路径)，File(本地文件),Integer（资源文件）。所以最终返回的DrawableTypeRequet里面装的可能是String.class，Integer.class也可能是File.class。<br>比较难懂的是 streamModelLoader和fileDescriptorModelLoader的创建.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ModelLoader</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">Y</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\">DataFetcher&lt;Y&gt; <span class=\"title\">getResourceFetcher</span><span class=\"params\">(T model, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ModelLoader其实就是只有一个方法的接口，例如with(File)会传一个File.class进来，返回的streamModelLoader的T就是File，Y就是InputStream。<br>ModelLoader<T, Y>负责提供DataFetcher<Y>，T是数据源，可以是File,Resourse，url等等。Y用于描述类型，本地的就使用ParcelFileDescriptor（记得FileDescriptor属于Native的东西），网络上的就使用InputStream.<br>T和Y的组合可能有很多种，Cache在Glide(全局唯一)的loaderFactory（成员变量）的一个HashMap(没用ConcurrentHashMap是因为buildModelLoader方法加锁了)中。所以这份缓存也是全局唯一的。<br>T和Y的一一对应其实是在Glide的构造函数里面写好的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">register(File.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorFileLoader.Factory());</div><div class=\"line\">register(File.class, InputStream.class, <span class=\"keyword\">new</span> StreamFileLoader.Factory());</div><div class=\"line\">register(<span class=\"keyword\">int</span>.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorResourceLoader.Factory());</div><div class=\"line\">register(<span class=\"keyword\">int</span>.class, InputStream.class, <span class=\"keyword\">new</span> StreamResourceLoader.Factory());</div><div class=\"line\">register(Integer.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorResourceLoader.Factory());</div><div class=\"line\">register(Integer.class, InputStream.class, <span class=\"keyword\">new</span> StreamResourceLoader.Factory());</div><div class=\"line\">register(String.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorStringLoader.Factory());</div><div class=\"line\">register(String.class, InputStream.class, <span class=\"keyword\">new</span> StreamStringLoader.Factory());</div><div class=\"line\">register(Uri.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorUriLoader.Factory());</div><div class=\"line\">register(Uri.class, InputStream.class, <span class=\"keyword\">new</span> StreamUriLoader.Factory());</div><div class=\"line\">register(URL.class, InputStream.class, <span class=\"keyword\">new</span> StreamUrlLoader.Factory());</div><div class=\"line\">register(GlideUrl.class, InputStream.class, <span class=\"keyword\">new</span> HttpUrlGlideUrlLoader.Factory());</div><div class=\"line\">register(<span class=\"keyword\">byte</span>[].class, InputStream.class, <span class=\"keyword\">new</span> StreamByteArrayLoader.Factory());</div></pre></td></tr></table></figure>\n<p>左边有很多种，右边只可能是InputStream或者ParcelFileDescriptor。</p>\n<h3 id=\"2-2-Request的继承关系\"><a href=\"#2-2-Request的继承关系\" class=\"headerlink\" title=\"2.2 Request的继承关系\"></a>2.2 Request的继承关系</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class DrawableTypeRequest&lt;ModelType&gt; extends DrawableRequestBuilder&lt;ModelType&gt; implements DownloadOptions</div><div class=\"line\">public class DrawableRequestBuilder&lt;ModelType&gt;</div><div class=\"line\">       extends GenericRequestBuilder&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt;</div><div class=\"line\">       implements BitmapOptions, DrawableOptions </div><div class=\"line\">public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable</div></pre></td></tr></table></figure>\n<p>记住这个ModelType就是Glide.with(context).load(XXX) 里面传进去的Object的Class，例如File.class，那么<br>上面其实就是创建了一个DrawableTypeRequest，泛型是File ，构造函数一层层往上调用，DrawableRequestBuilder这一层调用了crossFade方法，即默认会有一个crossFade的效果，默认用的是DrawableCrossFadeFactory。注意这里把属于RequestManager的RequestTracker也传进来了。</p>\n<ul>\n<li>Glide.with(context).load(XX)到目前为止只是返回了一个DrawableTypeRequest<ModelType> 的实例。(还在主线程)</li>\n</ul>\n<h2 id=\"2-3-小节\"><a href=\"#2-3-小节\" class=\"headerlink\" title=\"2.3 小节\"></a>2.3 小节</h2><p>Glide.with返回一个RequestManger，每个Activity只会有一个RequestManager<br>load方法返回了一个DrawableTypeRequest<T>，这个T可能是File,String,Interger等。<br>到目前为止还只是构建一个Request。</p>\n<h2 id=\"3-DrawableRequestBuilder的into方法\"><a href=\"#3-DrawableRequestBuilder的into方法\" class=\"headerlink\" title=\"3. DrawableRequestBuilder的into方法\"></a>3. DrawableRequestBuilder的into方法</h2><p>Glide的最后一个调用方法是into()，也是最终分发请求的方法</p>\n<p>DrawableRequestBuilder<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Target&lt;GlideDrawable&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.into(view);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Target&lt;TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</div><div class=\"line\">       Util.assertMainThread();<span class=\"comment\">//还是在主线程对不对</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must pass in a non null View\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (!isTransformationSet &amp;&amp; view.getScaleType() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">switch</span> (view.getScaleType()) &#123;</div><div class=\"line\">               <span class=\"keyword\">case</span> CENTER_CROP:</div><div class=\"line\">                   applyCenterCrop();</div><div class=\"line\">                   <span class=\"keyword\">break</span>;</div><div class=\"line\">               <span class=\"keyword\">case</span> FIT_CENTER:</div><div class=\"line\">               <span class=\"keyword\">case</span> FIT_START:</div><div class=\"line\">               <span class=\"keyword\">case</span> FIT_END:</div><div class=\"line\">                   applyFitCenter();</div><div class=\"line\">                   <span class=\"keyword\">break</span>;</div><div class=\"line\">               <span class=\"comment\">//$CASES-OMITTED$</span></div><div class=\"line\">               <span class=\"keyword\">default</span>:</div><div class=\"line\">                   <span class=\"comment\">// Do nothing.</span></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</div><div class=\"line\">       <span class=\"comment\">//这个into接收一个Target的子类的实例，而Target又继承自LifeCycleListener</span></div><div class=\"line\">       <span class=\"comment\">//这个TranscodeClass是每一个Request创建的时候从构造函数传进来的。</span></div><div class=\"line\">      </div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//transcodeclass可能是GlideDrawable.class，也可能是Bitmap.class也可能是Drawable.class</span></div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">   <span class=\"keyword\">public</span> &lt;Z&gt; <span class=\"function\">Target&lt;Z&gt; <span class=\"title\">buildTarget</span><span class=\"params\">(ImageView view, Class&lt;Z&gt; clazz)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (GlideDrawable.class.isAssignableFrom(clazz)) &#123; <span class=\"comment\">//isAssignableFrom表示左边的class是否是右边class一个类或者父类，应该和instaceof倒过来。</span></div><div class=\"line\">           <span class=\"keyword\">return</span> (Target&lt;Z&gt;) <span class=\"keyword\">new</span> GlideDrawableImageViewTarget(view);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Bitmap.class.equals(clazz)) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> (Target&lt;Z&gt;) <span class=\"keyword\">new</span> BitmapImageViewTarget(view);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> (Target&lt;Z&gt;) <span class=\"keyword\">new</span> DrawableImageViewTarget(view);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unhandled class: \"</span> + clazz</div><div class=\"line\">                   + <span class=\"string\">\", try .as*(Class).transcode(ResourceTranscoder)\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>GlideDrawableImageViewTarget、BitmapImageViewTarget以及DrawableImageViewTarget全部继承自ImageViewTarget，后者继承自ViewTarget,再继承自BaseTarget，再 implements Target。一层层继承下来，GlideDrawableImageViewTarget等三个子类中都有一个Request，一个T extents View(看来不一定是ImageView)</p>\n<h3 id=\"3-1-以GlideDrawableImageViewTarget为例\"><a href=\"#3-1-以GlideDrawableImageViewTarget为例\" class=\"headerlink\" title=\"3.1 以GlideDrawableImageViewTarget为例\"></a>3.1 以GlideDrawableImageViewTarget为例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlideDrawableImageViewTarget</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImageViewTarget</span>&lt;<span class=\"title\">GlideDrawable</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> SQUARE_RATIO_MARGIN = <span class=\"number\">0.05f</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxLoopCount;</div><div class=\"line\">    <span class=\"keyword\">private</span> GlideDrawable resource; </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>GlideDrawable是一个继承自Drawable的抽象类，添加了isAnimated(),setLoopCount以及由于实现了isAnimated所需要的三个方法(start,stop,isRunning)。子类必须实现这五个抽象方法。</p>\n<p>GlideDrawableImageViewTarget往上走<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageViewTarget</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ViewTarget</span>&lt;<span class=\"title\">ImageView</span>, <span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">GlideAnimation</span>.<span class=\"title\">ViewAdapter</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着往上找父类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewTarget</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span>, <span class=\"title\">Z</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BaseTarget</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"ViewTarget\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isTagUsedAtLeastOnce = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Integer tagId = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> T view;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SizeDeterminer sizeDeterminer;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看下文档：A base Target for loading android.graphics.Bitmaps into Views that provides default implementations for most most methods and can determine the size of views using a android.view.ViewTreeObserver.OnDrawListener<br>To detect View} reuse in android.widget.ListView or any android.view.ViewGroup that reuses views, this class uses the View setTag(Object) method to store some metadata so that if a view is reused, any previous loads or resources from previous loads can be cancelled or reused.<br> Any calls to View setTag(Object)on a View given to this class will result in excessive allocations and<br> and/or IllegalArgumentExceptions. If you must call View#setTag(Object)on a view, consider  using BaseTarget or SimpleTarget instead.</p>\n<ul>\n<li>翻译一下，ViewTarget提供了将Bitmap 加载进View的大部分方法的基本实现，并且添加了onPreDrawListener以获得View的尺寸，对于Resuse View的场景，通过setTag来取消被滑出屏幕的View的request的加载。</li>\n</ul>\n<p>既然提供了大部分方法的默认实现，那么一定有方法没实现，其实就是<br>protected void setResource(Z resource)啦。<br>这个Z可能是Bitmap,GlideDrawable或者Drawable。直接拿来setImageBitmap或者setImageDrawable就可以了，这个方法其实在是解码完成之后了。</p>\n<p>关键是default implementation是怎么实现的以及这些方法在父类中的调用时机。<br>ViewTarget的构造函数传进来一个View的子类，同时创建一个SizeDeterminer（只是通过onPreDrawListener获得View的宽和高）。</p>\n<p>再往上找父类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseTarget</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Target</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123; <span class=\"comment\">//添加了一个Request成员变量，为Target中的一些方法提供了空实现，比如onLoadStarted，onLoadXXX等</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> Request request;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>到这里，还只是配置资源要加载进的对象，我倾向于把Target看成一个资源加载完毕的中转者，它管理了View（也可以没有View）和Request，在外部调用Target.onLoadStarted等方法是，调用View(如果有的话)的xxx方法。</p>\n<h3 id=\"3-2任务分发\"><a href=\"#3-2任务分发\" class=\"headerlink\" title=\"3.2任务分发\"></a>3.2任务分发</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(Y target)</span> </span>&#123;</div><div class=\"line\">    Util.assertMainThread(); <span class=\"comment\">//还在主线程上</span></div><div class=\"line\">    Request previous = target.getRequest();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//每一个Target都只有一个Request，用于清除之前的请求</span></div><div class=\"line\">        previous.clear();</div><div class=\"line\">        requestTracker.removeRequest(previous);</div><div class=\"line\">        previous.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Request request = buildRequest(target);</div><div class=\"line\">    target.setRequest(request);</div><div class=\"line\">    lifecycle.addListener(target);</div><div class=\"line\">    requestTracker.runRequest(request);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> target; <span class=\"comment\">//这里返回Target的好处在于可以接着链式调用，上面只是添加到任务队列，真正被处理还得等到下一帧(onPreDraw调用时)，所以这里还可以接着对这个Target进行配置</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意 requestTracker.runRequest(request)方法<br>GenericRequest.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      startTime = LogTime.getLogTime();</div><div class=\"line\">      <span class=\"keyword\">if</span> (model == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          onException(<span class=\"keyword\">null</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      status = Status.WAITING_FOR_SIZE;</div><div class=\"line\">      <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class=\"line\">          onSizeReady(overrideWidth, overrideHeight);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          target.getSize(<span class=\"keyword\">this</span>); <span class=\"comment\">//这个方法其实就等于挂了个钩子在onPreDraw中调用，onPreDraw时会调用onSizeReady。</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</div><div class=\"line\">          target.onLoadStarted(getPlaceholderDrawable());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">          logV(<span class=\"string\">\"finished run method in \"</span> + LogTime.getElapsedMillis(startTime));</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>onSizeReady才是真正开始干活的时机，理由也很充分。解码Bitmap必须要知道需要多大的尺寸，否则也是白搭。<br>GenericRequest.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * A callback method that should never be invoked directly.</div><div class=\"line\">  */</span> </div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeReady</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"keyword\">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">     status = Status.RUNNING;</div><div class=\"line\"></div><div class=\"line\">     width = Math.round(sizeMultiplier * width); <span class=\"comment\">//这个sizeMultiplier可以通过链式调用配置</span></div><div class=\"line\">     height = Math.round(sizeMultiplier * height);</div><div class=\"line\"></div><div class=\"line\">     ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</div><div class=\"line\">     <span class=\"keyword\">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</div><div class=\"line\">         </div><div class=\"line\">     ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</div><div class=\"line\">     loadedFromMemoryCache = <span class=\"keyword\">true</span>;</div><div class=\"line\">     loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</div><div class=\"line\">             priority, isMemoryCacheable, diskCacheStrategy, <span class=\"keyword\">this</span>);</div><div class=\"line\">     loadedFromMemoryCache = resource != <span class=\"keyword\">null</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">         logV(<span class=\"string\">\"finished onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-缓存查找\"><a href=\"#3-3-缓存查找\" class=\"headerlink\" title=\"3.3 缓存查找\"></a>3.3 缓存查找</h3><p>开始查找缓存是engine.load开始的，找到了就调用Callback的onResourceReady<br>Engine.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</div><div class=\"line\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</div><div class=\"line\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</div><div class=\"line\">    Util.assertMainThread(); <span class=\"comment\">//还是在主线程上</span></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();<span class=\"comment\">//如果是个网络图片，返回网络url，类似这种</span></div><div class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</div><div class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</div><div class=\"line\">            transcoder, loadProvider.getSourceEncoder());</div><div class=\"line\"></div><div class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</div><div class=\"line\">    <span class=\"comment\">//EngineResource内部wrap了真正的Resource，并使用一个int acquire表示当前正在占用资源的使用者数。当这个数为0的时候可以release。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        cb.onResourceReady(cached);</div><div class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</div><div class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        cb.onResourceReady(active);</div><div class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    EngineJob current = jobs.get(key);</div><div class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        current.addCallback(cb);</div><div class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</div><div class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</div><div class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</div><div class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</div><div class=\"line\">    jobs.put(key, engineJob);</div><div class=\"line\">    engineJob.addCallback(cb);</div><div class=\"line\">    engineJob.start(runnable);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Engine先去Cache里面查找，找到了直接调用ResourceCallback(GenericRequest)的onResourceReady(EngineResource&lt;?&gt; resource)，注意这个EngineResource里面包装了一个Resource，主要是为了引用计数。</p>\n<p> Engine的loadFromCache(key, isMemoryCacheable)是第一步，从成员变量cache中获取。找到了就挪到activeResources里面。<br> Engine.java<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Engine</span> <span class=\"keyword\">implements</span> <span class=\"title\">EngineJobListener</span>,</div><div class=\"line\">        <span class=\"title\">MemoryCache</span>.<span class=\"title\">ResourceRemovedListener</span>,</div><div class=\"line\">        <span class=\"title\">EngineResource</span>.<span class=\"title\">ResourceListener</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"Engine\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, EngineJob&gt; jobs;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineKeyFactory keyFactory;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryCache cache;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineJobFactory engineJobFactory;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ResourceRecycler resourceRecycler;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LazyDiskCacheProvider diskCacheProvider;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果在MemoryCache这个Lru里面没找到，就调用loadFromActiveResources，从activeResources里面找到。</p>\n<p><strong>所以这里已经出现两层缓存了，先去Lru(内存)找，再去activeResources(HashMap)里面找。缓存都是放在Enginel里面的，全局只有一份</strong></p>\n<p>缓存里面的Value都是EngineResource。</p>\n<p>这个MemoryCache是一个LruCache，大小是在MemorySizeCalculator中获得的，<br>对于一般的设备，activityManager.getMemoryClass() <em> 1024 </em> 1024获得每个App能够使用的Size,乘以0.4。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxSize = getMaxSize(activityManager);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()</div><div class=\"line\">               * BYTES_PER_ARGB_8888_PIXEL; <span class=\"comment\">//算出占满整个屏幕的一张图的大小</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">int</span> targetPoolSize = screenSize * BITMAP_POOL_TARGET_SCREENS; <span class=\"comment\">//乘以4就是bitmappool的大小</span></div><div class=\"line\">       <span class=\"keyword\">int</span> targetMemoryCacheSize = screenSize * MEMORY_CACHE_TARGET_SCREENS;</div><div class=\"line\">       <span class=\"comment\">//乘以2就是MemoryCache的大小</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (targetMemoryCacheSize + targetPoolSize &lt;= maxSize) &#123;</div><div class=\"line\">           memoryCacheSize = targetMemoryCacheSize;</div><div class=\"line\">           bitmapPoolSize = targetPoolSize;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//这里判断了BitmapPool和MemoryCache的大小之和不能超出应用可以使用的内存大小的0.4倍。</span></div><div class=\"line\">           <span class=\"keyword\">int</span> part = Math.round((<span class=\"keyword\">float</span>) maxSize / (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));</div><div class=\"line\">           memoryCacheSize = part * MEMORY_CACHE_TARGET_SCREENS;</div><div class=\"line\">           bitmapPoolSize = part * BITMAP_POOL_TARGET_SCREENS;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>所以缓存的大小综合考虑了屏幕分辨率和内存大小。只要屏幕像素不是特别高，一般都会走到第一步。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>ViewTarget里面有一个 T extends View，可见Glide不只适用于ImageView。</li>\n<li>BaseTarget里带了一个private Request，其子类可以通过getRequest获得。</li>\n<li>对于ListView等可以快速滑动的View，如果某一个View被滑出屏幕外，自动取消请求(通过setTagId实现)</li>\n<li>“You must not call setTag() on a view Glide is targeting” setTag可能会崩，原因</li>\n<li>GenericRequestBuilder的obtainRequest内部使用了一个ArrayDeque来obtain Request。这样Request实例不会多次创建，回收是在request.recycle里面做的。</li>\n</ul>\n<h3 id=\"4-离开主线程，提交任务到线程池\"><a href=\"#4-离开主线程，提交任务到线程池\" class=\"headerlink\" title=\"4. 离开主线程，提交任务到线程池\"></a>4. 离开主线程，提交任务到线程池</h3><p>如果上面两层缓存都没找到，去jobs里找看下有没有已经加入队列的EngineJob<br>记住上面有两层缓存</p>\n<p>来看后面提交任务这几段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"> EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</div><div class=\"line\">        DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</div><div class=\"line\">                transcoder, diskCacheProvider, diskCacheStrategy, priority);</div><div class=\"line\">        EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</div><div class=\"line\">        jobs.put(key, engineJob);</div><div class=\"line\">        engineJob.addCallback(cb);</div><div class=\"line\">        engineJob.start(runnable); <span class=\"comment\">//往diskCacheService提交了一个Runnable</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineJob</span> <span class=\"keyword\">implements</span> <span class=\"title\">EngineRunnable</span>.<span class=\"title\">EngineRunnableManager</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EngineResourceFactory DEFAULT_FACTORY = <span class=\"keyword\">new</span> EngineResourceFactory();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Handler MAIN_THREAD_HANDLER = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper(), <span class=\"keyword\">new</span> MainThreadCallback());</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MSG_COMPLETE = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MSG_EXCEPTION = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ResourceCallback&gt; cbs = <span class=\"keyword\">new</span> ArrayList&lt;ResourceCallback&gt;();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineResourceFactory engineResourceFactory;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineJobListener listener;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Key key;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService diskCacheService; <span class=\"comment\">//线程池</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService sourceService; <span class=\"comment\">//线程池</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isCacheable;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isCancelled;</div><div class=\"line\">    <span class=\"comment\">// Either resource or exception (particularly exception) may be returned to us null, so use booleans to track if</span></div><div class=\"line\">    <span class=\"comment\">// we've received them instead of relying on them to be non-null. See issue #180.</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Resource&lt;?&gt; resource;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasResource;</div><div class=\"line\">    <span class=\"keyword\">private</span> Exception exception;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasException;</div><div class=\"line\">    <span class=\"comment\">// A set of callbacks that are removed while we're notifying other callbacks of a change in status.</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Set&lt;ResourceCallback&gt; ignoredCallbacks;</div><div class=\"line\">    <span class=\"keyword\">private</span> EngineRunnable engineRunnable;</div><div class=\"line\">    <span class=\"keyword\">private</span> EngineResource&lt;?&gt; engineResource;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Future&lt;?&gt; future;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>EngineJob是通过Factory创建的，创建时会传两个线程池进来。一个管DiskCache,一个管Source获取。初始化是在Glide.createGlide里面做的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (sourceService == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cores = Math.max(<span class=\"number\">1</span>, Runtime.getRuntime().availableProcessors());</div><div class=\"line\">            sourceService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(cores);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (diskCacheService == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            diskCacheService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>在外部没有提供线程池的情况下，DiskCache一个线程池就好了，SourceService的大小为当前cpu可用核心数，还是比较高效的。<br>上面是往DiskCacheService提交了一个EngineRunable，这个Runnable的run里面主要是decodeFromCache和DecodeFroSource，分别代表从<strong>磁盘缓存</strong>获取和从数据源获取。<br>首先会调用decodeFromCache，一层层往下找，如果没找到的话会调用onLoadFailed方法，并将任务提交给SourceService，去获取资源。</p>\n<h3 id=\"4-1-CacheService这个线程池的工作以及第三层缓存的出现\"><a href=\"#4-1-CacheService这个线程池的工作以及第三层缓存的出现\" class=\"headerlink\" title=\"4.1 CacheService这个线程池的工作以及第三层缓存的出现\"></a>4.1 CacheService这个线程池的工作以及第三层缓存的出现</h3><p><strong>注意这里出现了第三层缓存</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">File cacheFile = diskCacheProvider.getDiskCache().get(key);</div></pre></td></tr></table></figure></p>\n<p>这一层缓存是给DiskCache的线程池查找用的，查找的时候分为从Result中查找和从Source中查找，其实查找的目的地都是那个DiskCache，Resul是用ResultKey去找的，Source是用ResultKey.getOriginalKey去查找的。物理位置都放在那个磁盘目录下。</p>\n<p>另外在DecodeJob的cacheAndDecodeSourceData方法里，存的只是origin(因为用的是origin Key)，然后再拿着originKey去磁盘找，找出来decode。</p>\n<p>DecodeFromCache又包括两步decodeResultFromCache和decodeSourceFromCache，这就让人想到Glide的DiskCacheStrategy分为Result和Source，即可以缓存decode结果也可以缓存decode之前的source。前提是在上面的diskCacheProvider.getDiskCache().get(key)方法里面找到了CachedFile。这个路径在InternalCacheDiskCacheFactory里面写了具体的路径</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InternalCacheDiskCacheFactory</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> String diskCacheName, <span class=\"keyword\">int</span> diskCacheSize)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>(<span class=\"keyword\">new</span> CacheDirectoryGetter() &#123;</div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCacheDirectory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               File cacheDirectory = context.getCacheDir();</div><div class=\"line\">               <span class=\"keyword\">if</span> (cacheDirectory == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">if</span> (diskCacheName != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(cacheDirectory, diskCacheName);</div><div class=\"line\">                   <span class=\"comment\">//就是context.getCacheDir+\"image_manager_disk_cache\"</span></div><div class=\"line\">                   <span class=\"comment\">//默认上限是250MB</span></div><div class=\"line\">                   <span class=\"comment\">//由于这个Cache放在CacheDir里面，其他应用拿不到</span></div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">return</span> cacheDirectory;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;, diskCacheSize);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>注意无论是decodeResultFromCache还是decodeSourceFromCache里都有类似的一段：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Resource&lt;T&gt; transformed = loadFromCache(resultKey);</div><div class=\"line\">Resource&lt;Z&gt; result = transcode(transformed); <span class=\"comment\">///把一种资源转成另一种资源，比如把Bitmap的Resource转成一个ByteResource</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-SourceService这个线程池以及BitmapPool这一层缓存的出现\"><a href=\"#4-2-SourceService这个线程池以及BitmapPool这一层缓存的出现\" class=\"headerlink\" title=\"4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现\"></a>4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">decodeFromSourceData</span><span class=\"params\">(A data)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">final</span> Resource&lt;T&gt; decoded;</div><div class=\"line\">     <span class=\"keyword\">if</span> (diskCacheStrategy.cacheSource()) &#123;</div><div class=\"line\">         decoded = cacheAndDecodeSourceData(data);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</div><div class=\"line\">         decoded = loadProvider.getSourceDecoder().decode(data, width, height); <span class=\"comment\">// 这里面放进BitmapPool了</span></div><div class=\"line\">         <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">             logWithTimeAndKey(<span class=\"string\">\"Decoded from source\"</span>, startTime);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> decoded;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p><strong>第四层缓存出现。。。</strong><br>DecodeFromSource也是类似，判断是否允许Cache，通过DataFetcher获取数据这个数据可能是InputStream，也可能是ImageVideoWrapper。。。总之是一个可以提供数据的来源。如果可以Cache的话，先把数据写到lru里面，然后从lru里面取出来，从Source decode成想要的数据类型。<br>例如从Stream转成Bitmap是这么干的<br>StreamBitmapDecoder.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Bitmap&gt; <span class=\"title\">decode</span><span class=\"params\">(InputStream source, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">       Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);</div><div class=\"line\">       <span class=\"keyword\">return</span> BitmapResource.obtain(bitmap, bitmapPool);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>顺便还放进了LruBitmapPool（又一个实现了lru算法的缓存），Bitmap存在一个LruPoolStrategy接口实例的GroupedLinkedMap中。</p>\n<h3 id=\"4-3-回到主线程\"><a href=\"#4-3-回到主线程\" class=\"headerlink\" title=\"4.3 回到主线程\"></a>4.3 回到主线程</h3><p>EngineRunnable的run方法跑在子线程，在run的最后就是用一个handler推到主线程了。有可能是从CacheService这个线程池里面的线程推过去的，也可能是SourceSevice这个线程池里面推过去的。</p>\n<p>onResourceReady最终会走到GenericRequest的onResourceReady方法里<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123;</div><div class=\"line\"></div><div class=\"line\">      if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,</div><div class=\"line\">              isFirstResource)) &#123;</div><div class=\"line\">          GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</div><div class=\"line\">          target.onResourceReady(result, animation); //注意这句话就可以了</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>最终会调到ImageViewTarget,AppWidgetTarget等Target（持有Request和View,View可能没有），这时候，直接调用ImageView.setImagBitmap等方法就可以了。<br>图片设置完毕。</p>\n<h3 id=\"5-Glide除了普通的加载方法，还能用什么比较有意思的玩法\"><a href=\"#5-Glide除了普通的加载方法，还能用什么比较有意思的玩法\" class=\"headerlink\" title=\"5. Glide除了普通的加载方法，还能用什么比较有意思的玩法\"></a>5. Glide除了普通的加载方法，还能用什么比较有意思的玩法</h3><h2 id=\"来一些不拘一格的加载图片的方法\"><a href=\"#来一些不拘一格的加载图片的方法\" class=\"headerlink\" title=\"来一些不拘一格的加载图片的方法\"></a>来一些不拘一格的加载图片的方法</h2><h3 id=\"使用Application的Context-不跟生命周期走\"><a href=\"#使用Application的Context-不跟生命周期走\" class=\"headerlink\" title=\"使用Application的Context,不跟生命周期走\"></a>使用Application的Context,不跟生命周期走</h3><h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2>","excerpt":"<p>glide的源码几个月前曾经拜读过，大致了解了其异步加载的实现原理。图片加载和网络请求很类似，就像当初看Volley，从一个Request —&gt;  CacheDispatch  —&gt; NetworkDispatcher  —-&gt;  ResponseDeliver。优秀的轮子不仅执行效率高，同时具备高的扩展性。读懂源码其实只是第一步，往下应该是利用框架提供的扩展方案，再往后应该就是能够独立设计出一套类似的框架了。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/a11f41e0b1df95212c71920b3959cd72.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<h2 id=\"1-使用入门\"><a href=\"#1-使用入门\" class=\"headerlink\" title=\"1. 使用入门\"></a>1. 使用入门</h2><p>印象中最早接触Glide是在cheesequare中，顿时发现，原来加载图片可以这么简单，之后的开发过程中总会对Glide有所偏倚。接近两年之后再来过一遍源码，希望能够回答那个“如果让你来设计一个图片加载框架，你会怎么设计？”的问题。<br>使用方式很简单</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(activity)</div><div class=\"line\">              .load(R.drawable.image_id)</div><div class=\"line\">              .into(mImageView);</div></pre></td></tr></table></figure>\n<p>来看这里面做了什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Util.isOnBackgroundThread()) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> get(activity.getApplicationContext());</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        assertNotDestroyed(activity);</div><div class=\"line\">        FragmentManager fm = activity.getSupportFragmentManager();</div><div class=\"line\">        <span class=\"keyword\">return</span> supportFragmentGet(activity, fm);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">SupportRequestManagerFragment <span class=\"title\">getSupportRequestManagerFragment</span><span class=\"params\">(<span class=\"keyword\">final</span> FragmentManager fm)</span> </span>&#123;</div><div class=\"line\">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(</div><div class=\"line\">        FRAGMENT_TAG);</div><div class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        current = pendingSupportRequestManagerFragments.get(fm);</div><div class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            current = <span class=\"keyword\">new</span> SupportRequestManagerFragment();</div><div class=\"line\">            pendingSupportRequestManagerFragments.put(fm, current);</div><div class=\"line\">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class=\"line\">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> current;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>with方法只是返回了一个RequestManager，with方法可以接受Fragemnt,Activity以及Context等.以上面的activity为例，supportFragmentGet方法只是通过FragmentActivity的supportFragmentManager去findFragmentByTag，这个Tag叫做：“com.bumptech.glide.manager”，所以一般在Debug的时候，去SupportFragmentManager里面查找，有时候能够看到一个这样的Fragment。这个方法里面就是查找这样的一个Fragment，甚至我们自己也可以FindFragmentByTag去调用这个Fragment的方法(这是一个Public的class)然后从这个Fragemnt里面获得RequestManager成员变量（没有就new一个并set）。可以看出，一个Fragment只有一个RequestManager，Fragment主要是为了跟Activity生命周期挂钩的。这里有必要讲一下为什么要写两次current ==null，findFragmentByTag并不会在commitAllowingStateLoss之后就会返回添加的Fragment，只是往主线程的MessageQueue里面丢了一个消息，这个消息执行完毕之后才findFragmentByTag才不为空。这里用Handler丢一条消息，这条消息肯定要排在之前那条消息之后才被执行，所以才有这样一个Pendingmap的设计。当然到这里，最重要的还是Glide是通过commit了一个特殊的Fragment来实现生命周期监听。<br>具体来看：SupportRequestManagerFragment中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">      lifecycle.onStart();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">      lifecycle.onStop();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">      lifecycle.onDestroy();</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>而对应到LifeCycle的各个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       isStarted = <span class=\"keyword\">true</span>;</div><div class=\"line\">       <span class=\"keyword\">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class=\"line\">           lifecycleListener.onStart();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       isStarted = <span class=\"keyword\">false</span>;</div><div class=\"line\">       <span class=\"keyword\">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class=\"line\">           lifecycleListener.onStop();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       isDestroyed = <span class=\"keyword\">true</span>;</div><div class=\"line\">       <span class=\"keyword\">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class=\"line\">           lifecycleListener.onDestroy();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>就是把内部维护的一个集合一个个拿出来调用响应生命周期的方法。<br>而这个LifeCycleListener就是上面创建RequestManager时(构造函数传进来了fragment的lifeCycle)添加的。RequestManager还默认添加了一个ConnectivityMonitor，主要作用就是在生命周期的onStart注册了一个ConnectivityManager.CONNECTIVITY_ACTION的BroadCastReceiver，在onStop的时候unRegister，在网络状态变化的时候调用RequestManager的RequestTracker成员变量的restartRequet。</p>\n<p>小结：</p>\n<ul>\n<li>在有权限(android.permission.ACCESS_NETWORK_STATE)的情况下，Glide已经做好了有网-&gt; 断网-&gt; 有网的恢复请求。另外，Android 7.0虽说不再发送ConnectivityManager.CONNECTIVITY_ACTION这个广播，但对于前台应用，动态注册的Receiver还是能够收到，Glide由于是在OnStart注册的，所以完全没问题。</li>\n<li>在一个Activity中，RequestManager只要一个，其实开发者自己保留下来也没什么问题</li>\n</ul>\n<h2 id=\"2-RequestManager调度请求\"><a href=\"#2-RequestManager调度请求\" class=\"headerlink\" title=\"2. RequestManager调度请求\"></a>2. RequestManager调度请求</h2><p>来看下这个RequestManager的成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleListener</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Context context;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lifecycle lifecycle;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestManagerTreeNode treeNode;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestTracker requestTracker;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Glide glide; <span class=\"comment\">//全局只有一个，控制线程池，用Application的Context创建的</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OptionsApplier optionsApplier;</div><div class=\"line\">    <span class=\"keyword\">private</span> DefaultOptions options;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OptionsApplier</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> &lt;A, X extends GenericRequestBuilder&lt;A, ?, ?, ?&gt;&gt; <span class=\"function\">X <span class=\"title\">apply</span><span class=\"params\">(X builder)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                options.apply(builder);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> builder;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>上面这个泛型写的非常绕，OptionApplier的意思就是，如果用户提供了一些定制(存在options里面)，就给一些定制的选择。一般这个options为null。</p>\n<h3 id=\"2-1-各种Type的Request\"><a href=\"#2-1-各种Type的Request\" class=\"headerlink\" title=\"2.1 各种Type的Request\"></a>2.1 各种Type的Request</h3><p>Glide的RequestManager可以接受各种各样的来源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;Integer&gt; <span class=\"title\">load</span><span class=\"params\">(Integer resourceId)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;Integer&gt;) fromResource().load(resourceId);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">public</span> DrawableTypeRequest&lt;<span class=\"keyword\">byte</span>[]&gt; load(<span class=\"keyword\">byte</span>[] model) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;<span class=\"keyword\">byte</span>[]&gt;) fromBytes().load(model);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;File&gt; <span class=\"title\">load</span><span class=\"params\">(File file)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;File&gt;) fromFile().load(file);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//上述方法都调用到了</span></div><div class=\"line\">     <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">DrawableTypeRequest&lt;T&gt; <span class=\"title\">loadGeneric</span><span class=\"params\">(Class&lt;T&gt; modelClass)</span> </span>&#123;</div><div class=\"line\">        ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);</div><div class=\"line\">        ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =</div><div class=\"line\">                Glide.buildFileDescriptorModelLoader(modelClass, context);</div><div class=\"line\">        <span class=\"keyword\">if</span> (modelClass != <span class=\"keyword\">null</span> &amp;&amp; streamModelLoader == <span class=\"keyword\">null</span> &amp;&amp; fileDescriptorModelLoader == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown type \"</span> + modelClass + <span class=\"string\">\". You must provide a Model of a type for\"</span></div><div class=\"line\">                    + <span class=\"string\">\" which there is a registered ModelLoader, if you are using a custom model, you must first call\"</span></div><div class=\"line\">                    + <span class=\"string\">\" Glide#register with a ModelLoaderFactory for your custom model class\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> optionsApplier.apply(</div><div class=\"line\">                <span class=\"keyword\">new</span> DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</div><div class=\"line\">                        glide, requestTracker, lifecycle, optionsApplier));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>DrawableTypeRequest接受一个泛型，可以是String(网络路径)，File(本地文件),Integer（资源文件）。所以最终返回的DrawableTypeRequet里面装的可能是String.class，Integer.class也可能是File.class。<br>比较难懂的是 streamModelLoader和fileDescriptorModelLoader的创建.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ModelLoader</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">Y</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\">DataFetcher&lt;Y&gt; <span class=\"title\">getResourceFetcher</span><span class=\"params\">(T model, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ModelLoader其实就是只有一个方法的接口，例如with(File)会传一个File.class进来，返回的streamModelLoader的T就是File，Y就是InputStream。<br>ModelLoader<T, Y>负责提供DataFetcher<Y>，T是数据源，可以是File,Resourse，url等等。Y用于描述类型，本地的就使用ParcelFileDescriptor（记得FileDescriptor属于Native的东西），网络上的就使用InputStream.<br>T和Y的组合可能有很多种，Cache在Glide(全局唯一)的loaderFactory（成员变量）的一个HashMap(没用ConcurrentHashMap是因为buildModelLoader方法加锁了)中。所以这份缓存也是全局唯一的。<br>T和Y的一一对应其实是在Glide的构造函数里面写好的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">register(File.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorFileLoader.Factory());</div><div class=\"line\">register(File.class, InputStream.class, <span class=\"keyword\">new</span> StreamFileLoader.Factory());</div><div class=\"line\">register(<span class=\"keyword\">int</span>.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorResourceLoader.Factory());</div><div class=\"line\">register(<span class=\"keyword\">int</span>.class, InputStream.class, <span class=\"keyword\">new</span> StreamResourceLoader.Factory());</div><div class=\"line\">register(Integer.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorResourceLoader.Factory());</div><div class=\"line\">register(Integer.class, InputStream.class, <span class=\"keyword\">new</span> StreamResourceLoader.Factory());</div><div class=\"line\">register(String.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorStringLoader.Factory());</div><div class=\"line\">register(String.class, InputStream.class, <span class=\"keyword\">new</span> StreamStringLoader.Factory());</div><div class=\"line\">register(Uri.class, ParcelFileDescriptor.class, <span class=\"keyword\">new</span> FileDescriptorUriLoader.Factory());</div><div class=\"line\">register(Uri.class, InputStream.class, <span class=\"keyword\">new</span> StreamUriLoader.Factory());</div><div class=\"line\">register(URL.class, InputStream.class, <span class=\"keyword\">new</span> StreamUrlLoader.Factory());</div><div class=\"line\">register(GlideUrl.class, InputStream.class, <span class=\"keyword\">new</span> HttpUrlGlideUrlLoader.Factory());</div><div class=\"line\">register(<span class=\"keyword\">byte</span>[].class, InputStream.class, <span class=\"keyword\">new</span> StreamByteArrayLoader.Factory());</div></pre></td></tr></table></figure>\n<p>左边有很多种，右边只可能是InputStream或者ParcelFileDescriptor。</p>\n<h3 id=\"2-2-Request的继承关系\"><a href=\"#2-2-Request的继承关系\" class=\"headerlink\" title=\"2.2 Request的继承关系\"></a>2.2 Request的继承关系</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class DrawableTypeRequest&lt;ModelType&gt; extends DrawableRequestBuilder&lt;ModelType&gt; implements DownloadOptions</div><div class=\"line\">public class DrawableRequestBuilder&lt;ModelType&gt;</div><div class=\"line\">       extends GenericRequestBuilder&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt;</div><div class=\"line\">       implements BitmapOptions, DrawableOptions </div><div class=\"line\">public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable</div></pre></td></tr></table></figure>\n<p>记住这个ModelType就是Glide.with(context).load(XXX) 里面传进去的Object的Class，例如File.class，那么<br>上面其实就是创建了一个DrawableTypeRequest，泛型是File ，构造函数一层层往上调用，DrawableRequestBuilder这一层调用了crossFade方法，即默认会有一个crossFade的效果，默认用的是DrawableCrossFadeFactory。注意这里把属于RequestManager的RequestTracker也传进来了。</p>\n<ul>\n<li>Glide.with(context).load(XX)到目前为止只是返回了一个DrawableTypeRequest<ModelType> 的实例。(还在主线程)</li>\n</ul>\n<h2 id=\"2-3-小节\"><a href=\"#2-3-小节\" class=\"headerlink\" title=\"2.3 小节\"></a>2.3 小节</h2><p>Glide.with返回一个RequestManger，每个Activity只会有一个RequestManager<br>load方法返回了一个DrawableTypeRequest<T>，这个T可能是File,String,Interger等。<br>到目前为止还只是构建一个Request。</p>\n<h2 id=\"3-DrawableRequestBuilder的into方法\"><a href=\"#3-DrawableRequestBuilder的into方法\" class=\"headerlink\" title=\"3. DrawableRequestBuilder的into方法\"></a>3. DrawableRequestBuilder的into方法</h2><p>Glide的最后一个调用方法是into()，也是最终分发请求的方法</p>\n<p>DrawableRequestBuilder<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Target&lt;GlideDrawable&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.into(view);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Target&lt;TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</div><div class=\"line\">       Util.assertMainThread();<span class=\"comment\">//还是在主线程对不对</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must pass in a non null View\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (!isTransformationSet &amp;&amp; view.getScaleType() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">switch</span> (view.getScaleType()) &#123;</div><div class=\"line\">               <span class=\"keyword\">case</span> CENTER_CROP:</div><div class=\"line\">                   applyCenterCrop();</div><div class=\"line\">                   <span class=\"keyword\">break</span>;</div><div class=\"line\">               <span class=\"keyword\">case</span> FIT_CENTER:</div><div class=\"line\">               <span class=\"keyword\">case</span> FIT_START:</div><div class=\"line\">               <span class=\"keyword\">case</span> FIT_END:</div><div class=\"line\">                   applyFitCenter();</div><div class=\"line\">                   <span class=\"keyword\">break</span>;</div><div class=\"line\">               <span class=\"comment\">//$CASES-OMITTED$</span></div><div class=\"line\">               <span class=\"keyword\">default</span>:</div><div class=\"line\">                   <span class=\"comment\">// Do nothing.</span></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</div><div class=\"line\">       <span class=\"comment\">//这个into接收一个Target的子类的实例，而Target又继承自LifeCycleListener</span></div><div class=\"line\">       <span class=\"comment\">//这个TranscodeClass是每一个Request创建的时候从构造函数传进来的。</span></div><div class=\"line\">      </div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//transcodeclass可能是GlideDrawable.class，也可能是Bitmap.class也可能是Drawable.class</span></div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">   <span class=\"keyword\">public</span> &lt;Z&gt; <span class=\"function\">Target&lt;Z&gt; <span class=\"title\">buildTarget</span><span class=\"params\">(ImageView view, Class&lt;Z&gt; clazz)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (GlideDrawable.class.isAssignableFrom(clazz)) &#123; <span class=\"comment\">//isAssignableFrom表示左边的class是否是右边class一个类或者父类，应该和instaceof倒过来。</span></div><div class=\"line\">           <span class=\"keyword\">return</span> (Target&lt;Z&gt;) <span class=\"keyword\">new</span> GlideDrawableImageViewTarget(view);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Bitmap.class.equals(clazz)) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> (Target&lt;Z&gt;) <span class=\"keyword\">new</span> BitmapImageViewTarget(view);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> (Target&lt;Z&gt;) <span class=\"keyword\">new</span> DrawableImageViewTarget(view);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unhandled class: \"</span> + clazz</div><div class=\"line\">                   + <span class=\"string\">\", try .as*(Class).transcode(ResourceTranscoder)\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>GlideDrawableImageViewTarget、BitmapImageViewTarget以及DrawableImageViewTarget全部继承自ImageViewTarget，后者继承自ViewTarget,再继承自BaseTarget，再 implements Target。一层层继承下来，GlideDrawableImageViewTarget等三个子类中都有一个Request，一个T extents View(看来不一定是ImageView)</p>\n<h3 id=\"3-1-以GlideDrawableImageViewTarget为例\"><a href=\"#3-1-以GlideDrawableImageViewTarget为例\" class=\"headerlink\" title=\"3.1 以GlideDrawableImageViewTarget为例\"></a>3.1 以GlideDrawableImageViewTarget为例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlideDrawableImageViewTarget</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImageViewTarget</span>&lt;<span class=\"title\">GlideDrawable</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> SQUARE_RATIO_MARGIN = <span class=\"number\">0.05f</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxLoopCount;</div><div class=\"line\">    <span class=\"keyword\">private</span> GlideDrawable resource; </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>GlideDrawable是一个继承自Drawable的抽象类，添加了isAnimated(),setLoopCount以及由于实现了isAnimated所需要的三个方法(start,stop,isRunning)。子类必须实现这五个抽象方法。</p>\n<p>GlideDrawableImageViewTarget往上走<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageViewTarget</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ViewTarget</span>&lt;<span class=\"title\">ImageView</span>, <span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">GlideAnimation</span>.<span class=\"title\">ViewAdapter</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着往上找父类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewTarget</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span>, <span class=\"title\">Z</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BaseTarget</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"ViewTarget\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isTagUsedAtLeastOnce = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Integer tagId = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> T view;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SizeDeterminer sizeDeterminer;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看下文档：A base Target for loading android.graphics.Bitmaps into Views that provides default implementations for most most methods and can determine the size of views using a android.view.ViewTreeObserver.OnDrawListener<br>To detect View} reuse in android.widget.ListView or any android.view.ViewGroup that reuses views, this class uses the View setTag(Object) method to store some metadata so that if a view is reused, any previous loads or resources from previous loads can be cancelled or reused.<br> Any calls to View setTag(Object)on a View given to this class will result in excessive allocations and<br> and/or IllegalArgumentExceptions. If you must call View#setTag(Object)on a view, consider  using BaseTarget or SimpleTarget instead.</p>\n<ul>\n<li>翻译一下，ViewTarget提供了将Bitmap 加载进View的大部分方法的基本实现，并且添加了onPreDrawListener以获得View的尺寸，对于Resuse View的场景，通过setTag来取消被滑出屏幕的View的request的加载。</li>\n</ul>\n<p>既然提供了大部分方法的默认实现，那么一定有方法没实现，其实就是<br>protected void setResource(Z resource)啦。<br>这个Z可能是Bitmap,GlideDrawable或者Drawable。直接拿来setImageBitmap或者setImageDrawable就可以了，这个方法其实在是解码完成之后了。</p>\n<p>关键是default implementation是怎么实现的以及这些方法在父类中的调用时机。<br>ViewTarget的构造函数传进来一个View的子类，同时创建一个SizeDeterminer（只是通过onPreDrawListener获得View的宽和高）。</p>\n<p>再往上找父类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseTarget</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Target</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123; <span class=\"comment\">//添加了一个Request成员变量，为Target中的一些方法提供了空实现，比如onLoadStarted，onLoadXXX等</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> Request request;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>到这里，还只是配置资源要加载进的对象，我倾向于把Target看成一个资源加载完毕的中转者，它管理了View（也可以没有View）和Request，在外部调用Target.onLoadStarted等方法是，调用View(如果有的话)的xxx方法。</p>\n<h3 id=\"3-2任务分发\"><a href=\"#3-2任务分发\" class=\"headerlink\" title=\"3.2任务分发\"></a>3.2任务分发</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(Y target)</span> </span>&#123;</div><div class=\"line\">    Util.assertMainThread(); <span class=\"comment\">//还在主线程上</span></div><div class=\"line\">    Request previous = target.getRequest();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//每一个Target都只有一个Request，用于清除之前的请求</span></div><div class=\"line\">        previous.clear();</div><div class=\"line\">        requestTracker.removeRequest(previous);</div><div class=\"line\">        previous.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Request request = buildRequest(target);</div><div class=\"line\">    target.setRequest(request);</div><div class=\"line\">    lifecycle.addListener(target);</div><div class=\"line\">    requestTracker.runRequest(request);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> target; <span class=\"comment\">//这里返回Target的好处在于可以接着链式调用，上面只是添加到任务队列，真正被处理还得等到下一帧(onPreDraw调用时)，所以这里还可以接着对这个Target进行配置</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意 requestTracker.runRequest(request)方法<br>GenericRequest.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      startTime = LogTime.getLogTime();</div><div class=\"line\">      <span class=\"keyword\">if</span> (model == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          onException(<span class=\"keyword\">null</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      status = Status.WAITING_FOR_SIZE;</div><div class=\"line\">      <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class=\"line\">          onSizeReady(overrideWidth, overrideHeight);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          target.getSize(<span class=\"keyword\">this</span>); <span class=\"comment\">//这个方法其实就等于挂了个钩子在onPreDraw中调用，onPreDraw时会调用onSizeReady。</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</div><div class=\"line\">          target.onLoadStarted(getPlaceholderDrawable());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">          logV(<span class=\"string\">\"finished run method in \"</span> + LogTime.getElapsedMillis(startTime));</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>onSizeReady才是真正开始干活的时机，理由也很充分。解码Bitmap必须要知道需要多大的尺寸，否则也是白搭。<br>GenericRequest.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * A callback method that should never be invoked directly.</div><div class=\"line\">  */</span> </div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeReady</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"keyword\">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">     status = Status.RUNNING;</div><div class=\"line\"></div><div class=\"line\">     width = Math.round(sizeMultiplier * width); <span class=\"comment\">//这个sizeMultiplier可以通过链式调用配置</span></div><div class=\"line\">     height = Math.round(sizeMultiplier * height);</div><div class=\"line\"></div><div class=\"line\">     ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</div><div class=\"line\">     <span class=\"keyword\">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</div><div class=\"line\">         </div><div class=\"line\">     ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</div><div class=\"line\">     loadedFromMemoryCache = <span class=\"keyword\">true</span>;</div><div class=\"line\">     loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</div><div class=\"line\">             priority, isMemoryCacheable, diskCacheStrategy, <span class=\"keyword\">this</span>);</div><div class=\"line\">     loadedFromMemoryCache = resource != <span class=\"keyword\">null</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">         logV(<span class=\"string\">\"finished onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-缓存查找\"><a href=\"#3-3-缓存查找\" class=\"headerlink\" title=\"3.3 缓存查找\"></a>3.3 缓存查找</h3><p>开始查找缓存是engine.load开始的，找到了就调用Callback的onResourceReady<br>Engine.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</div><div class=\"line\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</div><div class=\"line\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</div><div class=\"line\">    Util.assertMainThread(); <span class=\"comment\">//还是在主线程上</span></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();<span class=\"comment\">//如果是个网络图片，返回网络url，类似这种</span></div><div class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</div><div class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</div><div class=\"line\">            transcoder, loadProvider.getSourceEncoder());</div><div class=\"line\"></div><div class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</div><div class=\"line\">    <span class=\"comment\">//EngineResource内部wrap了真正的Resource，并使用一个int acquire表示当前正在占用资源的使用者数。当这个数为0的时候可以release。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        cb.onResourceReady(cached);</div><div class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</div><div class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        cb.onResourceReady(active);</div><div class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    EngineJob current = jobs.get(key);</div><div class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        current.addCallback(cb);</div><div class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</div><div class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</div><div class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</div><div class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</div><div class=\"line\">    jobs.put(key, engineJob);</div><div class=\"line\">    engineJob.addCallback(cb);</div><div class=\"line\">    engineJob.start(runnable);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Engine先去Cache里面查找，找到了直接调用ResourceCallback(GenericRequest)的onResourceReady(EngineResource&lt;?&gt; resource)，注意这个EngineResource里面包装了一个Resource，主要是为了引用计数。</p>\n<p> Engine的loadFromCache(key, isMemoryCacheable)是第一步，从成员变量cache中获取。找到了就挪到activeResources里面。<br> Engine.java<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Engine</span> <span class=\"keyword\">implements</span> <span class=\"title\">EngineJobListener</span>,</div><div class=\"line\">        <span class=\"title\">MemoryCache</span>.<span class=\"title\">ResourceRemovedListener</span>,</div><div class=\"line\">        <span class=\"title\">EngineResource</span>.<span class=\"title\">ResourceListener</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"Engine\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, EngineJob&gt; jobs;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineKeyFactory keyFactory;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryCache cache;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineJobFactory engineJobFactory;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ResourceRecycler resourceRecycler;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LazyDiskCacheProvider diskCacheProvider;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果在MemoryCache这个Lru里面没找到，就调用loadFromActiveResources，从activeResources里面找到。</p>\n<p><strong>所以这里已经出现两层缓存了，先去Lru(内存)找，再去activeResources(HashMap)里面找。缓存都是放在Enginel里面的，全局只有一份</strong></p>\n<p>缓存里面的Value都是EngineResource。</p>\n<p>这个MemoryCache是一个LruCache，大小是在MemorySizeCalculator中获得的，<br>对于一般的设备，activityManager.getMemoryClass() <em> 1024 </em> 1024获得每个App能够使用的Size,乘以0.4。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxSize = getMaxSize(activityManager);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()</div><div class=\"line\">               * BYTES_PER_ARGB_8888_PIXEL; <span class=\"comment\">//算出占满整个屏幕的一张图的大小</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">int</span> targetPoolSize = screenSize * BITMAP_POOL_TARGET_SCREENS; <span class=\"comment\">//乘以4就是bitmappool的大小</span></div><div class=\"line\">       <span class=\"keyword\">int</span> targetMemoryCacheSize = screenSize * MEMORY_CACHE_TARGET_SCREENS;</div><div class=\"line\">       <span class=\"comment\">//乘以2就是MemoryCache的大小</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (targetMemoryCacheSize + targetPoolSize &lt;= maxSize) &#123;</div><div class=\"line\">           memoryCacheSize = targetMemoryCacheSize;</div><div class=\"line\">           bitmapPoolSize = targetPoolSize;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//这里判断了BitmapPool和MemoryCache的大小之和不能超出应用可以使用的内存大小的0.4倍。</span></div><div class=\"line\">           <span class=\"keyword\">int</span> part = Math.round((<span class=\"keyword\">float</span>) maxSize / (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));</div><div class=\"line\">           memoryCacheSize = part * MEMORY_CACHE_TARGET_SCREENS;</div><div class=\"line\">           bitmapPoolSize = part * BITMAP_POOL_TARGET_SCREENS;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>所以缓存的大小综合考虑了屏幕分辨率和内存大小。只要屏幕像素不是特别高，一般都会走到第一步。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>ViewTarget里面有一个 T extends View，可见Glide不只适用于ImageView。</li>\n<li>BaseTarget里带了一个private Request，其子类可以通过getRequest获得。</li>\n<li>对于ListView等可以快速滑动的View，如果某一个View被滑出屏幕外，自动取消请求(通过setTagId实现)</li>\n<li>“You must not call setTag() on a view Glide is targeting” setTag可能会崩，原因</li>\n<li>GenericRequestBuilder的obtainRequest内部使用了一个ArrayDeque来obtain Request。这样Request实例不会多次创建，回收是在request.recycle里面做的。</li>\n</ul>\n<h3 id=\"4-离开主线程，提交任务到线程池\"><a href=\"#4-离开主线程，提交任务到线程池\" class=\"headerlink\" title=\"4. 离开主线程，提交任务到线程池\"></a>4. 离开主线程，提交任务到线程池</h3><p>如果上面两层缓存都没找到，去jobs里找看下有没有已经加入队列的EngineJob<br>记住上面有两层缓存</p>\n<p>来看后面提交任务这几段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"> EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</div><div class=\"line\">        DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</div><div class=\"line\">                transcoder, diskCacheProvider, diskCacheStrategy, priority);</div><div class=\"line\">        EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</div><div class=\"line\">        jobs.put(key, engineJob);</div><div class=\"line\">        engineJob.addCallback(cb);</div><div class=\"line\">        engineJob.start(runnable); <span class=\"comment\">//往diskCacheService提交了一个Runnable</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineJob</span> <span class=\"keyword\">implements</span> <span class=\"title\">EngineRunnable</span>.<span class=\"title\">EngineRunnableManager</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EngineResourceFactory DEFAULT_FACTORY = <span class=\"keyword\">new</span> EngineResourceFactory();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Handler MAIN_THREAD_HANDLER = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper(), <span class=\"keyword\">new</span> MainThreadCallback());</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MSG_COMPLETE = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MSG_EXCEPTION = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ResourceCallback&gt; cbs = <span class=\"keyword\">new</span> ArrayList&lt;ResourceCallback&gt;();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineResourceFactory engineResourceFactory;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EngineJobListener listener;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Key key;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService diskCacheService; <span class=\"comment\">//线程池</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService sourceService; <span class=\"comment\">//线程池</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isCacheable;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isCancelled;</div><div class=\"line\">    <span class=\"comment\">// Either resource or exception (particularly exception) may be returned to us null, so use booleans to track if</span></div><div class=\"line\">    <span class=\"comment\">// we've received them instead of relying on them to be non-null. See issue #180.</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Resource&lt;?&gt; resource;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasResource;</div><div class=\"line\">    <span class=\"keyword\">private</span> Exception exception;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasException;</div><div class=\"line\">    <span class=\"comment\">// A set of callbacks that are removed while we're notifying other callbacks of a change in status.</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Set&lt;ResourceCallback&gt; ignoredCallbacks;</div><div class=\"line\">    <span class=\"keyword\">private</span> EngineRunnable engineRunnable;</div><div class=\"line\">    <span class=\"keyword\">private</span> EngineResource&lt;?&gt; engineResource;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Future&lt;?&gt; future;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>EngineJob是通过Factory创建的，创建时会传两个线程池进来。一个管DiskCache,一个管Source获取。初始化是在Glide.createGlide里面做的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (sourceService == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cores = Math.max(<span class=\"number\">1</span>, Runtime.getRuntime().availableProcessors());</div><div class=\"line\">            sourceService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(cores);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (diskCacheService == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            diskCacheService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>在外部没有提供线程池的情况下，DiskCache一个线程池就好了，SourceService的大小为当前cpu可用核心数，还是比较高效的。<br>上面是往DiskCacheService提交了一个EngineRunable，这个Runnable的run里面主要是decodeFromCache和DecodeFroSource，分别代表从<strong>磁盘缓存</strong>获取和从数据源获取。<br>首先会调用decodeFromCache，一层层往下找，如果没找到的话会调用onLoadFailed方法，并将任务提交给SourceService，去获取资源。</p>\n<h3 id=\"4-1-CacheService这个线程池的工作以及第三层缓存的出现\"><a href=\"#4-1-CacheService这个线程池的工作以及第三层缓存的出现\" class=\"headerlink\" title=\"4.1 CacheService这个线程池的工作以及第三层缓存的出现\"></a>4.1 CacheService这个线程池的工作以及第三层缓存的出现</h3><p><strong>注意这里出现了第三层缓存</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">File cacheFile = diskCacheProvider.getDiskCache().get(key);</div></pre></td></tr></table></figure></p>\n<p>这一层缓存是给DiskCache的线程池查找用的，查找的时候分为从Result中查找和从Source中查找，其实查找的目的地都是那个DiskCache，Resul是用ResultKey去找的，Source是用ResultKey.getOriginalKey去查找的。物理位置都放在那个磁盘目录下。</p>\n<p>另外在DecodeJob的cacheAndDecodeSourceData方法里，存的只是origin(因为用的是origin Key)，然后再拿着originKey去磁盘找，找出来decode。</p>\n<p>DecodeFromCache又包括两步decodeResultFromCache和decodeSourceFromCache，这就让人想到Glide的DiskCacheStrategy分为Result和Source，即可以缓存decode结果也可以缓存decode之前的source。前提是在上面的diskCacheProvider.getDiskCache().get(key)方法里面找到了CachedFile。这个路径在InternalCacheDiskCacheFactory里面写了具体的路径</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InternalCacheDiskCacheFactory</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> String diskCacheName, <span class=\"keyword\">int</span> diskCacheSize)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>(<span class=\"keyword\">new</span> CacheDirectoryGetter() &#123;</div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCacheDirectory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               File cacheDirectory = context.getCacheDir();</div><div class=\"line\">               <span class=\"keyword\">if</span> (cacheDirectory == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">if</span> (diskCacheName != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(cacheDirectory, diskCacheName);</div><div class=\"line\">                   <span class=\"comment\">//就是context.getCacheDir+\"image_manager_disk_cache\"</span></div><div class=\"line\">                   <span class=\"comment\">//默认上限是250MB</span></div><div class=\"line\">                   <span class=\"comment\">//由于这个Cache放在CacheDir里面，其他应用拿不到</span></div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">return</span> cacheDirectory;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;, diskCacheSize);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>注意无论是decodeResultFromCache还是decodeSourceFromCache里都有类似的一段：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Resource&lt;T&gt; transformed = loadFromCache(resultKey);</div><div class=\"line\">Resource&lt;Z&gt; result = transcode(transformed); <span class=\"comment\">///把一种资源转成另一种资源，比如把Bitmap的Resource转成一个ByteResource</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-SourceService这个线程池以及BitmapPool这一层缓存的出现\"><a href=\"#4-2-SourceService这个线程池以及BitmapPool这一层缓存的出现\" class=\"headerlink\" title=\"4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现\"></a>4.2 SourceService这个线程池以及BitmapPool这一层缓存的出现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">decodeFromSourceData</span><span class=\"params\">(A data)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">final</span> Resource&lt;T&gt; decoded;</div><div class=\"line\">     <span class=\"keyword\">if</span> (diskCacheStrategy.cacheSource()) &#123;</div><div class=\"line\">         decoded = cacheAndDecodeSourceData(data);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</div><div class=\"line\">         decoded = loadProvider.getSourceDecoder().decode(data, width, height); <span class=\"comment\">// 这里面放进BitmapPool了</span></div><div class=\"line\">         <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class=\"line\">             logWithTimeAndKey(<span class=\"string\">\"Decoded from source\"</span>, startTime);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> decoded;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p><strong>第四层缓存出现。。。</strong><br>DecodeFromSource也是类似，判断是否允许Cache，通过DataFetcher获取数据这个数据可能是InputStream，也可能是ImageVideoWrapper。。。总之是一个可以提供数据的来源。如果可以Cache的话，先把数据写到lru里面，然后从lru里面取出来，从Source decode成想要的数据类型。<br>例如从Stream转成Bitmap是这么干的<br>StreamBitmapDecoder.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Bitmap&gt; <span class=\"title\">decode</span><span class=\"params\">(InputStream source, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">       Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);</div><div class=\"line\">       <span class=\"keyword\">return</span> BitmapResource.obtain(bitmap, bitmapPool);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>顺便还放进了LruBitmapPool（又一个实现了lru算法的缓存），Bitmap存在一个LruPoolStrategy接口实例的GroupedLinkedMap中。</p>\n<h3 id=\"4-3-回到主线程\"><a href=\"#4-3-回到主线程\" class=\"headerlink\" title=\"4.3 回到主线程\"></a>4.3 回到主线程</h3><p>EngineRunnable的run方法跑在子线程，在run的最后就是用一个handler推到主线程了。有可能是从CacheService这个线程池里面的线程推过去的，也可能是SourceSevice这个线程池里面推过去的。</p>\n<p>onResourceReady最终会走到GenericRequest的onResourceReady方法里<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123;</div><div class=\"line\"></div><div class=\"line\">      if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,</div><div class=\"line\">              isFirstResource)) &#123;</div><div class=\"line\">          GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</div><div class=\"line\">          target.onResourceReady(result, animation); //注意这句话就可以了</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>最终会调到ImageViewTarget,AppWidgetTarget等Target（持有Request和View,View可能没有），这时候，直接调用ImageView.setImagBitmap等方法就可以了。<br>图片设置完毕。</p>\n<h3 id=\"5-Glide除了普通的加载方法，还能用什么比较有意思的玩法\"><a href=\"#5-Glide除了普通的加载方法，还能用什么比较有意思的玩法\" class=\"headerlink\" title=\"5. Glide除了普通的加载方法，还能用什么比较有意思的玩法\"></a>5. Glide除了普通的加载方法，还能用什么比较有意思的玩法</h3><h2 id=\"来一些不拘一格的加载图片的方法\"><a href=\"#来一些不拘一格的加载图片的方法\" class=\"headerlink\" title=\"来一些不拘一格的加载图片的方法\"></a>来一些不拘一格的加载图片的方法</h2><h3 id=\"使用Application的Context-不跟生命周期走\"><a href=\"#使用Application的Context-不跟生命周期走\" class=\"headerlink\" title=\"使用Application的Context,不跟生命周期走\"></a>使用Application的Context,不跟生命周期走</h3><h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2>"},{"title":"网络通信手册","date":"2017-07-20T16:05:32.000Z","_content":"\n网络相关的查找手册\n![](http://odzl05jxx.bkt.clouddn.com/b9ae1189145b4a4d9dfe4d0b89a21b47.jpg?imageView2/2/w/600)\n<!--more-->\n\n\n## 1. URI和URL是两件事\n根据[wiki的解释](https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6)\nURL是URI的子集，URL的一般格式包括三部分：资源类型、存放资源的主机域名，资源文件名。语法格式上,根据[百度百科](https://baike.baidu.com/item/URL%E6%A0%BC%E5%BC%8F/10056474?fr=aladdin)找到一个能用的：\n```\nprotocol :// hostname[:port] / path / [;parameters][?query]#fragment\n```\n\n- protocol 指使用的传输协议(http、file、https、mailto、ed2k、thunder等)\nhostname 是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。有时候是ip,有时候前面还带账号密码\nport http默认是80，https是443 ,ssh默认端口号是20\npath(路径) 由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。\nparameters（参数）这是用于指定特殊参数的可选项。\nquery(查询) 一般GET请求可以在这里面查找。可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&”符号隔开，每个参数的名和值用“=”符号隔开。\nfragment（信息片断）字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。\n\n\n## 2. http请求本质上是发送了一堆字符给服务器\n另外,domain(域名)是指www.wikipedia.org这种，DNS会把它转成一个ip地址\n而在http请求的header中经常或看到\nHost: www.baidu.com\\r\\n 这样的一行，其实这是[Http头字段](https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5)的标准请求字段，总之就是标准。这个Host指的是服务器的域名，就是domian。\nwiki上的[http名词解释](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)\n\n## 3. Header相关的\n首先看下请求百度首页的request和response\n\nRequest（其实发送的时候每一行后面都跟了一个\\r\\n用于换行）\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nDNT: 1\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4\nCookie: BAIDUID=B41D39A8836273546754tC7F0C5DE315B64E2:FG=1; MCITY=-289%3A; \n```\n\nResponse(同样，无线电传输的时候是没有换行的概念的，每一行末尾都有一个\\r\\n)\n\n```\nHTTP/1.1 200 OK\nBdpagetype: 1\nBdqid: 0xa1524365407b7\nBduserid: 0\nCache-Control: private\nConnection: Keep-Alive\nContent-Encoding: gzip\nContent-Type: text/html; charset=utf-8\nCxy_all: baidu+9bdfb3567324332546a7cb482b3\nDate: Sun, 23 Jul 2017 08:27:22 GMT\nExpires: Sun, 23 Jul 2017 08:26:51 GMT\nServer: BWS/1.1\nSet-Cookie: BDSVRTM=0; path=/\nSet-Cookie: BD_HOME=0; path=/\nSet-Cookie: H_PS_PSSID=1430_210543_17001; path=/; domain=.baidu.com\nStrict-Transport-Security: max-age=172800\nVary: Accept-Encoding\nX-Powered-By: HPHP\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n```\n\n报文的[语法](http://www.cnblogs.com/klguang/p/4618526.html)：\n请求的格式\n\n```\n<method> <request-URL> <version>\n<headers>\n<entity-body>\n```\n\n\n响应的格式\n\n```\n<version> <status> <reason-phrase>\n<headers>\n<entity-body>\n```\n\nrequest中常见的请求头包括：\n\n- Accept：指定客户端能够接收的内容类型\n示例 : Accept:image/webp,image/apng,image/*,*/*;q=0.8\n\n- Accept-Charset ：浏览器可以接受的字符编码集\n\n- Accept-Encoding:gzip, deflate, br \n客户端浏览器可以支持的压缩编码类型。比如gzip，用于压缩数据，节省带宽。\n\n- Accept-Language 指定Http客户端浏览器用来优先展示的语言\n示例: Accept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4 \n\n- Cache-Control： [参考](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n具体操作[百度百科](https://baike.baidu.com/item/Cache-Control)写的很清楚\n可能的值包括：\n\npublic 所有内容都将被缓存(客户端和代理服务器都可缓存)\nprivate 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)\nno-cache 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。\nno-store 所有内容都不会被缓存到缓存或 Internet 临时文件中\nmax-age=xxx (xxx is numeric) 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高\n\n实际过程中我看到了这种：\nCache-Control:private, no-cache, no-cache=Set-Cookie, no-store, proxy-revalidate\n\n- Connection:keep-alive  http1.1 默认为keep-alive\nhttp 1.0需要手动设置。原理就是服务器保持客户端到服务器的连接持续有效，避免了重新建立连接的开销(tcp三次握手)。这种情况下，客户端不能根据读取到EOF(-1)来判断传输完毕。有两种解决方案：对于静态文件，客户端和服务器能够知道其大小，使用content-length，根据这个判断数据是否已经接收完成；对于动态页面，不可能预先知道内容大小。可以使用Transfer-Encoding:chunked的模式进行传输。基本上就是服务器把文件分成几块，一块一块的发送过去。[参考](https://www.byvoid.com/zhs/blog/http-keep-alive-header)\n\n- Content-Type  代表文件类型。request只有POST请求中会有，Response中也会有。\nPOST里面的Content-type有两种: \nContent-type: application/x-www-form-urlencoded;charset:UTF-8 //缺省值，表示提交表单\nmultipart/form-data //上传文件时用这种，既可以发送文本数据，也支持二进制上传。上面那个CharSet只是为了告诉服务器用的是哪种编码\n响应头中的Content-Type示例： Content-Type:image/gif或者Content-Type: text/html;charset=utf-8 [参考](http://www.runoob.com/http/http-content-type.html)\n\n- Date:Sun, 23 Jul 2017 07:39:47 GMT 这就是当前的GMT时间\n\n- DNT: 1 Do Not Track（当用户提出启用“请勿追踪”功能后，具有“请勿追踪”功能的浏览器会在http数据传输中添加一个“头信息”（headers），这个头信息向商业网站的服务器表明用户不希望被追踪。这样，遵守该规则的网站就不会追踪用户的个人信息来用于更精准的在线广告。）\n\n\n- Etag 用于比较客户端请求的文件的内容是否发生了改变。跟Last-Modified的作用差不多。最简单的用hash值就可以了。\n\n- Expires:Mon, 01 Jan 1990 00:00:00 GMT    过期时间，这里应该是永不过期\n\n- HOST 服务器的域名(domian)或者ip地址\nHost: www.baidu.com\n\n- If-Modified-Since:Fri, 24 Feb 2017 12:37:22 GMT 这个跟缓存有关\n\n- If-None-Match:\"abf29cbe9a8ed21:0\" 还是缓存\n\n- Pramga 和Cache-Control一样\n实例： Pramga: no-cache 相当于 Cache-Control： no-cache。\n\n- User-Agent 这个代表用的是哪种浏览器(客户端)，写爬虫的时候找到一大堆\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\nAndroid设备发出来的可能长这样： Mozilla/5.0 (Linux; U; Android 4.4.4; zh-cn; HTC_D820u Build/KTU84P) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\nios设备发出来的长这样: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12A365 Safari/600.1.4\n\n\n- Referer 一般是一个url，代表当前请求时从哪个页面发出的，写爬虫有用\n\nHeader其实就是个字典，比较麻烦的就是Cache-Control了，这个还要结合If-None-Match，Etag来看。需要用的时候再看应该也不迟。\n\n\n[WikI上比较完整](https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5)\n\n\n## 4. Cookie和Session\n\n### 4.1 Cookie\n先看[Wiki](https://zh.wikipedia.org/wiki/Cookie)上的解释:\n- 指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密.主要是因为Http是无状态的，服务器不知道这一次连接和上一次连接是不是同一个客户端\nCookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。\n\nCookie的一些缺点，直接照搬WiKi了\n- Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。\n- 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）\n- Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。\n\n另外，不同域名是无法共享浏览器端本地信息，包括cookies，这即是跨域问题。百度是不能读取爱奇艺的Cookie的，这是安全性问题。\n需要注意的是，虽然网站images.google.com与网站www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。必须域名一样才能操作。\nJava中把Cookie封装成了javax.servlet.http.Cookie类，直接用就可以了。\n\nCookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。\n\n\n\n对了，在众多的Header中Cookie一般长这样:\n\n- Cookie:key1=value1;key_2=value2;key_3=value3;JSessionID=24DHFKDSFKJ324329NSANDI124EH\n故意把最后一个JSESSION写出来是因为底下要讲Session了嘛\n\n\n\n### 4.2 Session\n[参考文章](http://lavasoft.blog.51cto.com/62575/275589)\nHeader(字典)里面装着一个Cookie(字典)，Cookie里面有个键值对:JSESSIONID:SESSIONID\n宏观上就是这么个关系。\n\nCookie保存在客户端，Session保存在服务器端。Session是在客户端第一次访问的时候由服务器创建的，session一般存储在redis中（ram），客户端始终只有sessionId。第二次请求的时候(session还未过期)，浏览器会加上sessionId=XXXXX。服务器接收到请求后就得到该请求的sessionID，服务器找到该id的session返还给请求者（Servlet）使用。一个会话只能有一个session对象，对session来说是只认id不认人。\n\nSession超时：超时指的是连续一定时间服务器没有收到该Session所对应客户端的请求，并且这个时间超过了服务器设置的Session超时的最大时间。\nSession的maxAge一般为-1，表示仅当前浏览器内有效，关闭浏览器就会失效。\n\n知乎上有一段比较好的[描述](https://www.zhihu.com/question/19786827/answer/66706108),这里直接引用了。\nhttp是无状态的协议，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢，session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，web服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到 sessionid=KWJHUG6JJM65HS2K6之类的字符串。\njavax.servlet.http.HttpServletRequest.getSession() 将会返回当前request相关联的HttpSession对象，如果不存在，将会创建一个。翻译一下，当一个浏览器请求来到之后，Servlet处理程序（Servlet容器内部实现）将会主动检查请求信息Cookie当中是否有JSESSIONID，若有，找到对应JSESSION的HttpSession对象，如果没有，创建一个，具体的机制在Servlet容器的实现当中。\n\nSession就是维护会话的。\n\n### 4.3 自动登录的实现\n一些网站的“记住密码，自动登录功能”，据说discuz直接将加密的（可逆）uid和密码保存到cookie中。\n另外一种做法是可以尝试将Session的过期时间设置的长一点，比如一年，下次访问网站的时候就能实现自动登录了。\n更好一点的是是本地绝不保存用户敏感信息，登录生成一个有过期时间的的cookie或者token返回给客户端，下次打开浏览器判断下过期时间就好了。另外，现在浏览器大多带有记住密码的功能，这个锅还是丢给浏览器(用户)好了。\n\n\n\n## 5. 长连接\n像即时通讯软件，或者消息推送这种场景，都得维护一个长连接。\n[HTTP长连接和短连接](http://blog.csdn.net/mr_liabill/article/details/50705130)\n\n\n### 5.1长连接的实现原理\n- 轮询\n- 心跳\n- Tcp长连接\n\n### 5.2 keep-Alive和WebSocket的区别\n\n\n![](http://odzl05jxx.bkt.clouddn.com/ed541bc1ed61ead0bf6ea8233ef01c0a.jpg?imageView2/2/w/600)\n\n\n### 5.3 http2可以实现推送了\n\n\n## 6. WebSocket、SPDY、Http2\nWebSocket一种在单个TCP 连接上进行全双工通讯的协议。\nHTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接），是HTTP协议的的第二个主要版本\nSPDY也就是HTTP/2的前身，一种开放的网络传输协议，由Google开发，用来发送网页内容。基于传输控制协议（TCP）的应用层协议\n\n\n\n\n网络协议，架构，规范，spdy,http2,url规范.\nOSI七层网络体系结构 ： 物理层、数据链路层、网络层、传输层、表示层、会话层、应用层 \n\n应用层面的Http，SMTP,FTP,POP,TLS/SSL,IMAP\n\ntcp三次握手，四次挥手\nudp使用\n\ntls,https加密过程，sha1和sha256加密算法\n\n[http请求的TCP瓶颈](https://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/)\n\nping ,traceRouter\n\n[Restfull架构详解](http://www.runoob.com/w3cnote/restful-architecture.html)\n","source":"_posts/2017-07-21-network-manual.md","raw":"---\ntitle: 网络通信手册\ndate: 2017-07-21 00:05:32\ntags: \n  - linux\n  - tools\n---\n\n网络相关的查找手册\n![](http://odzl05jxx.bkt.clouddn.com/b9ae1189145b4a4d9dfe4d0b89a21b47.jpg?imageView2/2/w/600)\n<!--more-->\n\n\n## 1. URI和URL是两件事\n根据[wiki的解释](https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6)\nURL是URI的子集，URL的一般格式包括三部分：资源类型、存放资源的主机域名，资源文件名。语法格式上,根据[百度百科](https://baike.baidu.com/item/URL%E6%A0%BC%E5%BC%8F/10056474?fr=aladdin)找到一个能用的：\n```\nprotocol :// hostname[:port] / path / [;parameters][?query]#fragment\n```\n\n- protocol 指使用的传输协议(http、file、https、mailto、ed2k、thunder等)\nhostname 是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。有时候是ip,有时候前面还带账号密码\nport http默认是80，https是443 ,ssh默认端口号是20\npath(路径) 由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。\nparameters（参数）这是用于指定特殊参数的可选项。\nquery(查询) 一般GET请求可以在这里面查找。可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&”符号隔开，每个参数的名和值用“=”符号隔开。\nfragment（信息片断）字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。\n\n\n## 2. http请求本质上是发送了一堆字符给服务器\n另外,domain(域名)是指www.wikipedia.org这种，DNS会把它转成一个ip地址\n而在http请求的header中经常或看到\nHost: www.baidu.com\\r\\n 这样的一行，其实这是[Http头字段](https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5)的标准请求字段，总之就是标准。这个Host指的是服务器的域名，就是domian。\nwiki上的[http名词解释](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)\n\n## 3. Header相关的\n首先看下请求百度首页的request和response\n\nRequest（其实发送的时候每一行后面都跟了一个\\r\\n用于换行）\n\n```\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nDNT: 1\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4\nCookie: BAIDUID=B41D39A8836273546754tC7F0C5DE315B64E2:FG=1; MCITY=-289%3A; \n```\n\nResponse(同样，无线电传输的时候是没有换行的概念的，每一行末尾都有一个\\r\\n)\n\n```\nHTTP/1.1 200 OK\nBdpagetype: 1\nBdqid: 0xa1524365407b7\nBduserid: 0\nCache-Control: private\nConnection: Keep-Alive\nContent-Encoding: gzip\nContent-Type: text/html; charset=utf-8\nCxy_all: baidu+9bdfb3567324332546a7cb482b3\nDate: Sun, 23 Jul 2017 08:27:22 GMT\nExpires: Sun, 23 Jul 2017 08:26:51 GMT\nServer: BWS/1.1\nSet-Cookie: BDSVRTM=0; path=/\nSet-Cookie: BD_HOME=0; path=/\nSet-Cookie: H_PS_PSSID=1430_210543_17001; path=/; domain=.baidu.com\nStrict-Transport-Security: max-age=172800\nVary: Accept-Encoding\nX-Powered-By: HPHP\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n```\n\n报文的[语法](http://www.cnblogs.com/klguang/p/4618526.html)：\n请求的格式\n\n```\n<method> <request-URL> <version>\n<headers>\n<entity-body>\n```\n\n\n响应的格式\n\n```\n<version> <status> <reason-phrase>\n<headers>\n<entity-body>\n```\n\nrequest中常见的请求头包括：\n\n- Accept：指定客户端能够接收的内容类型\n示例 : Accept:image/webp,image/apng,image/*,*/*;q=0.8\n\n- Accept-Charset ：浏览器可以接受的字符编码集\n\n- Accept-Encoding:gzip, deflate, br \n客户端浏览器可以支持的压缩编码类型。比如gzip，用于压缩数据，节省带宽。\n\n- Accept-Language 指定Http客户端浏览器用来优先展示的语言\n示例: Accept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4 \n\n- Cache-Control： [参考](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n具体操作[百度百科](https://baike.baidu.com/item/Cache-Control)写的很清楚\n可能的值包括：\n\npublic 所有内容都将被缓存(客户端和代理服务器都可缓存)\nprivate 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)\nno-cache 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。\nno-store 所有内容都不会被缓存到缓存或 Internet 临时文件中\nmax-age=xxx (xxx is numeric) 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高\n\n实际过程中我看到了这种：\nCache-Control:private, no-cache, no-cache=Set-Cookie, no-store, proxy-revalidate\n\n- Connection:keep-alive  http1.1 默认为keep-alive\nhttp 1.0需要手动设置。原理就是服务器保持客户端到服务器的连接持续有效，避免了重新建立连接的开销(tcp三次握手)。这种情况下，客户端不能根据读取到EOF(-1)来判断传输完毕。有两种解决方案：对于静态文件，客户端和服务器能够知道其大小，使用content-length，根据这个判断数据是否已经接收完成；对于动态页面，不可能预先知道内容大小。可以使用Transfer-Encoding:chunked的模式进行传输。基本上就是服务器把文件分成几块，一块一块的发送过去。[参考](https://www.byvoid.com/zhs/blog/http-keep-alive-header)\n\n- Content-Type  代表文件类型。request只有POST请求中会有，Response中也会有。\nPOST里面的Content-type有两种: \nContent-type: application/x-www-form-urlencoded;charset:UTF-8 //缺省值，表示提交表单\nmultipart/form-data //上传文件时用这种，既可以发送文本数据，也支持二进制上传。上面那个CharSet只是为了告诉服务器用的是哪种编码\n响应头中的Content-Type示例： Content-Type:image/gif或者Content-Type: text/html;charset=utf-8 [参考](http://www.runoob.com/http/http-content-type.html)\n\n- Date:Sun, 23 Jul 2017 07:39:47 GMT 这就是当前的GMT时间\n\n- DNT: 1 Do Not Track（当用户提出启用“请勿追踪”功能后，具有“请勿追踪”功能的浏览器会在http数据传输中添加一个“头信息”（headers），这个头信息向商业网站的服务器表明用户不希望被追踪。这样，遵守该规则的网站就不会追踪用户的个人信息来用于更精准的在线广告。）\n\n\n- Etag 用于比较客户端请求的文件的内容是否发生了改变。跟Last-Modified的作用差不多。最简单的用hash值就可以了。\n\n- Expires:Mon, 01 Jan 1990 00:00:00 GMT    过期时间，这里应该是永不过期\n\n- HOST 服务器的域名(domian)或者ip地址\nHost: www.baidu.com\n\n- If-Modified-Since:Fri, 24 Feb 2017 12:37:22 GMT 这个跟缓存有关\n\n- If-None-Match:\"abf29cbe9a8ed21:0\" 还是缓存\n\n- Pramga 和Cache-Control一样\n实例： Pramga: no-cache 相当于 Cache-Control： no-cache。\n\n- User-Agent 这个代表用的是哪种浏览器(客户端)，写爬虫的时候找到一大堆\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\nAndroid设备发出来的可能长这样： Mozilla/5.0 (Linux; U; Android 4.4.4; zh-cn; HTC_D820u Build/KTU84P) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\nios设备发出来的长这样: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12A365 Safari/600.1.4\n\n\n- Referer 一般是一个url，代表当前请求时从哪个页面发出的，写爬虫有用\n\nHeader其实就是个字典，比较麻烦的就是Cache-Control了，这个还要结合If-None-Match，Etag来看。需要用的时候再看应该也不迟。\n\n\n[WikI上比较完整](https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5)\n\n\n## 4. Cookie和Session\n\n### 4.1 Cookie\n先看[Wiki](https://zh.wikipedia.org/wiki/Cookie)上的解释:\n- 指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密.主要是因为Http是无状态的，服务器不知道这一次连接和上一次连接是不是同一个客户端\nCookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。\n\nCookie的一些缺点，直接照搬WiKi了\n- Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。\n- 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）\n- Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。\n\n另外，不同域名是无法共享浏览器端本地信息，包括cookies，这即是跨域问题。百度是不能读取爱奇艺的Cookie的，这是安全性问题。\n需要注意的是，虽然网站images.google.com与网站www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。必须域名一样才能操作。\nJava中把Cookie封装成了javax.servlet.http.Cookie类，直接用就可以了。\n\nCookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。\n\n\n\n对了，在众多的Header中Cookie一般长这样:\n\n- Cookie:key1=value1;key_2=value2;key_3=value3;JSessionID=24DHFKDSFKJ324329NSANDI124EH\n故意把最后一个JSESSION写出来是因为底下要讲Session了嘛\n\n\n\n### 4.2 Session\n[参考文章](http://lavasoft.blog.51cto.com/62575/275589)\nHeader(字典)里面装着一个Cookie(字典)，Cookie里面有个键值对:JSESSIONID:SESSIONID\n宏观上就是这么个关系。\n\nCookie保存在客户端，Session保存在服务器端。Session是在客户端第一次访问的时候由服务器创建的，session一般存储在redis中（ram），客户端始终只有sessionId。第二次请求的时候(session还未过期)，浏览器会加上sessionId=XXXXX。服务器接收到请求后就得到该请求的sessionID，服务器找到该id的session返还给请求者（Servlet）使用。一个会话只能有一个session对象，对session来说是只认id不认人。\n\nSession超时：超时指的是连续一定时间服务器没有收到该Session所对应客户端的请求，并且这个时间超过了服务器设置的Session超时的最大时间。\nSession的maxAge一般为-1，表示仅当前浏览器内有效，关闭浏览器就会失效。\n\n知乎上有一段比较好的[描述](https://www.zhihu.com/question/19786827/answer/66706108),这里直接引用了。\nhttp是无状态的协议，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢，session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，web服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到 sessionid=KWJHUG6JJM65HS2K6之类的字符串。\njavax.servlet.http.HttpServletRequest.getSession() 将会返回当前request相关联的HttpSession对象，如果不存在，将会创建一个。翻译一下，当一个浏览器请求来到之后，Servlet处理程序（Servlet容器内部实现）将会主动检查请求信息Cookie当中是否有JSESSIONID，若有，找到对应JSESSION的HttpSession对象，如果没有，创建一个，具体的机制在Servlet容器的实现当中。\n\nSession就是维护会话的。\n\n### 4.3 自动登录的实现\n一些网站的“记住密码，自动登录功能”，据说discuz直接将加密的（可逆）uid和密码保存到cookie中。\n另外一种做法是可以尝试将Session的过期时间设置的长一点，比如一年，下次访问网站的时候就能实现自动登录了。\n更好一点的是是本地绝不保存用户敏感信息，登录生成一个有过期时间的的cookie或者token返回给客户端，下次打开浏览器判断下过期时间就好了。另外，现在浏览器大多带有记住密码的功能，这个锅还是丢给浏览器(用户)好了。\n\n\n\n## 5. 长连接\n像即时通讯软件，或者消息推送这种场景，都得维护一个长连接。\n[HTTP长连接和短连接](http://blog.csdn.net/mr_liabill/article/details/50705130)\n\n\n### 5.1长连接的实现原理\n- 轮询\n- 心跳\n- Tcp长连接\n\n### 5.2 keep-Alive和WebSocket的区别\n\n\n![](http://odzl05jxx.bkt.clouddn.com/ed541bc1ed61ead0bf6ea8233ef01c0a.jpg?imageView2/2/w/600)\n\n\n### 5.3 http2可以实现推送了\n\n\n## 6. WebSocket、SPDY、Http2\nWebSocket一种在单个TCP 连接上进行全双工通讯的协议。\nHTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接），是HTTP协议的的第二个主要版本\nSPDY也就是HTTP/2的前身，一种开放的网络传输协议，由Google开发，用来发送网页内容。基于传输控制协议（TCP）的应用层协议\n\n\n\n\n网络协议，架构，规范，spdy,http2,url规范.\nOSI七层网络体系结构 ： 物理层、数据链路层、网络层、传输层、表示层、会话层、应用层 \n\n应用层面的Http，SMTP,FTP,POP,TLS/SSL,IMAP\n\ntcp三次握手，四次挥手\nudp使用\n\ntls,https加密过程，sha1和sha256加密算法\n\n[http请求的TCP瓶颈](https://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/)\n\nping ,traceRouter\n\n[Restfull架构详解](http://www.runoob.com/w3cnote/restful-architecture.html)\n","slug":"2017-07-21-network-manual","published":1,"updated":"2017-07-23T11:12:39.421Z","_id":"cj5gmdnk9002qbovrxt27q4ov","comments":1,"layout":"post","photos":[],"link":"","content":"<p>网络相关的查找手册<br><img src=\"http://odzl05jxx.bkt.clouddn.com/b9ae1189145b4a4d9dfe4d0b89a21b47.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"1-URI和URL是两件事\"><a href=\"#1-URI和URL是两件事\" class=\"headerlink\" title=\"1. URI和URL是两件事\"></a>1. URI和URL是两件事</h2><p>根据<a href=\"https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6\">wiki的解释</a><br>URL是URI的子集，URL的一般格式包括三部分：资源类型、存放资源的主机域名，资源文件名。语法格式上,根据<a href=\"https://baike.baidu.com/item/URL%E6%A0%BC%E5%BC%8F/10056474?fr=aladdin\">百度百科</a>找到一个能用的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protocol :// hostname[:port] / path / [;parameters][?query]#fragment</div></pre></td></tr></table></figure></p>\n<ul>\n<li>protocol 指使用的传输协议(http、file、https、mailto、ed2k、thunder等)<br>hostname 是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。有时候是ip,有时候前面还带账号密码<br>port http默认是80，https是443 ,ssh默认端口号是20<br>path(路径) 由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。<br>parameters（参数）这是用于指定特殊参数的可选项。<br>query(查询) 一般GET请求可以在这里面查找。可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。<br>fragment（信息片断）字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。</li>\n</ul>\n<h2 id=\"2-http请求本质上是发送了一堆字符给服务器\"><a href=\"#2-http请求本质上是发送了一堆字符给服务器\" class=\"headerlink\" title=\"2. http请求本质上是发送了一堆字符给服务器\"></a>2. http请求本质上是发送了一堆字符给服务器</h2><p>另外,domain(域名)是指www.wikipedia.org这种，DNS会把它转成一个ip地址<br>而在http请求的header中经常或看到<br>Host: www.baidu.com\\r\\n 这样的一行，其实这是<a href=\"https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5\">Http头字段</a>的标准请求字段，总之就是标准。这个Host指的是服务器的域名，就是domian。<br>wiki上的<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\">http名词解释</a></p>\n<h2 id=\"3-Header相关的\"><a href=\"#3-Header相关的\" class=\"headerlink\" title=\"3. Header相关的\"></a>3. Header相关的</h2><p>首先看下请求百度首页的request和response</p>\n<p>Request（其实发送的时候每一行后面都跟了一个\\r\\n用于换行）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Host: www.baidu.com</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Cache-Control: max-age=0</div><div class=\"line\">Upgrade-Insecure-Requests: 1</div><div class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class=\"line\">DNT: 1</div><div class=\"line\">Accept-Encoding: gzip, deflate, br</div><div class=\"line\">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</div><div class=\"line\">Cookie: BAIDUID=B41D39A8836273546754tC7F0C5DE315B64E2:FG=1; MCITY=-289%3A;</div></pre></td></tr></table></figure>\n<p>Response(同样，无线电传输的时候是没有换行的概念的，每一行末尾都有一个\\r\\n)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Bdpagetype: 1</div><div class=\"line\">Bdqid: 0xa1524365407b7</div><div class=\"line\">Bduserid: 0</div><div class=\"line\">Cache-Control: private</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Type: text/html; charset=utf-8</div><div class=\"line\">Cxy_all: baidu+9bdfb3567324332546a7cb482b3</div><div class=\"line\">Date: Sun, 23 Jul 2017 08:27:22 GMT</div><div class=\"line\">Expires: Sun, 23 Jul 2017 08:26:51 GMT</div><div class=\"line\">Server: BWS/1.1</div><div class=\"line\">Set-Cookie: BDSVRTM=0; path=/</div><div class=\"line\">Set-Cookie: BD_HOME=0; path=/</div><div class=\"line\">Set-Cookie: H_PS_PSSID=1430_210543_17001; path=/; domain=.baidu.com</div><div class=\"line\">Strict-Transport-Security: max-age=172800</div><div class=\"line\">Vary: Accept-Encoding</div><div class=\"line\">X-Powered-By: HPHP</div><div class=\"line\">X-Ua-Compatible: IE=Edge,chrome=1</div><div class=\"line\">Transfer-Encoding: chunked</div></pre></td></tr></table></figure>\n<p>报文的<a href=\"http://www.cnblogs.com/klguang/p/4618526.html\">语法</a>：<br>请求的格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</div><div class=\"line\">&lt;headers&gt;</div><div class=\"line\">&lt;entity-body&gt;</div></pre></td></tr></table></figure>\n<p>响应的格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;</div><div class=\"line\">&lt;headers&gt;</div><div class=\"line\">&lt;entity-body&gt;</div></pre></td></tr></table></figure>\n<p>request中常见的请求头包括：</p>\n<ul>\n<li><p>Accept：指定客户端能够接收的内容类型<br>示例 : Accept:image/webp,image/apng,image/<em>,</em>/*;q=0.8</p>\n</li>\n<li><p>Accept-Charset ：浏览器可以接受的字符编码集</p>\n</li>\n<li><p>Accept-Encoding:gzip, deflate, br<br>客户端浏览器可以支持的压缩编码类型。比如gzip，用于压缩数据，节省带宽。</p>\n</li>\n<li><p>Accept-Language 指定Http客户端浏览器用来优先展示的语言<br>示例: Accept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4 </p>\n</li>\n<li><p>Cache-Control： <a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">参考</a><br>具体操作<a href=\"https://baike.baidu.com/item/Cache-Control\">百度百科</a>写的很清楚<br>可能的值包括：</p>\n</li>\n</ul>\n<p>public 所有内容都将被缓存(客户端和代理服务器都可缓存)<br>private 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)<br>no-cache 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。<br>no-store 所有内容都不会被缓存到缓存或 Internet 临时文件中<br>max-age=xxx (xxx is numeric) 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高</p>\n<p>实际过程中我看到了这种：<br>Cache-Control:private, no-cache, no-cache=Set-Cookie, no-store, proxy-revalidate</p>\n<ul>\n<li><p>Connection:keep-alive  http1.1 默认为keep-alive<br>http 1.0需要手动设置。原理就是服务器保持客户端到服务器的连接持续有效，避免了重新建立连接的开销(tcp三次握手)。这种情况下，客户端不能根据读取到EOF(-1)来判断传输完毕。有两种解决方案：对于静态文件，客户端和服务器能够知道其大小，使用content-length，根据这个判断数据是否已经接收完成；对于动态页面，不可能预先知道内容大小。可以使用Transfer-Encoding:chunked的模式进行传输。基本上就是服务器把文件分成几块，一块一块的发送过去。<a href=\"https://www.byvoid.com/zhs/blog/http-keep-alive-header\">参考</a></p>\n</li>\n<li><p>Content-Type  代表文件类型。request只有POST请求中会有，Response中也会有。<br>POST里面的Content-type有两种:<br>Content-type: application/x-www-form-urlencoded;charset:UTF-8 //缺省值，表示提交表单<br>multipart/form-data //上传文件时用这种，既可以发送文本数据，也支持二进制上传。上面那个CharSet只是为了告诉服务器用的是哪种编码<br>响应头中的Content-Type示例： Content-Type:image/gif或者Content-Type: text/html;charset=utf-8 <a href=\"http://www.runoob.com/http/http-content-type.html\">参考</a></p>\n</li>\n<li><p>Date:Sun, 23 Jul 2017 07:39:47 GMT 这就是当前的GMT时间</p>\n</li>\n<li><p>DNT: 1 Do Not Track（当用户提出启用“请勿追踪”功能后，具有“请勿追踪”功能的浏览器会在http数据传输中添加一个“头信息”（headers），这个头信息向商业网站的服务器表明用户不希望被追踪。这样，遵守该规则的网站就不会追踪用户的个人信息来用于更精准的在线广告。）</p>\n</li>\n</ul>\n<ul>\n<li><p>Etag 用于比较客户端请求的文件的内容是否发生了改变。跟Last-Modified的作用差不多。最简单的用hash值就可以了。</p>\n</li>\n<li><p>Expires:Mon, 01 Jan 1990 00:00:00 GMT    过期时间，这里应该是永不过期</p>\n</li>\n<li><p>HOST 服务器的域名(domian)或者ip地址<br>Host: www.baidu.com</p>\n</li>\n<li><p>If-Modified-Since:Fri, 24 Feb 2017 12:37:22 GMT 这个跟缓存有关</p>\n</li>\n<li><p>If-None-Match:”abf29cbe9a8ed21:0” 还是缓存</p>\n</li>\n<li><p>Pramga 和Cache-Control一样<br>实例： Pramga: no-cache 相当于 Cache-Control： no-cache。</p>\n</li>\n<li><p>User-Agent 这个代表用的是哪种浏览器(客户端)，写爬虫的时候找到一大堆<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36<br>Android设备发出来的可能长这样： Mozilla/5.0 (Linux; U; Android 4.4.4; zh-cn; HTC_D820u Build/KTU84P) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30<br>ios设备发出来的长这样: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12A365 Safari/600.1.4</p>\n</li>\n</ul>\n<ul>\n<li>Referer 一般是一个url，代表当前请求时从哪个页面发出的，写爬虫有用</li>\n</ul>\n<p>Header其实就是个字典，比较麻烦的就是Cache-Control了，这个还要结合If-None-Match，Etag来看。需要用的时候再看应该也不迟。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5\">WikI上比较完整</a></p>\n<h2 id=\"4-Cookie和Session\"><a href=\"#4-Cookie和Session\" class=\"headerlink\" title=\"4. Cookie和Session\"></a>4. Cookie和Session</h2><h3 id=\"4-1-Cookie\"><a href=\"#4-1-Cookie\" class=\"headerlink\" title=\"4.1 Cookie\"></a>4.1 Cookie</h3><p>先看<a href=\"https://zh.wikipedia.org/wiki/Cookie\">Wiki</a>上的解释:</p>\n<ul>\n<li>指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密.主要是因为Http是无状态的，服务器不知道这一次连接和上一次连接是不是同一个客户端<br>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。</li>\n</ul>\n<p>Cookie的一些缺点，直接照搬WiKi了</p>\n<ul>\n<li>Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>\n<li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）</li>\n<li>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</li>\n</ul>\n<p>另外，不同域名是无法共享浏览器端本地信息，包括cookies，这即是跨域问题。百度是不能读取爱奇艺的Cookie的，这是安全性问题。<br>需要注意的是，虽然网站images.google.com与网站www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。必须域名一样才能操作。<br>Java中把Cookie封装成了javax.servlet.http.Cookie类，直接用就可以了。</p>\n<p>Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。</p>\n<p>对了，在众多的Header中Cookie一般长这样:</p>\n<ul>\n<li>Cookie:key1=value1;key_2=value2;key_3=value3;JSessionID=24DHFKDSFKJ324329NSANDI124EH<br>故意把最后一个JSESSION写出来是因为底下要讲Session了嘛</li>\n</ul>\n<h3 id=\"4-2-Session\"><a href=\"#4-2-Session\" class=\"headerlink\" title=\"4.2 Session\"></a>4.2 Session</h3><p><a href=\"http://lavasoft.blog.51cto.com/62575/275589\">参考文章</a><br>Header(字典)里面装着一个Cookie(字典)，Cookie里面有个键值对:JSESSIONID:SESSIONID<br>宏观上就是这么个关系。</p>\n<p>Cookie保存在客户端，Session保存在服务器端。Session是在客户端第一次访问的时候由服务器创建的，session一般存储在redis中（ram），客户端始终只有sessionId。第二次请求的时候(session还未过期)，浏览器会加上sessionId=XXXXX。服务器接收到请求后就得到该请求的sessionID，服务器找到该id的session返还给请求者（Servlet）使用。一个会话只能有一个session对象，对session来说是只认id不认人。</p>\n<p>Session超时：超时指的是连续一定时间服务器没有收到该Session所对应客户端的请求，并且这个时间超过了服务器设置的Session超时的最大时间。<br>Session的maxAge一般为-1，表示仅当前浏览器内有效，关闭浏览器就会失效。</p>\n<p>知乎上有一段比较好的<a href=\"https://www.zhihu.com/question/19786827/answer/66706108\">描述</a>,这里直接引用了。<br>http是无状态的协议，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢，session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，web服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到 sessionid=KWJHUG6JJM65HS2K6之类的字符串。<br>javax.servlet.http.HttpServletRequest.getSession() 将会返回当前request相关联的HttpSession对象，如果不存在，将会创建一个。翻译一下，当一个浏览器请求来到之后，Servlet处理程序（Servlet容器内部实现）将会主动检查请求信息Cookie当中是否有JSESSIONID，若有，找到对应JSESSION的HttpSession对象，如果没有，创建一个，具体的机制在Servlet容器的实现当中。</p>\n<p>Session就是维护会话的。</p>\n<h3 id=\"4-3-自动登录的实现\"><a href=\"#4-3-自动登录的实现\" class=\"headerlink\" title=\"4.3 自动登录的实现\"></a>4.3 自动登录的实现</h3><p>一些网站的“记住密码，自动登录功能”，据说discuz直接将加密的（可逆）uid和密码保存到cookie中。<br>另外一种做法是可以尝试将Session的过期时间设置的长一点，比如一年，下次访问网站的时候就能实现自动登录了。<br>更好一点的是是本地绝不保存用户敏感信息，登录生成一个有过期时间的的cookie或者token返回给客户端，下次打开浏览器判断下过期时间就好了。另外，现在浏览器大多带有记住密码的功能，这个锅还是丢给浏览器(用户)好了。</p>\n<h2 id=\"5-长连接\"><a href=\"#5-长连接\" class=\"headerlink\" title=\"5. 长连接\"></a>5. 长连接</h2><p>像即时通讯软件，或者消息推送这种场景，都得维护一个长连接。<br><a href=\"http://blog.csdn.net/mr_liabill/article/details/50705130\">HTTP长连接和短连接</a></p>\n<h3 id=\"5-1长连接的实现原理\"><a href=\"#5-1长连接的实现原理\" class=\"headerlink\" title=\"5.1长连接的实现原理\"></a>5.1长连接的实现原理</h3><ul>\n<li>轮询</li>\n<li>心跳</li>\n<li>Tcp长连接</li>\n</ul>\n<h3 id=\"5-2-keep-Alive和WebSocket的区别\"><a href=\"#5-2-keep-Alive和WebSocket的区别\" class=\"headerlink\" title=\"5.2 keep-Alive和WebSocket的区别\"></a>5.2 keep-Alive和WebSocket的区别</h3><p><img src=\"http://odzl05jxx.bkt.clouddn.com/ed541bc1ed61ead0bf6ea8233ef01c0a.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<h3 id=\"5-3-http2可以实现推送了\"><a href=\"#5-3-http2可以实现推送了\" class=\"headerlink\" title=\"5.3 http2可以实现推送了\"></a>5.3 http2可以实现推送了</h3><h2 id=\"6-WebSocket、SPDY、Http2\"><a href=\"#6-WebSocket、SPDY、Http2\" class=\"headerlink\" title=\"6. WebSocket、SPDY、Http2\"></a>6. WebSocket、SPDY、Http2</h2><p>WebSocket一种在单个TCP 连接上进行全双工通讯的协议。<br>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接），是HTTP协议的的第二个主要版本<br>SPDY也就是HTTP/2的前身，一种开放的网络传输协议，由Google开发，用来发送网页内容。基于传输控制协议（TCP）的应用层协议</p>\n<p>网络协议，架构，规范，spdy,http2,url规范.<br>OSI七层网络体系结构 ： 物理层、数据链路层、网络层、传输层、表示层、会话层、应用层 </p>\n<p>应用层面的Http，SMTP,FTP,POP,TLS/SSL,IMAP</p>\n<p>tcp三次握手，四次挥手<br>udp使用</p>\n<p>tls,https加密过程，sha1和sha256加密算法</p>\n<p><a href=\"https://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/\">http请求的TCP瓶颈</a></p>\n<p>ping ,traceRouter</p>\n<p><a href=\"http://www.runoob.com/w3cnote/restful-architecture.html\">Restfull架构详解</a></p>\n","excerpt":"<p>网络相关的查找手册<br><img src=\"http://odzl05jxx.bkt.clouddn.com/b9ae1189145b4a4d9dfe4d0b89a21b47.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<h2 id=\"1-URI和URL是两件事\"><a href=\"#1-URI和URL是两件事\" class=\"headerlink\" title=\"1. URI和URL是两件事\"></a>1. URI和URL是两件事</h2><p>根据<a href=\"https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6\">wiki的解释</a><br>URL是URI的子集，URL的一般格式包括三部分：资源类型、存放资源的主机域名，资源文件名。语法格式上,根据<a href=\"https://baike.baidu.com/item/URL%E6%A0%BC%E5%BC%8F/10056474?fr=aladdin\">百度百科</a>找到一个能用的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protocol :// hostname[:port] / path / [;parameters][?query]#fragment</div></pre></td></tr></table></figure></p>\n<ul>\n<li>protocol 指使用的传输协议(http、file、https、mailto、ed2k、thunder等)<br>hostname 是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。有时候是ip,有时候前面还带账号密码<br>port http默认是80，https是443 ,ssh默认端口号是20<br>path(路径) 由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。<br>parameters（参数）这是用于指定特殊参数的可选项。<br>query(查询) 一般GET请求可以在这里面查找。可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。<br>fragment（信息片断）字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。</li>\n</ul>\n<h2 id=\"2-http请求本质上是发送了一堆字符给服务器\"><a href=\"#2-http请求本质上是发送了一堆字符给服务器\" class=\"headerlink\" title=\"2. http请求本质上是发送了一堆字符给服务器\"></a>2. http请求本质上是发送了一堆字符给服务器</h2><p>另外,domain(域名)是指www.wikipedia.org这种，DNS会把它转成一个ip地址<br>而在http请求的header中经常或看到<br>Host: www.baidu.com\\r\\n 这样的一行，其实这是<a href=\"https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5\">Http头字段</a>的标准请求字段，总之就是标准。这个Host指的是服务器的域名，就是domian。<br>wiki上的<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\">http名词解释</a></p>\n<h2 id=\"3-Header相关的\"><a href=\"#3-Header相关的\" class=\"headerlink\" title=\"3. Header相关的\"></a>3. Header相关的</h2><p>首先看下请求百度首页的request和response</p>\n<p>Request（其实发送的时候每一行后面都跟了一个\\r\\n用于换行）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Host: www.baidu.com</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Cache-Control: max-age=0</div><div class=\"line\">Upgrade-Insecure-Requests: 1</div><div class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class=\"line\">DNT: 1</div><div class=\"line\">Accept-Encoding: gzip, deflate, br</div><div class=\"line\">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</div><div class=\"line\">Cookie: BAIDUID=B41D39A8836273546754tC7F0C5DE315B64E2:FG=1; MCITY=-289%3A;</div></pre></td></tr></table></figure>\n<p>Response(同样，无线电传输的时候是没有换行的概念的，每一行末尾都有一个\\r\\n)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Bdpagetype: 1</div><div class=\"line\">Bdqid: 0xa1524365407b7</div><div class=\"line\">Bduserid: 0</div><div class=\"line\">Cache-Control: private</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Type: text/html; charset=utf-8</div><div class=\"line\">Cxy_all: baidu+9bdfb3567324332546a7cb482b3</div><div class=\"line\">Date: Sun, 23 Jul 2017 08:27:22 GMT</div><div class=\"line\">Expires: Sun, 23 Jul 2017 08:26:51 GMT</div><div class=\"line\">Server: BWS/1.1</div><div class=\"line\">Set-Cookie: BDSVRTM=0; path=/</div><div class=\"line\">Set-Cookie: BD_HOME=0; path=/</div><div class=\"line\">Set-Cookie: H_PS_PSSID=1430_210543_17001; path=/; domain=.baidu.com</div><div class=\"line\">Strict-Transport-Security: max-age=172800</div><div class=\"line\">Vary: Accept-Encoding</div><div class=\"line\">X-Powered-By: HPHP</div><div class=\"line\">X-Ua-Compatible: IE=Edge,chrome=1</div><div class=\"line\">Transfer-Encoding: chunked</div></pre></td></tr></table></figure>\n<p>报文的<a href=\"http://www.cnblogs.com/klguang/p/4618526.html\">语法</a>：<br>请求的格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</div><div class=\"line\">&lt;headers&gt;</div><div class=\"line\">&lt;entity-body&gt;</div></pre></td></tr></table></figure>\n<p>响应的格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;</div><div class=\"line\">&lt;headers&gt;</div><div class=\"line\">&lt;entity-body&gt;</div></pre></td></tr></table></figure>\n<p>request中常见的请求头包括：</p>\n<ul>\n<li><p>Accept：指定客户端能够接收的内容类型<br>示例 : Accept:image/webp,image/apng,image/<em>,</em>/*;q=0.8</p>\n</li>\n<li><p>Accept-Charset ：浏览器可以接受的字符编码集</p>\n</li>\n<li><p>Accept-Encoding:gzip, deflate, br<br>客户端浏览器可以支持的压缩编码类型。比如gzip，用于压缩数据，节省带宽。</p>\n</li>\n<li><p>Accept-Language 指定Http客户端浏览器用来优先展示的语言<br>示例: Accept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4 </p>\n</li>\n<li><p>Cache-Control： <a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">参考</a><br>具体操作<a href=\"https://baike.baidu.com/item/Cache-Control\">百度百科</a>写的很清楚<br>可能的值包括：</p>\n</li>\n</ul>\n<p>public 所有内容都将被缓存(客户端和代理服务器都可缓存)<br>private 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)<br>no-cache 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。<br>no-store 所有内容都不会被缓存到缓存或 Internet 临时文件中<br>max-age=xxx (xxx is numeric) 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高</p>\n<p>实际过程中我看到了这种：<br>Cache-Control:private, no-cache, no-cache=Set-Cookie, no-store, proxy-revalidate</p>\n<ul>\n<li><p>Connection:keep-alive  http1.1 默认为keep-alive<br>http 1.0需要手动设置。原理就是服务器保持客户端到服务器的连接持续有效，避免了重新建立连接的开销(tcp三次握手)。这种情况下，客户端不能根据读取到EOF(-1)来判断传输完毕。有两种解决方案：对于静态文件，客户端和服务器能够知道其大小，使用content-length，根据这个判断数据是否已经接收完成；对于动态页面，不可能预先知道内容大小。可以使用Transfer-Encoding:chunked的模式进行传输。基本上就是服务器把文件分成几块，一块一块的发送过去。<a href=\"https://www.byvoid.com/zhs/blog/http-keep-alive-header\">参考</a></p>\n</li>\n<li><p>Content-Type  代表文件类型。request只有POST请求中会有，Response中也会有。<br>POST里面的Content-type有两种:<br>Content-type: application/x-www-form-urlencoded;charset:UTF-8 //缺省值，表示提交表单<br>multipart/form-data //上传文件时用这种，既可以发送文本数据，也支持二进制上传。上面那个CharSet只是为了告诉服务器用的是哪种编码<br>响应头中的Content-Type示例： Content-Type:image/gif或者Content-Type: text/html;charset=utf-8 <a href=\"http://www.runoob.com/http/http-content-type.html\">参考</a></p>\n</li>\n<li><p>Date:Sun, 23 Jul 2017 07:39:47 GMT 这就是当前的GMT时间</p>\n</li>\n<li><p>DNT: 1 Do Not Track（当用户提出启用“请勿追踪”功能后，具有“请勿追踪”功能的浏览器会在http数据传输中添加一个“头信息”（headers），这个头信息向商业网站的服务器表明用户不希望被追踪。这样，遵守该规则的网站就不会追踪用户的个人信息来用于更精准的在线广告。）</p>\n</li>\n</ul>\n<ul>\n<li><p>Etag 用于比较客户端请求的文件的内容是否发生了改变。跟Last-Modified的作用差不多。最简单的用hash值就可以了。</p>\n</li>\n<li><p>Expires:Mon, 01 Jan 1990 00:00:00 GMT    过期时间，这里应该是永不过期</p>\n</li>\n<li><p>HOST 服务器的域名(domian)或者ip地址<br>Host: www.baidu.com</p>\n</li>\n<li><p>If-Modified-Since:Fri, 24 Feb 2017 12:37:22 GMT 这个跟缓存有关</p>\n</li>\n<li><p>If-None-Match:”abf29cbe9a8ed21:0” 还是缓存</p>\n</li>\n<li><p>Pramga 和Cache-Control一样<br>实例： Pramga: no-cache 相当于 Cache-Control： no-cache。</p>\n</li>\n<li><p>User-Agent 这个代表用的是哪种浏览器(客户端)，写爬虫的时候找到一大堆<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36<br>Android设备发出来的可能长这样： Mozilla/5.0 (Linux; U; Android 4.4.4; zh-cn; HTC_D820u Build/KTU84P) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30<br>ios设备发出来的长这样: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12A365 Safari/600.1.4</p>\n</li>\n</ul>\n<ul>\n<li>Referer 一般是一个url，代表当前请求时从哪个页面发出的，写爬虫有用</li>\n</ul>\n<p>Header其实就是个字典，比较麻烦的就是Cache-Control了，这个还要结合If-None-Match，Etag来看。需要用的时候再看应该也不迟。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5\">WikI上比较完整</a></p>\n<h2 id=\"4-Cookie和Session\"><a href=\"#4-Cookie和Session\" class=\"headerlink\" title=\"4. Cookie和Session\"></a>4. Cookie和Session</h2><h3 id=\"4-1-Cookie\"><a href=\"#4-1-Cookie\" class=\"headerlink\" title=\"4.1 Cookie\"></a>4.1 Cookie</h3><p>先看<a href=\"https://zh.wikipedia.org/wiki/Cookie\">Wiki</a>上的解释:</p>\n<ul>\n<li>指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密.主要是因为Http是无状态的，服务器不知道这一次连接和上一次连接是不是同一个客户端<br>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。</li>\n</ul>\n<p>Cookie的一些缺点，直接照搬WiKi了</p>\n<ul>\n<li>Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>\n<li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）</li>\n<li>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</li>\n</ul>\n<p>另外，不同域名是无法共享浏览器端本地信息，包括cookies，这即是跨域问题。百度是不能读取爱奇艺的Cookie的，这是安全性问题。<br>需要注意的是，虽然网站images.google.com与网站www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。必须域名一样才能操作。<br>Java中把Cookie封装成了javax.servlet.http.Cookie类，直接用就可以了。</p>\n<p>Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。</p>\n<p>对了，在众多的Header中Cookie一般长这样:</p>\n<ul>\n<li>Cookie:key1=value1;key_2=value2;key_3=value3;JSessionID=24DHFKDSFKJ324329NSANDI124EH<br>故意把最后一个JSESSION写出来是因为底下要讲Session了嘛</li>\n</ul>\n<h3 id=\"4-2-Session\"><a href=\"#4-2-Session\" class=\"headerlink\" title=\"4.2 Session\"></a>4.2 Session</h3><p><a href=\"http://lavasoft.blog.51cto.com/62575/275589\">参考文章</a><br>Header(字典)里面装着一个Cookie(字典)，Cookie里面有个键值对:JSESSIONID:SESSIONID<br>宏观上就是这么个关系。</p>\n<p>Cookie保存在客户端，Session保存在服务器端。Session是在客户端第一次访问的时候由服务器创建的，session一般存储在redis中（ram），客户端始终只有sessionId。第二次请求的时候(session还未过期)，浏览器会加上sessionId=XXXXX。服务器接收到请求后就得到该请求的sessionID，服务器找到该id的session返还给请求者（Servlet）使用。一个会话只能有一个session对象，对session来说是只认id不认人。</p>\n<p>Session超时：超时指的是连续一定时间服务器没有收到该Session所对应客户端的请求，并且这个时间超过了服务器设置的Session超时的最大时间。<br>Session的maxAge一般为-1，表示仅当前浏览器内有效，关闭浏览器就会失效。</p>\n<p>知乎上有一段比较好的<a href=\"https://www.zhihu.com/question/19786827/answer/66706108\">描述</a>,这里直接引用了。<br>http是无状态的协议，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢，session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，web服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到 sessionid=KWJHUG6JJM65HS2K6之类的字符串。<br>javax.servlet.http.HttpServletRequest.getSession() 将会返回当前request相关联的HttpSession对象，如果不存在，将会创建一个。翻译一下，当一个浏览器请求来到之后，Servlet处理程序（Servlet容器内部实现）将会主动检查请求信息Cookie当中是否有JSESSIONID，若有，找到对应JSESSION的HttpSession对象，如果没有，创建一个，具体的机制在Servlet容器的实现当中。</p>\n<p>Session就是维护会话的。</p>\n<h3 id=\"4-3-自动登录的实现\"><a href=\"#4-3-自动登录的实现\" class=\"headerlink\" title=\"4.3 自动登录的实现\"></a>4.3 自动登录的实现</h3><p>一些网站的“记住密码，自动登录功能”，据说discuz直接将加密的（可逆）uid和密码保存到cookie中。<br>另外一种做法是可以尝试将Session的过期时间设置的长一点，比如一年，下次访问网站的时候就能实现自动登录了。<br>更好一点的是是本地绝不保存用户敏感信息，登录生成一个有过期时间的的cookie或者token返回给客户端，下次打开浏览器判断下过期时间就好了。另外，现在浏览器大多带有记住密码的功能，这个锅还是丢给浏览器(用户)好了。</p>\n<h2 id=\"5-长连接\"><a href=\"#5-长连接\" class=\"headerlink\" title=\"5. 长连接\"></a>5. 长连接</h2><p>像即时通讯软件，或者消息推送这种场景，都得维护一个长连接。<br><a href=\"http://blog.csdn.net/mr_liabill/article/details/50705130\">HTTP长连接和短连接</a></p>\n<h3 id=\"5-1长连接的实现原理\"><a href=\"#5-1长连接的实现原理\" class=\"headerlink\" title=\"5.1长连接的实现原理\"></a>5.1长连接的实现原理</h3><ul>\n<li>轮询</li>\n<li>心跳</li>\n<li>Tcp长连接</li>\n</ul>\n<h3 id=\"5-2-keep-Alive和WebSocket的区别\"><a href=\"#5-2-keep-Alive和WebSocket的区别\" class=\"headerlink\" title=\"5.2 keep-Alive和WebSocket的区别\"></a>5.2 keep-Alive和WebSocket的区别</h3><p><img src=\"http://odzl05jxx.bkt.clouddn.com/ed541bc1ed61ead0bf6ea8233ef01c0a.jpg?imageView2/2/w/600\" alt=\"\"></p>\n<h3 id=\"5-3-http2可以实现推送了\"><a href=\"#5-3-http2可以实现推送了\" class=\"headerlink\" title=\"5.3 http2可以实现推送了\"></a>5.3 http2可以实现推送了</h3><h2 id=\"6-WebSocket、SPDY、Http2\"><a href=\"#6-WebSocket、SPDY、Http2\" class=\"headerlink\" title=\"6. WebSocket、SPDY、Http2\"></a>6. WebSocket、SPDY、Http2</h2><p>WebSocket一种在单个TCP 连接上进行全双工通讯的协议。<br>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接），是HTTP协议的的第二个主要版本<br>SPDY也就是HTTP/2的前身，一种开放的网络传输协议，由Google开发，用来发送网页内容。基于传输控制协议（TCP）的应用层协议</p>\n<p>网络协议，架构，规范，spdy,http2,url规范.<br>OSI七层网络体系结构 ： 物理层、数据链路层、网络层、传输层、表示层、会话层、应用层 </p>\n<p>应用层面的Http，SMTP,FTP,POP,TLS/SSL,IMAP</p>\n<p>tcp三次握手，四次挥手<br>udp使用</p>\n<p>tls,https加密过程，sha1和sha256加密算法</p>\n<p><a href=\"https://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/\">http请求的TCP瓶颈</a></p>\n<p>ping ,traceRouter</p>\n<p><a href=\"http://www.runoob.com/w3cnote/restful-architecture.html\">Restfull架构详解</a></p>"},{"title":"OkHttp和Okio阅读笔记","date":"2017-07-20T16:02:56.000Z","_content":"\n很早的时候就知道，OkHttp在io层面上的操作是由Okio代为完成的，所以实际意义上和Socket打交道的应该是Okio。而Okio又比传统的java io要高效。所以，在分析OkHttp之前，有必要针对Okio的一些方法进行展开，作为后面读写操作的铺垫。\n\nOkio -> OkHttp -> Picaso  -> Retrofit \nOkio版本 1.13.0 \nOkHttp版本 3.8.0\n\n![](http://odzl05jxx.bkt.clouddn.com/6da83b3b20094b044a320d1e89dfcd00.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1. Okio与java io相比的优势\njava的InputStream可以被查看成是一个数据的来源，调用read方法从中读取数据。由于有些文件特别大，我们不可能在内存中分配一个和文件大小一样大的字节数组来专门来读写文件。因此需要传入一个缓冲数组。所以一般的读写程序的代码是这么写的\n```java\npublic abstract class InputStream implements Closeable{\n       public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n    }\n}\n\n public static void main(String[] args) throws Exception {  \n        // 指定要读取文件的缓冲输入字节流  \n        BufferedInputStream in = new BufferedInputStream(new FileInputStream(\"F:\\\\test.jpg\"));  \n        File file = new File(\"E:\\\\test.jpg\");  \n        if (file != null) {  \n            file.createNewFile();  \n        }  \n        // 指定要写入文件的缓冲输出字节流  \n        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));  \n        byte[] bb = new byte[1024];// 用来存储每次读取到的字节数组  \n        int n;// 每次读取到的字节数组的长度  \n        while ((n = in.read(bb)) != -1) {  \n            out.write(bb, 0, n);// 写入到输出流  \n        }  \n        out.close();// 关闭流  \n        in.close();  \n    } \n```\n\nBufferedInputStream和BufferedOutputStream就是提供了这样的缓冲策略，其内部默认分配了一个默认大小的字节数组，或者在read方法中传入一个字节数组，每次一个byte一个byte的读，然后将读出来的内容写进outPutStream。读到-1就是文件终止(EOF)。具体原理可以参考IBM的[深入分析 Java I/O 的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html)。\n那么问题来了，buffer[]作为一个字节数组，其容量是恒定的。假设我们想要一次性读取特别多的数据怎么办。例如http的response header一般长这样,然而实际上在无线电传播的过程中，每一行的后面都跟了一个换行符'\\r\\n',而且无线电传播的时候其实根本没有换行的概念，就是一个字节跟着一个字节。假如服务器自己定义了特别长的header字段，inputstream读到这里的时候，事先预设的字节数组(没法改了)装不下，一种简单粗暴的方式是尝试扩容，这就意味着要把数据从原始数组copy到新的数组，丢掉旧的数组，把指针指向新的数组(一个是allocate数组，一个是arrayCopy，这俩都造成了性能损耗),当然jdk肯定不是这么干的。\n```\nHTTP/1.1 200 OK\nBdpagetype: 1\nBdqid: 0xc8f942640001e753\nBduserid: 0\nCache-Control: private\nConnection: Keep-Alive\nContent-Encoding: gzip\nContent-Type: text/html; charset=utf-8\nDate: Fri, 21 Jul 2017 15:35:58 GMT\nExpires: Fri, 21 Jul 2017 15:35:29 GMT\nServer: BWS/1.1\nSet-Cookie: BDSVRTM=0; path=/\nSet-Cookie: BD_HOME=0; path=/\nSet-Cookie: H_PS_PSSID=1428_21110_20930; path=/; domain=.baidu.com\nStrict-Transport-Security: max-age=172800\nVary: Accept-Encoding\nX-Powered-By: HPHP\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n```\n\n对于Http这种频繁的读写操作，allocate数组和copy数据无形中减慢了网络访问的速度。\n\n- Okio的解决方案\n```\nBuffer buffer = new Buffer();//cheap ,allocation literal nothing\nbuffer.writeUtf8(\"Hello Okio\"); //java中一个英文字符占一个字节(byte)，一个汉字占2个字节(byte)\nbuffer.writeUtf8(\"you can \"); //可以想象segment中被塞进了\"you can \"这几个byte\nbuffer.writeUtf8(\"Go faster\");\n```\nOkio将读写操作集中到到Buffer这个类中，用Sink和Source分别代表数据的去向和来源。而数据的承载类是Segment,读取数据(read)的时候从SegmentPool中索取Segment，读到Segment的byte[]数组中，装不下了再拿一个Segment。这个过程中是没有 new byte[]操作的。\n\n\n-  Read from a source， write to a sink\n\n```java\npublic final class Buffer implements BufferedSource, BufferedSink, Cloneable {\n    Segment head;\n    long size;\n\n     public Buffer() {\n        //构造函数里不分配任何对象，所以创建一个Buffer几乎没有什么性能开销\n    }\n\n    final class Segment {\n    static final int SIZE = 8192;\n    static final int SHARE_MINIMUM = 1024;\n    final byte[] data;\n    int pos;\n    int limit;\n    boolean shared;\n    boolean owner;\n    Segment next;\n    Segment prev;  \n    }\n}\n```\n\n现在那个读取一个文件写到另一个文件的程序可以写成这样:\n```java\nsink = Okio.sink(dstFile);  //返回了一个Sink匿名类，write的时候使用public void write(Buffer source, long byteCount)方法进行写操作\nsource = Okio.source(srcFile);\n   Buffer buf = new Buffer();\n   for (long readCount; (readCount = source.read(buf, 2048)) != -1; ) {\n      sink.write(buf, readCount);\n   }\n```\n看起来还是在数据源和数据终点之间塞了一个缓冲层，sink(dst)和source(src)都是接口，Buffer同时实现了这俩接口。\nwrite是从外面拿数据塞到自己的数组中，所以每次写的时候或让Buffer的Size变大(从segment pool中借用segment)。Buffer(Source)的read方法是把数据从Buffer中拿出来，所以会让Buffer的size变小(每一个Segment读完了会返回到segment pool中)\n在Buffer的所有readXXX方法中都能看到这么一句话 \n **SegmentPool.recycle(segment)**\n因为Buffer内部是通过Segment的next和prev实现了双向链表，write是在尾部添加数据，read是从头部读取数据并移除。\n\n\n**Okio能够实现高效率的核心在于,在java的inputStream和BufferedInputStream中，如果两块缓冲区之间想要交换数据。前面提到的扩容情况，从一个数组把数据复制到另一个更大的数组，必须走arrayCopy。**\n网上查找了很多博客，总的来说就是java io采用了装饰者模式，不同Stream之间要包一层。\n写数据时，写原始数据要用DataOutputStream，使用带缓冲的写要用BuffedOutputStream，使用字符编码要用OutputStreamWriter,写字节数组有ByteArrayOutputStream。\n读数据时也是，原始数据要用DataInputStream，带缓冲的要用BufferedInputStream,字符编码要用InputStreamReader，读字节数有ByteArrayInputStream。\n\n来看下其中带buffer的装饰类是怎么创建的，顺便把java io批判一下。\n```java\nByteArrayOutPutStream baos = new ByteArrayOutPutStream();\nByteArrayInputStream bis = new ByteArrayInputStream(baos.toByteAarray()); //toByteArry内部调用了Arrays.copyOf()，创建了新对象\n\npublic BufferedInputStream(InputStream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Buffer size <= 0\");\n        }\n        buf = new byte[size]; //创建新数组\n    }\n\n public BufferedOutputStream(OutputStream out, int size) {\n        super(out);\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Buffer size <= 0\");\n        }\n        buf = new byte[size]; //创建数组\n    }\n```\n\n\n同样的事情在okio中是这么干的\n```java\n RealBufferedSource(Source source) {\n        if(source == null) {\n            throw new NullPointerException(\"source == null\");\n        } else {\n            this.source = source; //其实是buffer\n        }\n    }\n\n   RealBufferedSink(Sink sink) {\n        if(sink == null) {\n            throw new NullPointerException(\"sink == null\");\n        } else {\n            this.sink = sink; //只是挪一下指针\n        }\n    }   \n```\n由于一个Buffer即是source也是sink，挪一下指针就行了。写的时候往链表的尾巴写，读的时候从链表的头部读，读完了segment回收。\n\n\nBufferedInputStream要求外部调用者带着一个固定大小的byte数组来取数据，难免会有人传进来一个特别小的数组，这样永远不可能读取超过这个数组大小长度的某一行。\n\nBufferedSource在读取Socket数据时，一边从socket里面拿一个Segment大小的数据，然后调用readInt,readLong等方法返回int,long(同时从segment头部清空数据)。如果读到segment最后发现剩下的byte不能组成一个int，就会从segment pool中借一个segment，并从socket中读取数据塞满，把第一个segment剩下的一点byte和第二个segment的头部一点拼成一个int。以BufferSource的readInt为例:\n```java\n    public int readInt() {\n        if(this.size < 4L) {\n            throw new IllegalStateException(\"size < 4: \" + this.size);\n        } else {\n            Segment segment = this.head;\n            int pos = segment.pos;\n            int limit = segment.limit;\n            if(limit - pos < 4) { //一个int 4个byte,这时候segment中未读的数据只剩下不到4个了\n                return (this.readByte() & 255) << 24 | (this.readByte() & 255) << 16 | (this.readByte() & 255) << 8 | this.readByte() & 255; //readByte就是从链表的头部开始一个byte一个byte的读，segment读完了自动回收，直到组成一个int。\n            } else { //剩下的byte足够组成一个int\n                byte[] data = segment.data;\n                int i = (data[pos++] & 255) << 24 | (data[pos++] & 255) << 16 | (data[pos++] & 255) << 8 | data[pos++] & 255; //从byte转int\n                this.size -= 4L; \n                if(pos == limit) {\n                    this.head = segment.pop();\n                    SegmentPool.recycle(segment); //读完了就把segment回收\n                } else {\n                    segment.pos = pos;\n                }\n                return i;\n            }\n        }\n    }\n```\n\n一个很有意思的现象是，java BufferedInputStream的默认buffer数组大小是8192，okio 的segment的默认size也是8192，这些都是以byte为单位的。找到一个合理的[解释](https://stackoverflow.com/questions/37404068/why-is-the-default-char-buffer-size-of-bufferedreader-8192)。大致意思是8192 = 2^13, windows和linux上这个大小正好占用两个分页文件(8kB)。另外java io的类图确实让人眼花缭乱。\n\n## 2. OkHttp的解析\n\n### 2.1 使用介绍\n先上一张图![](http://odzl05jxx.bkt.clouddn.com/okHttp_chain.JPG)。这是最简单的直接用OkHttpClient请求[百度首页](http://www.baidu.com)的堆栈调用情况。在没有做任何手动配置的情况下，至少发现了五个Interceptor:\n\n RetryAndFollowUpInterceptor\n BridgeInterceptor\n CacheInterceptor\n ConnectInterceptor\n CallServerInterceptor\n\n 走到CallServerInterceptor的时候，可以看到Response已经形成了。每一个Interceptor之间还有一个RealInterceptorChain，将各个Interceptor串联起来，\n\n首先是调用者的代码\n```java\nmClient = new OkHttpClient()\n//同步执行\n Request request = new Request.Builder()\n                .url(\"http:www.baidu.com\")\n                .build();\n        Call call = mClient.newCall(request);\n        Response response = null;\n        try {\n            response = call.execute();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n//异步执行代码\n Request request = new Request.Builder()\n                .url(\"http:www.baidu.com\")\n                .build();\n        Call call = mClient.newCall(request);\n        \n        call.enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                \n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                \n            }\n        });       \n```\n\n\n### 2.2 参数配置\n首先Request.Builder().build()方法，这里面只是使用Builder模式，和Retrofit很相似，方便链式调用。最终调用了Request的构造函数\n```java\n Request(Request.Builder builder) {\n        this.url = builder.url; //HttpUrl类型\n        this.method = builder.method; //String类型\n        this.headers = builder.headers.build(); //header就是个字典，内部用一个String数组维护。\n        this.body = builder.body;// RequestBody类型，用于POST提交表单或者Multipart上传文件。\n        this.tag = builder.tag != null?builder.tag:this; //Object类型\n    }\n```\nRequest里面的成员代表了一个网络请求所应该有的一切可能的元素，没什么可说的。\nOkHttpClient的构造也是Builder模式，一旦创建了不能setXX.找到一个比较丰富的例子\n```java\nclient = new OkHttpClient.Builder()\n                          .retryOnConnectionFailure(true)\n                          .connectTimeout(15, TimeUnit.SECONDS)\n                          //设置缓存\n                          .cache(cache)\n                          .build();\n```\n到这里都还只是发起真正的请求之前的configuration阶段，来看发起RealCall的过程\n\n Call call = mClient.newCall(request);\n 这里面初始化了一个RetryAndFollowUpInterceptor。这个拦截器的作用是在连接server失败后自动重连，但服务器500就不会重连,参考[okhttp-is-quietly-retrying-requests-is-your-api-ready](https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace)\n\n### 2.3 开始执行请求\nresponse = call.execute();\n\n```java\n    public Response execute() throws IOException {\n        synchronized(this) {\n            this.executed = true;\n        }\n        Response var2;\n        try {\n            this.client.dispatcher().executed(this); //这个Dispatcher负责记录当前OkHttpClient的所有Request的状态，提供线程池\n            Response result = this.getResponseWithInterceptorChain();\n            if(result == null) {\n                throw new IOException(\"Canceled\");\n            }\n\n            var2 = result;\n        } finally {\n            this.client.dispatcher().finished(this); //记录状态\n        }\n        return var2;\n    }\n```\n\n重点就在getResponseWithInterceptorChain里面\n```java\n Response getResponseWithInterceptorChain() throws IOException {\n        List<Interceptor> interceptors = new ArrayList();\n        interceptors.addAll(this.client.interceptors());\n        interceptors.add(this.retryAndFollowUpInterceptor);\n        interceptors.add(new BridgeInterceptor(this.client.cookieJar()));\n        interceptors.add(new CacheInterceptor(this.client.internalCache()));\n        interceptors.add(new ConnectInterceptor(this.client));\n        if(!this.forWebSocket) { \n            interceptors.addAll(this.client.networkInterceptors()); \n        }\n\n        interceptors.add(new CallServerInterceptor(this.forWebSocket));\n        Chain chain = new RealInterceptorChain(interceptors, (StreamAllocation)null, (HttpCodec)null, (RealConnection)null, 0, this.originalRequest);\n        return chain.proceed(this.originalRequest);\n    }\n```\n注意顺序，用户手动添加的interceptor是最先添加的。在添加完ConnectInterceptor之后，又添加了networkInterceptors(用户手动添加的，一个List)。道理也很清楚，一种是在发起Socket请求之前就拦下来，一种是连上Socket之后的拦截\n\nChain的proceed就是从List中一个个取出Inerceptor，然后执行\n\n\n## 3. 自带的五个Interceptor\n### 3.1 RetryAndFollowUpInterceptor\n```\n    while(!this.canceled) {\n            Response response = null;\n            boolean releaseConnection = true;\n\n            try {\n                response = ((RealInterceptorChain)chain).proceed(request, this.streamAllocation, (HttpCodec)null, (RealConnection)null);\n                releaseConnection = false;\n            } catch (RouteException var13) {\n                releaseConnection = false;\n                continue;\n            } catch (IOException var14) {\n                releaseConnection = false;\n                continue;\n            } finally {\n                if(releaseConnection) {\n                    this.streamAllocation.streamFailed((IOException)null);\n                    this.streamAllocation.release();\n                }\n            }\n            Request followUp = this.followUpRequest(response);\n            if(followUp == null) {\n                return response; \n            }\n            ++followUpCount;\n            if(followUpCount > 20) { \n                this.streamAllocation.release();\n                throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n            }\n        }\n```\n这里面写死了一个循环，只要没有cancel，catch到特定的Exception就一直让链条走下去。\n\n### 3.2 BridgeInterceptor\n这是第二个Interceptor\ninterceptors.add(new BridgeInterceptor(this.client.cookieJar()));//注意带进来了cookie，主要都是添加header什么的\n```java\n    public Response intercept(Chain chain) throws IOException {\n        Request userRequest = chain.request();\n         if(userRequest.header(\"Host\") == null) {\n            requestBuilder.header(\"Host\", Util.hostHeader(userRequest.url(), false));\n        }\n        Response networkResponse = chain.proceed(requestBuilder.build());\n\n        okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);\n\n        }\n        return responseBuilder.build();\n    }\n```\n\n都是些Host,Connection Keep-Alive,User-Agent,Content-Length等跟header有关的东西。随后将request交给链条的下一个interceptor。Response回来之后相应set-Cookie这些东西，下次请求带上cookie，这些都是Http的标准步骤。\n\n### 3.3 CacheInterceptor\n接下来轮到cache，对于response的处理也是差不多的过程\n```java\n    public Response intercept(Chain chain) throws IOException {\n        Response cacheCandidate = this.cache != null?this.cache.get(chain.request()):null;\n\n        Request networkRequest = strategy.networkRequest;\n        Response cacheResponse = strategy.cacheResponse;\n   \n            Response networkResponse = null;\n\n         networkResponse = chain.proceed(networkRequest); \n\n            Response response;\n            if(cacheResponse != null) {\n                if(networkResponse.code() == 304) {\n                    response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();\n                    networkResponse.body().close();\n                    this.cache.trackConditionalCacheHit();\n                    this.cache.update(cacheResponse, response);\n                    return response; //只针对304做了自动cache\n                }\n                Util.closeQuietly(cacheResponse.body());\n            }\n            response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();\n            return response;\n        \n    }\n```\n\n这里也是让请求接着走下去，response回来之后，只有304的时候才会去主动cache下来。\n\n### 3.4 ConnectInterceptor\n这里的interceptor方法异常简短\n```java\n\n    public Response intercept(Chain chain) throws IOException {\n        RealInterceptorChain realChain = (RealInterceptorChain)chain;\n        Request request = realChain.request();\n        StreamAllocation streamAllocation = realChain.streamAllocation();\n        boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n        HttpCodec httpCodec = streamAllocation.newStream(this.client, doExtensiveHealthChecks);\n        RealConnection connection = streamAllocation.connection();\n        return realChain.proceed(request, streamAllocation, httpCodec, connection);\n    }\n```\n这里重点关注 StreamAllocation这个类\n```java\npublic final class StreamAllocation {\n    public final Address address;\n    private Route route;\n    private final ConnectionPool connectionPool;\n    private final Object callStackTrace;\n    private final RouteSelector routeSelector;\n    private int refusedStreamCount;\n    private RealConnection connection;\n    private HttpCodec codec;\n}\n```\n从HttpCodec httpCodec = streamAllocation.newStream(this.client, doExtensiveHealthChecks); 这句话一直往下走，会走到Socket.connect()，也就是大多数人初学网络编程时被教导的如何创建Socket连接。现在想想，能够从操作系统底层的Socket封装出这么多复杂的步骤，实在是高手。\nStreamAllocation.newStream  ----> StreamAllocation.findHealthyConnection  ---> StreamAallocation.findConnection ---> new RealConnection ---> RealConnection.connect \n\nRealConnection.connect()方法\n```java\npublic void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n        if(this.protocol != null) {\n            throw new IllegalStateException(\"already connected\");\n        } else {\n            while(true) {\n                try {\n                    if(this.route.requiresTunnel()) {\n                        this.connectTunnel(connectTimeout, readTimeout, writeTimeout);\n                    } else {\n                        this.connectSocket(connectTimeout, readTimeout);\n                    }\n                    break;\n                } catch (IOException var11) {\n                    if(!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(var11)) {\n                        throw routeException; //这个Exception就是给RetryAndFollowupInterceptor准备的\n                    }\n                }\n            }\n\n           \n\n        }\n    }\n```\n最初学习Socket编程的时候，就是写了一个while(true)，是不是很像？\n\n对了ConnectionPool内部使用了一个Deque保存RealConnection,findConnection里面有这么一段\n- Internal.instance.get(this.connectionPool, this.address, this, (Route)null);//查找\n- Internal.instance.put(this.connectionPool, result);//放进pool\n\n\nconnectSocket长这样:\n```java\n\n    private void connectSocket(int connectTimeout, int readTimeout) throws IOException {\n        Proxy proxy = this.route.proxy();\n        Address address = this.route.address();\n        this.rawSocket = proxy.type() != Type.DIRECT && proxy.type() != Type.HTTP?new Socket(proxy):address.socketFactory().createSocket();\n        this.rawSocket.setSoTimeout(readTimeout);\n\n        try {\n            Platform.get().connectSocket(this.rawSocket, this.route.socketAddress(), connectTimeout); //这里面就一句话socket.connect\n        } catch (ConnectException var7) {\n            ConnectException ce = new ConnectException(\"Failed to connect to \" + this.route.socketAddress());\n            ce.initCause(var7);\n            throw ce;\n        }\n\n        try {\n            this.source = Okio.buffer(Okio.source(this.rawSocket)); \n            this.sink = Okio.buffer(Okio.sink(this.rawSocket));\n        } catch (NullPointerException var8) {\n            if(\"throw with null exception\".equals(var8.getMessage())) {\n                throw new IOException(var8);\n            }\n        }\n\n    }\n```\n\n**重点看**\nthis.source = Okio.buffer(Okio.source(this.rawSocket)); \nthis.sink = Okio.buffer(Okio.sink(this.rawSocket));\n通过sink往Socket里面写数据，通过source网Socket里面写数据，通过Okio包装了，虽然本质上还是socket.getOutputStream和Socket.getInputStream。到这一步，RealConnection内部sink和source初始化完成，socket已经连接上，Socket的inputStream和outPutStream都准备就绪。其实在这种状态下就已经可以开始读写了。\n\n### 3.5 CallServerInterceptor\n这里已经连上了服务器，可以像操作本地文件一样读写数据了，当然要在遵守http规范的前提下。\n```java\n    public Response intercept(Chain chain) throws IOException {\n        RealInterceptorChain realChain = (RealInterceptorChain)chain;\n        HttpCodec httpCodec = realChain.httpStream();\n        StreamAllocation streamAllocation = realChain.streamAllocation();\n        RealConnection connection = (RealConnection)realChain.connection();\n        Request request = realChain.request();\n        //可以看到，到这一步所需要的数据都准备就绪\n        long sentRequestMillis = System.currentTimeMillis();\n\n\n\n        httpCodec.writeRequestHeaders(request); //开始写数据\n\n        Builder responseBuilder = null;\n        if(HttpMethod.permitsRequestBody(request.method()) && request.body() != null) { //这里面是跟POST相关的\n            if(\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n                httpCodec.flushRequest();\n                responseBuilder = httpCodec.readResponseHeaders(true);\n            }\n\n            if(responseBuilder == null) {\n                Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());\n                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n                request.body().writeTo(bufferedRequestBody); //这里就是Okio发挥高效的地方\n                bufferedRequestBody.close();\n            } else if(!connection.isMultiplexed()) {\n                streamAllocation.noNewStreams();\n            }\n        }\n\n        httpCodec.finishRequest(); //到这里，client的数据全部写完并且发送给服务器，服务器开始干活。\n\n\n        if(responseBuilder == null) {\n            responseBuilder = httpCodec.readResponseHeaders(false); //开始从Socket里面读取数据\n        }\n\n        Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();\n        int code = response.code();\n        if(this.forWebSocket && code == 101) {\n            response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();\n        } else {\n            response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();\n        }\n\n        if(\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n            streamAllocation.noNewStreams();\n        }\n\n        if((code == 204 || code == 205) && response.body().contentLength() > 0L) {\n            throw new ProtocolException(\"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n        } else {\n            return response;\n        }\n    }\n```\n\n这里面就是一步步的开始写数据了。这里再借用下百度,chrome按下F12，打开百度首页，看下request的raw header \n```\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nDNT: 1\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4\nCookie: PSTM=122178321; BIDUPSID=CF3243290400VSDG52B3859AD4AEC2; BAIDUID=5176CC0A23DB1F3423426454DRTG5EC8:FG=1; MCITY=-%3A; BD_HOME=0; H_PS_PSSID=1428_24320_20930; BD_UPN=1223214323\n```\n看下httpCodec.writeRequestHeaders(request)的实现，就会发现真的是这么一行一行的写的\n例如RequestLine.java\n```java\n public static String get(Request request, Type proxyType) {\n        StringBuilder result = new StringBuilder();\n        result.append(request.method()); // GET \n        result.append(' '); //空格\n        if(includeAuthorityInRequestLine(request, proxyType)) {\n            result.append(request.url());\n        } else {\n            result.append(requestPath(request.url()));  //我们访问的是百度首页，当然是'/'这个Index啦\n        }\n\n        result.append(\" HTTP/1.1\");  //是不是和上面一模一样\n        return result.toString();\n    }\n```\n接下来轮到Http1Codec.class\n```java\npublic void writeRequest(Headers headers, String requestLine) throws IOException {\n        if(this.state != 0) {\n            throw new IllegalStateException(\"state: \" + this.state);\n        } else {\n            this.sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\"); //这是第一行，写完了加上换行符\n            int i = 0;\n\n            for(int size = headers.size(); i < size; ++i) {\n                this.sink.writeUtf8(headers.name(i)).writeUtf8(\": \").writeUtf8(headers.value(i)).writeUtf8(\"\\r\\n\"); //一个header写完就写一个换行符\n            }\n\n            this.sink.writeUtf8(\"\\r\\n\");\n            this.state = 1;\n        }\n    }\n```\n读取Response的顺序和写Request相反，不再赘述。\n\n## 4.结语\n这里只是针对OkHttp发起的一个最简单同步的网络请求进行了分析。\n关于异步请求再说两句：本质上不过是包装了一个回调，丢到线程池里面，相比整个Http请求，实在是不值一提。来看下这个线程池\n-  new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\n照说jdk不推荐这么创建线程池，一般用jdk封装好的CachedThreadPool，FixedThreadPool等等，但想必这样做也是不为了造成过大的系统开销吧。debug的时候如果看到OkHttp Dispatcher这条线程，应该明白是为什么了吧。另外，Okio会引入一条名为Okio WatchDog的线程，这跟Okio的AsyncTimeOut有关。时间关系(已经是夜里12点了)，不打算研究了。\n\n\nOkHttp总量过于庞大，很多方面，包括spdy,webSocket,RouterDatabase,DNS,网络执行周期触发回调，http2，http协议，太多太多，再研究一天也看不完。\n\n拎出来几个比较重要的点吧：\n- Okio放在最前面，就是为了说明在网络请求这样对于io性能要求高的场合，okio避免了memory allocation和不必要的缓存复制。\n- OkHttpClient应该是对标apache的HttpClient的，后者不清楚。\n- 底层还是调用操作系统的Socket接口，从这个角度来看，Retrofit只是一个Util，包括线程调度都是用的OkHttp的线程池；Volley我记得默认是4条NetWorkDispatcher和一个CacheDispatcher和一个ContentDelivery。\n- 不推荐创建多个OkHttpClient，真想创建多个的话，用newBuilder(浅复制)就好了嘛。\n- 网上说Picaso内部的cache其实就是OkHttp的cache，不愧square全家桶系列\n- 和Retrofit一样，也是用的Builder模式，提供了极大的自定义空间\n- Interceptor，广受业界好评的责任链模式\n\n\n写于2017年7月23日0:29\n\n## 5. 参考\n- [Paisy](https://blog.piasy.com/2016/07/11/Understand-OkHttp/)\n- [Frodo系列](http://frodoking.github.io/2015/03/12/android-okhttp/)\n- [A few ok library](https://www.youtube.com/watch?v=WvyScM_S88c)\n- [Forcing bytes downward in Okio](http://jakewharton.com/forcing-bytes-downward-in-okio/)","source":"_posts/2017-07-21-okhttp-demisified.md","raw":"---\ntitle: OkHttp和Okio阅读笔记\ndate: 2017-07-21 00:02:56\ntags: [android,java]\n---\n\n很早的时候就知道，OkHttp在io层面上的操作是由Okio代为完成的，所以实际意义上和Socket打交道的应该是Okio。而Okio又比传统的java io要高效。所以，在分析OkHttp之前，有必要针对Okio的一些方法进行展开，作为后面读写操作的铺垫。\n\nOkio -> OkHttp -> Picaso  -> Retrofit \nOkio版本 1.13.0 \nOkHttp版本 3.8.0\n\n![](http://odzl05jxx.bkt.clouddn.com/6da83b3b20094b044a320d1e89dfcd00.jpg?imageView2/2/w/600)\n<!--more-->\n\n## 1. Okio与java io相比的优势\njava的InputStream可以被查看成是一个数据的来源，调用read方法从中读取数据。由于有些文件特别大，我们不可能在内存中分配一个和文件大小一样大的字节数组来专门来读写文件。因此需要传入一个缓冲数组。所以一般的读写程序的代码是这么写的\n```java\npublic abstract class InputStream implements Closeable{\n       public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n    }\n}\n\n public static void main(String[] args) throws Exception {  \n        // 指定要读取文件的缓冲输入字节流  \n        BufferedInputStream in = new BufferedInputStream(new FileInputStream(\"F:\\\\test.jpg\"));  \n        File file = new File(\"E:\\\\test.jpg\");  \n        if (file != null) {  \n            file.createNewFile();  \n        }  \n        // 指定要写入文件的缓冲输出字节流  \n        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));  \n        byte[] bb = new byte[1024];// 用来存储每次读取到的字节数组  \n        int n;// 每次读取到的字节数组的长度  \n        while ((n = in.read(bb)) != -1) {  \n            out.write(bb, 0, n);// 写入到输出流  \n        }  \n        out.close();// 关闭流  \n        in.close();  \n    } \n```\n\nBufferedInputStream和BufferedOutputStream就是提供了这样的缓冲策略，其内部默认分配了一个默认大小的字节数组，或者在read方法中传入一个字节数组，每次一个byte一个byte的读，然后将读出来的内容写进outPutStream。读到-1就是文件终止(EOF)。具体原理可以参考IBM的[深入分析 Java I/O 的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html)。\n那么问题来了，buffer[]作为一个字节数组，其容量是恒定的。假设我们想要一次性读取特别多的数据怎么办。例如http的response header一般长这样,然而实际上在无线电传播的过程中，每一行的后面都跟了一个换行符'\\r\\n',而且无线电传播的时候其实根本没有换行的概念，就是一个字节跟着一个字节。假如服务器自己定义了特别长的header字段，inputstream读到这里的时候，事先预设的字节数组(没法改了)装不下，一种简单粗暴的方式是尝试扩容，这就意味着要把数据从原始数组copy到新的数组，丢掉旧的数组，把指针指向新的数组(一个是allocate数组，一个是arrayCopy，这俩都造成了性能损耗),当然jdk肯定不是这么干的。\n```\nHTTP/1.1 200 OK\nBdpagetype: 1\nBdqid: 0xc8f942640001e753\nBduserid: 0\nCache-Control: private\nConnection: Keep-Alive\nContent-Encoding: gzip\nContent-Type: text/html; charset=utf-8\nDate: Fri, 21 Jul 2017 15:35:58 GMT\nExpires: Fri, 21 Jul 2017 15:35:29 GMT\nServer: BWS/1.1\nSet-Cookie: BDSVRTM=0; path=/\nSet-Cookie: BD_HOME=0; path=/\nSet-Cookie: H_PS_PSSID=1428_21110_20930; path=/; domain=.baidu.com\nStrict-Transport-Security: max-age=172800\nVary: Accept-Encoding\nX-Powered-By: HPHP\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n```\n\n对于Http这种频繁的读写操作，allocate数组和copy数据无形中减慢了网络访问的速度。\n\n- Okio的解决方案\n```\nBuffer buffer = new Buffer();//cheap ,allocation literal nothing\nbuffer.writeUtf8(\"Hello Okio\"); //java中一个英文字符占一个字节(byte)，一个汉字占2个字节(byte)\nbuffer.writeUtf8(\"you can \"); //可以想象segment中被塞进了\"you can \"这几个byte\nbuffer.writeUtf8(\"Go faster\");\n```\nOkio将读写操作集中到到Buffer这个类中，用Sink和Source分别代表数据的去向和来源。而数据的承载类是Segment,读取数据(read)的时候从SegmentPool中索取Segment，读到Segment的byte[]数组中，装不下了再拿一个Segment。这个过程中是没有 new byte[]操作的。\n\n\n-  Read from a source， write to a sink\n\n```java\npublic final class Buffer implements BufferedSource, BufferedSink, Cloneable {\n    Segment head;\n    long size;\n\n     public Buffer() {\n        //构造函数里不分配任何对象，所以创建一个Buffer几乎没有什么性能开销\n    }\n\n    final class Segment {\n    static final int SIZE = 8192;\n    static final int SHARE_MINIMUM = 1024;\n    final byte[] data;\n    int pos;\n    int limit;\n    boolean shared;\n    boolean owner;\n    Segment next;\n    Segment prev;  \n    }\n}\n```\n\n现在那个读取一个文件写到另一个文件的程序可以写成这样:\n```java\nsink = Okio.sink(dstFile);  //返回了一个Sink匿名类，write的时候使用public void write(Buffer source, long byteCount)方法进行写操作\nsource = Okio.source(srcFile);\n   Buffer buf = new Buffer();\n   for (long readCount; (readCount = source.read(buf, 2048)) != -1; ) {\n      sink.write(buf, readCount);\n   }\n```\n看起来还是在数据源和数据终点之间塞了一个缓冲层，sink(dst)和source(src)都是接口，Buffer同时实现了这俩接口。\nwrite是从外面拿数据塞到自己的数组中，所以每次写的时候或让Buffer的Size变大(从segment pool中借用segment)。Buffer(Source)的read方法是把数据从Buffer中拿出来，所以会让Buffer的size变小(每一个Segment读完了会返回到segment pool中)\n在Buffer的所有readXXX方法中都能看到这么一句话 \n **SegmentPool.recycle(segment)**\n因为Buffer内部是通过Segment的next和prev实现了双向链表，write是在尾部添加数据，read是从头部读取数据并移除。\n\n\n**Okio能够实现高效率的核心在于,在java的inputStream和BufferedInputStream中，如果两块缓冲区之间想要交换数据。前面提到的扩容情况，从一个数组把数据复制到另一个更大的数组，必须走arrayCopy。**\n网上查找了很多博客，总的来说就是java io采用了装饰者模式，不同Stream之间要包一层。\n写数据时，写原始数据要用DataOutputStream，使用带缓冲的写要用BuffedOutputStream，使用字符编码要用OutputStreamWriter,写字节数组有ByteArrayOutputStream。\n读数据时也是，原始数据要用DataInputStream，带缓冲的要用BufferedInputStream,字符编码要用InputStreamReader，读字节数有ByteArrayInputStream。\n\n来看下其中带buffer的装饰类是怎么创建的，顺便把java io批判一下。\n```java\nByteArrayOutPutStream baos = new ByteArrayOutPutStream();\nByteArrayInputStream bis = new ByteArrayInputStream(baos.toByteAarray()); //toByteArry内部调用了Arrays.copyOf()，创建了新对象\n\npublic BufferedInputStream(InputStream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Buffer size <= 0\");\n        }\n        buf = new byte[size]; //创建新数组\n    }\n\n public BufferedOutputStream(OutputStream out, int size) {\n        super(out);\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Buffer size <= 0\");\n        }\n        buf = new byte[size]; //创建数组\n    }\n```\n\n\n同样的事情在okio中是这么干的\n```java\n RealBufferedSource(Source source) {\n        if(source == null) {\n            throw new NullPointerException(\"source == null\");\n        } else {\n            this.source = source; //其实是buffer\n        }\n    }\n\n   RealBufferedSink(Sink sink) {\n        if(sink == null) {\n            throw new NullPointerException(\"sink == null\");\n        } else {\n            this.sink = sink; //只是挪一下指针\n        }\n    }   \n```\n由于一个Buffer即是source也是sink，挪一下指针就行了。写的时候往链表的尾巴写，读的时候从链表的头部读，读完了segment回收。\n\n\nBufferedInputStream要求外部调用者带着一个固定大小的byte数组来取数据，难免会有人传进来一个特别小的数组，这样永远不可能读取超过这个数组大小长度的某一行。\n\nBufferedSource在读取Socket数据时，一边从socket里面拿一个Segment大小的数据，然后调用readInt,readLong等方法返回int,long(同时从segment头部清空数据)。如果读到segment最后发现剩下的byte不能组成一个int，就会从segment pool中借一个segment，并从socket中读取数据塞满，把第一个segment剩下的一点byte和第二个segment的头部一点拼成一个int。以BufferSource的readInt为例:\n```java\n    public int readInt() {\n        if(this.size < 4L) {\n            throw new IllegalStateException(\"size < 4: \" + this.size);\n        } else {\n            Segment segment = this.head;\n            int pos = segment.pos;\n            int limit = segment.limit;\n            if(limit - pos < 4) { //一个int 4个byte,这时候segment中未读的数据只剩下不到4个了\n                return (this.readByte() & 255) << 24 | (this.readByte() & 255) << 16 | (this.readByte() & 255) << 8 | this.readByte() & 255; //readByte就是从链表的头部开始一个byte一个byte的读，segment读完了自动回收，直到组成一个int。\n            } else { //剩下的byte足够组成一个int\n                byte[] data = segment.data;\n                int i = (data[pos++] & 255) << 24 | (data[pos++] & 255) << 16 | (data[pos++] & 255) << 8 | data[pos++] & 255; //从byte转int\n                this.size -= 4L; \n                if(pos == limit) {\n                    this.head = segment.pop();\n                    SegmentPool.recycle(segment); //读完了就把segment回收\n                } else {\n                    segment.pos = pos;\n                }\n                return i;\n            }\n        }\n    }\n```\n\n一个很有意思的现象是，java BufferedInputStream的默认buffer数组大小是8192，okio 的segment的默认size也是8192，这些都是以byte为单位的。找到一个合理的[解释](https://stackoverflow.com/questions/37404068/why-is-the-default-char-buffer-size-of-bufferedreader-8192)。大致意思是8192 = 2^13, windows和linux上这个大小正好占用两个分页文件(8kB)。另外java io的类图确实让人眼花缭乱。\n\n## 2. OkHttp的解析\n\n### 2.1 使用介绍\n先上一张图![](http://odzl05jxx.bkt.clouddn.com/okHttp_chain.JPG)。这是最简单的直接用OkHttpClient请求[百度首页](http://www.baidu.com)的堆栈调用情况。在没有做任何手动配置的情况下，至少发现了五个Interceptor:\n\n RetryAndFollowUpInterceptor\n BridgeInterceptor\n CacheInterceptor\n ConnectInterceptor\n CallServerInterceptor\n\n 走到CallServerInterceptor的时候，可以看到Response已经形成了。每一个Interceptor之间还有一个RealInterceptorChain，将各个Interceptor串联起来，\n\n首先是调用者的代码\n```java\nmClient = new OkHttpClient()\n//同步执行\n Request request = new Request.Builder()\n                .url(\"http:www.baidu.com\")\n                .build();\n        Call call = mClient.newCall(request);\n        Response response = null;\n        try {\n            response = call.execute();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n//异步执行代码\n Request request = new Request.Builder()\n                .url(\"http:www.baidu.com\")\n                .build();\n        Call call = mClient.newCall(request);\n        \n        call.enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                \n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                \n            }\n        });       \n```\n\n\n### 2.2 参数配置\n首先Request.Builder().build()方法，这里面只是使用Builder模式，和Retrofit很相似，方便链式调用。最终调用了Request的构造函数\n```java\n Request(Request.Builder builder) {\n        this.url = builder.url; //HttpUrl类型\n        this.method = builder.method; //String类型\n        this.headers = builder.headers.build(); //header就是个字典，内部用一个String数组维护。\n        this.body = builder.body;// RequestBody类型，用于POST提交表单或者Multipart上传文件。\n        this.tag = builder.tag != null?builder.tag:this; //Object类型\n    }\n```\nRequest里面的成员代表了一个网络请求所应该有的一切可能的元素，没什么可说的。\nOkHttpClient的构造也是Builder模式，一旦创建了不能setXX.找到一个比较丰富的例子\n```java\nclient = new OkHttpClient.Builder()\n                          .retryOnConnectionFailure(true)\n                          .connectTimeout(15, TimeUnit.SECONDS)\n                          //设置缓存\n                          .cache(cache)\n                          .build();\n```\n到这里都还只是发起真正的请求之前的configuration阶段，来看发起RealCall的过程\n\n Call call = mClient.newCall(request);\n 这里面初始化了一个RetryAndFollowUpInterceptor。这个拦截器的作用是在连接server失败后自动重连，但服务器500就不会重连,参考[okhttp-is-quietly-retrying-requests-is-your-api-ready](https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace)\n\n### 2.3 开始执行请求\nresponse = call.execute();\n\n```java\n    public Response execute() throws IOException {\n        synchronized(this) {\n            this.executed = true;\n        }\n        Response var2;\n        try {\n            this.client.dispatcher().executed(this); //这个Dispatcher负责记录当前OkHttpClient的所有Request的状态，提供线程池\n            Response result = this.getResponseWithInterceptorChain();\n            if(result == null) {\n                throw new IOException(\"Canceled\");\n            }\n\n            var2 = result;\n        } finally {\n            this.client.dispatcher().finished(this); //记录状态\n        }\n        return var2;\n    }\n```\n\n重点就在getResponseWithInterceptorChain里面\n```java\n Response getResponseWithInterceptorChain() throws IOException {\n        List<Interceptor> interceptors = new ArrayList();\n        interceptors.addAll(this.client.interceptors());\n        interceptors.add(this.retryAndFollowUpInterceptor);\n        interceptors.add(new BridgeInterceptor(this.client.cookieJar()));\n        interceptors.add(new CacheInterceptor(this.client.internalCache()));\n        interceptors.add(new ConnectInterceptor(this.client));\n        if(!this.forWebSocket) { \n            interceptors.addAll(this.client.networkInterceptors()); \n        }\n\n        interceptors.add(new CallServerInterceptor(this.forWebSocket));\n        Chain chain = new RealInterceptorChain(interceptors, (StreamAllocation)null, (HttpCodec)null, (RealConnection)null, 0, this.originalRequest);\n        return chain.proceed(this.originalRequest);\n    }\n```\n注意顺序，用户手动添加的interceptor是最先添加的。在添加完ConnectInterceptor之后，又添加了networkInterceptors(用户手动添加的，一个List)。道理也很清楚，一种是在发起Socket请求之前就拦下来，一种是连上Socket之后的拦截\n\nChain的proceed就是从List中一个个取出Inerceptor，然后执行\n\n\n## 3. 自带的五个Interceptor\n### 3.1 RetryAndFollowUpInterceptor\n```\n    while(!this.canceled) {\n            Response response = null;\n            boolean releaseConnection = true;\n\n            try {\n                response = ((RealInterceptorChain)chain).proceed(request, this.streamAllocation, (HttpCodec)null, (RealConnection)null);\n                releaseConnection = false;\n            } catch (RouteException var13) {\n                releaseConnection = false;\n                continue;\n            } catch (IOException var14) {\n                releaseConnection = false;\n                continue;\n            } finally {\n                if(releaseConnection) {\n                    this.streamAllocation.streamFailed((IOException)null);\n                    this.streamAllocation.release();\n                }\n            }\n            Request followUp = this.followUpRequest(response);\n            if(followUp == null) {\n                return response; \n            }\n            ++followUpCount;\n            if(followUpCount > 20) { \n                this.streamAllocation.release();\n                throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n            }\n        }\n```\n这里面写死了一个循环，只要没有cancel，catch到特定的Exception就一直让链条走下去。\n\n### 3.2 BridgeInterceptor\n这是第二个Interceptor\ninterceptors.add(new BridgeInterceptor(this.client.cookieJar()));//注意带进来了cookie，主要都是添加header什么的\n```java\n    public Response intercept(Chain chain) throws IOException {\n        Request userRequest = chain.request();\n         if(userRequest.header(\"Host\") == null) {\n            requestBuilder.header(\"Host\", Util.hostHeader(userRequest.url(), false));\n        }\n        Response networkResponse = chain.proceed(requestBuilder.build());\n\n        okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);\n\n        }\n        return responseBuilder.build();\n    }\n```\n\n都是些Host,Connection Keep-Alive,User-Agent,Content-Length等跟header有关的东西。随后将request交给链条的下一个interceptor。Response回来之后相应set-Cookie这些东西，下次请求带上cookie，这些都是Http的标准步骤。\n\n### 3.3 CacheInterceptor\n接下来轮到cache，对于response的处理也是差不多的过程\n```java\n    public Response intercept(Chain chain) throws IOException {\n        Response cacheCandidate = this.cache != null?this.cache.get(chain.request()):null;\n\n        Request networkRequest = strategy.networkRequest;\n        Response cacheResponse = strategy.cacheResponse;\n   \n            Response networkResponse = null;\n\n         networkResponse = chain.proceed(networkRequest); \n\n            Response response;\n            if(cacheResponse != null) {\n                if(networkResponse.code() == 304) {\n                    response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();\n                    networkResponse.body().close();\n                    this.cache.trackConditionalCacheHit();\n                    this.cache.update(cacheResponse, response);\n                    return response; //只针对304做了自动cache\n                }\n                Util.closeQuietly(cacheResponse.body());\n            }\n            response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();\n            return response;\n        \n    }\n```\n\n这里也是让请求接着走下去，response回来之后，只有304的时候才会去主动cache下来。\n\n### 3.4 ConnectInterceptor\n这里的interceptor方法异常简短\n```java\n\n    public Response intercept(Chain chain) throws IOException {\n        RealInterceptorChain realChain = (RealInterceptorChain)chain;\n        Request request = realChain.request();\n        StreamAllocation streamAllocation = realChain.streamAllocation();\n        boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n        HttpCodec httpCodec = streamAllocation.newStream(this.client, doExtensiveHealthChecks);\n        RealConnection connection = streamAllocation.connection();\n        return realChain.proceed(request, streamAllocation, httpCodec, connection);\n    }\n```\n这里重点关注 StreamAllocation这个类\n```java\npublic final class StreamAllocation {\n    public final Address address;\n    private Route route;\n    private final ConnectionPool connectionPool;\n    private final Object callStackTrace;\n    private final RouteSelector routeSelector;\n    private int refusedStreamCount;\n    private RealConnection connection;\n    private HttpCodec codec;\n}\n```\n从HttpCodec httpCodec = streamAllocation.newStream(this.client, doExtensiveHealthChecks); 这句话一直往下走，会走到Socket.connect()，也就是大多数人初学网络编程时被教导的如何创建Socket连接。现在想想，能够从操作系统底层的Socket封装出这么多复杂的步骤，实在是高手。\nStreamAllocation.newStream  ----> StreamAllocation.findHealthyConnection  ---> StreamAallocation.findConnection ---> new RealConnection ---> RealConnection.connect \n\nRealConnection.connect()方法\n```java\npublic void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n        if(this.protocol != null) {\n            throw new IllegalStateException(\"already connected\");\n        } else {\n            while(true) {\n                try {\n                    if(this.route.requiresTunnel()) {\n                        this.connectTunnel(connectTimeout, readTimeout, writeTimeout);\n                    } else {\n                        this.connectSocket(connectTimeout, readTimeout);\n                    }\n                    break;\n                } catch (IOException var11) {\n                    if(!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(var11)) {\n                        throw routeException; //这个Exception就是给RetryAndFollowupInterceptor准备的\n                    }\n                }\n            }\n\n           \n\n        }\n    }\n```\n最初学习Socket编程的时候，就是写了一个while(true)，是不是很像？\n\n对了ConnectionPool内部使用了一个Deque保存RealConnection,findConnection里面有这么一段\n- Internal.instance.get(this.connectionPool, this.address, this, (Route)null);//查找\n- Internal.instance.put(this.connectionPool, result);//放进pool\n\n\nconnectSocket长这样:\n```java\n\n    private void connectSocket(int connectTimeout, int readTimeout) throws IOException {\n        Proxy proxy = this.route.proxy();\n        Address address = this.route.address();\n        this.rawSocket = proxy.type() != Type.DIRECT && proxy.type() != Type.HTTP?new Socket(proxy):address.socketFactory().createSocket();\n        this.rawSocket.setSoTimeout(readTimeout);\n\n        try {\n            Platform.get().connectSocket(this.rawSocket, this.route.socketAddress(), connectTimeout); //这里面就一句话socket.connect\n        } catch (ConnectException var7) {\n            ConnectException ce = new ConnectException(\"Failed to connect to \" + this.route.socketAddress());\n            ce.initCause(var7);\n            throw ce;\n        }\n\n        try {\n            this.source = Okio.buffer(Okio.source(this.rawSocket)); \n            this.sink = Okio.buffer(Okio.sink(this.rawSocket));\n        } catch (NullPointerException var8) {\n            if(\"throw with null exception\".equals(var8.getMessage())) {\n                throw new IOException(var8);\n            }\n        }\n\n    }\n```\n\n**重点看**\nthis.source = Okio.buffer(Okio.source(this.rawSocket)); \nthis.sink = Okio.buffer(Okio.sink(this.rawSocket));\n通过sink往Socket里面写数据，通过source网Socket里面写数据，通过Okio包装了，虽然本质上还是socket.getOutputStream和Socket.getInputStream。到这一步，RealConnection内部sink和source初始化完成，socket已经连接上，Socket的inputStream和outPutStream都准备就绪。其实在这种状态下就已经可以开始读写了。\n\n### 3.5 CallServerInterceptor\n这里已经连上了服务器，可以像操作本地文件一样读写数据了，当然要在遵守http规范的前提下。\n```java\n    public Response intercept(Chain chain) throws IOException {\n        RealInterceptorChain realChain = (RealInterceptorChain)chain;\n        HttpCodec httpCodec = realChain.httpStream();\n        StreamAllocation streamAllocation = realChain.streamAllocation();\n        RealConnection connection = (RealConnection)realChain.connection();\n        Request request = realChain.request();\n        //可以看到，到这一步所需要的数据都准备就绪\n        long sentRequestMillis = System.currentTimeMillis();\n\n\n\n        httpCodec.writeRequestHeaders(request); //开始写数据\n\n        Builder responseBuilder = null;\n        if(HttpMethod.permitsRequestBody(request.method()) && request.body() != null) { //这里面是跟POST相关的\n            if(\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n                httpCodec.flushRequest();\n                responseBuilder = httpCodec.readResponseHeaders(true);\n            }\n\n            if(responseBuilder == null) {\n                Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());\n                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n                request.body().writeTo(bufferedRequestBody); //这里就是Okio发挥高效的地方\n                bufferedRequestBody.close();\n            } else if(!connection.isMultiplexed()) {\n                streamAllocation.noNewStreams();\n            }\n        }\n\n        httpCodec.finishRequest(); //到这里，client的数据全部写完并且发送给服务器，服务器开始干活。\n\n\n        if(responseBuilder == null) {\n            responseBuilder = httpCodec.readResponseHeaders(false); //开始从Socket里面读取数据\n        }\n\n        Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();\n        int code = response.code();\n        if(this.forWebSocket && code == 101) {\n            response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();\n        } else {\n            response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();\n        }\n\n        if(\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n            streamAllocation.noNewStreams();\n        }\n\n        if((code == 204 || code == 205) && response.body().contentLength() > 0L) {\n            throw new ProtocolException(\"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n        } else {\n            return response;\n        }\n    }\n```\n\n这里面就是一步步的开始写数据了。这里再借用下百度,chrome按下F12，打开百度首页，看下request的raw header \n```\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nDNT: 1\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4\nCookie: PSTM=122178321; BIDUPSID=CF3243290400VSDG52B3859AD4AEC2; BAIDUID=5176CC0A23DB1F3423426454DRTG5EC8:FG=1; MCITY=-%3A; BD_HOME=0; H_PS_PSSID=1428_24320_20930; BD_UPN=1223214323\n```\n看下httpCodec.writeRequestHeaders(request)的实现，就会发现真的是这么一行一行的写的\n例如RequestLine.java\n```java\n public static String get(Request request, Type proxyType) {\n        StringBuilder result = new StringBuilder();\n        result.append(request.method()); // GET \n        result.append(' '); //空格\n        if(includeAuthorityInRequestLine(request, proxyType)) {\n            result.append(request.url());\n        } else {\n            result.append(requestPath(request.url()));  //我们访问的是百度首页，当然是'/'这个Index啦\n        }\n\n        result.append(\" HTTP/1.1\");  //是不是和上面一模一样\n        return result.toString();\n    }\n```\n接下来轮到Http1Codec.class\n```java\npublic void writeRequest(Headers headers, String requestLine) throws IOException {\n        if(this.state != 0) {\n            throw new IllegalStateException(\"state: \" + this.state);\n        } else {\n            this.sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\"); //这是第一行，写完了加上换行符\n            int i = 0;\n\n            for(int size = headers.size(); i < size; ++i) {\n                this.sink.writeUtf8(headers.name(i)).writeUtf8(\": \").writeUtf8(headers.value(i)).writeUtf8(\"\\r\\n\"); //一个header写完就写一个换行符\n            }\n\n            this.sink.writeUtf8(\"\\r\\n\");\n            this.state = 1;\n        }\n    }\n```\n读取Response的顺序和写Request相反，不再赘述。\n\n## 4.结语\n这里只是针对OkHttp发起的一个最简单同步的网络请求进行了分析。\n关于异步请求再说两句：本质上不过是包装了一个回调，丢到线程池里面，相比整个Http请求，实在是不值一提。来看下这个线程池\n-  new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\n照说jdk不推荐这么创建线程池，一般用jdk封装好的CachedThreadPool，FixedThreadPool等等，但想必这样做也是不为了造成过大的系统开销吧。debug的时候如果看到OkHttp Dispatcher这条线程，应该明白是为什么了吧。另外，Okio会引入一条名为Okio WatchDog的线程，这跟Okio的AsyncTimeOut有关。时间关系(已经是夜里12点了)，不打算研究了。\n\n\nOkHttp总量过于庞大，很多方面，包括spdy,webSocket,RouterDatabase,DNS,网络执行周期触发回调，http2，http协议，太多太多，再研究一天也看不完。\n\n拎出来几个比较重要的点吧：\n- Okio放在最前面，就是为了说明在网络请求这样对于io性能要求高的场合，okio避免了memory allocation和不必要的缓存复制。\n- OkHttpClient应该是对标apache的HttpClient的，后者不清楚。\n- 底层还是调用操作系统的Socket接口，从这个角度来看，Retrofit只是一个Util，包括线程调度都是用的OkHttp的线程池；Volley我记得默认是4条NetWorkDispatcher和一个CacheDispatcher和一个ContentDelivery。\n- 不推荐创建多个OkHttpClient，真想创建多个的话，用newBuilder(浅复制)就好了嘛。\n- 网上说Picaso内部的cache其实就是OkHttp的cache，不愧square全家桶系列\n- 和Retrofit一样，也是用的Builder模式，提供了极大的自定义空间\n- Interceptor，广受业界好评的责任链模式\n\n\n写于2017年7月23日0:29\n\n## 5. 参考\n- [Paisy](https://blog.piasy.com/2016/07/11/Understand-OkHttp/)\n- [Frodo系列](http://frodoking.github.io/2015/03/12/android-okhttp/)\n- [A few ok library](https://www.youtube.com/watch?v=WvyScM_S88c)\n- [Forcing bytes downward in Okio](http://jakewharton.com/forcing-bytes-downward-in-okio/)","slug":"2017-07-21-okhttp-demisified","published":1,"updated":"2017-07-23T11:11:24.058Z","_id":"cj5gmdnkb002sbovrkpad2vbj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>很早的时候就知道，OkHttp在io层面上的操作是由Okio代为完成的，所以实际意义上和Socket打交道的应该是Okio。而Okio又比传统的java io要高效。所以，在分析OkHttp之前，有必要针对Okio的一些方法进行展开，作为后面读写操作的铺垫。</p>\n<p>Okio -&gt; OkHttp -&gt; Picaso  -&gt; Retrofit<br>Okio版本 1.13.0<br>OkHttp版本 3.8.0</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/6da83b3b20094b044a320d1e89dfcd00.jpg?imageView2/2/w/600\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"1-Okio与java-io相比的优势\"><a href=\"#1-Okio与java-io相比的优势\" class=\"headerlink\" title=\"1. Okio与java io相比的优势\"></a>1. Okio与java io相比的优势</h2><p>java的InputStream可以被查看成是一个数据的来源，调用read方法从中读取数据。由于有些文件特别大，我们不可能在内存中分配一个和文件大小一样大的字节数组来专门来读写文件。因此需要传入一个缓冲数组。所以一般的读写程序的代码是这么写的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span></span>&#123;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 指定要读取文件的缓冲输入字节流  </span></div><div class=\"line\">        BufferedInputStream in = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"F:\\\\test.jpg\"</span>));  </div><div class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"E:\\\\test.jpg\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            file.createNewFile();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"comment\">// 指定要写入文件的缓冲输出字节流  </span></div><div class=\"line\">        BufferedOutputStream out = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(file));  </div><div class=\"line\">        <span class=\"keyword\">byte</span>[] bb = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">// 用来存储每次读取到的字节数组  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> n;<span class=\"comment\">// 每次读取到的字节数组的长度  </span></div><div class=\"line\">        <span class=\"keyword\">while</span> ((n = in.read(bb)) != -<span class=\"number\">1</span>) &#123;  </div><div class=\"line\">            out.write(bb, <span class=\"number\">0</span>, n);<span class=\"comment\">// 写入到输出流  </span></div><div class=\"line\">        &#125;  </div><div class=\"line\">        out.close();<span class=\"comment\">// 关闭流  </span></div><div class=\"line\">        in.close();  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>BufferedInputStream和BufferedOutputStream就是提供了这样的缓冲策略，其内部默认分配了一个默认大小的字节数组，或者在read方法中传入一个字节数组，每次一个byte一个byte的读，然后将读出来的内容写进outPutStream。读到-1就是文件终止(EOF)。具体原理可以参考IBM的<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html\">深入分析 Java I/O 的工作机制</a>。<br>那么问题来了，buffer[]作为一个字节数组，其容量是恒定的。假设我们想要一次性读取特别多的数据怎么办。例如http的response header一般长这样,然而实际上在无线电传播的过程中，每一行的后面都跟了一个换行符’\\r\\n’,而且无线电传播的时候其实根本没有换行的概念，就是一个字节跟着一个字节。假如服务器自己定义了特别长的header字段，inputstream读到这里的时候，事先预设的字节数组(没法改了)装不下，一种简单粗暴的方式是尝试扩容，这就意味着要把数据从原始数组copy到新的数组，丢掉旧的数组，把指针指向新的数组(一个是allocate数组，一个是arrayCopy，这俩都造成了性能损耗),当然jdk肯定不是这么干的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Bdpagetype: 1</div><div class=\"line\">Bdqid: 0xc8f942640001e753</div><div class=\"line\">Bduserid: 0</div><div class=\"line\">Cache-Control: private</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Type: text/html; charset=utf-8</div><div class=\"line\">Date: Fri, 21 Jul 2017 15:35:58 GMT</div><div class=\"line\">Expires: Fri, 21 Jul 2017 15:35:29 GMT</div><div class=\"line\">Server: BWS/1.1</div><div class=\"line\">Set-Cookie: BDSVRTM=0; path=/</div><div class=\"line\">Set-Cookie: BD_HOME=0; path=/</div><div class=\"line\">Set-Cookie: H_PS_PSSID=1428_21110_20930; path=/; domain=.baidu.com</div><div class=\"line\">Strict-Transport-Security: max-age=172800</div><div class=\"line\">Vary: Accept-Encoding</div><div class=\"line\">X-Powered-By: HPHP</div><div class=\"line\">X-Ua-Compatible: IE=Edge,chrome=1</div><div class=\"line\">Transfer-Encoding: chunked</div></pre></td></tr></table></figure></p>\n<p>对于Http这种频繁的读写操作，allocate数组和copy数据无形中减慢了网络访问的速度。</p>\n<ul>\n<li>Okio的解决方案<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Buffer buffer = new Buffer();//cheap ,allocation literal nothing</div><div class=\"line\">buffer.writeUtf8(&quot;Hello Okio&quot;); //java中一个英文字符占一个字节(byte)，一个汉字占2个字节(byte)</div><div class=\"line\">buffer.writeUtf8(&quot;you can &quot;); //可以想象segment中被塞进了&quot;you can &quot;这几个byte</div><div class=\"line\">buffer.writeUtf8(&quot;Go faster&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Okio将读写操作集中到到Buffer这个类中，用Sink和Source分别代表数据的去向和来源。而数据的承载类是Segment,读取数据(read)的时候从SegmentPool中索取Segment，读到Segment的byte[]数组中，装不下了再拿一个Segment。这个过程中是没有 new byte[]操作的。</p>\n<ul>\n<li>Read from a source， write to a sink</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">BufferedSource</span>, <span class=\"title\">BufferedSink</span>, <span class=\"title\">Cloneable</span> </span>&#123;</div><div class=\"line\">    Segment head;</div><div class=\"line\">    <span class=\"keyword\">long</span> size;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Buffer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//构造函数里不分配任何对象，所以创建一个Buffer几乎没有什么性能开销</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">8192</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHARE_MINIMUM = <span class=\"number\">1024</span>;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] data;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos;</div><div class=\"line\">    <span class=\"keyword\">int</span> limit;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> shared;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> owner;</div><div class=\"line\">    Segment next;</div><div class=\"line\">    Segment prev;  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在那个读取一个文件写到另一个文件的程序可以写成这样:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sink = Okio.sink(dstFile);  <span class=\"comment\">//返回了一个Sink匿名类，write的时候使用public void write(Buffer source, long byteCount)方法进行写操作</span></div><div class=\"line\">source = Okio.source(srcFile);</div><div class=\"line\">   Buffer buf = <span class=\"keyword\">new</span> Buffer();</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> readCount; (readCount = source.read(buf, <span class=\"number\">2048</span>)) != -<span class=\"number\">1</span>; ) &#123;</div><div class=\"line\">      sink.write(buf, readCount);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>看起来还是在数据源和数据终点之间塞了一个缓冲层，sink(dst)和source(src)都是接口，Buffer同时实现了这俩接口。<br>write是从外面拿数据塞到自己的数组中，所以每次写的时候或让Buffer的Size变大(从segment pool中借用segment)。Buffer(Source)的read方法是把数据从Buffer中拿出来，所以会让Buffer的size变小(每一个Segment读完了会返回到segment pool中)<br>在Buffer的所有readXXX方法中都能看到这么一句话<br> <strong>SegmentPool.recycle(segment)</strong><br>因为Buffer内部是通过Segment的next和prev实现了双向链表，write是在尾部添加数据，read是从头部读取数据并移除。</p>\n<p><strong>Okio能够实现高效率的核心在于,在java的inputStream和BufferedInputStream中，如果两块缓冲区之间想要交换数据。前面提到的扩容情况，从一个数组把数据复制到另一个更大的数组，必须走arrayCopy。</strong><br>网上查找了很多博客，总的来说就是java io采用了装饰者模式，不同Stream之间要包一层。<br>写数据时，写原始数据要用DataOutputStream，使用带缓冲的写要用BuffedOutputStream，使用字符编码要用OutputStreamWriter,写字节数组有ByteArrayOutputStream。<br>读数据时也是，原始数据要用DataInputStream，带缓冲的要用BufferedInputStream,字符编码要用InputStreamReader，读字节数有ByteArrayInputStream。</p>\n<p>来看下其中带buffer的装饰类是怎么创建的，顺便把java io批判一下。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteArrayOutPutStream baos = <span class=\"keyword\">new</span> ByteArrayOutPutStream();</div><div class=\"line\">ByteArrayInputStream bis = <span class=\"keyword\">new</span> ByteArrayInputStream(baos.toByteAarray()); <span class=\"comment\">//toByteArry内部调用了Arrays.copyOf()，创建了新对象</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in, <span class=\"keyword\">int</span> size)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(in);</div><div class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Buffer size &lt;= 0\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[size]; <span class=\"comment\">//创建新数组</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BufferedOutputStream</span><span class=\"params\">(OutputStream out, <span class=\"keyword\">int</span> size)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(out);</div><div class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Buffer size &lt;= 0\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[size]; <span class=\"comment\">//创建数组</span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>同样的事情在okio中是这么干的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">RealBufferedSource(Source source) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span>(source == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"source == null\"</span>);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">this</span>.source = source; <span class=\"comment\">//其实是buffer</span></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  RealBufferedSink(Sink sink) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span>(sink == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"sink == null\"</span>);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">this</span>.sink = sink; <span class=\"comment\">//只是挪一下指针</span></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>由于一个Buffer即是source也是sink，挪一下指针就行了。写的时候往链表的尾巴写，读的时候从链表的头部读，读完了segment回收。</p>\n<p>BufferedInputStream要求外部调用者带着一个固定大小的byte数组来取数据，难免会有人传进来一个特别小的数组，这样永远不可能读取超过这个数组大小长度的某一行。</p>\n<p>BufferedSource在读取Socket数据时，一边从socket里面拿一个Segment大小的数据，然后调用readInt,readLong等方法返回int,long(同时从segment头部清空数据)。如果读到segment最后发现剩下的byte不能组成一个int，就会从segment pool中借一个segment，并从socket中读取数据塞满，把第一个segment剩下的一点byte和第二个segment的头部一点拼成一个int。以BufferSource的readInt为例:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">readInt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size &lt; <span class=\"number\">4L</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"size &lt; 4: \"</span> + <span class=\"keyword\">this</span>.size);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        Segment segment = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">        <span class=\"keyword\">int</span> pos = segment.pos;</div><div class=\"line\">        <span class=\"keyword\">int</span> limit = segment.limit;</div><div class=\"line\">        <span class=\"keyword\">if</span>(limit - pos &lt; <span class=\"number\">4</span>) &#123; <span class=\"comment\">//一个int 4个byte,这时候segment中未读的数据只剩下不到4个了</span></div><div class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">24</span> | (<span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">16</span> | (<span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>; <span class=\"comment\">//readByte就是从链表的头部开始一个byte一个byte的读，segment读完了自动回收，直到组成一个int。</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//剩下的byte足够组成一个int</span></div><div class=\"line\">            <span class=\"keyword\">byte</span>[] data = segment.data;</div><div class=\"line\">            <span class=\"keyword\">int</span> i = (data[pos++] &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">24</span> | (data[pos++] &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">16</span> | (data[pos++] &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">8</span> | data[pos++] &amp; <span class=\"number\">255</span>; <span class=\"comment\">//从byte转int</span></div><div class=\"line\">            <span class=\"keyword\">this</span>.size -= <span class=\"number\">4L</span>; </div><div class=\"line\">            <span class=\"keyword\">if</span>(pos == limit) &#123;</div><div class=\"line\">                <span class=\"keyword\">this</span>.head = segment.pop();</div><div class=\"line\">                SegmentPool.recycle(segment); <span class=\"comment\">//读完了就把segment回收</span></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                segment.pos = pos;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> i;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一个很有意思的现象是，java BufferedInputStream的默认buffer数组大小是8192，okio 的segment的默认size也是8192，这些都是以byte为单位的。找到一个合理的<a href=\"https://stackoverflow.com/questions/37404068/why-is-the-default-char-buffer-size-of-bufferedreader-8192\">解释</a>。大致意思是8192 = 2^13, windows和linux上这个大小正好占用两个分页文件(8kB)。另外java io的类图确实让人眼花缭乱。</p>\n<h2 id=\"2-OkHttp的解析\"><a href=\"#2-OkHttp的解析\" class=\"headerlink\" title=\"2. OkHttp的解析\"></a>2. OkHttp的解析</h2><h3 id=\"2-1-使用介绍\"><a href=\"#2-1-使用介绍\" class=\"headerlink\" title=\"2.1 使用介绍\"></a>2.1 使用介绍</h3><p>先上一张图<img src=\"http://odzl05jxx.bkt.clouddn.com/okHttp_chain.JPG\" alt=\"\">。这是最简单的直接用OkHttpClient请求<a href=\"http://www.baidu.com\">百度首页</a>的堆栈调用情况。在没有做任何手动配置的情况下，至少发现了五个Interceptor:</p>\n<p> RetryAndFollowUpInterceptor<br> BridgeInterceptor<br> CacheInterceptor<br> ConnectInterceptor<br> CallServerInterceptor</p>\n<p> 走到CallServerInterceptor的时候，可以看到Response已经形成了。每一个Interceptor之间还有一个RealInterceptorChain，将各个Interceptor串联起来，</p>\n<p>首先是调用者的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">mClient = <span class=\"keyword\">new</span> OkHttpClient()</div><div class=\"line\"><span class=\"comment\">//同步执行</span></div><div class=\"line\"> Request request = <span class=\"keyword\">new</span> Request.Builder()</div><div class=\"line\">                .url(<span class=\"string\">\"http:www.baidu.com\"</span>)</div><div class=\"line\">                .build();</div><div class=\"line\">        Call call = mClient.newCall(request);</div><div class=\"line\">        Response response = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            response = call.execute();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//异步执行代码</span></div><div class=\"line\"> Request request = <span class=\"keyword\">new</span> Request.Builder()</div><div class=\"line\">                .url(<span class=\"string\">\"http:www.baidu.com\"</span>)</div><div class=\"line\">                .build();</div><div class=\"line\">        Call call = mClient.newCall(request);</div><div class=\"line\">        </div><div class=\"line\">        call.enqueue(<span class=\"keyword\">new</span> Callback() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> </span>&#123;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-参数配置\"><a href=\"#2-2-参数配置\" class=\"headerlink\" title=\"2.2 参数配置\"></a>2.2 参数配置</h3><p>首先Request.Builder().build()方法，这里面只是使用Builder模式，和Retrofit很相似，方便链式调用。最终调用了Request的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request(Request.Builder builder) &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.url = builder.url; <span class=\"comment\">//HttpUrl类型</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.method = builder.method; <span class=\"comment\">//String类型</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.headers = builder.headers.build(); <span class=\"comment\">//header就是个字典，内部用一个String数组维护。</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.body = builder.body;<span class=\"comment\">// RequestBody类型，用于POST提交表单或者Multipart上传文件。</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.tag = builder.tag != <span class=\"keyword\">null</span>?builder.tag:<span class=\"keyword\">this</span>; <span class=\"comment\">//Object类型</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>Request里面的成员代表了一个网络请求所应该有的一切可能的元素，没什么可说的。<br>OkHttpClient的构造也是Builder模式，一旦创建了不能setXX.找到一个比较丰富的例子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">                          .retryOnConnectionFailure(<span class=\"keyword\">true</span>)</div><div class=\"line\">                          .connectTimeout(<span class=\"number\">15</span>, TimeUnit.SECONDS)</div><div class=\"line\">                          <span class=\"comment\">//设置缓存</span></div><div class=\"line\">                          .cache(cache)</div><div class=\"line\">                          .build();</div></pre></td></tr></table></figure></p>\n<p>到这里都还只是发起真正的请求之前的configuration阶段，来看发起RealCall的过程</p>\n<p> Call call = mClient.newCall(request);<br> 这里面初始化了一个RetryAndFollowUpInterceptor。这个拦截器的作用是在连接server失败后自动重连，但服务器500就不会重连,参考<a href=\"https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace\">okhttp-is-quietly-retrying-requests-is-your-api-ready</a></p>\n<h3 id=\"2-3-开始执行请求\"><a href=\"#2-3-开始执行请求\" class=\"headerlink\" title=\"2.3 开始执行请求\"></a>2.3 开始执行请求</h3><p>response = call.execute();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.executed = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Response var2;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.client.dispatcher().executed(<span class=\"keyword\">this</span>); <span class=\"comment\">//这个Dispatcher负责记录当前OkHttpClient的所有Request的状态，提供线程池</span></div><div class=\"line\">        Response result = <span class=\"keyword\">this</span>.getResponseWithInterceptorChain();</div><div class=\"line\">        <span class=\"keyword\">if</span>(result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var2 = result;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.client.dispatcher().finished(<span class=\"keyword\">this</span>); <span class=\"comment\">//记录状态</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> var2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重点就在getResponseWithInterceptorChain里面<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">       List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList();</div><div class=\"line\">       interceptors.addAll(<span class=\"keyword\">this</span>.client.interceptors());</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">this</span>.retryAndFollowUpInterceptor);</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(<span class=\"keyword\">this</span>.client.cookieJar()));</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(<span class=\"keyword\">this</span>.client.internalCache()));</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(<span class=\"keyword\">this</span>.client));</div><div class=\"line\">       <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.forWebSocket) &#123; </div><div class=\"line\">           interceptors.addAll(<span class=\"keyword\">this</span>.client.networkInterceptors()); </div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(<span class=\"keyword\">this</span>.forWebSocket));</div><div class=\"line\">       Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, (StreamAllocation)<span class=\"keyword\">null</span>, (HttpCodec)<span class=\"keyword\">null</span>, (RealConnection)<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>.originalRequest);</div><div class=\"line\">       <span class=\"keyword\">return</span> chain.proceed(<span class=\"keyword\">this</span>.originalRequest);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>注意顺序，用户手动添加的interceptor是最先添加的。在添加完ConnectInterceptor之后，又添加了networkInterceptors(用户手动添加的，一个List)。道理也很清楚，一种是在发起Socket请求之前就拦下来，一种是连上Socket之后的拦截</p>\n<p>Chain的proceed就是从List中一个个取出Inerceptor，然后执行</p>\n<h2 id=\"3-自带的五个Interceptor\"><a href=\"#3-自带的五个Interceptor\" class=\"headerlink\" title=\"3. 自带的五个Interceptor\"></a>3. 自带的五个Interceptor</h2><h3 id=\"3-1-RetryAndFollowUpInterceptor\"><a href=\"#3-1-RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"3.1 RetryAndFollowUpInterceptor\"></a>3.1 RetryAndFollowUpInterceptor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">while(!this.canceled) &#123;</div><div class=\"line\">        Response response = null;</div><div class=\"line\">        boolean releaseConnection = true;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            response = ((RealInterceptorChain)chain).proceed(request, this.streamAllocation, (HttpCodec)null, (RealConnection)null);</div><div class=\"line\">            releaseConnection = false;</div><div class=\"line\">        &#125; catch (RouteException var13) &#123;</div><div class=\"line\">            releaseConnection = false;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125; catch (IOException var14) &#123;</div><div class=\"line\">            releaseConnection = false;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            if(releaseConnection) &#123;</div><div class=\"line\">                this.streamAllocation.streamFailed((IOException)null);</div><div class=\"line\">                this.streamAllocation.release();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        Request followUp = this.followUpRequest(response);</div><div class=\"line\">        if(followUp == null) &#123;</div><div class=\"line\">            return response; </div><div class=\"line\">        &#125;</div><div class=\"line\">        ++followUpCount;</div><div class=\"line\">        if(followUpCount &gt; 20) &#123; </div><div class=\"line\">            this.streamAllocation.release();</div><div class=\"line\">            throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这里面写死了一个循环，只要没有cancel，catch到特定的Exception就一直让链条走下去。</p>\n<h3 id=\"3-2-BridgeInterceptor\"><a href=\"#3-2-BridgeInterceptor\" class=\"headerlink\" title=\"3.2 BridgeInterceptor\"></a>3.2 BridgeInterceptor</h3><p>这是第二个Interceptor<br>interceptors.add(new BridgeInterceptor(this.client.cookieJar()));//注意带进来了cookie，主要都是添加header什么的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Request userRequest = chain.request();</div><div class=\"line\">     <span class=\"keyword\">if</span>(userRequest.header(<span class=\"string\">\"Host\"</span>) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        requestBuilder.header(<span class=\"string\">\"Host\"</span>, Util.hostHeader(userRequest.url(), <span class=\"keyword\">false</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    Response networkResponse = chain.proceed(requestBuilder.build());</div><div class=\"line\"></div><div class=\"line\">    okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> responseBuilder.build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>都是些Host,Connection Keep-Alive,User-Agent,Content-Length等跟header有关的东西。随后将request交给链条的下一个interceptor。Response回来之后相应set-Cookie这些东西，下次请求带上cookie，这些都是Http的标准步骤。</p>\n<h3 id=\"3-3-CacheInterceptor\"><a href=\"#3-3-CacheInterceptor\" class=\"headerlink\" title=\"3.3 CacheInterceptor\"></a>3.3 CacheInterceptor</h3><p>接下来轮到cache，对于response的处理也是差不多的过程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Response cacheCandidate = <span class=\"keyword\">this</span>.cache != <span class=\"keyword\">null</span>?<span class=\"keyword\">this</span>.cache.get(chain.request()):<span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    Request networkRequest = strategy.networkRequest;</div><div class=\"line\">    Response cacheResponse = strategy.cacheResponse;</div><div class=\"line\">   </div><div class=\"line\">        Response networkResponse = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">     networkResponse = chain.proceed(networkRequest); </div><div class=\"line\"></div><div class=\"line\">        Response response;</div><div class=\"line\">        <span class=\"keyword\">if</span>(cacheResponse != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(networkResponse.code() == <span class=\"number\">304</span>) &#123;</div><div class=\"line\">                response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class=\"line\">                networkResponse.body().close();</div><div class=\"line\">                <span class=\"keyword\">this</span>.cache.trackConditionalCacheHit();</div><div class=\"line\">                <span class=\"keyword\">this</span>.cache.update(cacheResponse, response);</div><div class=\"line\">                <span class=\"keyword\">return</span> response; <span class=\"comment\">//只针对304做了自动cache</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            Util.closeQuietly(cacheResponse.body());</div><div class=\"line\">        &#125;</div><div class=\"line\">        response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class=\"line\">        <span class=\"keyword\">return</span> response;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里也是让请求接着走下去，response回来之后，只有304的时候才会去主动cache下来。</p>\n<h3 id=\"3-4-ConnectInterceptor\"><a href=\"#3-4-ConnectInterceptor\" class=\"headerlink\" title=\"3.4 ConnectInterceptor\"></a>3.4 ConnectInterceptor</h3><p>这里的interceptor方法异常简短<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain)chain;</div><div class=\"line\">    Request request = realChain.request();</div><div class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</div><div class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(<span class=\"keyword\">this</span>.client, doExtensiveHealthChecks);</div><div class=\"line\">    RealConnection connection = streamAllocation.connection();</div><div class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里重点关注 StreamAllocation这个类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamAllocation</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Address address;</div><div class=\"line\">    <span class=\"keyword\">private</span> Route route;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnectionPool connectionPool;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object callStackTrace;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RouteSelector routeSelector;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> refusedStreamCount;</div><div class=\"line\">    <span class=\"keyword\">private</span> RealConnection connection;</div><div class=\"line\">    <span class=\"keyword\">private</span> HttpCodec codec;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>从HttpCodec httpCodec = streamAllocation.newStream(this.client, doExtensiveHealthChecks); 这句话一直往下走，会走到Socket.connect()，也就是大多数人初学网络编程时被教导的如何创建Socket连接。现在想想，能够从操作系统底层的Socket封装出这么多复杂的步骤，实在是高手。<br>StreamAllocation.newStream  —-&gt; StreamAllocation.findHealthyConnection  —&gt; StreamAallocation.findConnection —&gt; new RealConnection —&gt; RealConnection.connect </p>\n<p>RealConnection.connect()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.protocol != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"already connected\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.route.requiresTunnel()) &#123;</div><div class=\"line\">                        <span class=\"keyword\">this</span>.connectTunnel(connectTimeout, readTimeout, writeTimeout);</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        <span class=\"keyword\">this</span>.connectSocket(connectTimeout, readTimeout);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException var11) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span>(!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(var11)) &#123;</div><div class=\"line\">                        <span class=\"keyword\">throw</span> routeException; <span class=\"comment\">//这个Exception就是给RetryAndFollowupInterceptor准备的</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">           </div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>最初学习Socket编程的时候，就是写了一个while(true)，是不是很像？</p>\n<p>对了ConnectionPool内部使用了一个Deque保存RealConnection,findConnection里面有这么一段</p>\n<ul>\n<li>Internal.instance.get(this.connectionPool, this.address, this, (Route)null);//查找</li>\n<li>Internal.instance.put(this.connectionPool, result);//放进pool</li>\n</ul>\n<p>connectSocket长这样:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">connectSocket</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Proxy proxy = <span class=\"keyword\">this</span>.route.proxy();</div><div class=\"line\">    Address address = <span class=\"keyword\">this</span>.route.address();</div><div class=\"line\">    <span class=\"keyword\">this</span>.rawSocket = proxy.type() != Type.DIRECT &amp;&amp; proxy.type() != Type.HTTP?<span class=\"keyword\">new</span> Socket(proxy):address.socketFactory().createSocket();</div><div class=\"line\">    <span class=\"keyword\">this</span>.rawSocket.setSoTimeout(readTimeout);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Platform.get().connectSocket(<span class=\"keyword\">this</span>.rawSocket, <span class=\"keyword\">this</span>.route.socketAddress(), connectTimeout); <span class=\"comment\">//这里面就一句话socket.connect</span></div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ConnectException var7) &#123;</div><div class=\"line\">        ConnectException ce = <span class=\"keyword\">new</span> ConnectException(<span class=\"string\">\"Failed to connect to \"</span> + <span class=\"keyword\">this</span>.route.socketAddress());</div><div class=\"line\">        ce.initCause(var7);</div><div class=\"line\">        <span class=\"keyword\">throw</span> ce;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.source = Okio.buffer(Okio.source(<span class=\"keyword\">this</span>.rawSocket)); </div><div class=\"line\">        <span class=\"keyword\">this</span>.sink = Okio.buffer(Okio.sink(<span class=\"keyword\">this</span>.rawSocket));</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NullPointerException var8) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"throw with null exception\"</span>.equals(var8.getMessage())) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(var8);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>重点看</strong><br>this.source = Okio.buffer(Okio.source(this.rawSocket));<br>this.sink = Okio.buffer(Okio.sink(this.rawSocket));<br>通过sink往Socket里面写数据，通过source网Socket里面写数据，通过Okio包装了，虽然本质上还是socket.getOutputStream和Socket.getInputStream。到这一步，RealConnection内部sink和source初始化完成，socket已经连接上，Socket的inputStream和outPutStream都准备就绪。其实在这种状态下就已经可以开始读写了。</p>\n<h3 id=\"3-5-CallServerInterceptor\"><a href=\"#3-5-CallServerInterceptor\" class=\"headerlink\" title=\"3.5 CallServerInterceptor\"></a>3.5 CallServerInterceptor</h3><p>这里已经连上了服务器，可以像操作本地文件一样读写数据了，当然要在遵守http规范的前提下。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain)chain;</div><div class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</div><div class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class=\"line\">    RealConnection connection = (RealConnection)realChain.connection();</div><div class=\"line\">    Request request = realChain.request();</div><div class=\"line\">    <span class=\"comment\">//可以看到，到这一步所需要的数据都准备就绪</span></div><div class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    httpCodec.writeRequestHeaders(request); <span class=\"comment\">//开始写数据</span></div><div class=\"line\"></div><div class=\"line\">    Builder responseBuilder = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//这里面是跟POST相关的</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</div><div class=\"line\">            httpCodec.flushRequest();</div><div class=\"line\">            responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(responseBuilder == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class=\"line\">            BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class=\"line\">            request.body().writeTo(bufferedRequestBody); <span class=\"comment\">//这里就是Okio发挥高效的地方</span></div><div class=\"line\">            bufferedRequestBody.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!connection.isMultiplexed()) &#123;</div><div class=\"line\">            streamAllocation.noNewStreams();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    httpCodec.finishRequest(); <span class=\"comment\">//到这里，client的数据全部写完并且发送给服务器，服务器开始干活。</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(responseBuilder == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>); <span class=\"comment\">//开始从Socket里面读取数据</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</div><div class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</div><div class=\"line\">        response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>)) || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</div><div class=\"line\">        streamAllocation.noNewStreams();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0L</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(<span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> response;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里面就是一步步的开始写数据了。这里再借用下百度,chrome按下F12，打开百度首页，看下request的raw header<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Host: www.baidu.com</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Cache-Control: max-age=0</div><div class=\"line\">Upgrade-Insecure-Requests: 1</div><div class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class=\"line\">DNT: 1</div><div class=\"line\">Accept-Encoding: gzip, deflate, br</div><div class=\"line\">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</div><div class=\"line\">Cookie: PSTM=122178321; BIDUPSID=CF3243290400VSDG52B3859AD4AEC2; BAIDUID=5176CC0A23DB1F3423426454DRTG5EC8:FG=1; MCITY=-%3A; BD_HOME=0; H_PS_PSSID=1428_24320_20930; BD_UPN=1223214323</div></pre></td></tr></table></figure></p>\n<p>看下httpCodec.writeRequestHeaders(request)的实现，就会发现真的是这么一行一行的写的<br>例如RequestLine.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">get</span><span class=\"params\">(Request request, Type proxyType)</span> </span>&#123;</div><div class=\"line\">       StringBuilder result = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">       result.append(request.method()); <span class=\"comment\">// GET </span></div><div class=\"line\">       result.append(<span class=\"string\">' '</span>); <span class=\"comment\">//空格</span></div><div class=\"line\">       <span class=\"keyword\">if</span>(includeAuthorityInRequestLine(request, proxyType)) &#123;</div><div class=\"line\">           result.append(request.url());</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           result.append(requestPath(request.url()));  <span class=\"comment\">//我们访问的是百度首页，当然是'/'这个Index啦</span></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       result.append(<span class=\"string\">\" HTTP/1.1\"</span>);  <span class=\"comment\">//是不是和上面一模一样</span></div><div class=\"line\">       <span class=\"keyword\">return</span> result.toString();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来轮到Http1Codec.class<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequest</span><span class=\"params\">(Headers headers, String requestLine)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"state: \"</span> + <span class=\"keyword\">this</span>.state);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.sink.writeUtf8(requestLine).writeUtf8(<span class=\"string\">\"\\r\\n\"</span>); <span class=\"comment\">//这是第一行，写完了加上换行符</span></div><div class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> size = headers.size(); i &lt; size; ++i) &#123;</div><div class=\"line\">                <span class=\"keyword\">this</span>.sink.writeUtf8(headers.name(i)).writeUtf8(<span class=\"string\">\": \"</span>).writeUtf8(headers.value(i)).writeUtf8(<span class=\"string\">\"\\r\\n\"</span>); <span class=\"comment\">//一个header写完就写一个换行符</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">this</span>.sink.writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">this</span>.state = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读取Response的顺序和写Request相反，不再赘述。</p>\n<h2 id=\"4-结语\"><a href=\"#4-结语\" class=\"headerlink\" title=\"4.结语\"></a>4.结语</h2><p>这里只是针对OkHttp发起的一个最简单同步的网络请求进行了分析。<br>关于异步请求再说两句：本质上不过是包装了一个回调，丢到线程池里面，相比整个Http请求，实在是不值一提。来看下这个线程池</p>\n<ul>\n<li>new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(“OkHttp Dispatcher”, false));</li>\n</ul>\n<p>照说jdk不推荐这么创建线程池，一般用jdk封装好的CachedThreadPool，FixedThreadPool等等，但想必这样做也是不为了造成过大的系统开销吧。debug的时候如果看到OkHttp Dispatcher这条线程，应该明白是为什么了吧。另外，Okio会引入一条名为Okio WatchDog的线程，这跟Okio的AsyncTimeOut有关。时间关系(已经是夜里12点了)，不打算研究了。</p>\n<p>OkHttp总量过于庞大，很多方面，包括spdy,webSocket,RouterDatabase,DNS,网络执行周期触发回调，http2，http协议，太多太多，再研究一天也看不完。</p>\n<p>拎出来几个比较重要的点吧：</p>\n<ul>\n<li>Okio放在最前面，就是为了说明在网络请求这样对于io性能要求高的场合，okio避免了memory allocation和不必要的缓存复制。</li>\n<li>OkHttpClient应该是对标apache的HttpClient的，后者不清楚。</li>\n<li>底层还是调用操作系统的Socket接口，从这个角度来看，Retrofit只是一个Util，包括线程调度都是用的OkHttp的线程池；Volley我记得默认是4条NetWorkDispatcher和一个CacheDispatcher和一个ContentDelivery。</li>\n<li>不推荐创建多个OkHttpClient，真想创建多个的话，用newBuilder(浅复制)就好了嘛。</li>\n<li>网上说Picaso内部的cache其实就是OkHttp的cache，不愧square全家桶系列</li>\n<li>和Retrofit一样，也是用的Builder模式，提供了极大的自定义空间</li>\n<li>Interceptor，广受业界好评的责任链模式</li>\n</ul>\n<p>写于2017年7月23日0:29</p>\n<h2 id=\"5-参考\"><a href=\"#5-参考\" class=\"headerlink\" title=\"5. 参考\"></a>5. 参考</h2><ul>\n<li><a href=\"https://blog.piasy.com/2016/07/11/Understand-OkHttp/\">Paisy</a></li>\n<li><a href=\"http://frodoking.github.io/2015/03/12/android-okhttp/\">Frodo系列</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=WvyScM_S88c\">A few ok library</a></li>\n<li><a href=\"http://jakewharton.com/forcing-bytes-downward-in-okio/\">Forcing bytes downward in Okio</a></li>\n</ul>\n","excerpt":"<p>很早的时候就知道，OkHttp在io层面上的操作是由Okio代为完成的，所以实际意义上和Socket打交道的应该是Okio。而Okio又比传统的java io要高效。所以，在分析OkHttp之前，有必要针对Okio的一些方法进行展开，作为后面读写操作的铺垫。</p>\n<p>Okio -&gt; OkHttp -&gt; Picaso  -&gt; Retrofit<br>Okio版本 1.13.0<br>OkHttp版本 3.8.0</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/6da83b3b20094b044a320d1e89dfcd00.jpg?imageView2/2/w/600\" alt=\"\"><br>","more":"</p>\n<h2 id=\"1-Okio与java-io相比的优势\"><a href=\"#1-Okio与java-io相比的优势\" class=\"headerlink\" title=\"1. Okio与java io相比的优势\"></a>1. Okio与java io相比的优势</h2><p>java的InputStream可以被查看成是一个数据的来源，调用read方法从中读取数据。由于有些文件特别大，我们不可能在内存中分配一个和文件大小一样大的字节数组来专门来读写文件。因此需要传入一个缓冲数组。所以一般的读写程序的代码是这么写的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span></span>&#123;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 指定要读取文件的缓冲输入字节流  </span></div><div class=\"line\">        BufferedInputStream in = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"F:\\\\test.jpg\"</span>));  </div><div class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"E:\\\\test.jpg\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            file.createNewFile();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"comment\">// 指定要写入文件的缓冲输出字节流  </span></div><div class=\"line\">        BufferedOutputStream out = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(file));  </div><div class=\"line\">        <span class=\"keyword\">byte</span>[] bb = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">// 用来存储每次读取到的字节数组  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> n;<span class=\"comment\">// 每次读取到的字节数组的长度  </span></div><div class=\"line\">        <span class=\"keyword\">while</span> ((n = in.read(bb)) != -<span class=\"number\">1</span>) &#123;  </div><div class=\"line\">            out.write(bb, <span class=\"number\">0</span>, n);<span class=\"comment\">// 写入到输出流  </span></div><div class=\"line\">        &#125;  </div><div class=\"line\">        out.close();<span class=\"comment\">// 关闭流  </span></div><div class=\"line\">        in.close();  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>BufferedInputStream和BufferedOutputStream就是提供了这样的缓冲策略，其内部默认分配了一个默认大小的字节数组，或者在read方法中传入一个字节数组，每次一个byte一个byte的读，然后将读出来的内容写进outPutStream。读到-1就是文件终止(EOF)。具体原理可以参考IBM的<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html\">深入分析 Java I/O 的工作机制</a>。<br>那么问题来了，buffer[]作为一个字节数组，其容量是恒定的。假设我们想要一次性读取特别多的数据怎么办。例如http的response header一般长这样,然而实际上在无线电传播的过程中，每一行的后面都跟了一个换行符’\\r\\n’,而且无线电传播的时候其实根本没有换行的概念，就是一个字节跟着一个字节。假如服务器自己定义了特别长的header字段，inputstream读到这里的时候，事先预设的字节数组(没法改了)装不下，一种简单粗暴的方式是尝试扩容，这就意味着要把数据从原始数组copy到新的数组，丢掉旧的数组，把指针指向新的数组(一个是allocate数组，一个是arrayCopy，这俩都造成了性能损耗),当然jdk肯定不是这么干的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Bdpagetype: 1</div><div class=\"line\">Bdqid: 0xc8f942640001e753</div><div class=\"line\">Bduserid: 0</div><div class=\"line\">Cache-Control: private</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Type: text/html; charset=utf-8</div><div class=\"line\">Date: Fri, 21 Jul 2017 15:35:58 GMT</div><div class=\"line\">Expires: Fri, 21 Jul 2017 15:35:29 GMT</div><div class=\"line\">Server: BWS/1.1</div><div class=\"line\">Set-Cookie: BDSVRTM=0; path=/</div><div class=\"line\">Set-Cookie: BD_HOME=0; path=/</div><div class=\"line\">Set-Cookie: H_PS_PSSID=1428_21110_20930; path=/; domain=.baidu.com</div><div class=\"line\">Strict-Transport-Security: max-age=172800</div><div class=\"line\">Vary: Accept-Encoding</div><div class=\"line\">X-Powered-By: HPHP</div><div class=\"line\">X-Ua-Compatible: IE=Edge,chrome=1</div><div class=\"line\">Transfer-Encoding: chunked</div></pre></td></tr></table></figure></p>\n<p>对于Http这种频繁的读写操作，allocate数组和copy数据无形中减慢了网络访问的速度。</p>\n<ul>\n<li>Okio的解决方案<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Buffer buffer = new Buffer();//cheap ,allocation literal nothing</div><div class=\"line\">buffer.writeUtf8(&quot;Hello Okio&quot;); //java中一个英文字符占一个字节(byte)，一个汉字占2个字节(byte)</div><div class=\"line\">buffer.writeUtf8(&quot;you can &quot;); //可以想象segment中被塞进了&quot;you can &quot;这几个byte</div><div class=\"line\">buffer.writeUtf8(&quot;Go faster&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Okio将读写操作集中到到Buffer这个类中，用Sink和Source分别代表数据的去向和来源。而数据的承载类是Segment,读取数据(read)的时候从SegmentPool中索取Segment，读到Segment的byte[]数组中，装不下了再拿一个Segment。这个过程中是没有 new byte[]操作的。</p>\n<ul>\n<li>Read from a source， write to a sink</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">BufferedSource</span>, <span class=\"title\">BufferedSink</span>, <span class=\"title\">Cloneable</span> </span>&#123;</div><div class=\"line\">    Segment head;</div><div class=\"line\">    <span class=\"keyword\">long</span> size;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Buffer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//构造函数里不分配任何对象，所以创建一个Buffer几乎没有什么性能开销</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">8192</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHARE_MINIMUM = <span class=\"number\">1024</span>;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] data;</div><div class=\"line\">    <span class=\"keyword\">int</span> pos;</div><div class=\"line\">    <span class=\"keyword\">int</span> limit;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> shared;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> owner;</div><div class=\"line\">    Segment next;</div><div class=\"line\">    Segment prev;  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在那个读取一个文件写到另一个文件的程序可以写成这样:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sink = Okio.sink(dstFile);  <span class=\"comment\">//返回了一个Sink匿名类，write的时候使用public void write(Buffer source, long byteCount)方法进行写操作</span></div><div class=\"line\">source = Okio.source(srcFile);</div><div class=\"line\">   Buffer buf = <span class=\"keyword\">new</span> Buffer();</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> readCount; (readCount = source.read(buf, <span class=\"number\">2048</span>)) != -<span class=\"number\">1</span>; ) &#123;</div><div class=\"line\">      sink.write(buf, readCount);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>看起来还是在数据源和数据终点之间塞了一个缓冲层，sink(dst)和source(src)都是接口，Buffer同时实现了这俩接口。<br>write是从外面拿数据塞到自己的数组中，所以每次写的时候或让Buffer的Size变大(从segment pool中借用segment)。Buffer(Source)的read方法是把数据从Buffer中拿出来，所以会让Buffer的size变小(每一个Segment读完了会返回到segment pool中)<br>在Buffer的所有readXXX方法中都能看到这么一句话<br> <strong>SegmentPool.recycle(segment)</strong><br>因为Buffer内部是通过Segment的next和prev实现了双向链表，write是在尾部添加数据，read是从头部读取数据并移除。</p>\n<p><strong>Okio能够实现高效率的核心在于,在java的inputStream和BufferedInputStream中，如果两块缓冲区之间想要交换数据。前面提到的扩容情况，从一个数组把数据复制到另一个更大的数组，必须走arrayCopy。</strong><br>网上查找了很多博客，总的来说就是java io采用了装饰者模式，不同Stream之间要包一层。<br>写数据时，写原始数据要用DataOutputStream，使用带缓冲的写要用BuffedOutputStream，使用字符编码要用OutputStreamWriter,写字节数组有ByteArrayOutputStream。<br>读数据时也是，原始数据要用DataInputStream，带缓冲的要用BufferedInputStream,字符编码要用InputStreamReader，读字节数有ByteArrayInputStream。</p>\n<p>来看下其中带buffer的装饰类是怎么创建的，顺便把java io批判一下。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteArrayOutPutStream baos = <span class=\"keyword\">new</span> ByteArrayOutPutStream();</div><div class=\"line\">ByteArrayInputStream bis = <span class=\"keyword\">new</span> ByteArrayInputStream(baos.toByteAarray()); <span class=\"comment\">//toByteArry内部调用了Arrays.copyOf()，创建了新对象</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in, <span class=\"keyword\">int</span> size)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(in);</div><div class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Buffer size &lt;= 0\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[size]; <span class=\"comment\">//创建新数组</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BufferedOutputStream</span><span class=\"params\">(OutputStream out, <span class=\"keyword\">int</span> size)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(out);</div><div class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Buffer size &lt;= 0\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[size]; <span class=\"comment\">//创建数组</span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>同样的事情在okio中是这么干的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">RealBufferedSource(Source source) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span>(source == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"source == null\"</span>);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">this</span>.source = source; <span class=\"comment\">//其实是buffer</span></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  RealBufferedSink(Sink sink) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span>(sink == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"sink == null\"</span>);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">this</span>.sink = sink; <span class=\"comment\">//只是挪一下指针</span></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>由于一个Buffer即是source也是sink，挪一下指针就行了。写的时候往链表的尾巴写，读的时候从链表的头部读，读完了segment回收。</p>\n<p>BufferedInputStream要求外部调用者带着一个固定大小的byte数组来取数据，难免会有人传进来一个特别小的数组，这样永远不可能读取超过这个数组大小长度的某一行。</p>\n<p>BufferedSource在读取Socket数据时，一边从socket里面拿一个Segment大小的数据，然后调用readInt,readLong等方法返回int,long(同时从segment头部清空数据)。如果读到segment最后发现剩下的byte不能组成一个int，就会从segment pool中借一个segment，并从socket中读取数据塞满，把第一个segment剩下的一点byte和第二个segment的头部一点拼成一个int。以BufferSource的readInt为例:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">readInt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size &lt; <span class=\"number\">4L</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"size &lt; 4: \"</span> + <span class=\"keyword\">this</span>.size);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        Segment segment = <span class=\"keyword\">this</span>.head;</div><div class=\"line\">        <span class=\"keyword\">int</span> pos = segment.pos;</div><div class=\"line\">        <span class=\"keyword\">int</span> limit = segment.limit;</div><div class=\"line\">        <span class=\"keyword\">if</span>(limit - pos &lt; <span class=\"number\">4</span>) &#123; <span class=\"comment\">//一个int 4个byte,这时候segment中未读的数据只剩下不到4个了</span></div><div class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">24</span> | (<span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">16</span> | (<span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">8</span> | <span class=\"keyword\">this</span>.readByte() &amp; <span class=\"number\">255</span>; <span class=\"comment\">//readByte就是从链表的头部开始一个byte一个byte的读，segment读完了自动回收，直到组成一个int。</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//剩下的byte足够组成一个int</span></div><div class=\"line\">            <span class=\"keyword\">byte</span>[] data = segment.data;</div><div class=\"line\">            <span class=\"keyword\">int</span> i = (data[pos++] &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">24</span> | (data[pos++] &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">16</span> | (data[pos++] &amp; <span class=\"number\">255</span>) &lt;&lt; <span class=\"number\">8</span> | data[pos++] &amp; <span class=\"number\">255</span>; <span class=\"comment\">//从byte转int</span></div><div class=\"line\">            <span class=\"keyword\">this</span>.size -= <span class=\"number\">4L</span>; </div><div class=\"line\">            <span class=\"keyword\">if</span>(pos == limit) &#123;</div><div class=\"line\">                <span class=\"keyword\">this</span>.head = segment.pop();</div><div class=\"line\">                SegmentPool.recycle(segment); <span class=\"comment\">//读完了就把segment回收</span></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                segment.pos = pos;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> i;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一个很有意思的现象是，java BufferedInputStream的默认buffer数组大小是8192，okio 的segment的默认size也是8192，这些都是以byte为单位的。找到一个合理的<a href=\"https://stackoverflow.com/questions/37404068/why-is-the-default-char-buffer-size-of-bufferedreader-8192\">解释</a>。大致意思是8192 = 2^13, windows和linux上这个大小正好占用两个分页文件(8kB)。另外java io的类图确实让人眼花缭乱。</p>\n<h2 id=\"2-OkHttp的解析\"><a href=\"#2-OkHttp的解析\" class=\"headerlink\" title=\"2. OkHttp的解析\"></a>2. OkHttp的解析</h2><h3 id=\"2-1-使用介绍\"><a href=\"#2-1-使用介绍\" class=\"headerlink\" title=\"2.1 使用介绍\"></a>2.1 使用介绍</h3><p>先上一张图<img src=\"http://odzl05jxx.bkt.clouddn.com/okHttp_chain.JPG\" alt=\"\">。这是最简单的直接用OkHttpClient请求<a href=\"http://www.baidu.com\">百度首页</a>的堆栈调用情况。在没有做任何手动配置的情况下，至少发现了五个Interceptor:</p>\n<p> RetryAndFollowUpInterceptor<br> BridgeInterceptor<br> CacheInterceptor<br> ConnectInterceptor<br> CallServerInterceptor</p>\n<p> 走到CallServerInterceptor的时候，可以看到Response已经形成了。每一个Interceptor之间还有一个RealInterceptorChain，将各个Interceptor串联起来，</p>\n<p>首先是调用者的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">mClient = <span class=\"keyword\">new</span> OkHttpClient()</div><div class=\"line\"><span class=\"comment\">//同步执行</span></div><div class=\"line\"> Request request = <span class=\"keyword\">new</span> Request.Builder()</div><div class=\"line\">                .url(<span class=\"string\">\"http:www.baidu.com\"</span>)</div><div class=\"line\">                .build();</div><div class=\"line\">        Call call = mClient.newCall(request);</div><div class=\"line\">        Response response = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            response = call.execute();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//异步执行代码</span></div><div class=\"line\"> Request request = <span class=\"keyword\">new</span> Request.Builder()</div><div class=\"line\">                .url(<span class=\"string\">\"http:www.baidu.com\"</span>)</div><div class=\"line\">                .build();</div><div class=\"line\">        Call call = mClient.newCall(request);</div><div class=\"line\">        </div><div class=\"line\">        call.enqueue(<span class=\"keyword\">new</span> Callback() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> </span>&#123;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-参数配置\"><a href=\"#2-2-参数配置\" class=\"headerlink\" title=\"2.2 参数配置\"></a>2.2 参数配置</h3><p>首先Request.Builder().build()方法，这里面只是使用Builder模式，和Retrofit很相似，方便链式调用。最终调用了Request的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request(Request.Builder builder) &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.url = builder.url; <span class=\"comment\">//HttpUrl类型</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.method = builder.method; <span class=\"comment\">//String类型</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.headers = builder.headers.build(); <span class=\"comment\">//header就是个字典，内部用一个String数组维护。</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.body = builder.body;<span class=\"comment\">// RequestBody类型，用于POST提交表单或者Multipart上传文件。</span></div><div class=\"line\">       <span class=\"keyword\">this</span>.tag = builder.tag != <span class=\"keyword\">null</span>?builder.tag:<span class=\"keyword\">this</span>; <span class=\"comment\">//Object类型</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>Request里面的成员代表了一个网络请求所应该有的一切可能的元素，没什么可说的。<br>OkHttpClient的构造也是Builder模式，一旦创建了不能setXX.找到一个比较丰富的例子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">                          .retryOnConnectionFailure(<span class=\"keyword\">true</span>)</div><div class=\"line\">                          .connectTimeout(<span class=\"number\">15</span>, TimeUnit.SECONDS)</div><div class=\"line\">                          <span class=\"comment\">//设置缓存</span></div><div class=\"line\">                          .cache(cache)</div><div class=\"line\">                          .build();</div></pre></td></tr></table></figure></p>\n<p>到这里都还只是发起真正的请求之前的configuration阶段，来看发起RealCall的过程</p>\n<p> Call call = mClient.newCall(request);<br> 这里面初始化了一个RetryAndFollowUpInterceptor。这个拦截器的作用是在连接server失败后自动重连，但服务器500就不会重连,参考<a href=\"https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace\">okhttp-is-quietly-retrying-requests-is-your-api-ready</a></p>\n<h3 id=\"2-3-开始执行请求\"><a href=\"#2-3-开始执行请求\" class=\"headerlink\" title=\"2.3 开始执行请求\"></a>2.3 开始执行请求</h3><p>response = call.execute();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.executed = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Response var2;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.client.dispatcher().executed(<span class=\"keyword\">this</span>); <span class=\"comment\">//这个Dispatcher负责记录当前OkHttpClient的所有Request的状态，提供线程池</span></div><div class=\"line\">        Response result = <span class=\"keyword\">this</span>.getResponseWithInterceptorChain();</div><div class=\"line\">        <span class=\"keyword\">if</span>(result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var2 = result;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.client.dispatcher().finished(<span class=\"keyword\">this</span>); <span class=\"comment\">//记录状态</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> var2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重点就在getResponseWithInterceptorChain里面<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">       List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList();</div><div class=\"line\">       interceptors.addAll(<span class=\"keyword\">this</span>.client.interceptors());</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">this</span>.retryAndFollowUpInterceptor);</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(<span class=\"keyword\">this</span>.client.cookieJar()));</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(<span class=\"keyword\">this</span>.client.internalCache()));</div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(<span class=\"keyword\">this</span>.client));</div><div class=\"line\">       <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.forWebSocket) &#123; </div><div class=\"line\">           interceptors.addAll(<span class=\"keyword\">this</span>.client.networkInterceptors()); </div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(<span class=\"keyword\">this</span>.forWebSocket));</div><div class=\"line\">       Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, (StreamAllocation)<span class=\"keyword\">null</span>, (HttpCodec)<span class=\"keyword\">null</span>, (RealConnection)<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>.originalRequest);</div><div class=\"line\">       <span class=\"keyword\">return</span> chain.proceed(<span class=\"keyword\">this</span>.originalRequest);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>注意顺序，用户手动添加的interceptor是最先添加的。在添加完ConnectInterceptor之后，又添加了networkInterceptors(用户手动添加的，一个List)。道理也很清楚，一种是在发起Socket请求之前就拦下来，一种是连上Socket之后的拦截</p>\n<p>Chain的proceed就是从List中一个个取出Inerceptor，然后执行</p>\n<h2 id=\"3-自带的五个Interceptor\"><a href=\"#3-自带的五个Interceptor\" class=\"headerlink\" title=\"3. 自带的五个Interceptor\"></a>3. 自带的五个Interceptor</h2><h3 id=\"3-1-RetryAndFollowUpInterceptor\"><a href=\"#3-1-RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"3.1 RetryAndFollowUpInterceptor\"></a>3.1 RetryAndFollowUpInterceptor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">while(!this.canceled) &#123;</div><div class=\"line\">        Response response = null;</div><div class=\"line\">        boolean releaseConnection = true;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            response = ((RealInterceptorChain)chain).proceed(request, this.streamAllocation, (HttpCodec)null, (RealConnection)null);</div><div class=\"line\">            releaseConnection = false;</div><div class=\"line\">        &#125; catch (RouteException var13) &#123;</div><div class=\"line\">            releaseConnection = false;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125; catch (IOException var14) &#123;</div><div class=\"line\">            releaseConnection = false;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            if(releaseConnection) &#123;</div><div class=\"line\">                this.streamAllocation.streamFailed((IOException)null);</div><div class=\"line\">                this.streamAllocation.release();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        Request followUp = this.followUpRequest(response);</div><div class=\"line\">        if(followUp == null) &#123;</div><div class=\"line\">            return response; </div><div class=\"line\">        &#125;</div><div class=\"line\">        ++followUpCount;</div><div class=\"line\">        if(followUpCount &gt; 20) &#123; </div><div class=\"line\">            this.streamAllocation.release();</div><div class=\"line\">            throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这里面写死了一个循环，只要没有cancel，catch到特定的Exception就一直让链条走下去。</p>\n<h3 id=\"3-2-BridgeInterceptor\"><a href=\"#3-2-BridgeInterceptor\" class=\"headerlink\" title=\"3.2 BridgeInterceptor\"></a>3.2 BridgeInterceptor</h3><p>这是第二个Interceptor<br>interceptors.add(new BridgeInterceptor(this.client.cookieJar()));//注意带进来了cookie，主要都是添加header什么的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Request userRequest = chain.request();</div><div class=\"line\">     <span class=\"keyword\">if</span>(userRequest.header(<span class=\"string\">\"Host\"</span>) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        requestBuilder.header(<span class=\"string\">\"Host\"</span>, Util.hostHeader(userRequest.url(), <span class=\"keyword\">false</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    Response networkResponse = chain.proceed(requestBuilder.build());</div><div class=\"line\"></div><div class=\"line\">    okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> responseBuilder.build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>都是些Host,Connection Keep-Alive,User-Agent,Content-Length等跟header有关的东西。随后将request交给链条的下一个interceptor。Response回来之后相应set-Cookie这些东西，下次请求带上cookie，这些都是Http的标准步骤。</p>\n<h3 id=\"3-3-CacheInterceptor\"><a href=\"#3-3-CacheInterceptor\" class=\"headerlink\" title=\"3.3 CacheInterceptor\"></a>3.3 CacheInterceptor</h3><p>接下来轮到cache，对于response的处理也是差不多的过程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Response cacheCandidate = <span class=\"keyword\">this</span>.cache != <span class=\"keyword\">null</span>?<span class=\"keyword\">this</span>.cache.get(chain.request()):<span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    Request networkRequest = strategy.networkRequest;</div><div class=\"line\">    Response cacheResponse = strategy.cacheResponse;</div><div class=\"line\">   </div><div class=\"line\">        Response networkResponse = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">     networkResponse = chain.proceed(networkRequest); </div><div class=\"line\"></div><div class=\"line\">        Response response;</div><div class=\"line\">        <span class=\"keyword\">if</span>(cacheResponse != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(networkResponse.code() == <span class=\"number\">304</span>) &#123;</div><div class=\"line\">                response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class=\"line\">                networkResponse.body().close();</div><div class=\"line\">                <span class=\"keyword\">this</span>.cache.trackConditionalCacheHit();</div><div class=\"line\">                <span class=\"keyword\">this</span>.cache.update(cacheResponse, response);</div><div class=\"line\">                <span class=\"keyword\">return</span> response; <span class=\"comment\">//只针对304做了自动cache</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            Util.closeQuietly(cacheResponse.body());</div><div class=\"line\">        &#125;</div><div class=\"line\">        response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</div><div class=\"line\">        <span class=\"keyword\">return</span> response;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里也是让请求接着走下去，response回来之后，只有304的时候才会去主动cache下来。</p>\n<h3 id=\"3-4-ConnectInterceptor\"><a href=\"#3-4-ConnectInterceptor\" class=\"headerlink\" title=\"3.4 ConnectInterceptor\"></a>3.4 ConnectInterceptor</h3><p>这里的interceptor方法异常简短<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain)chain;</div><div class=\"line\">    Request request = realChain.request();</div><div class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</div><div class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(<span class=\"keyword\">this</span>.client, doExtensiveHealthChecks);</div><div class=\"line\">    RealConnection connection = streamAllocation.connection();</div><div class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里重点关注 StreamAllocation这个类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamAllocation</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Address address;</div><div class=\"line\">    <span class=\"keyword\">private</span> Route route;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConnectionPool connectionPool;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object callStackTrace;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RouteSelector routeSelector;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> refusedStreamCount;</div><div class=\"line\">    <span class=\"keyword\">private</span> RealConnection connection;</div><div class=\"line\">    <span class=\"keyword\">private</span> HttpCodec codec;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>从HttpCodec httpCodec = streamAllocation.newStream(this.client, doExtensiveHealthChecks); 这句话一直往下走，会走到Socket.connect()，也就是大多数人初学网络编程时被教导的如何创建Socket连接。现在想想，能够从操作系统底层的Socket封装出这么多复杂的步骤，实在是高手。<br>StreamAllocation.newStream  —-&gt; StreamAllocation.findHealthyConnection  —&gt; StreamAallocation.findConnection —&gt; new RealConnection —&gt; RealConnection.connect </p>\n<p>RealConnection.connect()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.protocol != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"already connected\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.route.requiresTunnel()) &#123;</div><div class=\"line\">                        <span class=\"keyword\">this</span>.connectTunnel(connectTimeout, readTimeout, writeTimeout);</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        <span class=\"keyword\">this</span>.connectSocket(connectTimeout, readTimeout);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException var11) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span>(!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(var11)) &#123;</div><div class=\"line\">                        <span class=\"keyword\">throw</span> routeException; <span class=\"comment\">//这个Exception就是给RetryAndFollowupInterceptor准备的</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">           </div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>最初学习Socket编程的时候，就是写了一个while(true)，是不是很像？</p>\n<p>对了ConnectionPool内部使用了一个Deque保存RealConnection,findConnection里面有这么一段</p>\n<ul>\n<li>Internal.instance.get(this.connectionPool, this.address, this, (Route)null);//查找</li>\n<li>Internal.instance.put(this.connectionPool, result);//放进pool</li>\n</ul>\n<p>connectSocket长这样:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">connectSocket</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Proxy proxy = <span class=\"keyword\">this</span>.route.proxy();</div><div class=\"line\">    Address address = <span class=\"keyword\">this</span>.route.address();</div><div class=\"line\">    <span class=\"keyword\">this</span>.rawSocket = proxy.type() != Type.DIRECT &amp;&amp; proxy.type() != Type.HTTP?<span class=\"keyword\">new</span> Socket(proxy):address.socketFactory().createSocket();</div><div class=\"line\">    <span class=\"keyword\">this</span>.rawSocket.setSoTimeout(readTimeout);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        Platform.get().connectSocket(<span class=\"keyword\">this</span>.rawSocket, <span class=\"keyword\">this</span>.route.socketAddress(), connectTimeout); <span class=\"comment\">//这里面就一句话socket.connect</span></div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ConnectException var7) &#123;</div><div class=\"line\">        ConnectException ce = <span class=\"keyword\">new</span> ConnectException(<span class=\"string\">\"Failed to connect to \"</span> + <span class=\"keyword\">this</span>.route.socketAddress());</div><div class=\"line\">        ce.initCause(var7);</div><div class=\"line\">        <span class=\"keyword\">throw</span> ce;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.source = Okio.buffer(Okio.source(<span class=\"keyword\">this</span>.rawSocket)); </div><div class=\"line\">        <span class=\"keyword\">this</span>.sink = Okio.buffer(Okio.sink(<span class=\"keyword\">this</span>.rawSocket));</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NullPointerException var8) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"throw with null exception\"</span>.equals(var8.getMessage())) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(var8);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>重点看</strong><br>this.source = Okio.buffer(Okio.source(this.rawSocket));<br>this.sink = Okio.buffer(Okio.sink(this.rawSocket));<br>通过sink往Socket里面写数据，通过source网Socket里面写数据，通过Okio包装了，虽然本质上还是socket.getOutputStream和Socket.getInputStream。到这一步，RealConnection内部sink和source初始化完成，socket已经连接上，Socket的inputStream和outPutStream都准备就绪。其实在这种状态下就已经可以开始读写了。</p>\n<h3 id=\"3-5-CallServerInterceptor\"><a href=\"#3-5-CallServerInterceptor\" class=\"headerlink\" title=\"3.5 CallServerInterceptor\"></a>3.5 CallServerInterceptor</h3><p>这里已经连上了服务器，可以像操作本地文件一样读写数据了，当然要在遵守http规范的前提下。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain)chain;</div><div class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</div><div class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class=\"line\">    RealConnection connection = (RealConnection)realChain.connection();</div><div class=\"line\">    Request request = realChain.request();</div><div class=\"line\">    <span class=\"comment\">//可以看到，到这一步所需要的数据都准备就绪</span></div><div class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    httpCodec.writeRequestHeaders(request); <span class=\"comment\">//开始写数据</span></div><div class=\"line\"></div><div class=\"line\">    Builder responseBuilder = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//这里面是跟POST相关的</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</div><div class=\"line\">            httpCodec.flushRequest();</div><div class=\"line\">            responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(responseBuilder == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class=\"line\">            BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class=\"line\">            request.body().writeTo(bufferedRequestBody); <span class=\"comment\">//这里就是Okio发挥高效的地方</span></div><div class=\"line\">            bufferedRequestBody.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!connection.isMultiplexed()) &#123;</div><div class=\"line\">            streamAllocation.noNewStreams();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    httpCodec.finishRequest(); <span class=\"comment\">//到这里，client的数据全部写完并且发送给服务器，服务器开始干活。</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(responseBuilder == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>); <span class=\"comment\">//开始从Socket里面读取数据</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</div><div class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</div><div class=\"line\">        response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>)) || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</div><div class=\"line\">        streamAllocation.noNewStreams();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0L</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(<span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> response;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里面就是一步步的开始写数据了。这里再借用下百度,chrome按下F12，打开百度首页，看下request的raw header<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Host: www.baidu.com</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Cache-Control: max-age=0</div><div class=\"line\">Upgrade-Insecure-Requests: 1</div><div class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class=\"line\">DNT: 1</div><div class=\"line\">Accept-Encoding: gzip, deflate, br</div><div class=\"line\">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</div><div class=\"line\">Cookie: PSTM=122178321; BIDUPSID=CF3243290400VSDG52B3859AD4AEC2; BAIDUID=5176CC0A23DB1F3423426454DRTG5EC8:FG=1; MCITY=-%3A; BD_HOME=0; H_PS_PSSID=1428_24320_20930; BD_UPN=1223214323</div></pre></td></tr></table></figure></p>\n<p>看下httpCodec.writeRequestHeaders(request)的实现，就会发现真的是这么一行一行的写的<br>例如RequestLine.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">get</span><span class=\"params\">(Request request, Type proxyType)</span> </span>&#123;</div><div class=\"line\">       StringBuilder result = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">       result.append(request.method()); <span class=\"comment\">// GET </span></div><div class=\"line\">       result.append(<span class=\"string\">' '</span>); <span class=\"comment\">//空格</span></div><div class=\"line\">       <span class=\"keyword\">if</span>(includeAuthorityInRequestLine(request, proxyType)) &#123;</div><div class=\"line\">           result.append(request.url());</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           result.append(requestPath(request.url()));  <span class=\"comment\">//我们访问的是百度首页，当然是'/'这个Index啦</span></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       result.append(<span class=\"string\">\" HTTP/1.1\"</span>);  <span class=\"comment\">//是不是和上面一模一样</span></div><div class=\"line\">       <span class=\"keyword\">return</span> result.toString();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来轮到Http1Codec.class<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequest</span><span class=\"params\">(Headers headers, String requestLine)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"state: \"</span> + <span class=\"keyword\">this</span>.state);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.sink.writeUtf8(requestLine).writeUtf8(<span class=\"string\">\"\\r\\n\"</span>); <span class=\"comment\">//这是第一行，写完了加上换行符</span></div><div class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> size = headers.size(); i &lt; size; ++i) &#123;</div><div class=\"line\">                <span class=\"keyword\">this</span>.sink.writeUtf8(headers.name(i)).writeUtf8(<span class=\"string\">\": \"</span>).writeUtf8(headers.value(i)).writeUtf8(<span class=\"string\">\"\\r\\n\"</span>); <span class=\"comment\">//一个header写完就写一个换行符</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">this</span>.sink.writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">            <span class=\"keyword\">this</span>.state = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读取Response的顺序和写Request相反，不再赘述。</p>\n<h2 id=\"4-结语\"><a href=\"#4-结语\" class=\"headerlink\" title=\"4.结语\"></a>4.结语</h2><p>这里只是针对OkHttp发起的一个最简单同步的网络请求进行了分析。<br>关于异步请求再说两句：本质上不过是包装了一个回调，丢到线程池里面，相比整个Http请求，实在是不值一提。来看下这个线程池</p>\n<ul>\n<li>new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), Util.threadFactory(“OkHttp Dispatcher”, false));</li>\n</ul>\n<p>照说jdk不推荐这么创建线程池，一般用jdk封装好的CachedThreadPool，FixedThreadPool等等，但想必这样做也是不为了造成过大的系统开销吧。debug的时候如果看到OkHttp Dispatcher这条线程，应该明白是为什么了吧。另外，Okio会引入一条名为Okio WatchDog的线程，这跟Okio的AsyncTimeOut有关。时间关系(已经是夜里12点了)，不打算研究了。</p>\n<p>OkHttp总量过于庞大，很多方面，包括spdy,webSocket,RouterDatabase,DNS,网络执行周期触发回调，http2，http协议，太多太多，再研究一天也看不完。</p>\n<p>拎出来几个比较重要的点吧：</p>\n<ul>\n<li>Okio放在最前面，就是为了说明在网络请求这样对于io性能要求高的场合，okio避免了memory allocation和不必要的缓存复制。</li>\n<li>OkHttpClient应该是对标apache的HttpClient的，后者不清楚。</li>\n<li>底层还是调用操作系统的Socket接口，从这个角度来看，Retrofit只是一个Util，包括线程调度都是用的OkHttp的线程池；Volley我记得默认是4条NetWorkDispatcher和一个CacheDispatcher和一个ContentDelivery。</li>\n<li>不推荐创建多个OkHttpClient，真想创建多个的话，用newBuilder(浅复制)就好了嘛。</li>\n<li>网上说Picaso内部的cache其实就是OkHttp的cache，不愧square全家桶系列</li>\n<li>和Retrofit一样，也是用的Builder模式，提供了极大的自定义空间</li>\n<li>Interceptor，广受业界好评的责任链模式</li>\n</ul>\n<p>写于2017年7月23日0:29</p>\n<h2 id=\"5-参考\"><a href=\"#5-参考\" class=\"headerlink\" title=\"5. 参考\"></a>5. 参考</h2><ul>\n<li><a href=\"https://blog.piasy.com/2016/07/11/Understand-OkHttp/\">Paisy</a></li>\n<li><a href=\"http://frodoking.github.io/2015/03/12/android-okhttp/\">Frodo系列</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=WvyScM_S88c\">A few ok library</a></li>\n<li><a href=\"http://jakewharton.com/forcing-bytes-downward-in-okio/\">Forcing bytes downward in Okio</a></li>\n</ul>"},{"title":"设计模式总结","date":"2017-07-23T11:03:51.000Z","_content":"\nTBD\n<!--more-->","source":"_posts/2017-07-23-design-pattern.md","raw":"---\ntitle: 设计模式总结\ndate: 2017-07-23 19:03:51\ntags: [java,designpattern,tools]\n---\n\nTBD\n<!--more-->","slug":"2017-07-23-design-pattern","published":1,"updated":"2017-07-28T23:49:48.687Z","_id":"cj5gmdnke002vbovr98w9klwo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>TBD<br><a id=\"more\"></a></p>\n","excerpt":"<p>TBD<br>","more":"</p>"},{"title":"java对象内存占用分析","date":"2017-07-23T11:02:52.000Z","_content":"\n\n![](http://odzl05jxx.bkt.clouddn.com/9b157a7acab582078ac1fabada5c8009.jpg?imageView2/2/w/600)\n面向对象语言就意味着对象要占用内存空间，那么，java中随便new 出来的东西到底多大？还有，new出来的东西全都都放在heap上吗(有些真不是)？\n<!--more-->\n\n\n## 1.首先给出精确判断Object大小的一种方法\n\n一个判断Java Object大小的方法\n比较精准的确定一个对象的大小的[方法](https://github.com/liaohuqiu/java-object-size):\n\n\n```java\npublic class ObjectSizeFetcher {\n\n    private static Instrumentation instrumentation;\n\n    public static void premain(String args, Instrumentation inst) {\n        instrumentation = inst;\n    }\n\n    public static long getObjectSize(Object o) {\n        return instrumentation.getObjectSize(o);\n    }\n}\n```\n这样通常在IDE里面跑不起来。\n\n据说dump memory也行，没试过。\n\n## 2. 内存对齐\nJVM为了malloc与gc方便，指定分配的每个对象都需要是8字节的整数倍[参考](http://github.thinkingbar.com/alignment/)\n简单来说，一个Object占用的内存大小是8 Byte的倍数\n\n\n## 3. java进程的内存占用情况\n\n### 3.1 操作系统和runtime占用的内存\n操作系统的内存中，一部分被操作系统和kernel所占用。对于用c或者c++写的jvm，还需要分配一部分给c runtime。操作系统和c \nruntime占用的内存比较大，不同的操作系统上不一样，windows上默认是2GB。剩下的内存(即user space)，就是进程可以使用的内存。\n\n### 3.2 剩下的内存(user space)\n对于Java进程来讲，这剩下的部分分为两块:\n- Java Heap(s)\n- Native (non-java) Heap\n\nJava Heap可以通过-Xms 和 -Xmx 来设置最小值和最大值\nNative Heap是在分配了java maximum Heap大小之后剩下的大小(jvm占用的内存也算在这里面)\n\n\n### 3.3 数据类型大小\n基本数据类型大小很简单，其实也不简单。这张图是从ibm网站上截下来的\n![](http://odzl05jxx.bkt.clouddn.com/official_java_primitive_type_size_table.JPG)\n注意一个boolean在数组中只占用一个字节，单独使用占用4个字节。\n原理[参考](http://www.jianshu.com/p/2f663dc820d0)\n\n\n引用的大小：\n在 32 位的 JVM 上，一个对象引用占用 4 个字节；在 64 位上，占用 8 个字节。通过 java -d64 -version 可确定是否是 64 位的 JVM。\n处理器能够处理的bit范围决定了操作系统能够使用的内存范围：\n32位的cpu(2^32 = 4,294,967,296 bits = 4GB)\n64位cpu (2^64 = 18,446,744,073,709,551,616 = 16 exabytes)\n多数jvm是用c或者c++写的:\n-  the Java runtime creates an operating-system process — just as if you were running a C-based program. In fact, most JVMs are written largely in C or C++\n\n查看jvm是否64位的方法:\n- java -d64 -version\n64位上引用占用大小变大的原因是，需要管理4g以上的内存，指针(内存地址不够用了)\n\n## 4. java对象内存布局，从一个Integer说起\n\n一个class实例占据的大小包括:\n1. 自身的大小（对象头+基本数据类型数据大小） - Shadow heap size\nObject自身的大小在不同的jvm版本和厂商之间有一些变化，但大体上包括三个部分:\n\n- Class ： 一个指针，指向对应的class，用于表明其类型。比如一个Integer就指向java.lang.Integer这个类(32位上4字节，64位上8字节)\n- Flags : A collection of flags that describe the state of the object, including the hash code for the object if it has one, and the shape of the object (that is, whether or not the object is an array).（就是存hash值和用于表示是不是数组的，32位上4字节，64位上8字节）\n- Lock 所有的Object都能lock，这部分内存用于表示当前Object是否是被synchronized(32位上4字节，64位上8字节)\n\n所以，对于java.lang.Integer来说，一个Integer的大小就是：\n32(class信息)+32(Flags)+32(Lock))+32(int是基本数据类型，4字节) = 128bits（16字节）\n事实上，一个Interger的大小是int（4个字节）的四倍，简单来说一个对象的头信息就占用了3个字节。\n\n2. 数组的大小\n数组和普通的object差不多，多了一个size(32字节)。也就是说。为了存储一个int值。使用一个大小为1的int[]数组的内存消耗比一个Integer还要大。（同样，32位4字节，64位8字节）。数组因为多一个size，所以4个字节起步。\n\n3. 8个字节变成4个字节\nIBM和Oracle的jvm都能够提供ompressed References (-Xcompressedrefs) 和Compressed OOPs (-XX:+UseCompressedOops) 选项。这样一来，原本在64位机器上要占用8个字节的指针就只要占用4个字节了。但这只对java Heap上的内存有效，对于Native Heap这部分，64位占用内存还是要比32位多。所以同样的一份代码，在64位上占用的内存一定比32位上多。jdk 1.6.x之后好像默认是打开了的。\n\n4. 引用的对象的大小(递归即可) - Retained heap size(Shallow Heap大小加上引用的对象的)\njava.lang.Integer还算比较简单的，里面除了一个int值表示value以外，没有其它的成员变量，所以并没有引用到其他对象的实例。对于复杂一点的数据类型，比如jav.lang.String呢？\n\nString本身是一个很简单的类(如果不算常量池的话)，几乎可以看成一个char数组的wrapper。除了一个普通对象的class、Flag和Locks等信息外，String内部还有一个 private int hash（用于Cache hash值），还有offset和count（这俩好像没找到），此外就是一个char数组了。\n所以，为了存储8个字符(16个字节,128bits)。首先这个char数组对象占用了16个字节(2*8)+（对象头+数组大小）16个字节 = 256bits。\n算到String头上，String本身的文件头是12个字节，算上hash,count,offset各自4个字节，就24个字节了。再加上数组的引用4个字节，再加上数组的大小32个字节。\n合计60个字节（480bits）。而这里面实际有用的数据只有16个字节。73.3%的内存都是存储其他东西的。\n\n\n说的比较乱了，这里直接照搬一段计算,[参考](http://www.yunweipai.com/archives/1092.html)\n```\n- 一般而言，Java 对象在虚拟机的结构如下：\n•对象头（object header）：8 个字节（保存对象的 class 信息、ID、在虚拟机中的状态）\n•Java 原始类型数据：如 int, float, char 等类型的数据\n•引用（reference）：4 个字节\n•填充符（padding）\n\nString定义：\n\nJDK6:\nprivate final char value[];\nprivate final int offset;\nprivate final int count;\nprivate int hash;\n\nJDK6的空字符串所占的空间为40字节\n\nJDK7:\nprivate final char value[];\nprivate int hash;\nprivate transient int hash32;\n\nJDK7的空字符串所占的空间也是40字节\n\nJDK6字符串内存占用的计算方式：\n首先计算一个空的 char 数组所占空间，在 Java 里数组也是对象，因而数组也有对象头，故一个数组所占的空间为对象头所占的空间加上数组长度，即 8 + 4 = 12 字节 , 经过填充后为 16 字节。\n\n那么一个空 String 所占空间为：\n\n对象头（8 字节）+ char 数组（16 字节）+ 3 个 int（3 × 4 = 12 字节）+1 个 char 数组的引用 (4 字节 ) = 40 字节。\n\n因此一个实际的 String 所占空间的计算公式如下：\n\n8*( ( 8+12+2*n+4+12)+7 ) / 8 = 8*(int) ( ( ( (n) *2 )+43) /8 )\n\n其中，n 为字符串长度。\n```\n\n5. 小结\n随便new一个Object就意味着12个Byte没了，数组的话16个字节没了。每添加一个成员变量（指针），4个字节没了。这些都还没算上实际存储的数据。\n\n\n## 5. java.util框架中使用的那些集合类\n\n### 5.1 HashSet\nA HashSet is an implementation of the Set interface。无重复元素，不保证迭代顺序，常规的add,contains等方法速度不会随着内部元素的增加而变慢。HashSet内部最多有一个null，底层实现是HashMap，这意味着其占用内存要比HashMap大。\n默认容量 16个Entries\n内部元素为空时的大小 144bytes\n查找，添加，删除的时间复杂度为 O(1)，在没有Hash collisions发生的前提下 \n\n### 5.2 HashMap\nA HashMap is an implementation of the Map interface.\nHashMap是一种存储Key-Value型数据的集合，一个key最多map到一个value，key和value都可以为null，可以存储重复元素。（所以）——HashMap是HashSet的一种功能上的简化。\n底层是Entries(Entries元素是链表)，长这样。\n-  transient HashMapEntry<K,V>[] table = (HashMapEntry<K,V>[]) EMPTY_TABLE;\nHashMap的成员变量包括：\n\ntransient HashMapEntry<K,V>[] table（HashMapEntry的数组）\nint size\nint threshold\nfinal float loadFactor \ntransient int modCount;\n\n一个HashMap刚创建时(完全为空时)的大小为128bytes，jdk 1.8在初始化时没有加载Entries，在put操作时才去分配。可能会好一点。\n内部结构一般是这样的，一个HashMapEntry的大小为32byte。\nint KeyHash\nObject next\nObject key\nObject value\nHashMap每次put键值对时，都使用了一个HashMap$Entry这样的包装类，这意味着整个HashMap的overhead包括：\nThis means that the total overhead of a HashMap consists of the HashMap object, a HashMap$Entry array entry, and a HashMap$Entry object for each entry. \n直接照搬结论：对于HashMap\nDefault capacities为16个 entries\n\n对于一个有10000个Entries的HashMap，光是由于HashMap，Entry数组以及每个Entry对象带来的overhead就达到了360K左右，这里还不算存储的键值对本身的大小。\n\n### 5.3 Hashtable\nHashTable和HashMap的主要区别是HashTable是线程安全的，HashTable中很多方法都加上了synchronized修饰。一般来讲，jdk1.5以上如果想要线程安全，直接用synchronizedHashMap。Hashtable继承自Dictionary，后者已经被废弃了，推荐使用map接口的实现类。\n照搬结论：要存储10k个Entries，overhead达到360k。\n\n### 5.4 LinkedList\nLinkedist是典型的双向链表，除非增删操作特别频繁，否则没必要使用。\n查找的时间复杂度为 o(n)。添加的元素被包装在一个Node节点中。\n存储10K个元素的overhead为240K。\n\n### 5.5 ArrayList\nArrayList要好很多，value直接存在一个数组内部，查找的时间复杂度为o(1)\n存储10K个元素的overhead为40K左右。\n\n### 5.6 StringBuffer，StringBuilder\nStringBuffer直接强加synchronized，StringBuilder和StringBuffer都继承自AbstractStringBuilder。成员变量就两个一个char[] value和一个int count。\n\n\n## 6.集合的默认初始容量和扩系数\n以StirngBuffer为例（也算一种char的集合吧），默认容量是16，即创建了一个char[16]，空的，算上对象头，一共72bytes。这还只是StringBuffer里什么都没存储的情况。\nStringBuffer sb = new StringBuffer(\"My String\")。//算下用了多少内存\n首先算数组，文件头12bytes，加上size 16bytes。算上数组，（数组长度为str.length+16）一共116bytes，算上内存对齐，一共120bytes。StringBuffer对象的大小：对象头+count+数组指针 = 20 bytes。\n合计140bytes，内存对齐后144bytes，只为存储\"My String\"这9个字符（36bytes）。\n上面提到的这些集合类都对外提供了可以设置初始容量的构造函数以避免内存浪费，但要注意HashMap只接受2的指数幂。\n\n\n### 7.high level抽象带来的便利性及所需付出的代价\n面向对象语言推荐开发者使用一些高层抽象化的类，但更加复杂的功能意味着内存占用的增加。而内存意味着一切，所以，权衡好开发便利与内存占用对于程序的高效运行就十分重要，而这一切的前提就在于了解这些Wrapper对象工作的原理。\n\n\n## 一些很有意思的事情\n- Integer内部缓存了一个Integer[] ，最大值可以通过(java.lang.Integer.IntegerCache.high)配置\n- 不同版本jdk上String的优化很有意思，又是那个一个String占用多少字节的问题\n- 关于ConcurrentModificationException，对一个集合的更改分为结构性更改和集合元素值的更改，前者会抛出ConcurrentModificationException，后者不会。\n\n\n\n## 参考\n- [JAVA 对象大小](https://www.liaohuqiu.net/cn/posts/caculate-object-size-in-java/)\n- [一个Java对象到底占用多大内存](http://www.cnblogs.com/zhanjindong/p/3757767.html)\n- [查看 Java 对象大小](http://github.thinkingbar.com/lookup-objsize/)\n- [From Java code to Java heap](https://www.ibm.com/developerworks/library/j-codetoheap/index.html)\n- [Understanding the Memory Usage of Your Application](https://www.youtube.com/watch?v=FLcXf9pO27w)\n- [Thanks for the memory, Linux](https://www.ibm.com/developerworks/library/j-nativememory-linux/index.html)\n- [boolean数组中一个值占用1bit](http://www.jianshu.com/p/2f663dc820d0)\n- [不同jdk版本String做的优化](http://www.yunweipai.com/archives/1092.html) \n\n","source":"_posts/2017-07-23-from-java-code-to-java-heap.md","raw":"---\ntitle: java对象内存占用分析\ndate: 2017-07-23 19:02:52\ntags: [java]\n---\n\n\n![](http://odzl05jxx.bkt.clouddn.com/9b157a7acab582078ac1fabada5c8009.jpg?imageView2/2/w/600)\n面向对象语言就意味着对象要占用内存空间，那么，java中随便new 出来的东西到底多大？还有，new出来的东西全都都放在heap上吗(有些真不是)？\n<!--more-->\n\n\n## 1.首先给出精确判断Object大小的一种方法\n\n一个判断Java Object大小的方法\n比较精准的确定一个对象的大小的[方法](https://github.com/liaohuqiu/java-object-size):\n\n\n```java\npublic class ObjectSizeFetcher {\n\n    private static Instrumentation instrumentation;\n\n    public static void premain(String args, Instrumentation inst) {\n        instrumentation = inst;\n    }\n\n    public static long getObjectSize(Object o) {\n        return instrumentation.getObjectSize(o);\n    }\n}\n```\n这样通常在IDE里面跑不起来。\n\n据说dump memory也行，没试过。\n\n## 2. 内存对齐\nJVM为了malloc与gc方便，指定分配的每个对象都需要是8字节的整数倍[参考](http://github.thinkingbar.com/alignment/)\n简单来说，一个Object占用的内存大小是8 Byte的倍数\n\n\n## 3. java进程的内存占用情况\n\n### 3.1 操作系统和runtime占用的内存\n操作系统的内存中，一部分被操作系统和kernel所占用。对于用c或者c++写的jvm，还需要分配一部分给c runtime。操作系统和c \nruntime占用的内存比较大，不同的操作系统上不一样，windows上默认是2GB。剩下的内存(即user space)，就是进程可以使用的内存。\n\n### 3.2 剩下的内存(user space)\n对于Java进程来讲，这剩下的部分分为两块:\n- Java Heap(s)\n- Native (non-java) Heap\n\nJava Heap可以通过-Xms 和 -Xmx 来设置最小值和最大值\nNative Heap是在分配了java maximum Heap大小之后剩下的大小(jvm占用的内存也算在这里面)\n\n\n### 3.3 数据类型大小\n基本数据类型大小很简单，其实也不简单。这张图是从ibm网站上截下来的\n![](http://odzl05jxx.bkt.clouddn.com/official_java_primitive_type_size_table.JPG)\n注意一个boolean在数组中只占用一个字节，单独使用占用4个字节。\n原理[参考](http://www.jianshu.com/p/2f663dc820d0)\n\n\n引用的大小：\n在 32 位的 JVM 上，一个对象引用占用 4 个字节；在 64 位上，占用 8 个字节。通过 java -d64 -version 可确定是否是 64 位的 JVM。\n处理器能够处理的bit范围决定了操作系统能够使用的内存范围：\n32位的cpu(2^32 = 4,294,967,296 bits = 4GB)\n64位cpu (2^64 = 18,446,744,073,709,551,616 = 16 exabytes)\n多数jvm是用c或者c++写的:\n-  the Java runtime creates an operating-system process — just as if you were running a C-based program. In fact, most JVMs are written largely in C or C++\n\n查看jvm是否64位的方法:\n- java -d64 -version\n64位上引用占用大小变大的原因是，需要管理4g以上的内存，指针(内存地址不够用了)\n\n## 4. java对象内存布局，从一个Integer说起\n\n一个class实例占据的大小包括:\n1. 自身的大小（对象头+基本数据类型数据大小） - Shadow heap size\nObject自身的大小在不同的jvm版本和厂商之间有一些变化，但大体上包括三个部分:\n\n- Class ： 一个指针，指向对应的class，用于表明其类型。比如一个Integer就指向java.lang.Integer这个类(32位上4字节，64位上8字节)\n- Flags : A collection of flags that describe the state of the object, including the hash code for the object if it has one, and the shape of the object (that is, whether or not the object is an array).（就是存hash值和用于表示是不是数组的，32位上4字节，64位上8字节）\n- Lock 所有的Object都能lock，这部分内存用于表示当前Object是否是被synchronized(32位上4字节，64位上8字节)\n\n所以，对于java.lang.Integer来说，一个Integer的大小就是：\n32(class信息)+32(Flags)+32(Lock))+32(int是基本数据类型，4字节) = 128bits（16字节）\n事实上，一个Interger的大小是int（4个字节）的四倍，简单来说一个对象的头信息就占用了3个字节。\n\n2. 数组的大小\n数组和普通的object差不多，多了一个size(32字节)。也就是说。为了存储一个int值。使用一个大小为1的int[]数组的内存消耗比一个Integer还要大。（同样，32位4字节，64位8字节）。数组因为多一个size，所以4个字节起步。\n\n3. 8个字节变成4个字节\nIBM和Oracle的jvm都能够提供ompressed References (-Xcompressedrefs) 和Compressed OOPs (-XX:+UseCompressedOops) 选项。这样一来，原本在64位机器上要占用8个字节的指针就只要占用4个字节了。但这只对java Heap上的内存有效，对于Native Heap这部分，64位占用内存还是要比32位多。所以同样的一份代码，在64位上占用的内存一定比32位上多。jdk 1.6.x之后好像默认是打开了的。\n\n4. 引用的对象的大小(递归即可) - Retained heap size(Shallow Heap大小加上引用的对象的)\njava.lang.Integer还算比较简单的，里面除了一个int值表示value以外，没有其它的成员变量，所以并没有引用到其他对象的实例。对于复杂一点的数据类型，比如jav.lang.String呢？\n\nString本身是一个很简单的类(如果不算常量池的话)，几乎可以看成一个char数组的wrapper。除了一个普通对象的class、Flag和Locks等信息外，String内部还有一个 private int hash（用于Cache hash值），还有offset和count（这俩好像没找到），此外就是一个char数组了。\n所以，为了存储8个字符(16个字节,128bits)。首先这个char数组对象占用了16个字节(2*8)+（对象头+数组大小）16个字节 = 256bits。\n算到String头上，String本身的文件头是12个字节，算上hash,count,offset各自4个字节，就24个字节了。再加上数组的引用4个字节，再加上数组的大小32个字节。\n合计60个字节（480bits）。而这里面实际有用的数据只有16个字节。73.3%的内存都是存储其他东西的。\n\n\n说的比较乱了，这里直接照搬一段计算,[参考](http://www.yunweipai.com/archives/1092.html)\n```\n- 一般而言，Java 对象在虚拟机的结构如下：\n•对象头（object header）：8 个字节（保存对象的 class 信息、ID、在虚拟机中的状态）\n•Java 原始类型数据：如 int, float, char 等类型的数据\n•引用（reference）：4 个字节\n•填充符（padding）\n\nString定义：\n\nJDK6:\nprivate final char value[];\nprivate final int offset;\nprivate final int count;\nprivate int hash;\n\nJDK6的空字符串所占的空间为40字节\n\nJDK7:\nprivate final char value[];\nprivate int hash;\nprivate transient int hash32;\n\nJDK7的空字符串所占的空间也是40字节\n\nJDK6字符串内存占用的计算方式：\n首先计算一个空的 char 数组所占空间，在 Java 里数组也是对象，因而数组也有对象头，故一个数组所占的空间为对象头所占的空间加上数组长度，即 8 + 4 = 12 字节 , 经过填充后为 16 字节。\n\n那么一个空 String 所占空间为：\n\n对象头（8 字节）+ char 数组（16 字节）+ 3 个 int（3 × 4 = 12 字节）+1 个 char 数组的引用 (4 字节 ) = 40 字节。\n\n因此一个实际的 String 所占空间的计算公式如下：\n\n8*( ( 8+12+2*n+4+12)+7 ) / 8 = 8*(int) ( ( ( (n) *2 )+43) /8 )\n\n其中，n 为字符串长度。\n```\n\n5. 小结\n随便new一个Object就意味着12个Byte没了，数组的话16个字节没了。每添加一个成员变量（指针），4个字节没了。这些都还没算上实际存储的数据。\n\n\n## 5. java.util框架中使用的那些集合类\n\n### 5.1 HashSet\nA HashSet is an implementation of the Set interface。无重复元素，不保证迭代顺序，常规的add,contains等方法速度不会随着内部元素的增加而变慢。HashSet内部最多有一个null，底层实现是HashMap，这意味着其占用内存要比HashMap大。\n默认容量 16个Entries\n内部元素为空时的大小 144bytes\n查找，添加，删除的时间复杂度为 O(1)，在没有Hash collisions发生的前提下 \n\n### 5.2 HashMap\nA HashMap is an implementation of the Map interface.\nHashMap是一种存储Key-Value型数据的集合，一个key最多map到一个value，key和value都可以为null，可以存储重复元素。（所以）——HashMap是HashSet的一种功能上的简化。\n底层是Entries(Entries元素是链表)，长这样。\n-  transient HashMapEntry<K,V>[] table = (HashMapEntry<K,V>[]) EMPTY_TABLE;\nHashMap的成员变量包括：\n\ntransient HashMapEntry<K,V>[] table（HashMapEntry的数组）\nint size\nint threshold\nfinal float loadFactor \ntransient int modCount;\n\n一个HashMap刚创建时(完全为空时)的大小为128bytes，jdk 1.8在初始化时没有加载Entries，在put操作时才去分配。可能会好一点。\n内部结构一般是这样的，一个HashMapEntry的大小为32byte。\nint KeyHash\nObject next\nObject key\nObject value\nHashMap每次put键值对时，都使用了一个HashMap$Entry这样的包装类，这意味着整个HashMap的overhead包括：\nThis means that the total overhead of a HashMap consists of the HashMap object, a HashMap$Entry array entry, and a HashMap$Entry object for each entry. \n直接照搬结论：对于HashMap\nDefault capacities为16个 entries\n\n对于一个有10000个Entries的HashMap，光是由于HashMap，Entry数组以及每个Entry对象带来的overhead就达到了360K左右，这里还不算存储的键值对本身的大小。\n\n### 5.3 Hashtable\nHashTable和HashMap的主要区别是HashTable是线程安全的，HashTable中很多方法都加上了synchronized修饰。一般来讲，jdk1.5以上如果想要线程安全，直接用synchronizedHashMap。Hashtable继承自Dictionary，后者已经被废弃了，推荐使用map接口的实现类。\n照搬结论：要存储10k个Entries，overhead达到360k。\n\n### 5.4 LinkedList\nLinkedist是典型的双向链表，除非增删操作特别频繁，否则没必要使用。\n查找的时间复杂度为 o(n)。添加的元素被包装在一个Node节点中。\n存储10K个元素的overhead为240K。\n\n### 5.5 ArrayList\nArrayList要好很多，value直接存在一个数组内部，查找的时间复杂度为o(1)\n存储10K个元素的overhead为40K左右。\n\n### 5.6 StringBuffer，StringBuilder\nStringBuffer直接强加synchronized，StringBuilder和StringBuffer都继承自AbstractStringBuilder。成员变量就两个一个char[] value和一个int count。\n\n\n## 6.集合的默认初始容量和扩系数\n以StirngBuffer为例（也算一种char的集合吧），默认容量是16，即创建了一个char[16]，空的，算上对象头，一共72bytes。这还只是StringBuffer里什么都没存储的情况。\nStringBuffer sb = new StringBuffer(\"My String\")。//算下用了多少内存\n首先算数组，文件头12bytes，加上size 16bytes。算上数组，（数组长度为str.length+16）一共116bytes，算上内存对齐，一共120bytes。StringBuffer对象的大小：对象头+count+数组指针 = 20 bytes。\n合计140bytes，内存对齐后144bytes，只为存储\"My String\"这9个字符（36bytes）。\n上面提到的这些集合类都对外提供了可以设置初始容量的构造函数以避免内存浪费，但要注意HashMap只接受2的指数幂。\n\n\n### 7.high level抽象带来的便利性及所需付出的代价\n面向对象语言推荐开发者使用一些高层抽象化的类，但更加复杂的功能意味着内存占用的增加。而内存意味着一切，所以，权衡好开发便利与内存占用对于程序的高效运行就十分重要，而这一切的前提就在于了解这些Wrapper对象工作的原理。\n\n\n## 一些很有意思的事情\n- Integer内部缓存了一个Integer[] ，最大值可以通过(java.lang.Integer.IntegerCache.high)配置\n- 不同版本jdk上String的优化很有意思，又是那个一个String占用多少字节的问题\n- 关于ConcurrentModificationException，对一个集合的更改分为结构性更改和集合元素值的更改，前者会抛出ConcurrentModificationException，后者不会。\n\n\n\n## 参考\n- [JAVA 对象大小](https://www.liaohuqiu.net/cn/posts/caculate-object-size-in-java/)\n- [一个Java对象到底占用多大内存](http://www.cnblogs.com/zhanjindong/p/3757767.html)\n- [查看 Java 对象大小](http://github.thinkingbar.com/lookup-objsize/)\n- [From Java code to Java heap](https://www.ibm.com/developerworks/library/j-codetoheap/index.html)\n- [Understanding the Memory Usage of Your Application](https://www.youtube.com/watch?v=FLcXf9pO27w)\n- [Thanks for the memory, Linux](https://www.ibm.com/developerworks/library/j-nativememory-linux/index.html)\n- [boolean数组中一个值占用1bit](http://www.jianshu.com/p/2f663dc820d0)\n- [不同jdk版本String做的优化](http://www.yunweipai.com/archives/1092.html) \n\n","slug":"2017-07-23-from-java-code-to-java-heap","published":1,"updated":"2017-07-28T23:49:48.698Z","_id":"cj5gmdnkh002xbovre66s0yog","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/9b157a7acab582078ac1fabada5c8009.jpg?imageView2/2/w/600\" alt=\"\"><br>面向对象语言就意味着对象要占用内存空间，那么，java中随便new 出来的东西到底多大？还有，new出来的东西全都都放在heap上吗(有些真不是)？<br><a id=\"more\"></a></p>\n<h2 id=\"1-首先给出精确判断Object大小的一种方法\"><a href=\"#1-首先给出精确判断Object大小的一种方法\" class=\"headerlink\" title=\"1.首先给出精确判断Object大小的一种方法\"></a>1.首先给出精确判断Object大小的一种方法</h2><p>一个判断Java Object大小的方法<br>比较精准的确定一个对象的大小的<a href=\"https://github.com/liaohuqiu/java-object-size\">方法</a>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectSizeFetcher</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Instrumentation instrumentation;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">premain</span><span class=\"params\">(String args, Instrumentation inst)</span> </span>&#123;</div><div class=\"line\">        instrumentation = inst;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">getObjectSize</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instrumentation.getObjectSize(o);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样通常在IDE里面跑不起来。</p>\n<p>据说dump memory也行，没试过。</p>\n<h2 id=\"2-内存对齐\"><a href=\"#2-内存对齐\" class=\"headerlink\" title=\"2. 内存对齐\"></a>2. 内存对齐</h2><p>JVM为了malloc与gc方便，指定分配的每个对象都需要是8字节的整数倍<a href=\"http://github.thinkingbar.com/alignment/\">参考</a><br>简单来说，一个Object占用的内存大小是8 Byte的倍数</p>\n<h2 id=\"3-java进程的内存占用情况\"><a href=\"#3-java进程的内存占用情况\" class=\"headerlink\" title=\"3. java进程的内存占用情况\"></a>3. java进程的内存占用情况</h2><h3 id=\"3-1-操作系统和runtime占用的内存\"><a href=\"#3-1-操作系统和runtime占用的内存\" class=\"headerlink\" title=\"3.1 操作系统和runtime占用的内存\"></a>3.1 操作系统和runtime占用的内存</h3><p>操作系统的内存中，一部分被操作系统和kernel所占用。对于用c或者c++写的jvm，还需要分配一部分给c runtime。操作系统和c<br>runtime占用的内存比较大，不同的操作系统上不一样，windows上默认是2GB。剩下的内存(即user space)，就是进程可以使用的内存。</p>\n<h3 id=\"3-2-剩下的内存-user-space\"><a href=\"#3-2-剩下的内存-user-space\" class=\"headerlink\" title=\"3.2 剩下的内存(user space)\"></a>3.2 剩下的内存(user space)</h3><p>对于Java进程来讲，这剩下的部分分为两块:</p>\n<ul>\n<li>Java Heap(s)</li>\n<li>Native (non-java) Heap</li>\n</ul>\n<p>Java Heap可以通过-Xms 和 -Xmx 来设置最小值和最大值<br>Native Heap是在分配了java maximum Heap大小之后剩下的大小(jvm占用的内存也算在这里面)</p>\n<h3 id=\"3-3-数据类型大小\"><a href=\"#3-3-数据类型大小\" class=\"headerlink\" title=\"3.3 数据类型大小\"></a>3.3 数据类型大小</h3><p>基本数据类型大小很简单，其实也不简单。这张图是从ibm网站上截下来的<br><img src=\"http://odzl05jxx.bkt.clouddn.com/official_java_primitive_type_size_table.JPG\" alt=\"\"><br>注意一个boolean在数组中只占用一个字节，单独使用占用4个字节。<br>原理<a href=\"http://www.jianshu.com/p/2f663dc820d0\">参考</a></p>\n<p>引用的大小：<br>在 32 位的 JVM 上，一个对象引用占用 4 个字节；在 64 位上，占用 8 个字节。通过 java -d64 -version 可确定是否是 64 位的 JVM。<br>处理器能够处理的bit范围决定了操作系统能够使用的内存范围：<br>32位的cpu(2^32 = 4,294,967,296 bits = 4GB)<br>64位cpu (2^64 = 18,446,744,073,709,551,616 = 16 exabytes)<br>多数jvm是用c或者c++写的:</p>\n<ul>\n<li>the Java runtime creates an operating-system process — just as if you were running a C-based program. In fact, most JVMs are written largely in C or C++</li>\n</ul>\n<p>查看jvm是否64位的方法:</p>\n<ul>\n<li>java -d64 -version<br>64位上引用占用大小变大的原因是，需要管理4g以上的内存，指针(内存地址不够用了)</li>\n</ul>\n<h2 id=\"4-java对象内存布局，从一个Integer说起\"><a href=\"#4-java对象内存布局，从一个Integer说起\" class=\"headerlink\" title=\"4. java对象内存布局，从一个Integer说起\"></a>4. java对象内存布局，从一个Integer说起</h2><p>一个class实例占据的大小包括:</p>\n<ol>\n<li>自身的大小（对象头+基本数据类型数据大小） - Shadow heap size<br>Object自身的大小在不同的jvm版本和厂商之间有一些变化，但大体上包括三个部分:</li>\n</ol>\n<ul>\n<li>Class ： 一个指针，指向对应的class，用于表明其类型。比如一个Integer就指向java.lang.Integer这个类(32位上4字节，64位上8字节)</li>\n<li>Flags : A collection of flags that describe the state of the object, including the hash code for the object if it has one, and the shape of the object (that is, whether or not the object is an array).（就是存hash值和用于表示是不是数组的，32位上4字节，64位上8字节）</li>\n<li>Lock 所有的Object都能lock，这部分内存用于表示当前Object是否是被synchronized(32位上4字节，64位上8字节)</li>\n</ul>\n<p>所以，对于java.lang.Integer来说，一个Integer的大小就是：<br>32(class信息)+32(Flags)+32(Lock))+32(int是基本数据类型，4字节) = 128bits（16字节）<br>事实上，一个Interger的大小是int（4个字节）的四倍，简单来说一个对象的头信息就占用了3个字节。</p>\n<ol>\n<li><p>数组的大小<br>数组和普通的object差不多，多了一个size(32字节)。也就是说。为了存储一个int值。使用一个大小为1的int[]数组的内存消耗比一个Integer还要大。（同样，32位4字节，64位8字节）。数组因为多一个size，所以4个字节起步。</p>\n</li>\n<li><p>8个字节变成4个字节<br>IBM和Oracle的jvm都能够提供ompressed References (-Xcompressedrefs) 和Compressed OOPs (-XX:+UseCompressedOops) 选项。这样一来，原本在64位机器上要占用8个字节的指针就只要占用4个字节了。但这只对java Heap上的内存有效，对于Native Heap这部分，64位占用内存还是要比32位多。所以同样的一份代码，在64位上占用的内存一定比32位上多。jdk 1.6.x之后好像默认是打开了的。</p>\n</li>\n<li><p>引用的对象的大小(递归即可) - Retained heap size(Shallow Heap大小加上引用的对象的)<br>java.lang.Integer还算比较简单的，里面除了一个int值表示value以外，没有其它的成员变量，所以并没有引用到其他对象的实例。对于复杂一点的数据类型，比如jav.lang.String呢？</p>\n</li>\n</ol>\n<p>String本身是一个很简单的类(如果不算常量池的话)，几乎可以看成一个char数组的wrapper。除了一个普通对象的class、Flag和Locks等信息外，String内部还有一个 private int hash（用于Cache hash值），还有offset和count（这俩好像没找到），此外就是一个char数组了。<br>所以，为了存储8个字符(16个字节,128bits)。首先这个char数组对象占用了16个字节(2*8)+（对象头+数组大小）16个字节 = 256bits。<br>算到String头上，String本身的文件头是12个字节，算上hash,count,offset各自4个字节，就24个字节了。再加上数组的引用4个字节，再加上数组的大小32个字节。<br>合计60个字节（480bits）。而这里面实际有用的数据只有16个字节。73.3%的内存都是存储其他东西的。</p>\n<p>说的比较乱了，这里直接照搬一段计算,<a href=\"http://www.yunweipai.com/archives/1092.html\">参考</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 一般而言，Java 对象在虚拟机的结构如下：</div><div class=\"line\">•对象头（object header）：8 个字节（保存对象的 class 信息、ID、在虚拟机中的状态）</div><div class=\"line\">•Java 原始类型数据：如 int, float, char 等类型的数据</div><div class=\"line\">•引用（reference）：4 个字节</div><div class=\"line\">•填充符（padding）</div><div class=\"line\"></div><div class=\"line\">String定义：</div><div class=\"line\"></div><div class=\"line\">JDK6:</div><div class=\"line\">private final char value[];</div><div class=\"line\">private final int offset;</div><div class=\"line\">private final int count;</div><div class=\"line\">private int hash;</div><div class=\"line\"></div><div class=\"line\">JDK6的空字符串所占的空间为40字节</div><div class=\"line\"></div><div class=\"line\">JDK7:</div><div class=\"line\">private final char value[];</div><div class=\"line\">private int hash;</div><div class=\"line\">private transient int hash32;</div><div class=\"line\"></div><div class=\"line\">JDK7的空字符串所占的空间也是40字节</div><div class=\"line\"></div><div class=\"line\">JDK6字符串内存占用的计算方式：</div><div class=\"line\">首先计算一个空的 char 数组所占空间，在 Java 里数组也是对象，因而数组也有对象头，故一个数组所占的空间为对象头所占的空间加上数组长度，即 8 + 4 = 12 字节 , 经过填充后为 16 字节。</div><div class=\"line\"></div><div class=\"line\">那么一个空 String 所占空间为：</div><div class=\"line\"></div><div class=\"line\">对象头（8 字节）+ char 数组（16 字节）+ 3 个 int（3 × 4 = 12 字节）+1 个 char 数组的引用 (4 字节 ) = 40 字节。</div><div class=\"line\"></div><div class=\"line\">因此一个实际的 String 所占空间的计算公式如下：</div><div class=\"line\"></div><div class=\"line\">8*( ( 8+12+2*n+4+12)+7 ) / 8 = 8*(int) ( ( ( (n) *2 )+43) /8 )</div><div class=\"line\"></div><div class=\"line\">其中，n 为字符串长度。</div></pre></td></tr></table></figure></p>\n<ol>\n<li>小结<br>随便new一个Object就意味着12个Byte没了，数组的话16个字节没了。每添加一个成员变量（指针），4个字节没了。这些都还没算上实际存储的数据。</li>\n</ol>\n<h2 id=\"5-java-util框架中使用的那些集合类\"><a href=\"#5-java-util框架中使用的那些集合类\" class=\"headerlink\" title=\"5. java.util框架中使用的那些集合类\"></a>5. java.util框架中使用的那些集合类</h2><h3 id=\"5-1-HashSet\"><a href=\"#5-1-HashSet\" class=\"headerlink\" title=\"5.1 HashSet\"></a>5.1 HashSet</h3><p>A HashSet is an implementation of the Set interface。无重复元素，不保证迭代顺序，常规的add,contains等方法速度不会随着内部元素的增加而变慢。HashSet内部最多有一个null，底层实现是HashMap，这意味着其占用内存要比HashMap大。<br>默认容量 16个Entries<br>内部元素为空时的大小 144bytes<br>查找，添加，删除的时间复杂度为 O(1)，在没有Hash collisions发生的前提下 </p>\n<h3 id=\"5-2-HashMap\"><a href=\"#5-2-HashMap\" class=\"headerlink\" title=\"5.2 HashMap\"></a>5.2 HashMap</h3><p>A HashMap is an implementation of the Map interface.<br>HashMap是一种存储Key-Value型数据的集合，一个key最多map到一个value，key和value都可以为null，可以存储重复元素。（所以）——HashMap是HashSet的一种功能上的简化。<br>底层是Entries(Entries元素是链表)，长这样。</p>\n<ul>\n<li>transient HashMapEntry<K,V>[] table = (HashMapEntry<K,V>[]) EMPTY_TABLE;<br>HashMap的成员变量包括：</li>\n</ul>\n<p>transient HashMapEntry<K,V>[] table（HashMapEntry的数组）<br>int size<br>int threshold<br>final float loadFactor<br>transient int modCount;</p>\n<p>一个HashMap刚创建时(完全为空时)的大小为128bytes，jdk 1.8在初始化时没有加载Entries，在put操作时才去分配。可能会好一点。<br>内部结构一般是这样的，一个HashMapEntry的大小为32byte。<br>int KeyHash<br>Object next<br>Object key<br>Object value<br>HashMap每次put键值对时，都使用了一个HashMap$Entry这样的包装类，这意味着整个HashMap的overhead包括：<br>This means that the total overhead of a HashMap consists of the HashMap object, a HashMap$Entry array entry, and a HashMap$Entry object for each entry.<br>直接照搬结论：对于HashMap<br>Default capacities为16个 entries</p>\n<p>对于一个有10000个Entries的HashMap，光是由于HashMap，Entry数组以及每个Entry对象带来的overhead就达到了360K左右，这里还不算存储的键值对本身的大小。</p>\n<h3 id=\"5-3-Hashtable\"><a href=\"#5-3-Hashtable\" class=\"headerlink\" title=\"5.3 Hashtable\"></a>5.3 Hashtable</h3><p>HashTable和HashMap的主要区别是HashTable是线程安全的，HashTable中很多方法都加上了synchronized修饰。一般来讲，jdk1.5以上如果想要线程安全，直接用synchronizedHashMap。Hashtable继承自Dictionary，后者已经被废弃了，推荐使用map接口的实现类。<br>照搬结论：要存储10k个Entries，overhead达到360k。</p>\n<h3 id=\"5-4-LinkedList\"><a href=\"#5-4-LinkedList\" class=\"headerlink\" title=\"5.4 LinkedList\"></a>5.4 LinkedList</h3><p>Linkedist是典型的双向链表，除非增删操作特别频繁，否则没必要使用。<br>查找的时间复杂度为 o(n)。添加的元素被包装在一个Node节点中。<br>存储10K个元素的overhead为240K。</p>\n<h3 id=\"5-5-ArrayList\"><a href=\"#5-5-ArrayList\" class=\"headerlink\" title=\"5.5 ArrayList\"></a>5.5 ArrayList</h3><p>ArrayList要好很多，value直接存在一个数组内部，查找的时间复杂度为o(1)<br>存储10K个元素的overhead为40K左右。</p>\n<h3 id=\"5-6-StringBuffer，StringBuilder\"><a href=\"#5-6-StringBuffer，StringBuilder\" class=\"headerlink\" title=\"5.6 StringBuffer，StringBuilder\"></a>5.6 StringBuffer，StringBuilder</h3><p>StringBuffer直接强加synchronized，StringBuilder和StringBuffer都继承自AbstractStringBuilder。成员变量就两个一个char[] value和一个int count。</p>\n<h2 id=\"6-集合的默认初始容量和扩系数\"><a href=\"#6-集合的默认初始容量和扩系数\" class=\"headerlink\" title=\"6.集合的默认初始容量和扩系数\"></a>6.集合的默认初始容量和扩系数</h2><p>以StirngBuffer为例（也算一种char的集合吧），默认容量是16，即创建了一个char[16]，空的，算上对象头，一共72bytes。这还只是StringBuffer里什么都没存储的情况。<br>StringBuffer sb = new StringBuffer(“My String”)。//算下用了多少内存<br>首先算数组，文件头12bytes，加上size 16bytes。算上数组，（数组长度为str.length+16）一共116bytes，算上内存对齐，一共120bytes。StringBuffer对象的大小：对象头+count+数组指针 = 20 bytes。<br>合计140bytes，内存对齐后144bytes，只为存储”My String”这9个字符（36bytes）。<br>上面提到的这些集合类都对外提供了可以设置初始容量的构造函数以避免内存浪费，但要注意HashMap只接受2的指数幂。</p>\n<h3 id=\"7-high-level抽象带来的便利性及所需付出的代价\"><a href=\"#7-high-level抽象带来的便利性及所需付出的代价\" class=\"headerlink\" title=\"7.high level抽象带来的便利性及所需付出的代价\"></a>7.high level抽象带来的便利性及所需付出的代价</h3><p>面向对象语言推荐开发者使用一些高层抽象化的类，但更加复杂的功能意味着内存占用的增加。而内存意味着一切，所以，权衡好开发便利与内存占用对于程序的高效运行就十分重要，而这一切的前提就在于了解这些Wrapper对象工作的原理。</p>\n<h2 id=\"一些很有意思的事情\"><a href=\"#一些很有意思的事情\" class=\"headerlink\" title=\"一些很有意思的事情\"></a>一些很有意思的事情</h2><ul>\n<li>Integer内部缓存了一个Integer[] ，最大值可以通过(java.lang.Integer.IntegerCache.high)配置</li>\n<li>不同版本jdk上String的优化很有意思，又是那个一个String占用多少字节的问题</li>\n<li>关于ConcurrentModificationException，对一个集合的更改分为结构性更改和集合元素值的更改，前者会抛出ConcurrentModificationException，后者不会。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.liaohuqiu.net/cn/posts/caculate-object-size-in-java/\">JAVA 对象大小</a></li>\n<li><a href=\"http://www.cnblogs.com/zhanjindong/p/3757767.html\">一个Java对象到底占用多大内存</a></li>\n<li><a href=\"http://github.thinkingbar.com/lookup-objsize/\">查看 Java 对象大小</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/library/j-codetoheap/index.html\">From Java code to Java heap</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=FLcXf9pO27w\">Understanding the Memory Usage of Your Application</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/library/j-nativememory-linux/index.html\">Thanks for the memory, Linux</a></li>\n<li><a href=\"http://www.jianshu.com/p/2f663dc820d0\">boolean数组中一个值占用1bit</a></li>\n<li><a href=\"http://www.yunweipai.com/archives/1092.html\">不同jdk版本String做的优化</a> </li>\n</ul>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/9b157a7acab582078ac1fabada5c8009.jpg?imageView2/2/w/600\" alt=\"\"><br>面向对象语言就意味着对象要占用内存空间，那么，java中随便new 出来的东西到底多大？还有，new出来的东西全都都放在heap上吗(有些真不是)？<br>","more":"</p>\n<h2 id=\"1-首先给出精确判断Object大小的一种方法\"><a href=\"#1-首先给出精确判断Object大小的一种方法\" class=\"headerlink\" title=\"1.首先给出精确判断Object大小的一种方法\"></a>1.首先给出精确判断Object大小的一种方法</h2><p>一个判断Java Object大小的方法<br>比较精准的确定一个对象的大小的<a href=\"https://github.com/liaohuqiu/java-object-size\">方法</a>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectSizeFetcher</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Instrumentation instrumentation;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">premain</span><span class=\"params\">(String args, Instrumentation inst)</span> </span>&#123;</div><div class=\"line\">        instrumentation = inst;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">getObjectSize</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instrumentation.getObjectSize(o);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样通常在IDE里面跑不起来。</p>\n<p>据说dump memory也行，没试过。</p>\n<h2 id=\"2-内存对齐\"><a href=\"#2-内存对齐\" class=\"headerlink\" title=\"2. 内存对齐\"></a>2. 内存对齐</h2><p>JVM为了malloc与gc方便，指定分配的每个对象都需要是8字节的整数倍<a href=\"http://github.thinkingbar.com/alignment/\">参考</a><br>简单来说，一个Object占用的内存大小是8 Byte的倍数</p>\n<h2 id=\"3-java进程的内存占用情况\"><a href=\"#3-java进程的内存占用情况\" class=\"headerlink\" title=\"3. java进程的内存占用情况\"></a>3. java进程的内存占用情况</h2><h3 id=\"3-1-操作系统和runtime占用的内存\"><a href=\"#3-1-操作系统和runtime占用的内存\" class=\"headerlink\" title=\"3.1 操作系统和runtime占用的内存\"></a>3.1 操作系统和runtime占用的内存</h3><p>操作系统的内存中，一部分被操作系统和kernel所占用。对于用c或者c++写的jvm，还需要分配一部分给c runtime。操作系统和c<br>runtime占用的内存比较大，不同的操作系统上不一样，windows上默认是2GB。剩下的内存(即user space)，就是进程可以使用的内存。</p>\n<h3 id=\"3-2-剩下的内存-user-space\"><a href=\"#3-2-剩下的内存-user-space\" class=\"headerlink\" title=\"3.2 剩下的内存(user space)\"></a>3.2 剩下的内存(user space)</h3><p>对于Java进程来讲，这剩下的部分分为两块:</p>\n<ul>\n<li>Java Heap(s)</li>\n<li>Native (non-java) Heap</li>\n</ul>\n<p>Java Heap可以通过-Xms 和 -Xmx 来设置最小值和最大值<br>Native Heap是在分配了java maximum Heap大小之后剩下的大小(jvm占用的内存也算在这里面)</p>\n<h3 id=\"3-3-数据类型大小\"><a href=\"#3-3-数据类型大小\" class=\"headerlink\" title=\"3.3 数据类型大小\"></a>3.3 数据类型大小</h3><p>基本数据类型大小很简单，其实也不简单。这张图是从ibm网站上截下来的<br><img src=\"http://odzl05jxx.bkt.clouddn.com/official_java_primitive_type_size_table.JPG\" alt=\"\"><br>注意一个boolean在数组中只占用一个字节，单独使用占用4个字节。<br>原理<a href=\"http://www.jianshu.com/p/2f663dc820d0\">参考</a></p>\n<p>引用的大小：<br>在 32 位的 JVM 上，一个对象引用占用 4 个字节；在 64 位上，占用 8 个字节。通过 java -d64 -version 可确定是否是 64 位的 JVM。<br>处理器能够处理的bit范围决定了操作系统能够使用的内存范围：<br>32位的cpu(2^32 = 4,294,967,296 bits = 4GB)<br>64位cpu (2^64 = 18,446,744,073,709,551,616 = 16 exabytes)<br>多数jvm是用c或者c++写的:</p>\n<ul>\n<li>the Java runtime creates an operating-system process — just as if you were running a C-based program. In fact, most JVMs are written largely in C or C++</li>\n</ul>\n<p>查看jvm是否64位的方法:</p>\n<ul>\n<li>java -d64 -version<br>64位上引用占用大小变大的原因是，需要管理4g以上的内存，指针(内存地址不够用了)</li>\n</ul>\n<h2 id=\"4-java对象内存布局，从一个Integer说起\"><a href=\"#4-java对象内存布局，从一个Integer说起\" class=\"headerlink\" title=\"4. java对象内存布局，从一个Integer说起\"></a>4. java对象内存布局，从一个Integer说起</h2><p>一个class实例占据的大小包括:</p>\n<ol>\n<li>自身的大小（对象头+基本数据类型数据大小） - Shadow heap size<br>Object自身的大小在不同的jvm版本和厂商之间有一些变化，但大体上包括三个部分:</li>\n</ol>\n<ul>\n<li>Class ： 一个指针，指向对应的class，用于表明其类型。比如一个Integer就指向java.lang.Integer这个类(32位上4字节，64位上8字节)</li>\n<li>Flags : A collection of flags that describe the state of the object, including the hash code for the object if it has one, and the shape of the object (that is, whether or not the object is an array).（就是存hash值和用于表示是不是数组的，32位上4字节，64位上8字节）</li>\n<li>Lock 所有的Object都能lock，这部分内存用于表示当前Object是否是被synchronized(32位上4字节，64位上8字节)</li>\n</ul>\n<p>所以，对于java.lang.Integer来说，一个Integer的大小就是：<br>32(class信息)+32(Flags)+32(Lock))+32(int是基本数据类型，4字节) = 128bits（16字节）<br>事实上，一个Interger的大小是int（4个字节）的四倍，简单来说一个对象的头信息就占用了3个字节。</p>\n<ol>\n<li><p>数组的大小<br>数组和普通的object差不多，多了一个size(32字节)。也就是说。为了存储一个int值。使用一个大小为1的int[]数组的内存消耗比一个Integer还要大。（同样，32位4字节，64位8字节）。数组因为多一个size，所以4个字节起步。</p>\n</li>\n<li><p>8个字节变成4个字节<br>IBM和Oracle的jvm都能够提供ompressed References (-Xcompressedrefs) 和Compressed OOPs (-XX:+UseCompressedOops) 选项。这样一来，原本在64位机器上要占用8个字节的指针就只要占用4个字节了。但这只对java Heap上的内存有效，对于Native Heap这部分，64位占用内存还是要比32位多。所以同样的一份代码，在64位上占用的内存一定比32位上多。jdk 1.6.x之后好像默认是打开了的。</p>\n</li>\n<li><p>引用的对象的大小(递归即可) - Retained heap size(Shallow Heap大小加上引用的对象的)<br>java.lang.Integer还算比较简单的，里面除了一个int值表示value以外，没有其它的成员变量，所以并没有引用到其他对象的实例。对于复杂一点的数据类型，比如jav.lang.String呢？</p>\n</li>\n</ol>\n<p>String本身是一个很简单的类(如果不算常量池的话)，几乎可以看成一个char数组的wrapper。除了一个普通对象的class、Flag和Locks等信息外，String内部还有一个 private int hash（用于Cache hash值），还有offset和count（这俩好像没找到），此外就是一个char数组了。<br>所以，为了存储8个字符(16个字节,128bits)。首先这个char数组对象占用了16个字节(2*8)+（对象头+数组大小）16个字节 = 256bits。<br>算到String头上，String本身的文件头是12个字节，算上hash,count,offset各自4个字节，就24个字节了。再加上数组的引用4个字节，再加上数组的大小32个字节。<br>合计60个字节（480bits）。而这里面实际有用的数据只有16个字节。73.3%的内存都是存储其他东西的。</p>\n<p>说的比较乱了，这里直接照搬一段计算,<a href=\"http://www.yunweipai.com/archives/1092.html\">参考</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 一般而言，Java 对象在虚拟机的结构如下：</div><div class=\"line\">•对象头（object header）：8 个字节（保存对象的 class 信息、ID、在虚拟机中的状态）</div><div class=\"line\">•Java 原始类型数据：如 int, float, char 等类型的数据</div><div class=\"line\">•引用（reference）：4 个字节</div><div class=\"line\">•填充符（padding）</div><div class=\"line\"></div><div class=\"line\">String定义：</div><div class=\"line\"></div><div class=\"line\">JDK6:</div><div class=\"line\">private final char value[];</div><div class=\"line\">private final int offset;</div><div class=\"line\">private final int count;</div><div class=\"line\">private int hash;</div><div class=\"line\"></div><div class=\"line\">JDK6的空字符串所占的空间为40字节</div><div class=\"line\"></div><div class=\"line\">JDK7:</div><div class=\"line\">private final char value[];</div><div class=\"line\">private int hash;</div><div class=\"line\">private transient int hash32;</div><div class=\"line\"></div><div class=\"line\">JDK7的空字符串所占的空间也是40字节</div><div class=\"line\"></div><div class=\"line\">JDK6字符串内存占用的计算方式：</div><div class=\"line\">首先计算一个空的 char 数组所占空间，在 Java 里数组也是对象，因而数组也有对象头，故一个数组所占的空间为对象头所占的空间加上数组长度，即 8 + 4 = 12 字节 , 经过填充后为 16 字节。</div><div class=\"line\"></div><div class=\"line\">那么一个空 String 所占空间为：</div><div class=\"line\"></div><div class=\"line\">对象头（8 字节）+ char 数组（16 字节）+ 3 个 int（3 × 4 = 12 字节）+1 个 char 数组的引用 (4 字节 ) = 40 字节。</div><div class=\"line\"></div><div class=\"line\">因此一个实际的 String 所占空间的计算公式如下：</div><div class=\"line\"></div><div class=\"line\">8*( ( 8+12+2*n+4+12)+7 ) / 8 = 8*(int) ( ( ( (n) *2 )+43) /8 )</div><div class=\"line\"></div><div class=\"line\">其中，n 为字符串长度。</div></pre></td></tr></table></figure></p>\n<ol>\n<li>小结<br>随便new一个Object就意味着12个Byte没了，数组的话16个字节没了。每添加一个成员变量（指针），4个字节没了。这些都还没算上实际存储的数据。</li>\n</ol>\n<h2 id=\"5-java-util框架中使用的那些集合类\"><a href=\"#5-java-util框架中使用的那些集合类\" class=\"headerlink\" title=\"5. java.util框架中使用的那些集合类\"></a>5. java.util框架中使用的那些集合类</h2><h3 id=\"5-1-HashSet\"><a href=\"#5-1-HashSet\" class=\"headerlink\" title=\"5.1 HashSet\"></a>5.1 HashSet</h3><p>A HashSet is an implementation of the Set interface。无重复元素，不保证迭代顺序，常规的add,contains等方法速度不会随着内部元素的增加而变慢。HashSet内部最多有一个null，底层实现是HashMap，这意味着其占用内存要比HashMap大。<br>默认容量 16个Entries<br>内部元素为空时的大小 144bytes<br>查找，添加，删除的时间复杂度为 O(1)，在没有Hash collisions发生的前提下 </p>\n<h3 id=\"5-2-HashMap\"><a href=\"#5-2-HashMap\" class=\"headerlink\" title=\"5.2 HashMap\"></a>5.2 HashMap</h3><p>A HashMap is an implementation of the Map interface.<br>HashMap是一种存储Key-Value型数据的集合，一个key最多map到一个value，key和value都可以为null，可以存储重复元素。（所以）——HashMap是HashSet的一种功能上的简化。<br>底层是Entries(Entries元素是链表)，长这样。</p>\n<ul>\n<li>transient HashMapEntry<K,V>[] table = (HashMapEntry<K,V>[]) EMPTY_TABLE;<br>HashMap的成员变量包括：</li>\n</ul>\n<p>transient HashMapEntry<K,V>[] table（HashMapEntry的数组）<br>int size<br>int threshold<br>final float loadFactor<br>transient int modCount;</p>\n<p>一个HashMap刚创建时(完全为空时)的大小为128bytes，jdk 1.8在初始化时没有加载Entries，在put操作时才去分配。可能会好一点。<br>内部结构一般是这样的，一个HashMapEntry的大小为32byte。<br>int KeyHash<br>Object next<br>Object key<br>Object value<br>HashMap每次put键值对时，都使用了一个HashMap$Entry这样的包装类，这意味着整个HashMap的overhead包括：<br>This means that the total overhead of a HashMap consists of the HashMap object, a HashMap$Entry array entry, and a HashMap$Entry object for each entry.<br>直接照搬结论：对于HashMap<br>Default capacities为16个 entries</p>\n<p>对于一个有10000个Entries的HashMap，光是由于HashMap，Entry数组以及每个Entry对象带来的overhead就达到了360K左右，这里还不算存储的键值对本身的大小。</p>\n<h3 id=\"5-3-Hashtable\"><a href=\"#5-3-Hashtable\" class=\"headerlink\" title=\"5.3 Hashtable\"></a>5.3 Hashtable</h3><p>HashTable和HashMap的主要区别是HashTable是线程安全的，HashTable中很多方法都加上了synchronized修饰。一般来讲，jdk1.5以上如果想要线程安全，直接用synchronizedHashMap。Hashtable继承自Dictionary，后者已经被废弃了，推荐使用map接口的实现类。<br>照搬结论：要存储10k个Entries，overhead达到360k。</p>\n<h3 id=\"5-4-LinkedList\"><a href=\"#5-4-LinkedList\" class=\"headerlink\" title=\"5.4 LinkedList\"></a>5.4 LinkedList</h3><p>Linkedist是典型的双向链表，除非增删操作特别频繁，否则没必要使用。<br>查找的时间复杂度为 o(n)。添加的元素被包装在一个Node节点中。<br>存储10K个元素的overhead为240K。</p>\n<h3 id=\"5-5-ArrayList\"><a href=\"#5-5-ArrayList\" class=\"headerlink\" title=\"5.5 ArrayList\"></a>5.5 ArrayList</h3><p>ArrayList要好很多，value直接存在一个数组内部，查找的时间复杂度为o(1)<br>存储10K个元素的overhead为40K左右。</p>\n<h3 id=\"5-6-StringBuffer，StringBuilder\"><a href=\"#5-6-StringBuffer，StringBuilder\" class=\"headerlink\" title=\"5.6 StringBuffer，StringBuilder\"></a>5.6 StringBuffer，StringBuilder</h3><p>StringBuffer直接强加synchronized，StringBuilder和StringBuffer都继承自AbstractStringBuilder。成员变量就两个一个char[] value和一个int count。</p>\n<h2 id=\"6-集合的默认初始容量和扩系数\"><a href=\"#6-集合的默认初始容量和扩系数\" class=\"headerlink\" title=\"6.集合的默认初始容量和扩系数\"></a>6.集合的默认初始容量和扩系数</h2><p>以StirngBuffer为例（也算一种char的集合吧），默认容量是16，即创建了一个char[16]，空的，算上对象头，一共72bytes。这还只是StringBuffer里什么都没存储的情况。<br>StringBuffer sb = new StringBuffer(“My String”)。//算下用了多少内存<br>首先算数组，文件头12bytes，加上size 16bytes。算上数组，（数组长度为str.length+16）一共116bytes，算上内存对齐，一共120bytes。StringBuffer对象的大小：对象头+count+数组指针 = 20 bytes。<br>合计140bytes，内存对齐后144bytes，只为存储”My String”这9个字符（36bytes）。<br>上面提到的这些集合类都对外提供了可以设置初始容量的构造函数以避免内存浪费，但要注意HashMap只接受2的指数幂。</p>\n<h3 id=\"7-high-level抽象带来的便利性及所需付出的代价\"><a href=\"#7-high-level抽象带来的便利性及所需付出的代价\" class=\"headerlink\" title=\"7.high level抽象带来的便利性及所需付出的代价\"></a>7.high level抽象带来的便利性及所需付出的代价</h3><p>面向对象语言推荐开发者使用一些高层抽象化的类，但更加复杂的功能意味着内存占用的增加。而内存意味着一切，所以，权衡好开发便利与内存占用对于程序的高效运行就十分重要，而这一切的前提就在于了解这些Wrapper对象工作的原理。</p>\n<h2 id=\"一些很有意思的事情\"><a href=\"#一些很有意思的事情\" class=\"headerlink\" title=\"一些很有意思的事情\"></a>一些很有意思的事情</h2><ul>\n<li>Integer内部缓存了一个Integer[] ，最大值可以通过(java.lang.Integer.IntegerCache.high)配置</li>\n<li>不同版本jdk上String的优化很有意思，又是那个一个String占用多少字节的问题</li>\n<li>关于ConcurrentModificationException，对一个集合的更改分为结构性更改和集合元素值的更改，前者会抛出ConcurrentModificationException，后者不会。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.liaohuqiu.net/cn/posts/caculate-object-size-in-java/\">JAVA 对象大小</a></li>\n<li><a href=\"http://www.cnblogs.com/zhanjindong/p/3757767.html\">一个Java对象到底占用多大内存</a></li>\n<li><a href=\"http://github.thinkingbar.com/lookup-objsize/\">查看 Java 对象大小</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/library/j-codetoheap/index.html\">From Java code to Java heap</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=FLcXf9pO27w\">Understanding the Memory Usage of Your Application</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/library/j-nativememory-linux/index.html\">Thanks for the memory, Linux</a></li>\n<li><a href=\"http://www.jianshu.com/p/2f663dc820d0\">boolean数组中一个值占用1bit</a></li>\n<li><a href=\"http://www.yunweipai.com/archives/1092.html\">不同jdk版本String做的优化</a> </li>\n</ul>"},{"title":"activity transition pre and post lollipop","date":"2016-09-27T06:53:25.000Z","_content":"\nLollipop开始引入了新的Activity Transition动画效果，比起常用的overridePendingTransaction() 效果要强大许多\n\n测试环境\nsupportLibVersion = \"24.2.1\"\ngradle plugin version : \"classpath 'com.android.tools.build:gradle:2.2.0'\"\ngradle version : 3.1\ncompileSdkVersion 24\nbuildToolsVersion \"24.0.2\"\n\n<!--more-->\n\n- 常规用法:\n\nA activity >>>> B activity\n\nA activity中:\n\n```java\n intent = new Intent(getActivity(), PictureDetailSubActivity2.class);\n                intent.putExtra(EXTRA_IMAGE_URL, R.drawable.b2);\n                intent.putExtra(EXTRA_IMAGE_TITLE, \"使用ActivityCompat动画\");\n                ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.\n                        makeSceneTransitionAnimation(getActivity(), view, TRANSIT_PIC);\n                try {\n                    ActivityCompat.startActivity(getActivity(), intent, optionsCompat.toBundle()); //据说部分三星手机上会失效\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    ToastUtils.showTextShort(getActivity(), \"ActivityCompat出错！！\");\n                    startActivity(intent);\n                }\n```\n\nPair这个class是v4包里的一个Util类，用来装载一组(pair)对象，支持泛型，很好用。由于都是v4包里的方法，省去了做API版本判断，在API 16以下，就只会调用普通的startActivity方法。上面加了try catch是避免部分手机上出现问题\n\nB activity中onCreate调用\n\n```java\n ViewCompat.setTransitionName(binding.imageDetail, TRANSIT_PIC);\n```\n\n就可实现普通的转场动画。\n\n- 兼容方式(将连续的Transition带到API16以下)\n\n  主要的原理: 在A activity中记录要带到B activity中的View的当前位置，在B activity中添加onPredrawListener(measure完毕，layout完毕，即将开始Draw的时候)，此时开始进行动画，将SharedView从原位置animate到B Activty中的位置\n\n  原理及详细代码在这里:\n\n   [Dev Bytes Activity Animations Youtube](https://www.youtube.com/watch?v=CPxkoe2MraA) 我照着写了一些关于Activity Transition的模板，[gitHub](https://github.com/Haldir65/CustomActivityTransition) 基本能实现兼容到API 16以下的效果\n\n- 最后是这几天遇到的天坑\n\n```java\n@Override\npublic void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) {\n    super.onCreate(savedInstanceState, persistentState);\n}\n```\n\n这样的Activity绝对会出ClassNotFoundException , 而且并不会主动出现在logcat中\n\n- overridePendingTransaction要在startActivity以及finish之后才能调用\n\n\n\ngitHub上有一个比较好的[兼容库](https://github.com/takahirom/PreLollipopTransition)，大致原理也是使用onPreDrawListener\n\n\n\n","source":"_posts/activity-transition-pre-and-post-lollipop.md","raw":"---\ntitle: activity transition pre and post lollipop\ndate: 2016-09-27 14:53:25\ncategories: blog\ntags: [transition,android]\n---\n\nLollipop开始引入了新的Activity Transition动画效果，比起常用的overridePendingTransaction() 效果要强大许多\n\n测试环境\nsupportLibVersion = \"24.2.1\"\ngradle plugin version : \"classpath 'com.android.tools.build:gradle:2.2.0'\"\ngradle version : 3.1\ncompileSdkVersion 24\nbuildToolsVersion \"24.0.2\"\n\n<!--more-->\n\n- 常规用法:\n\nA activity >>>> B activity\n\nA activity中:\n\n```java\n intent = new Intent(getActivity(), PictureDetailSubActivity2.class);\n                intent.putExtra(EXTRA_IMAGE_URL, R.drawable.b2);\n                intent.putExtra(EXTRA_IMAGE_TITLE, \"使用ActivityCompat动画\");\n                ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.\n                        makeSceneTransitionAnimation(getActivity(), view, TRANSIT_PIC);\n                try {\n                    ActivityCompat.startActivity(getActivity(), intent, optionsCompat.toBundle()); //据说部分三星手机上会失效\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    ToastUtils.showTextShort(getActivity(), \"ActivityCompat出错！！\");\n                    startActivity(intent);\n                }\n```\n\nPair这个class是v4包里的一个Util类，用来装载一组(pair)对象，支持泛型，很好用。由于都是v4包里的方法，省去了做API版本判断，在API 16以下，就只会调用普通的startActivity方法。上面加了try catch是避免部分手机上出现问题\n\nB activity中onCreate调用\n\n```java\n ViewCompat.setTransitionName(binding.imageDetail, TRANSIT_PIC);\n```\n\n就可实现普通的转场动画。\n\n- 兼容方式(将连续的Transition带到API16以下)\n\n  主要的原理: 在A activity中记录要带到B activity中的View的当前位置，在B activity中添加onPredrawListener(measure完毕，layout完毕，即将开始Draw的时候)，此时开始进行动画，将SharedView从原位置animate到B Activty中的位置\n\n  原理及详细代码在这里:\n\n   [Dev Bytes Activity Animations Youtube](https://www.youtube.com/watch?v=CPxkoe2MraA) 我照着写了一些关于Activity Transition的模板，[gitHub](https://github.com/Haldir65/CustomActivityTransition) 基本能实现兼容到API 16以下的效果\n\n- 最后是这几天遇到的天坑\n\n```java\n@Override\npublic void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) {\n    super.onCreate(savedInstanceState, persistentState);\n}\n```\n\n这样的Activity绝对会出ClassNotFoundException , 而且并不会主动出现在logcat中\n\n- overridePendingTransaction要在startActivity以及finish之后才能调用\n\n\n\ngitHub上有一个比较好的[兼容库](https://github.com/takahirom/PreLollipopTransition)，大致原理也是使用onPreDrawListener\n\n\n\n","slug":"activity-transition-pre-and-post-lollipop","published":1,"updated":"2017-04-23T10:52:01.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnkk002zbovrcwx4iqcn","content":"<p>Lollipop开始引入了新的Activity Transition动画效果，比起常用的overridePendingTransaction() 效果要强大许多</p>\n<p>测试环境<br>supportLibVersion = “24.2.1”<br>gradle plugin version : “classpath ‘com.android.tools.build:gradle:2.2.0’”<br>gradle version : 3.1<br>compileSdkVersion 24<br>buildToolsVersion “24.0.2”</p>\n<a id=\"more\"></a>\n<ul>\n<li>常规用法:</li>\n</ul>\n<p>A activity &gt;&gt;&gt;&gt; B activity</p>\n<p>A activity中:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent = <span class=\"keyword\">new</span> Intent(getActivity(), PictureDetailSubActivity2.class);</div><div class=\"line\">               intent.putExtra(EXTRA_IMAGE_URL, R.drawable.b2);</div><div class=\"line\">               intent.putExtra(EXTRA_IMAGE_TITLE, <span class=\"string\">\"使用ActivityCompat动画\"</span>);</div><div class=\"line\">               ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.</div><div class=\"line\">                       makeSceneTransitionAnimation(getActivity(), view, TRANSIT_PIC);</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   ActivityCompat.startActivity(getActivity(), intent, optionsCompat.toBundle()); <span class=\"comment\">//据说部分三星手机上会失效</span></div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                   e.printStackTrace();</div><div class=\"line\">                   ToastUtils.showTextShort(getActivity(), <span class=\"string\">\"ActivityCompat出错！！\"</span>);</div><div class=\"line\">                   startActivity(intent);</div><div class=\"line\">               &#125;</div></pre></td></tr></table></figure>\n<p>Pair这个class是v4包里的一个Util类，用来装载一组(pair)对象，支持泛型，很好用。由于都是v4包里的方法，省去了做API版本判断，在API 16以下，就只会调用普通的startActivity方法。上面加了try catch是避免部分手机上出现问题</p>\n<p>B activity中onCreate调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ViewCompat.setTransitionName(binding.imageDetail, TRANSIT_PIC);</div></pre></td></tr></table></figure>\n<p>就可实现普通的转场动画。</p>\n<ul>\n<li><p>兼容方式(将连续的Transition带到API16以下)</p>\n<p>主要的原理: 在A activity中记录要带到B activity中的View的当前位置，在B activity中添加onPredrawListener(measure完毕，layout完毕，即将开始Draw的时候)，此时开始进行动画，将SharedView从原位置animate到B Activty中的位置</p>\n<p>原理及详细代码在这里:</p>\n<p> <a href=\"https://www.youtube.com/watch?v=CPxkoe2MraA\">Dev Bytes Activity Animations Youtube</a> 我照着写了一些关于Activity Transition的模板，<a href=\"https://github.com/Haldir65/CustomActivityTransition\">gitHub</a> 基本能实现兼容到API 16以下的效果</p>\n</li>\n<li><p>最后是这几天遇到的天坑</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState, PersistableBundle persistentState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState, persistentState);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样的Activity绝对会出ClassNotFoundException , 而且并不会主动出现在logcat中</p>\n<ul>\n<li>overridePendingTransaction要在startActivity以及finish之后才能调用</li>\n</ul>\n<p>gitHub上有一个比较好的<a href=\"https://github.com/takahirom/PreLollipopTransition\">兼容库</a>，大致原理也是使用onPreDrawListener</p>\n","excerpt":"<p>Lollipop开始引入了新的Activity Transition动画效果，比起常用的overridePendingTransaction() 效果要强大许多</p>\n<p>测试环境<br>supportLibVersion = “24.2.1”<br>gradle plugin version : “classpath ‘com.android.tools.build:gradle:2.2.0’”<br>gradle version : 3.1<br>compileSdkVersion 24<br>buildToolsVersion “24.0.2”</p>","more":"<ul>\n<li>常规用法:</li>\n</ul>\n<p>A activity &gt;&gt;&gt;&gt; B activity</p>\n<p>A activity中:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent = <span class=\"keyword\">new</span> Intent(getActivity(), PictureDetailSubActivity2.class);</div><div class=\"line\">               intent.putExtra(EXTRA_IMAGE_URL, R.drawable.b2);</div><div class=\"line\">               intent.putExtra(EXTRA_IMAGE_TITLE, <span class=\"string\">\"使用ActivityCompat动画\"</span>);</div><div class=\"line\">               ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.</div><div class=\"line\">                       makeSceneTransitionAnimation(getActivity(), view, TRANSIT_PIC);</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   ActivityCompat.startActivity(getActivity(), intent, optionsCompat.toBundle()); <span class=\"comment\">//据说部分三星手机上会失效</span></div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                   e.printStackTrace();</div><div class=\"line\">                   ToastUtils.showTextShort(getActivity(), <span class=\"string\">\"ActivityCompat出错！！\"</span>);</div><div class=\"line\">                   startActivity(intent);</div><div class=\"line\">               &#125;</div></pre></td></tr></table></figure>\n<p>Pair这个class是v4包里的一个Util类，用来装载一组(pair)对象，支持泛型，很好用。由于都是v4包里的方法，省去了做API版本判断，在API 16以下，就只会调用普通的startActivity方法。上面加了try catch是避免部分手机上出现问题</p>\n<p>B activity中onCreate调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ViewCompat.setTransitionName(binding.imageDetail, TRANSIT_PIC);</div></pre></td></tr></table></figure>\n<p>就可实现普通的转场动画。</p>\n<ul>\n<li><p>兼容方式(将连续的Transition带到API16以下)</p>\n<p>主要的原理: 在A activity中记录要带到B activity中的View的当前位置，在B activity中添加onPredrawListener(measure完毕，layout完毕，即将开始Draw的时候)，此时开始进行动画，将SharedView从原位置animate到B Activty中的位置</p>\n<p>原理及详细代码在这里:</p>\n<p> <a href=\"https://www.youtube.com/watch?v=CPxkoe2MraA\">Dev Bytes Activity Animations Youtube</a> 我照着写了一些关于Activity Transition的模板，<a href=\"https://github.com/Haldir65/CustomActivityTransition\">gitHub</a> 基本能实现兼容到API 16以下的效果</p>\n</li>\n<li><p>最后是这几天遇到的天坑</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState, PersistableBundle persistentState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState, persistentState);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样的Activity绝对会出ClassNotFoundException , 而且并不会主动出现在logcat中</p>\n<ul>\n<li>overridePendingTransaction要在startActivity以及finish之后才能调用</li>\n</ul>\n<p>gitHub上有一个比较好的<a href=\"https://github.com/takahirom/PreLollipopTransition\">兼容库</a>，大致原理也是使用onPreDrawListener</p>"},{"title":"LruCache阅读笔记","date":"2017-07-23T11:02:21.000Z","_content":"\nLruCache在android3.1中加入，即android.util.LruCache，主要是作为一种合理的缓存策略的实现，用于替代原来的SoftReference。v4包提供了static version的实现，即android.support.v4.util.LruCache。\n此外，还有DiskLruCache对应磁盘缓存，在OkHttp和Glide等开源项目中都有，可直接复制过来，改下包名直接用。这些类本质上都是对于Least Recently Used算法的实现。稍微看了下网上的博客，LruCache实际上就是利用了LinkedHashmap的accessorder来实现末位淘汰的。v4包里的LinkedHashmap就是java.util里面的,platform里的LinkedHashmap添加了一些方法。\n<!--more-->\n\n\n## 1. 使用入门\n这是最简单的一个用于缓存图片Bitmap的cache的算法\n```java\nint maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);\n        int cacheSize = maxMemory/8;\n        mMemoryCache = new LruCache<String,Bitmap>(cacheSize){\n            @Override\n            protected int sizeOf(String key, Bitmap value) {\n                return value.getRowBytes()*value.getHeight()/1024;\n            }\n        };\n```\n这个sizeOf函数必须复写，用于计算单个元素大小，主要为了确保缓存不超出最大容量。\n\n\n\n\n\n\n## 参考 \n- [彻底解析Android缓存机制——LruCache](http://www.jianshu.com/p/b49a111147ee)","source":"_posts/2017-07-23-lru-cache-and-more.md","raw":"---\ntitle: LruCache阅读笔记\ndate: 2017-07-23 19:02:21\ntags: [android]\n---\n\nLruCache在android3.1中加入，即android.util.LruCache，主要是作为一种合理的缓存策略的实现，用于替代原来的SoftReference。v4包提供了static version的实现，即android.support.v4.util.LruCache。\n此外，还有DiskLruCache对应磁盘缓存，在OkHttp和Glide等开源项目中都有，可直接复制过来，改下包名直接用。这些类本质上都是对于Least Recently Used算法的实现。稍微看了下网上的博客，LruCache实际上就是利用了LinkedHashmap的accessorder来实现末位淘汰的。v4包里的LinkedHashmap就是java.util里面的,platform里的LinkedHashmap添加了一些方法。\n<!--more-->\n\n\n## 1. 使用入门\n这是最简单的一个用于缓存图片Bitmap的cache的算法\n```java\nint maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);\n        int cacheSize = maxMemory/8;\n        mMemoryCache = new LruCache<String,Bitmap>(cacheSize){\n            @Override\n            protected int sizeOf(String key, Bitmap value) {\n                return value.getRowBytes()*value.getHeight()/1024;\n            }\n        };\n```\n这个sizeOf函数必须复写，用于计算单个元素大小，主要为了确保缓存不超出最大容量。\n\n\n\n\n\n\n## 参考 \n- [彻底解析Android缓存机制——LruCache](http://www.jianshu.com/p/b49a111147ee)","slug":"2017-07-23-lru-cache-and-more","published":1,"updated":"2017-07-28T23:49:48.705Z","_id":"cj5gmdnkp0030bovrskm34ba1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>LruCache在android3.1中加入，即android.util.LruCache，主要是作为一种合理的缓存策略的实现，用于替代原来的SoftReference。v4包提供了static version的实现，即android.support.v4.util.LruCache。<br>此外，还有DiskLruCache对应磁盘缓存，在OkHttp和Glide等开源项目中都有，可直接复制过来，改下包名直接用。这些类本质上都是对于Least Recently Used算法的实现。稍微看了下网上的博客，LruCache实际上就是利用了LinkedHashmap的accessorder来实现末位淘汰的。v4包里的LinkedHashmap就是java.util里面的,platform里的LinkedHashmap添加了一些方法。<br><a id=\"more\"></a></p>\n<h2 id=\"1-使用入门\"><a href=\"#1-使用入门\" class=\"headerlink\" title=\"1. 使用入门\"></a>1. 使用入门</h2><p>这是最简单的一个用于缓存图片Bitmap的cache的算法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().totalMemory()/<span class=\"number\">1024</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> cacheSize = maxMemory/<span class=\"number\">8</span>;</div><div class=\"line\">        mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> value.getRowBytes()*value.getHeight()/<span class=\"number\">1024</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>这个sizeOf函数必须复写，用于计算单个元素大小，主要为了确保缓存不超出最大容量。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/b49a111147ee\">彻底解析Android缓存机制——LruCache</a></li>\n</ul>\n","excerpt":"<p>LruCache在android3.1中加入，即android.util.LruCache，主要是作为一种合理的缓存策略的实现，用于替代原来的SoftReference。v4包提供了static version的实现，即android.support.v4.util.LruCache。<br>此外，还有DiskLruCache对应磁盘缓存，在OkHttp和Glide等开源项目中都有，可直接复制过来，改下包名直接用。这些类本质上都是对于Least Recently Used算法的实现。稍微看了下网上的博客，LruCache实际上就是利用了LinkedHashmap的accessorder来实现末位淘汰的。v4包里的LinkedHashmap就是java.util里面的,platform里的LinkedHashmap添加了一些方法。<br>","more":"</p>\n<h2 id=\"1-使用入门\"><a href=\"#1-使用入门\" class=\"headerlink\" title=\"1. 使用入门\"></a>1. 使用入门</h2><p>这是最简单的一个用于缓存图片Bitmap的cache的算法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().totalMemory()/<span class=\"number\">1024</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> cacheSize = maxMemory/<span class=\"number\">8</span>;</div><div class=\"line\">        mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> value.getRowBytes()*value.getHeight()/<span class=\"number\">1024</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>这个sizeOf函数必须复写，用于计算单个元素大小，主要为了确保缓存不超出最大容量。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/b49a111147ee\">彻底解析Android缓存机制——LruCache</a></li>\n</ul>"},{"title":"位运算总结","date":"2017-07-23T11:06:46.000Z","_content":"\n\n<!--more-->\n\n","source":"_posts/2017-07-23-manipulating-bits.md","raw":"---\ntitle: 位运算总结\ndate: 2017-07-23 19:06:46\ntags: [java]\n---\n\n\n<!--more-->\n\n","slug":"2017-07-23-manipulating-bits","published":1,"updated":"2017-07-28T23:49:48.712Z","_id":"cj5gmdnkt0032bovr55chdy2a","comments":1,"layout":"post","photos":[],"link":"","content":"<a id=\"more\"></a>\n","excerpt":"","more":""},{"title":"android 7.0一些新特性介绍及适配方案","date":"2016-10-07T19:02:26.000Z","_content":"\nGoogle I/O 2016上的[What's new in Android](https://www.youtube.com/watch?v=B08iLAtS3AQ)介绍的比较全面，MultiWindow、Notification、ConstraintLayout等都比较简单。这里拎出来开发者不得不注意的几点来介绍。\n<!--more-->\n\n### 1. BackGround Optimization\n\n~~CONNECTIVITY_CHANGE~~(很多应用喜欢在Manifest里注册这个BroadcastReceiver，导致网络变化时，一大堆应用都被唤醒，而ram中无法同时存在这么多process，系统不得不kill old process，由此导致memory thrashing)\n\n同时被移除的还有~~NEW_PICTURE~~,~~NEW_VIDEO~~.\n\n具体来说: 对于**targeting N**的应用，在manifest文件中声明 static broadcastReceiver，监听~~CONNECTIVITY_CHANGE~~将不会唤醒应用。如果应用正在运行，使用context.registerReceiver，将仍能够接受到broadcast。但不会被唤醒。\n\n解决方案: 使用JobScheduler或firebase jobDispatcher。\n举个例子:\n```java\n  public static final int MY_BACKGROUND_JOB = 0;\n    public static void scheduleJob(Context context){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            JobScheduler js =\n                    (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);\n            JobInfo job = new JobInfo.Builder(\n                    MY_BACKGROUND_JOB,\n                    new ComponentName(context,MyJobService.class)).\n                    setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED).\n                    setRequiresCharging(true).\n                    build();\n            js.schedule(job);\n        }\n      \n    }\n```\n\n\n对于~~NEW_PICTURE~~,~~NEW_VIDEO~~.\n\n所有在7.0 Nuget以上设备运行的应用(无论是否 target N) 都不会收到这些broadcast。简单来说，fully deprecated  !!!\n\n解决方案：使用JobScheduler(可以监听contentProvider change)\n~~NEW_PICTURE~~的处理(这段代码只在API24以上存在，所以加了版本判断)\n```java\n    public static void scheduleJob(Context context){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n            JobScheduler js =\n                    context.getSystemService(JobScheduler.class);\n            JobInfo.Builder builder = new JobInfo.Builder(\n                    R.id.schedule_photo_jobs,\n                    new ComponentName(context,PhotoContentJob.class));\n\n            builder.addTriggerContentUri(\n                    new JobInfo.TriggerContentUri(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                            JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS)\n            );\n            js.schedule(builder.build());\n        }\n    }\n```\n参考[youtube上谷歌员工的演讲](https://www.youtube.com/watch?v=3ZX0CfVfVP8)\n\n### 2. 文件系统的权限更改(FileProvider)\n\n File storage permission change \n 简单来说就是Uri.fromFile(file://URI)不能再用了，需要使用FileProvider，这主要是为了6.0开始引进的permission model 考虑的，storage permission例如WRITE_EXTERNAL_STORAGE这种都已经属于Dangerous permission了。\n 一个常见的场景就是调用系统相机拍照，给Intent设置一个uri，在7.0上直接用Uri.FromFile会崩\n 需要通过FileProvider提供Uri,写了一个[Demo](https://github.com/Haldir65/FileProviderDmo)，使用FileProvider传递文件给另一个App。\n 另一个需要注意的就是DownloadManager访问COLUMN_LOCAL_FILENAME会报错，这个不常见。\n\n\n\n\n\n## Reference\n\n1. [Docs](https://developer.android.com/topic/performance/background-optimization.html?utm_campaign=adp_series__100616&utm_source=anddev&utm_medium=yt-desc)\n2. [youtube](https://www.youtube.com/watch?v=vBjTXKpaFj8)\n3. [Andrioid 7.0适配心得](http://gold.xitu.io/entry/57ff7e14a0bb9f005860c805)\n4. [Android 7.0 Behavior Changes](https://developer.android.com/about/versions/nougat/android-7.0-changes.html)","source":"_posts/android-7-0-new-features.md","raw":"---\ntitle: android 7.0一些新特性介绍及适配方案\ndate: 2016-10-08 03:02:26\ncategories: blog  \ntags: [android]\n---\n\nGoogle I/O 2016上的[What's new in Android](https://www.youtube.com/watch?v=B08iLAtS3AQ)介绍的比较全面，MultiWindow、Notification、ConstraintLayout等都比较简单。这里拎出来开发者不得不注意的几点来介绍。\n<!--more-->\n\n### 1. BackGround Optimization\n\n~~CONNECTIVITY_CHANGE~~(很多应用喜欢在Manifest里注册这个BroadcastReceiver，导致网络变化时，一大堆应用都被唤醒，而ram中无法同时存在这么多process，系统不得不kill old process，由此导致memory thrashing)\n\n同时被移除的还有~~NEW_PICTURE~~,~~NEW_VIDEO~~.\n\n具体来说: 对于**targeting N**的应用，在manifest文件中声明 static broadcastReceiver，监听~~CONNECTIVITY_CHANGE~~将不会唤醒应用。如果应用正在运行，使用context.registerReceiver，将仍能够接受到broadcast。但不会被唤醒。\n\n解决方案: 使用JobScheduler或firebase jobDispatcher。\n举个例子:\n```java\n  public static final int MY_BACKGROUND_JOB = 0;\n    public static void scheduleJob(Context context){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            JobScheduler js =\n                    (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);\n            JobInfo job = new JobInfo.Builder(\n                    MY_BACKGROUND_JOB,\n                    new ComponentName(context,MyJobService.class)).\n                    setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED).\n                    setRequiresCharging(true).\n                    build();\n            js.schedule(job);\n        }\n      \n    }\n```\n\n\n对于~~NEW_PICTURE~~,~~NEW_VIDEO~~.\n\n所有在7.0 Nuget以上设备运行的应用(无论是否 target N) 都不会收到这些broadcast。简单来说，fully deprecated  !!!\n\n解决方案：使用JobScheduler(可以监听contentProvider change)\n~~NEW_PICTURE~~的处理(这段代码只在API24以上存在，所以加了版本判断)\n```java\n    public static void scheduleJob(Context context){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n            JobScheduler js =\n                    context.getSystemService(JobScheduler.class);\n            JobInfo.Builder builder = new JobInfo.Builder(\n                    R.id.schedule_photo_jobs,\n                    new ComponentName(context,PhotoContentJob.class));\n\n            builder.addTriggerContentUri(\n                    new JobInfo.TriggerContentUri(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                            JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS)\n            );\n            js.schedule(builder.build());\n        }\n    }\n```\n参考[youtube上谷歌员工的演讲](https://www.youtube.com/watch?v=3ZX0CfVfVP8)\n\n### 2. 文件系统的权限更改(FileProvider)\n\n File storage permission change \n 简单来说就是Uri.fromFile(file://URI)不能再用了，需要使用FileProvider，这主要是为了6.0开始引进的permission model 考虑的，storage permission例如WRITE_EXTERNAL_STORAGE这种都已经属于Dangerous permission了。\n 一个常见的场景就是调用系统相机拍照，给Intent设置一个uri，在7.0上直接用Uri.FromFile会崩\n 需要通过FileProvider提供Uri,写了一个[Demo](https://github.com/Haldir65/FileProviderDmo)，使用FileProvider传递文件给另一个App。\n 另一个需要注意的就是DownloadManager访问COLUMN_LOCAL_FILENAME会报错，这个不常见。\n\n\n\n\n\n## Reference\n\n1. [Docs](https://developer.android.com/topic/performance/background-optimization.html?utm_campaign=adp_series__100616&utm_source=anddev&utm_medium=yt-desc)\n2. [youtube](https://www.youtube.com/watch?v=vBjTXKpaFj8)\n3. [Andrioid 7.0适配心得](http://gold.xitu.io/entry/57ff7e14a0bb9f005860c805)\n4. [Android 7.0 Behavior Changes](https://developer.android.com/about/versions/nougat/android-7.0-changes.html)","slug":"android-7-0-new-features","published":1,"updated":"2017-04-23T10:52:07.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnkx0035bovrh3ue0ugc","content":"<p>Google I/O 2016上的<a href=\"https://www.youtube.com/watch?v=B08iLAtS3AQ\">What’s new in Android</a>介绍的比较全面，MultiWindow、Notification、ConstraintLayout等都比较简单。这里拎出来开发者不得不注意的几点来介绍。<br><a id=\"more\"></a></p>\n<h3 id=\"1-BackGround-Optimization\"><a href=\"#1-BackGround-Optimization\" class=\"headerlink\" title=\"1. BackGround Optimization\"></a>1. BackGround Optimization</h3><p><del>CONNECTIVITY_CHANGE</del>(很多应用喜欢在Manifest里注册这个BroadcastReceiver，导致网络变化时，一大堆应用都被唤醒，而ram中无法同时存在这么多process，系统不得不kill old process，由此导致memory thrashing)</p>\n<p>同时被移除的还有<del>NEW_PICTURE</del>,<del>NEW_VIDEO</del>.</p>\n<p>具体来说: 对于<strong>targeting N</strong>的应用，在manifest文件中声明 static broadcastReceiver，监听<del>CONNECTIVITY_CHANGE</del>将不会唤醒应用。如果应用正在运行，使用context.registerReceiver，将仍能够接受到broadcast。但不会被唤醒。</p>\n<p>解决方案: 使用JobScheduler或firebase jobDispatcher。<br>举个例子:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MY_BACKGROUND_JOB = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleJob</span><span class=\"params\">(Context context)</span></span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class=\"line\">          JobScheduler js =</div><div class=\"line\">                  (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</div><div class=\"line\">          JobInfo job = <span class=\"keyword\">new</span> JobInfo.Builder(</div><div class=\"line\">                  MY_BACKGROUND_JOB,</div><div class=\"line\">                  <span class=\"keyword\">new</span> ComponentName(context,MyJobService.class)).</div><div class=\"line\">                  setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED).</div><div class=\"line\">                  setRequiresCharging(<span class=\"keyword\">true</span>).</div><div class=\"line\">                  build();</div><div class=\"line\">          js.schedule(job);</div><div class=\"line\">      &#125;</div><div class=\"line\">    </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>对于<del>NEW_PICTURE</del>,<del>NEW_VIDEO</del>.</p>\n<p>所有在7.0 Nuget以上设备运行的应用(无论是否 target N) 都不会收到这些broadcast。简单来说，fully deprecated  !!!</p>\n<p>解决方案：使用JobScheduler(可以监听contentProvider change)<br><del>NEW_PICTURE</del>的处理(这段代码只在API24以上存在，所以加了版本判断)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleJob</span><span class=\"params\">(Context context)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</div><div class=\"line\">        JobScheduler js =</div><div class=\"line\">                context.getSystemService(JobScheduler.class);</div><div class=\"line\">        JobInfo.Builder builder = <span class=\"keyword\">new</span> JobInfo.Builder(</div><div class=\"line\">                R.id.schedule_photo_jobs,</div><div class=\"line\">                <span class=\"keyword\">new</span> ComponentName(context,PhotoContentJob.class));</div><div class=\"line\"></div><div class=\"line\">        builder.addTriggerContentUri(</div><div class=\"line\">                <span class=\"keyword\">new</span> JobInfo.TriggerContentUri(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,</div><div class=\"line\">                        JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS)</div><div class=\"line\">        );</div><div class=\"line\">        js.schedule(builder.build());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>参考<a href=\"https://www.youtube.com/watch?v=3ZX0CfVfVP8\">youtube上谷歌员工的演讲</a></p>\n<h3 id=\"2-文件系统的权限更改-FileProvider\"><a href=\"#2-文件系统的权限更改-FileProvider\" class=\"headerlink\" title=\"2. 文件系统的权限更改(FileProvider)\"></a>2. 文件系统的权限更改(FileProvider)</h3><p> File storage permission change<br> 简单来说就是Uri.fromFile(file://URI)不能再用了，需要使用FileProvider，这主要是为了6.0开始引进的permission model 考虑的，storage permission例如WRITE_EXTERNAL_STORAGE这种都已经属于Dangerous permission了。<br> 一个常见的场景就是调用系统相机拍照，给Intent设置一个uri，在7.0上直接用Uri.FromFile会崩<br> 需要通过FileProvider提供Uri,写了一个<a href=\"https://github.com/Haldir65/FileProviderDmo\">Demo</a>，使用FileProvider传递文件给另一个App。<br> 另一个需要注意的就是DownloadManager访问COLUMN_LOCAL_FILENAME会报错，这个不常见。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"https://developer.android.com/topic/performance/background-optimization.html?utm_campaign=adp_series__100616&amp;utm_source=anddev&amp;utm_medium=yt-desc\">Docs</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=vBjTXKpaFj8\">youtube</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57ff7e14a0bb9f005860c805\">Andrioid 7.0适配心得</a></li>\n<li><a href=\"https://developer.android.com/about/versions/nougat/android-7.0-changes.html\">Android 7.0 Behavior Changes</a></li>\n</ol>\n","excerpt":"<p>Google I/O 2016上的<a href=\"https://www.youtube.com/watch?v=B08iLAtS3AQ\">What’s new in Android</a>介绍的比较全面，MultiWindow、Notification、ConstraintLayout等都比较简单。这里拎出来开发者不得不注意的几点来介绍。<br>","more":"</p>\n<h3 id=\"1-BackGround-Optimization\"><a href=\"#1-BackGround-Optimization\" class=\"headerlink\" title=\"1. BackGround Optimization\"></a>1. BackGround Optimization</h3><p><del>CONNECTIVITY_CHANGE</del>(很多应用喜欢在Manifest里注册这个BroadcastReceiver，导致网络变化时，一大堆应用都被唤醒，而ram中无法同时存在这么多process，系统不得不kill old process，由此导致memory thrashing)</p>\n<p>同时被移除的还有<del>NEW_PICTURE</del>,<del>NEW_VIDEO</del>.</p>\n<p>具体来说: 对于<strong>targeting N</strong>的应用，在manifest文件中声明 static broadcastReceiver，监听<del>CONNECTIVITY_CHANGE</del>将不会唤醒应用。如果应用正在运行，使用context.registerReceiver，将仍能够接受到broadcast。但不会被唤醒。</p>\n<p>解决方案: 使用JobScheduler或firebase jobDispatcher。<br>举个例子:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MY_BACKGROUND_JOB = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleJob</span><span class=\"params\">(Context context)</span></span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class=\"line\">          JobScheduler js =</div><div class=\"line\">                  (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</div><div class=\"line\">          JobInfo job = <span class=\"keyword\">new</span> JobInfo.Builder(</div><div class=\"line\">                  MY_BACKGROUND_JOB,</div><div class=\"line\">                  <span class=\"keyword\">new</span> ComponentName(context,MyJobService.class)).</div><div class=\"line\">                  setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED).</div><div class=\"line\">                  setRequiresCharging(<span class=\"keyword\">true</span>).</div><div class=\"line\">                  build();</div><div class=\"line\">          js.schedule(job);</div><div class=\"line\">      &#125;</div><div class=\"line\">    </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>对于<del>NEW_PICTURE</del>,<del>NEW_VIDEO</del>.</p>\n<p>所有在7.0 Nuget以上设备运行的应用(无论是否 target N) 都不会收到这些broadcast。简单来说，fully deprecated  !!!</p>\n<p>解决方案：使用JobScheduler(可以监听contentProvider change)<br><del>NEW_PICTURE</del>的处理(这段代码只在API24以上存在，所以加了版本判断)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleJob</span><span class=\"params\">(Context context)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</div><div class=\"line\">        JobScheduler js =</div><div class=\"line\">                context.getSystemService(JobScheduler.class);</div><div class=\"line\">        JobInfo.Builder builder = <span class=\"keyword\">new</span> JobInfo.Builder(</div><div class=\"line\">                R.id.schedule_photo_jobs,</div><div class=\"line\">                <span class=\"keyword\">new</span> ComponentName(context,PhotoContentJob.class));</div><div class=\"line\"></div><div class=\"line\">        builder.addTriggerContentUri(</div><div class=\"line\">                <span class=\"keyword\">new</span> JobInfo.TriggerContentUri(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,</div><div class=\"line\">                        JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS)</div><div class=\"line\">        );</div><div class=\"line\">        js.schedule(builder.build());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>参考<a href=\"https://www.youtube.com/watch?v=3ZX0CfVfVP8\">youtube上谷歌员工的演讲</a></p>\n<h3 id=\"2-文件系统的权限更改-FileProvider\"><a href=\"#2-文件系统的权限更改-FileProvider\" class=\"headerlink\" title=\"2. 文件系统的权限更改(FileProvider)\"></a>2. 文件系统的权限更改(FileProvider)</h3><p> File storage permission change<br> 简单来说就是Uri.fromFile(file://URI)不能再用了，需要使用FileProvider，这主要是为了6.0开始引进的permission model 考虑的，storage permission例如WRITE_EXTERNAL_STORAGE这种都已经属于Dangerous permission了。<br> 一个常见的场景就是调用系统相机拍照，给Intent设置一个uri，在7.0上直接用Uri.FromFile会崩<br> 需要通过FileProvider提供Uri,写了一个<a href=\"https://github.com/Haldir65/FileProviderDmo\">Demo</a>，使用FileProvider传递文件给另一个App。<br> 另一个需要注意的就是DownloadManager访问COLUMN_LOCAL_FILENAME会报错，这个不常见。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"https://developer.android.com/topic/performance/background-optimization.html?utm_campaign=adp_series__100616&amp;utm_source=anddev&amp;utm_medium=yt-desc\">Docs</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=vBjTXKpaFj8\">youtube</a></li>\n<li><a href=\"http://gold.xitu.io/entry/57ff7e14a0bb9f005860c805\">Andrioid 7.0适配心得</a></li>\n<li><a href=\"https://developer.android.com/about/versions/nougat/android-7.0-changes.html\">Android 7.0 Behavior Changes</a></li>\n</ol>"},{"title":"android内部类导致leak模板","date":"2016-09-18T02:23:42.000Z","_content":"\n\n----------\n\n通常我们在一个class里面写内部类时，不是一定要用static声明为静态类，但是推荐作为内部静态类，因为内部类会隐式持有外部类的引用，有些时候如果代码处理不对容易造成内存泄漏\n下面就是个内存泄漏的例子\n<!--more-->\n```java\npublic class MainActivity extends Activity {\n\n\tpublic class MyHandler extends Handler{\n\t@Override\n\tpublic void handleMessage(Message msg) {\n\t\tif(msg.what==1){\n\t\t\tnew Thread(){\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\t//do something\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\t}\n\tpublic MyHandler handler;\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\t\n\t\t//...\n\t\thandler.sendEmptyMessage(1);\n\t\tfinish();\n\t    }\n}\n```\n\n\n如上面代码所示，在onCreate方法里发送了一条消息给handler处理然后finish方法关闭activity，但是代码并不能如愿，因为在handler收到消息启动了一个线程并且是**死循环**，\n这时候Thread持有handler的引用，而handler又持有activity的引用，这就导致了handler不能回收和activty也不能回收，所以推荐使用静态内部类，因为静态内部类不持有外部类的引用，可以避免这些不必要的麻烦。\n\n除此之外，在Activity里面创建一个AsyncTask的子类也容易导致leak\n例如 [stackoverFlow上的这个问题](http://stackoverflow.com/questions/24679383/memory-leak-using-asynctask-as-a-inner-class)\n\n对于这类问题的比较常用的方式:\nWeakReference\n例如,写这样一个的静态内部类\n    \n```java\nprivate static class IncomingHandler extends Handler {\n    private final WeakReference<MessagingService> mReference;\n\n    IncomingHandler(MessagingService service) {\n        mReference = new WeakReference<>(service);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        MessagingService service = mReference.get();\n        switch (msg.what) {\n            case MSG_SEND_NOTIFICATION:\n                int howManyConversations = msg.arg1 <= 0 ? 1 : msg.arg1;\n                int messagesPerConversation = msg.arg2 <= 0 ? 1 : msg.arg2;\n                if (service != null) {\n                    service.sendNotification(howManyConversations,\n                    messagesPerConversation);\n                }\n                break;\n            default:\n                super.handleMessage(msg);\n        }\n    }\n}\n```    \n//handler通过弱引用持有service对象，外加static内部类不持有外部类引用，应该不会leak了\n\n\n\n\n\n\n","source":"_posts/android-inner-class-leak.md","raw":"---\ntitle: \"android内部类导致leak模板\"\ndate: 2016-09-18 10:23:42\ncategories: blog\ntags: [android]\n---\n\n\n----------\n\n通常我们在一个class里面写内部类时，不是一定要用static声明为静态类，但是推荐作为内部静态类，因为内部类会隐式持有外部类的引用，有些时候如果代码处理不对容易造成内存泄漏\n下面就是个内存泄漏的例子\n<!--more-->\n```java\npublic class MainActivity extends Activity {\n\n\tpublic class MyHandler extends Handler{\n\t@Override\n\tpublic void handleMessage(Message msg) {\n\t\tif(msg.what==1){\n\t\t\tnew Thread(){\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\t//do something\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\t}\n\tpublic MyHandler handler;\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\t\n\t\t//...\n\t\thandler.sendEmptyMessage(1);\n\t\tfinish();\n\t    }\n}\n```\n\n\n如上面代码所示，在onCreate方法里发送了一条消息给handler处理然后finish方法关闭activity，但是代码并不能如愿，因为在handler收到消息启动了一个线程并且是**死循环**，\n这时候Thread持有handler的引用，而handler又持有activity的引用，这就导致了handler不能回收和activty也不能回收，所以推荐使用静态内部类，因为静态内部类不持有外部类的引用，可以避免这些不必要的麻烦。\n\n除此之外，在Activity里面创建一个AsyncTask的子类也容易导致leak\n例如 [stackoverFlow上的这个问题](http://stackoverflow.com/questions/24679383/memory-leak-using-asynctask-as-a-inner-class)\n\n对于这类问题的比较常用的方式:\nWeakReference\n例如,写这样一个的静态内部类\n    \n```java\nprivate static class IncomingHandler extends Handler {\n    private final WeakReference<MessagingService> mReference;\n\n    IncomingHandler(MessagingService service) {\n        mReference = new WeakReference<>(service);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        MessagingService service = mReference.get();\n        switch (msg.what) {\n            case MSG_SEND_NOTIFICATION:\n                int howManyConversations = msg.arg1 <= 0 ? 1 : msg.arg1;\n                int messagesPerConversation = msg.arg2 <= 0 ? 1 : msg.arg2;\n                if (service != null) {\n                    service.sendNotification(howManyConversations,\n                    messagesPerConversation);\n                }\n                break;\n            default:\n                super.handleMessage(msg);\n        }\n    }\n}\n```    \n//handler通过弱引用持有service对象，外加static内部类不持有外部类引用，应该不会leak了\n\n\n\n\n\n\n","slug":"android-inner-class-leak","published":1,"updated":"2017-06-15T15:21:46.986Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnl00037bovrogi1a5sh","content":"<hr>\n<p>通常我们在一个class里面写内部类时，不是一定要用static声明为静态类，但是推荐作为内部静态类，因为内部类会隐式持有外部类的引用，有些时候如果代码处理不对容易造成内存泄漏<br>下面就是个内存泄漏的例子<br><a id=\"more\"></a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">true<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">true<span class=\"meta\">@Override</span></div><div class=\"line\">true<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">truetrue<span class=\"keyword\">if</span>(msg.what==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">truetruetrue<span class=\"keyword\">new</span> Thread()&#123;</div><div class=\"line\">truetruetruetrue<span class=\"meta\">@Override</span></div><div class=\"line\">truetruetruetrue<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">truetruetruetruetrue<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</div><div class=\"line\">truetruetruetruetruetrue<span class=\"comment\">//do something</span></div><div class=\"line\">truetruetruetruetrue&#125;</div><div class=\"line\">truetruetruetrue&#125;</div><div class=\"line\">truetruetrue&#125;.start();</div><div class=\"line\">truetrue&#125;</div><div class=\"line\">true&#125;</div><div class=\"line\">true&#125;</div><div class=\"line\">true<span class=\"keyword\">public</span> MyHandler handler;</div><div class=\"line\">true<span class=\"meta\">@Override</span></div><div class=\"line\">true<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">truetrue<span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">truetruesetContentView(R.layout.activity_main);</div><div class=\"line\">truetrue</div><div class=\"line\">truetrue<span class=\"comment\">//...</span></div><div class=\"line\">truetruehandler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">truetruefinish();</div><div class=\"line\">true    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如上面代码所示，在onCreate方法里发送了一条消息给handler处理然后finish方法关闭activity，但是代码并不能如愿，因为在handler收到消息启动了一个线程并且是<strong>死循环</strong>，<br>这时候Thread持有handler的引用，而handler又持有activity的引用，这就导致了handler不能回收和activty也不能回收，所以推荐使用静态内部类，因为静态内部类不持有外部类的引用，可以避免这些不必要的麻烦。</p>\n<p>除此之外，在Activity里面创建一个AsyncTask的子类也容易导致leak<br>例如 <a href=\"http://stackoverflow.com/questions/24679383/memory-leak-using-asynctask-as-a-inner-class\">stackoverFlow上的这个问题</a></p>\n<p>对于这类问题的比较常用的方式:<br>WeakReference<br>例如,写这样一个的静态内部类</p>\n<pre><code class=\"java\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IncomingHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;MessagingService&gt; mReference;\n\n    IncomingHandler(MessagingService service) {\n        mReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(service);\n    }\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n        MessagingService service = mReference.get();\n        <span class=\"keyword\">switch</span> (msg.what) {\n            <span class=\"keyword\">case</span> MSG_SEND_NOTIFICATION:\n                <span class=\"keyword\">int</span> howManyConversations = msg.arg1 &lt;= <span class=\"number\">0</span> ? <span class=\"number\">1</span> : msg.arg1;\n                <span class=\"keyword\">int</span> messagesPerConversation = msg.arg2 &lt;= <span class=\"number\">0</span> ? <span class=\"number\">1</span> : msg.arg2;\n                <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) {\n                    service.sendNotification(howManyConversations,\n                    messagesPerConversation);\n                }\n                <span class=\"keyword\">break</span>;\n            <span class=\"keyword\">default</span>:\n                <span class=\"keyword\">super</span>.handleMessage(msg);\n        }\n    }\n}\n</code></pre>\n<p>//handler通过弱引用持有service对象，外加static内部类不持有外部类引用，应该不会leak了</p>\n","excerpt":"<hr>\n<p>通常我们在一个class里面写内部类时，不是一定要用static声明为静态类，但是推荐作为内部静态类，因为内部类会隐式持有外部类的引用，有些时候如果代码处理不对容易造成内存泄漏<br>下面就是个内存泄漏的例子<br>","more":"<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">true<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">true<span class=\"meta\">@Override</span></div><div class=\"line\">true<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">truetrue<span class=\"keyword\">if</span>(msg.what==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">truetruetrue<span class=\"keyword\">new</span> Thread()&#123;</div><div class=\"line\">truetruetruetrue<span class=\"meta\">@Override</span></div><div class=\"line\">truetruetruetrue<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">truetruetruetruetrue<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</div><div class=\"line\">truetruetruetruetruetrue<span class=\"comment\">//do something</span></div><div class=\"line\">truetruetruetruetrue&#125;</div><div class=\"line\">truetruetruetrue&#125;</div><div class=\"line\">truetruetrue&#125;.start();</div><div class=\"line\">truetrue&#125;</div><div class=\"line\">true&#125;</div><div class=\"line\">true&#125;</div><div class=\"line\">true<span class=\"keyword\">public</span> MyHandler handler;</div><div class=\"line\">true<span class=\"meta\">@Override</span></div><div class=\"line\">true<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">truetrue<span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">truetruesetContentView(R.layout.activity_main);</div><div class=\"line\">truetrue</div><div class=\"line\">truetrue<span class=\"comment\">//...</span></div><div class=\"line\">truetruehandler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">truetruefinish();</div><div class=\"line\">true    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如上面代码所示，在onCreate方法里发送了一条消息给handler处理然后finish方法关闭activity，但是代码并不能如愿，因为在handler收到消息启动了一个线程并且是<strong>死循环</strong>，<br>这时候Thread持有handler的引用，而handler又持有activity的引用，这就导致了handler不能回收和activty也不能回收，所以推荐使用静态内部类，因为静态内部类不持有外部类的引用，可以避免这些不必要的麻烦。</p>\n<p>除此之外，在Activity里面创建一个AsyncTask的子类也容易导致leak<br>例如 <a href=\"http://stackoverflow.com/questions/24679383/memory-leak-using-asynctask-as-a-inner-class\">stackoverFlow上的这个问题</a></p>\n<p>对于这类问题的比较常用的方式:<br>WeakReference<br>例如,写这样一个的静态内部类</p>\n<pre><code class=\"java\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IncomingHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;MessagingService&gt; mReference;\n\n    IncomingHandler(MessagingService service) {\n        mReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(service);\n    }\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n        MessagingService service = mReference.get();\n        <span class=\"keyword\">switch</span> (msg.what) {\n            <span class=\"keyword\">case</span> MSG_SEND_NOTIFICATION:\n                <span class=\"keyword\">int</span> howManyConversations = msg.arg1 &lt;= <span class=\"number\">0</span> ? <span class=\"number\">1</span> : msg.arg1;\n                <span class=\"keyword\">int</span> messagesPerConversation = msg.arg2 &lt;= <span class=\"number\">0</span> ? <span class=\"number\">1</span> : msg.arg2;\n                <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) {\n                    service.sendNotification(howManyConversations,\n                    messagesPerConversation);\n                }\n                <span class=\"keyword\">break</span>;\n            <span class=\"keyword\">default</span>:\n                <span class=\"keyword\">super</span>.handleMessage(msg);\n        }\n    }\n}\n</code></pre>\n<p>//handler通过弱引用持有service对象，外加static内部类不持有外部类引用，应该不会leak了</p>"},{"title":"git常用操作手册","date":"2016-09-27T09:24:51.000Z","_content":"\n记录一下常用git的命令，作为日常使用的参考手册\n\n[](http://odzl05jxx.bkt.clouddn.com/f787b2e8d757dc83b782bcd6d4c9f523.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n## 1. 在本地创建一个项目并同步到github的过程\n\n```git\n$ mkdir ~/hello-world    //创建一个项目hello-world\n$ cd ~/hello-world       //打开这个项目\n$ git init             //初始化\n$ touch README   \t\t//创建文件\n$ git add README        //更新README文件\n$ git commit -m 'first commit'     //提交更新，并注释信息“first commit”\n$ git remote add origin git@github.test/hellotest.git     //连接远程github项目  \n$ git push -u origin master     //将本地项目更新到github项目上去\n```\n\n## 2.  将本地git branch和远程github repository同步\n\n可行的方式\n```git\ngit branch --set-upstream local_branch origin/remote_branch\n```\n这样做可行，但出现下面的错误提示，照着操作就行了。\n\n```git\n$ git branch --set-upstream master origin/master\nThe --set-upstream flag is deprecated and will be removed. Consider using --track or --set-upstream-to\nBranch master set up to track remote branch master from origin.\n```\n\n<!--more-->\n\n## 3. git处理大小写字母的问题\n\n> git默认对大小写不敏感，所以，新建一个文件adapter.java，上传到github之后说不定就给变成了Adapter.java。在windows下面将已经push到远端的文件，改变其文件名的大小写时，git默认会认为文件没有发生任何改动，从而拒绝提交和推送，原因是其默认配置为大小写不敏感，故须在bash下修改配置：\n\n```git\ngit config core.ignorecase false\n```\n\n## 4. git设置用户名\n\n```git\n$ git config --global user.name \"name\"\n$ git config --global user.email xxx@163.com\n```\n这样可以为git所有的仓库设置用户名，如果想为指定仓库设置用户名或email:\n\n```git\n$ git config user.name \"name\"\n$ git config user.email \"myEmail.awesome.com\"\n```\n查看当前用户名或email\n```git\n$ git config user.name\n$ git config user.email\n```\n\n## 5. 设置代理\n\n设置全局代理\n```git\ngit config --global http.proxy socks5://127.0.0.1:1080\n```\n\n对指定url设置代理\n###\ngit config --global http.<要设置代理的URL>.proxy socks5://127.0.0.1:1080\n\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1080\n```\n\n## 6. 对上一次commit进行修改(在不添加新的commit的基础上)\n```git\ngit commit --amend\n```\n\n## 7. git revert和reset的区别\n> reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. 即reset是通过一次反向的commit操作撤销之前的commit，而reset则会直接从提交历史里删除commit。如果还没有push，用reset可以在本地解决问题，之后重新commit再push。如果已经push，可以考虑通过一次revert来实现“撤销”的效果。\n\n\n语法：\n### reset\n```git\ngit reset --hard HEAD //本地仓库文件修改也会消失\ngit reset --soft HEAD //本地文件修改不会消失，类似于回到git add 之前的状态\ngit reset --hard HEAD~3 //最近的三次提交全部撤销\n```\n\n### revert\n```git\ngit revert c011eb3c20ba6fb38cc94fe //之后在分支图上就能看到一个新的反向的commit，push即可。\n```\n\n## 8. 切分支, 删除分支\n本地新建分支\n```git\ngit checkout -b <branchName>\n```\n将这条分支与远程同步的方式\n```git\ngit branch --set-upstream <laocalBranchName> origin/<RemoteBranchName>\n// 或者\ngit branch -u origin/dev\n```\n直接从远程仓库切一个分支出来并保持同步的方式\n```git\ngit checkout -b <branchName> origin/<branchName>\n\ngit checkout --track origin/dev\n```\n\n\n删除远程分支:\n```git\ngit push origin --delete <branchName>\n```\n删除远程tag\n```git\ngit push origin --delete tag <tagName>\n```\n\n\n## 9. pull和rebase的区别\npull = fetch +merge ，会生成新的提交\n\n> Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点\n\n## 10. rebase和cherry-pick\nrebase不会生成新的提交，而且会使得项目提交历史呈现出完美的线性。但注意[不要在公共的分支上使用](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n\n\n\n## 11. gitignore文件写法\n参考[repo](https://github.com/suzeyu1992/repo/tree/master/project/git)\n```git\n# 忽略所有以 .c结尾的文件\n*.c\n\n# 但是 stream.c 会被git追踪\n!stream.c\n\n# 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO\n/TODO\n\n# 忽略所有在build文件夹下的文件\nbuild/\n\n# 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt\ndoc/*.txt\n\n# 忽略所有在doc目录下的.pdf文件\ndoc/**/*.pdf\n```\n\n## 12. git stash\n常用命令\n```git\ngit stash  //保存下来，压进一个栈，基本上就是先进后出了\ngit stash pop //推出一个栈\n\ngit stash save -a \"message to add\" // 添加一次stash，打上标记\n\ngit stash list  //展示当前仓库所有的被stash的变更以及对应的id，记得这个不是跟着branch走的\ngit stash drop stah@{id} // 从stash的List中删除指定的某一次stash\ngit stash apply <stash@{id}> //应用某一次的stash\n\ngit stash clear// 一次性删除stash List中所有的item\n\n```\n\n## 13. 强推\n谨慎使用\n```git\n# Be very careful with this command!\ngit push --force\n```\n\n## Reference\n-[git reset和revert](http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html)\n-[git recipes](https://github.com/geeeeeeeeek/git-recipes)\n","source":"_posts/git-manual.md","raw":"---\ntitle: git常用操作手册\ndate: 2016-09-27 17:24:51\ncategories: blog\ntags: [git,tools]\n---\n\n记录一下常用git的命令，作为日常使用的参考手册\n\n[](http://odzl05jxx.bkt.clouddn.com/f787b2e8d757dc83b782bcd6d4c9f523.jpg?imageView2/2/w/600)\n\n<!--more-->\n\n## 1. 在本地创建一个项目并同步到github的过程\n\n```git\n$ mkdir ~/hello-world    //创建一个项目hello-world\n$ cd ~/hello-world       //打开这个项目\n$ git init             //初始化\n$ touch README   \t\t//创建文件\n$ git add README        //更新README文件\n$ git commit -m 'first commit'     //提交更新，并注释信息“first commit”\n$ git remote add origin git@github.test/hellotest.git     //连接远程github项目  \n$ git push -u origin master     //将本地项目更新到github项目上去\n```\n\n## 2.  将本地git branch和远程github repository同步\n\n可行的方式\n```git\ngit branch --set-upstream local_branch origin/remote_branch\n```\n这样做可行，但出现下面的错误提示，照着操作就行了。\n\n```git\n$ git branch --set-upstream master origin/master\nThe --set-upstream flag is deprecated and will be removed. Consider using --track or --set-upstream-to\nBranch master set up to track remote branch master from origin.\n```\n\n<!--more-->\n\n## 3. git处理大小写字母的问题\n\n> git默认对大小写不敏感，所以，新建一个文件adapter.java，上传到github之后说不定就给变成了Adapter.java。在windows下面将已经push到远端的文件，改变其文件名的大小写时，git默认会认为文件没有发生任何改动，从而拒绝提交和推送，原因是其默认配置为大小写不敏感，故须在bash下修改配置：\n\n```git\ngit config core.ignorecase false\n```\n\n## 4. git设置用户名\n\n```git\n$ git config --global user.name \"name\"\n$ git config --global user.email xxx@163.com\n```\n这样可以为git所有的仓库设置用户名，如果想为指定仓库设置用户名或email:\n\n```git\n$ git config user.name \"name\"\n$ git config user.email \"myEmail.awesome.com\"\n```\n查看当前用户名或email\n```git\n$ git config user.name\n$ git config user.email\n```\n\n## 5. 设置代理\n\n设置全局代理\n```git\ngit config --global http.proxy socks5://127.0.0.1:1080\n```\n\n对指定url设置代理\n###\ngit config --global http.<要设置代理的URL>.proxy socks5://127.0.0.1:1080\n\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1080\n```\n\n## 6. 对上一次commit进行修改(在不添加新的commit的基础上)\n```git\ngit commit --amend\n```\n\n## 7. git revert和reset的区别\n> reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. 即reset是通过一次反向的commit操作撤销之前的commit，而reset则会直接从提交历史里删除commit。如果还没有push，用reset可以在本地解决问题，之后重新commit再push。如果已经push，可以考虑通过一次revert来实现“撤销”的效果。\n\n\n语法：\n### reset\n```git\ngit reset --hard HEAD //本地仓库文件修改也会消失\ngit reset --soft HEAD //本地文件修改不会消失，类似于回到git add 之前的状态\ngit reset --hard HEAD~3 //最近的三次提交全部撤销\n```\n\n### revert\n```git\ngit revert c011eb3c20ba6fb38cc94fe //之后在分支图上就能看到一个新的反向的commit，push即可。\n```\n\n## 8. 切分支, 删除分支\n本地新建分支\n```git\ngit checkout -b <branchName>\n```\n将这条分支与远程同步的方式\n```git\ngit branch --set-upstream <laocalBranchName> origin/<RemoteBranchName>\n// 或者\ngit branch -u origin/dev\n```\n直接从远程仓库切一个分支出来并保持同步的方式\n```git\ngit checkout -b <branchName> origin/<branchName>\n\ngit checkout --track origin/dev\n```\n\n\n删除远程分支:\n```git\ngit push origin --delete <branchName>\n```\n删除远程tag\n```git\ngit push origin --delete tag <tagName>\n```\n\n\n## 9. pull和rebase的区别\npull = fetch +merge ，会生成新的提交\n\n> Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点\n\n## 10. rebase和cherry-pick\nrebase不会生成新的提交，而且会使得项目提交历史呈现出完美的线性。但注意[不要在公共的分支上使用](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n\n\n\n## 11. gitignore文件写法\n参考[repo](https://github.com/suzeyu1992/repo/tree/master/project/git)\n```git\n# 忽略所有以 .c结尾的文件\n*.c\n\n# 但是 stream.c 会被git追踪\n!stream.c\n\n# 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO\n/TODO\n\n# 忽略所有在build文件夹下的文件\nbuild/\n\n# 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt\ndoc/*.txt\n\n# 忽略所有在doc目录下的.pdf文件\ndoc/**/*.pdf\n```\n\n## 12. git stash\n常用命令\n```git\ngit stash  //保存下来，压进一个栈，基本上就是先进后出了\ngit stash pop //推出一个栈\n\ngit stash save -a \"message to add\" // 添加一次stash，打上标记\n\ngit stash list  //展示当前仓库所有的被stash的变更以及对应的id，记得这个不是跟着branch走的\ngit stash drop stah@{id} // 从stash的List中删除指定的某一次stash\ngit stash apply <stash@{id}> //应用某一次的stash\n\ngit stash clear// 一次性删除stash List中所有的item\n\n```\n\n## 13. 强推\n谨慎使用\n```git\n# Be very careful with this command!\ngit push --force\n```\n\n## Reference\n-[git reset和revert](http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html)\n-[git recipes](https://github.com/geeeeeeeeek/git-recipes)\n","slug":"git-manual","published":1,"updated":"2017-07-23T11:23:45.421Z","_id":"cj5gmdnl3003abovr5zyvgge2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录一下常用git的命令，作为日常使用的参考手册</p>\n<p><a href=\"http://odzl05jxx.bkt.clouddn.com/f787b2e8d757dc83b782bcd6d4c9f523.jpg?imageView2/2/w/600\"></a></p>\n<a id=\"more\"></a>\n<h2 id=\"1-在本地创建一个项目并同步到github的过程\"><a href=\"#1-在本地创建一个项目并同步到github的过程\" class=\"headerlink\" title=\"1. 在本地创建一个项目并同步到github的过程\"></a>1. 在本地创建一个项目并同步到github的过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir ~/hello-world    //创建一个项目hello-world</div><div class=\"line\">$ cd ~/hello-world       //打开这个项目</div><div class=\"line\">$ git init             //初始化</div><div class=\"line\">$ touch README   \t\t//创建文件</div><div class=\"line\">$ git add README        //更新README文件</div><div class=\"line\">$ git commit -m &apos;first commit&apos;     //提交更新，并注释信息“first commit”</div><div class=\"line\">$ git remote add origin git@github.test/hellotest.git     //连接远程github项目  </div><div class=\"line\">$ git push -u origin master     //将本地项目更新到github项目上去</div></pre></td></tr></table></figure>\n<h2 id=\"2-将本地git-branch和远程github-repository同步\"><a href=\"#2-将本地git-branch和远程github-repository同步\" class=\"headerlink\" title=\"2.  将本地git branch和远程github repository同步\"></a>2.  将本地git branch和远程github repository同步</h2><p>可行的方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch --set-upstream local_branch origin/remote_branch</div></pre></td></tr></table></figure></p>\n<p>这样做可行，但出现下面的错误提示，照着操作就行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch --set-upstream master origin/master</div><div class=\"line\">The --set-upstream flag is deprecated and will be removed. Consider using --track or --set-upstream-to</div><div class=\"line\">Branch master set up to track remote branch master from origin.</div></pre></td></tr></table></figure>\n<!--more-->\n<h2 id=\"3-git处理大小写字母的问题\"><a href=\"#3-git处理大小写字母的问题\" class=\"headerlink\" title=\"3. git处理大小写字母的问题\"></a>3. git处理大小写字母的问题</h2><blockquote>\n<p>git默认对大小写不敏感，所以，新建一个文件adapter.java，上传到github之后说不定就给变成了Adapter.java。在windows下面将已经push到远端的文件，改变其文件名的大小写时，git默认会认为文件没有发生任何改动，从而拒绝提交和推送，原因是其默认配置为大小写不敏感，故须在bash下修改配置：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config core.ignorecase false</div></pre></td></tr></table></figure>\n<h2 id=\"4-git设置用户名\"><a href=\"#4-git设置用户名\" class=\"headerlink\" title=\"4. git设置用户名\"></a>4. git设置用户名</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;name&quot;</div><div class=\"line\">$ git config --global user.email xxx@163.com</div></pre></td></tr></table></figure>\n<p>这样可以为git所有的仓库设置用户名，如果想为指定仓库设置用户名或email:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config user.name &quot;name&quot;</div><div class=\"line\">$ git config user.email &quot;myEmail.awesome.com&quot;</div></pre></td></tr></table></figure>\n<p>查看当前用户名或email<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config user.name</div><div class=\"line\">$ git config user.email</div></pre></td></tr></table></figure></p>\n<h2 id=\"5-设置代理\"><a href=\"#5-设置代理\" class=\"headerlink\" title=\"5. 设置代理\"></a>5. 设置代理</h2><p>设置全局代理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global http.proxy socks5://127.0.0.1:1080</div></pre></td></tr></table></figure></p>\n<p>对指定url设置代理</p>\n<p>###<br>git config –global http.&lt;要设置代理的URL&gt;.proxy socks5://127.0.0.1:1080</p>\n<p>git config –global http.<a href=\"https://github.com.proxy\">https://github.com.proxy</a> socks5://127.0.0.1:1080<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">## 6. 对上一次commit进行修改(在不添加新的commit的基础上)</div><div class=\"line\">```git</div><div class=\"line\">git commit --amend</div></pre></td></tr></table></figure></p>\n<h2 id=\"7-git-revert和reset的区别\"><a href=\"#7-git-revert和reset的区别\" class=\"headerlink\" title=\"7. git revert和reset的区别\"></a>7. git revert和reset的区别</h2><blockquote>\n<p>reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. 即reset是通过一次反向的commit操作撤销之前的commit，而reset则会直接从提交历史里删除commit。如果还没有push，用reset可以在本地解决问题，之后重新commit再push。如果已经push，可以考虑通过一次revert来实现“撤销”的效果。</p>\n</blockquote>\n<p>语法：</p>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git reset --hard HEAD //本地仓库文件修改也会消失</div><div class=\"line\">git reset --soft HEAD //本地文件修改不会消失，类似于回到git add 之前的状态</div><div class=\"line\">git reset --hard HEAD~3 //最近的三次提交全部撤销</div></pre></td></tr></table></figure>\n<h3 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git revert c011eb3c20ba6fb38cc94fe //之后在分支图上就能看到一个新的反向的commit，push即可。</div></pre></td></tr></table></figure>\n<h2 id=\"8-切分支-删除分支\"><a href=\"#8-切分支-删除分支\" class=\"headerlink\" title=\"8. 切分支, 删除分支\"></a>8. 切分支, 删除分支</h2><p>本地新建分支<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b &lt;branchName&gt;</div></pre></td></tr></table></figure></p>\n<p>将这条分支与远程同步的方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch --set-upstream &lt;laocalBranchName&gt; origin/&lt;RemoteBranchName&gt;</div><div class=\"line\">// 或者</div><div class=\"line\">git branch -u origin/dev</div></pre></td></tr></table></figure></p>\n<p>直接从远程仓库切一个分支出来并保持同步的方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b &lt;branchName&gt; origin/&lt;branchName&gt;</div><div class=\"line\"></div><div class=\"line\">git checkout --track origin/dev</div></pre></td></tr></table></figure></p>\n<p>删除远程分支:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin --delete &lt;branchName&gt;</div></pre></td></tr></table></figure></p>\n<p>删除远程tag<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin --delete tag &lt;tagName&gt;</div></pre></td></tr></table></figure></p>\n<h2 id=\"9-pull和rebase的区别\"><a href=\"#9-pull和rebase的区别\" class=\"headerlink\" title=\"9. pull和rebase的区别\"></a>9. pull和rebase的区别</h2><p>pull = fetch +merge ，会生成新的提交</p>\n<blockquote>\n<p>Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点</p>\n</blockquote>\n<h2 id=\"10-rebase和cherry-pick\"><a href=\"#10-rebase和cherry-pick\" class=\"headerlink\" title=\"10. rebase和cherry-pick\"></a>10. rebase和cherry-pick</h2><p>rebase不会生成新的提交，而且会使得项目提交历史呈现出完美的线性。但注意<a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\">不要在公共的分支上使用</a></p>\n<h2 id=\"11-gitignore文件写法\"><a href=\"#11-gitignore文件写法\" class=\"headerlink\" title=\"11. gitignore文件写法\"></a>11. gitignore文件写法</h2><p>参考<a href=\"https://github.com/suzeyu1992/repo/tree/master/project/git\">repo</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 忽略所有以 .c结尾的文件</div><div class=\"line\">*.c</div><div class=\"line\"></div><div class=\"line\"># 但是 stream.c 会被git追踪</div><div class=\"line\">!stream.c</div><div class=\"line\"></div><div class=\"line\"># 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO</div><div class=\"line\">/TODO</div><div class=\"line\"></div><div class=\"line\"># 忽略所有在build文件夹下的文件</div><div class=\"line\">build/</div><div class=\"line\"></div><div class=\"line\"># 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt</div><div class=\"line\">doc/*.txt</div><div class=\"line\"></div><div class=\"line\"># 忽略所有在doc目录下的.pdf文件</div><div class=\"line\">doc/**/*.pdf</div></pre></td></tr></table></figure></p>\n<h2 id=\"12-git-stash\"><a href=\"#12-git-stash\" class=\"headerlink\" title=\"12. git stash\"></a>12. git stash</h2><p>常用命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">git stash  //保存下来，压进一个栈，基本上就是先进后出了</div><div class=\"line\">git stash pop //推出一个栈</div><div class=\"line\"></div><div class=\"line\">git stash save -a &quot;message to add&quot; // 添加一次stash，打上标记</div><div class=\"line\"></div><div class=\"line\">git stash list  //展示当前仓库所有的被stash的变更以及对应的id，记得这个不是跟着branch走的</div><div class=\"line\">git stash drop stah@&#123;id&#125; // 从stash的List中删除指定的某一次stash</div><div class=\"line\">git stash apply &lt;stash@&#123;id&#125;&gt; //应用某一次的stash</div><div class=\"line\"></div><div class=\"line\">git stash clear// 一次性删除stash List中所有的item</div></pre></td></tr></table></figure></p>\n<h2 id=\"13-强推\"><a href=\"#13-强推\" class=\"headerlink\" title=\"13. 强推\"></a>13. 强推</h2><p>谨慎使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Be very careful with this command!</div><div class=\"line\">git push --force</div></pre></td></tr></table></figure></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>-<a href=\"http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html\">git reset和revert</a><br>-<a href=\"https://github.com/geeeeeeeeek/git-recipes\">git recipes</a></p>\n","excerpt":"<p>记录一下常用git的命令，作为日常使用的参考手册</p>\n<p><a href=\"http://odzl05jxx.bkt.clouddn.com/f787b2e8d757dc83b782bcd6d4c9f523.jpg?imageView2/2/w/600\"></a></p>","more":"<h2 id=\"1-在本地创建一个项目并同步到github的过程\"><a href=\"#1-在本地创建一个项目并同步到github的过程\" class=\"headerlink\" title=\"1. 在本地创建一个项目并同步到github的过程\"></a>1. 在本地创建一个项目并同步到github的过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir ~/hello-world    //创建一个项目hello-world</div><div class=\"line\">$ cd ~/hello-world       //打开这个项目</div><div class=\"line\">$ git init             //初始化</div><div class=\"line\">$ touch README   \t\t//创建文件</div><div class=\"line\">$ git add README        //更新README文件</div><div class=\"line\">$ git commit -m &apos;first commit&apos;     //提交更新，并注释信息“first commit”</div><div class=\"line\">$ git remote add origin git@github.test/hellotest.git     //连接远程github项目  </div><div class=\"line\">$ git push -u origin master     //将本地项目更新到github项目上去</div></pre></td></tr></table></figure>\n<h2 id=\"2-将本地git-branch和远程github-repository同步\"><a href=\"#2-将本地git-branch和远程github-repository同步\" class=\"headerlink\" title=\"2.  将本地git branch和远程github repository同步\"></a>2.  将本地git branch和远程github repository同步</h2><p>可行的方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch --set-upstream local_branch origin/remote_branch</div></pre></td></tr></table></figure></p>\n<p>这样做可行，但出现下面的错误提示，照着操作就行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch --set-upstream master origin/master</div><div class=\"line\">The --set-upstream flag is deprecated and will be removed. Consider using --track or --set-upstream-to</div><div class=\"line\">Branch master set up to track remote branch master from origin.</div></pre></td></tr></table></figure>\n<!--more-->\n<h2 id=\"3-git处理大小写字母的问题\"><a href=\"#3-git处理大小写字母的问题\" class=\"headerlink\" title=\"3. git处理大小写字母的问题\"></a>3. git处理大小写字母的问题</h2><blockquote>\n<p>git默认对大小写不敏感，所以，新建一个文件adapter.java，上传到github之后说不定就给变成了Adapter.java。在windows下面将已经push到远端的文件，改变其文件名的大小写时，git默认会认为文件没有发生任何改动，从而拒绝提交和推送，原因是其默认配置为大小写不敏感，故须在bash下修改配置：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config core.ignorecase false</div></pre></td></tr></table></figure>\n<h2 id=\"4-git设置用户名\"><a href=\"#4-git设置用户名\" class=\"headerlink\" title=\"4. git设置用户名\"></a>4. git设置用户名</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;name&quot;</div><div class=\"line\">$ git config --global user.email xxx@163.com</div></pre></td></tr></table></figure>\n<p>这样可以为git所有的仓库设置用户名，如果想为指定仓库设置用户名或email:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config user.name &quot;name&quot;</div><div class=\"line\">$ git config user.email &quot;myEmail.awesome.com&quot;</div></pre></td></tr></table></figure>\n<p>查看当前用户名或email<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config user.name</div><div class=\"line\">$ git config user.email</div></pre></td></tr></table></figure></p>\n<h2 id=\"5-设置代理\"><a href=\"#5-设置代理\" class=\"headerlink\" title=\"5. 设置代理\"></a>5. 设置代理</h2><p>设置全局代理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global http.proxy socks5://127.0.0.1:1080</div></pre></td></tr></table></figure></p>\n<p>对指定url设置代理</p>\n<p>###<br>git config –global http.&lt;要设置代理的URL&gt;.proxy socks5://127.0.0.1:1080</p>\n<p>git config –global http.<a href=\"https://github.com.proxy\">https://github.com.proxy</a> socks5://127.0.0.1:1080<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">## 6. 对上一次commit进行修改(在不添加新的commit的基础上)</div><div class=\"line\">```git</div><div class=\"line\">git commit --amend</div></pre></td></tr></table></figure></p>\n<h2 id=\"7-git-revert和reset的区别\"><a href=\"#7-git-revert和reset的区别\" class=\"headerlink\" title=\"7. git revert和reset的区别\"></a>7. git revert和reset的区别</h2><blockquote>\n<p>reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的. 即reset是通过一次反向的commit操作撤销之前的commit，而reset则会直接从提交历史里删除commit。如果还没有push，用reset可以在本地解决问题，之后重新commit再push。如果已经push，可以考虑通过一次revert来实现“撤销”的效果。</p>\n</blockquote>\n<p>语法：</p>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git reset --hard HEAD //本地仓库文件修改也会消失</div><div class=\"line\">git reset --soft HEAD //本地文件修改不会消失，类似于回到git add 之前的状态</div><div class=\"line\">git reset --hard HEAD~3 //最近的三次提交全部撤销</div></pre></td></tr></table></figure>\n<h3 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git revert c011eb3c20ba6fb38cc94fe //之后在分支图上就能看到一个新的反向的commit，push即可。</div></pre></td></tr></table></figure>\n<h2 id=\"8-切分支-删除分支\"><a href=\"#8-切分支-删除分支\" class=\"headerlink\" title=\"8. 切分支, 删除分支\"></a>8. 切分支, 删除分支</h2><p>本地新建分支<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b &lt;branchName&gt;</div></pre></td></tr></table></figure></p>\n<p>将这条分支与远程同步的方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch --set-upstream &lt;laocalBranchName&gt; origin/&lt;RemoteBranchName&gt;</div><div class=\"line\">// 或者</div><div class=\"line\">git branch -u origin/dev</div></pre></td></tr></table></figure></p>\n<p>直接从远程仓库切一个分支出来并保持同步的方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b &lt;branchName&gt; origin/&lt;branchName&gt;</div><div class=\"line\"></div><div class=\"line\">git checkout --track origin/dev</div></pre></td></tr></table></figure></p>\n<p>删除远程分支:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin --delete &lt;branchName&gt;</div></pre></td></tr></table></figure></p>\n<p>删除远程tag<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin --delete tag &lt;tagName&gt;</div></pre></td></tr></table></figure></p>\n<h2 id=\"9-pull和rebase的区别\"><a href=\"#9-pull和rebase的区别\" class=\"headerlink\" title=\"9. pull和rebase的区别\"></a>9. pull和rebase的区别</h2><p>pull = fetch +merge ，会生成新的提交</p>\n<blockquote>\n<p>Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点</p>\n</blockquote>\n<h2 id=\"10-rebase和cherry-pick\"><a href=\"#10-rebase和cherry-pick\" class=\"headerlink\" title=\"10. rebase和cherry-pick\"></a>10. rebase和cherry-pick</h2><p>rebase不会生成新的提交，而且会使得项目提交历史呈现出完美的线性。但注意<a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\">不要在公共的分支上使用</a></p>\n<h2 id=\"11-gitignore文件写法\"><a href=\"#11-gitignore文件写法\" class=\"headerlink\" title=\"11. gitignore文件写法\"></a>11. gitignore文件写法</h2><p>参考<a href=\"https://github.com/suzeyu1992/repo/tree/master/project/git\">repo</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 忽略所有以 .c结尾的文件</div><div class=\"line\">*.c</div><div class=\"line\"></div><div class=\"line\"># 但是 stream.c 会被git追踪</div><div class=\"line\">!stream.c</div><div class=\"line\"></div><div class=\"line\"># 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO</div><div class=\"line\">/TODO</div><div class=\"line\"></div><div class=\"line\"># 忽略所有在build文件夹下的文件</div><div class=\"line\">build/</div><div class=\"line\"></div><div class=\"line\"># 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt</div><div class=\"line\">doc/*.txt</div><div class=\"line\"></div><div class=\"line\"># 忽略所有在doc目录下的.pdf文件</div><div class=\"line\">doc/**/*.pdf</div></pre></td></tr></table></figure></p>\n<h2 id=\"12-git-stash\"><a href=\"#12-git-stash\" class=\"headerlink\" title=\"12. git stash\"></a>12. git stash</h2><p>常用命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">git stash  //保存下来，压进一个栈，基本上就是先进后出了</div><div class=\"line\">git stash pop //推出一个栈</div><div class=\"line\"></div><div class=\"line\">git stash save -a &quot;message to add&quot; // 添加一次stash，打上标记</div><div class=\"line\"></div><div class=\"line\">git stash list  //展示当前仓库所有的被stash的变更以及对应的id，记得这个不是跟着branch走的</div><div class=\"line\">git stash drop stah@&#123;id&#125; // 从stash的List中删除指定的某一次stash</div><div class=\"line\">git stash apply &lt;stash@&#123;id&#125;&gt; //应用某一次的stash</div><div class=\"line\"></div><div class=\"line\">git stash clear// 一次性删除stash List中所有的item</div></pre></td></tr></table></figure></p>\n<h2 id=\"13-强推\"><a href=\"#13-强推\" class=\"headerlink\" title=\"13. 强推\"></a>13. 强推</h2><p>谨慎使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Be very careful with this command!</div><div class=\"line\">git push --force</div></pre></td></tr></table></figure></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>-<a href=\"http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html\">git reset和revert</a><br>-<a href=\"https://github.com/geeeeeeeeek/git-recipes\">git recipes</a></p>"},{"title":"replace butterKnife with databinding","date":"2016-09-22T07:17:39.000Z","_content":"\n\nYigit Boyar 在2015年的android Dev summit上介绍了Databinding，当时好像提到一句:\n\"no binding libraries will be created from now on \"，大意如此。\n本文介绍使用Databinding替代ButterKnife的用法\n## 本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\n<!--more-->\n\n# 1.在Activity中使用\n*before*\n```java\nclass ExampleActivity extends Activity {\n  @Bind(R.id.title) TextView title;\n  @Bind(R.id.subtitle) TextView subtitle;\n  @Bind(R.id.footer) TextView footer;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.simple_activity);\n    ButterKnife.bind(this);\n  }\n}\n```\n*after*\n首先需要将xml文件添加 **Layout** tag \n`R.layout.smple_activity`\n```xml\n<layout>\n  <LinearLayout>\n    <TextView android:id=\"@+id/title\">\n    <TextView android:id=\"@+id/subtitle\">\n    <TextView android:id=\"@+id/footer\">\n  </LinearLayout>\n</layout>\n```\n```java\nclass ExampleActivity extends Activity {\n  private ActivitySampleBinding binding;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    binding = DataBindingUtils.setContentView(this, R.layout.simple_activity);\n    binding.title.setText(\"I am Title\");\n    //no more findViewById!!!\n  }\n}\n```\n\n# 2.在Fragment中使用\n*before*\n```java\npublic class FancyFragment extends Fragment {\n  @Bind(R.id.button1) Button button1;\n  @Bind(R.id.button2) Button button2;\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    View view = inflater.inflate(R.layout.fancy_fragment, container, false);\n    ButterKnife.bind(this, view);\n    // TODO Use fields...\n    return view;\n  }\n}\n```\n\n*after*\n```java\npublic class FancyFragment extends Fragment {\n  private FragmentFancyBinding binding;\n\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    binding = DataBindingUtil.inflate(inflater,R.layout.fragment_fancy, container, false);\n\t  return binding.getRoot();\n  }\n\n}\n```\n\n# 3.在ViewHolder中使用\n\n*before*\n```java\npublic class MyAdapter extends BaseAdapter {\n  @Override\n  public View getView(int position, View view, ViewGroup parent) {\n    ViewHolder holder;\n    if (view != null) {\n      holder = (ViewHolder) view.getTag();\n    } else {\n      view = inflater.inflate(R.layout.list_item_sample, parent, false);\n      holder = new ViewHolder(view);\n      view.setTag(holder);\n    }\n\n    holder.name.setText(\"John Doe\");\n    // etc...\n\n    return view;\n  }\n\n  static class ViewHolder {\n    @Bind(R.id.title) TextView name;\n    @Bind(R.id.job_title) TextView jobTitle;\n    public ViewHolder(View view) {\n      ButterKnife.bind(this, view);\n    }\n  }\n}\n```\n\n*after*\n### ListView \n```java\npublic class MyAdapter extends BaseAdapter {\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n      ListItemSampleBinding binding;\n      if (convertView == null) {\n          binding = DataBindingUtil.inflate(inflater, R.layout.list_item_sample, parent, false);\n          convertView = binding.getRoot();\n          convertView.setTag(binding);\n      } else {\n          binding = (ListItemSampleBinding) convertView.getTag();\n      }\n      binding.setUser(getItem(position));\n      // binding.name.setText(\"John Doe\");\n\n      return convertView;\n  }\n}\n```\n\n### recyclerView\n```java\npublic class SampleRecyclerAdapter extends RecyclerView.Adapter<SampleRecyclerAdapter.BindingHolder> {\n\n    @Override\n    public RegisterableDeviceListAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n      final View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_sample, parent, false);\n      return new BindingHolder(v);\n    }\n\n  @Override\n  public void onBindViewHolder(BindingHolder holder, int position) {\n    holder.getBinding().setVariable(BR.user, getItem(position));\n  }\n\n  static class BindingHolder extends RecyclerView.ViewHolder {\n    private final ViewDataBinding binding;\n\n    public BindingHolder(View itemView) {\n      super(itemView);\n      binding = DataBindingUtil.bind(itemView)\n    }\n\n    public ViewDataBinding getBinding() {\n      return binding;\n    }\n  }\n}\n```\n\n# 4.在CustomView中使用\n在自定义View(ViewGroup)的时候，可以用ButterKnife减少自定义ViewGroup中的findViewById,使用Databinding之后是这样的。\n```java\npublic class Pagination extends RelativeLayout {\n  private ViewPaginationBinding binding;\n\n  public Pagination(Context context) {\n    this(context, null);\n  }\n\n  public Pagination(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    binding = DataBindingUtil.inflate(LayoutInflater.from(context), R.layout.view_pagination, this, true);\n  }\n\n  public static void setListener(Pagination paginate, View target, OnPaginationClickListener listener) {\n    if (listener != null) {\n      target.setOnClickListener(_v -> listener.onClick(paginate));\n    }\n  }\n\n  @BindingAdapter({\"android:onPrevButtonClicked\"})\n  public static void setPrevClickListener(Pagination view, OnPaginationClickListener listener) {\n    setListener(view, view.binding.btnPrevPage, listener);\n  }\n\n  @BindingAdapter({\"android:onNextButtonClicked\"})\n  public static void setNextClickListener(Pagination view, OnPaginationClickListener listener) {\n    setListener(view, view.binding.btnNextPage, listener);\n  }\n\n  public interface OnPaginationClickListener {\n    void onClick(Pagination pagination);\n  }\n}\n```\n\n# 5.EventHandler, setDefaultComponent...</br>\nDatabinding还有很多高级用法，目前给我带来的好处就是明显减少了boilerplate code </br>\nSo ,感谢ButterKnife给我们带来的便利，Googbye ButterKnife，Hello DataBinding!\n\n＊todo＊ \n###　how did ButterKnife work?\n\n# Reference\n\n 1. [Data Binding Library](https://developer.android.com/topic/libraries/data-binding/index.html)\n 2. [data-binding-android-boyar-mount](https://realm.io/cn/news/data-binding-android-boyar-mount/) \n 3. [Advanced Data Bindinding](https://www.youtube.com/watch?v=DAmMN7m3wLU) Two-Way Data Binding at google io 2016\n 4. [Android Dev Summit 2015](https://www.youtube.com/watch?v=NBbeQMOcnZ0)\n 5. [Goodbye Butter Knife](http://qiita.com/izumin5210/items/2784576d86ce6b9b51e6)\n 6. [Google Sample](https://github.com/google/android-ui-toolkit-demos)\n \n","source":"_posts/replace-butterKnife-with-databinding.md","raw":"---\ntitle: replace butterKnife with databinding\ndate: 2016-09-22 15:17:39\ncategories: blog \ntags: [databinding, Butterknife,android]\n---\n\n\nYigit Boyar 在2015年的android Dev summit上介绍了Databinding，当时好像提到一句:\n\"no binding libraries will be created from now on \"，大意如此。\n本文介绍使用Databinding替代ButterKnife的用法\n## 本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\n<!--more-->\n\n# 1.在Activity中使用\n*before*\n```java\nclass ExampleActivity extends Activity {\n  @Bind(R.id.title) TextView title;\n  @Bind(R.id.subtitle) TextView subtitle;\n  @Bind(R.id.footer) TextView footer;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.simple_activity);\n    ButterKnife.bind(this);\n  }\n}\n```\n*after*\n首先需要将xml文件添加 **Layout** tag \n`R.layout.smple_activity`\n```xml\n<layout>\n  <LinearLayout>\n    <TextView android:id=\"@+id/title\">\n    <TextView android:id=\"@+id/subtitle\">\n    <TextView android:id=\"@+id/footer\">\n  </LinearLayout>\n</layout>\n```\n```java\nclass ExampleActivity extends Activity {\n  private ActivitySampleBinding binding;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    binding = DataBindingUtils.setContentView(this, R.layout.simple_activity);\n    binding.title.setText(\"I am Title\");\n    //no more findViewById!!!\n  }\n}\n```\n\n# 2.在Fragment中使用\n*before*\n```java\npublic class FancyFragment extends Fragment {\n  @Bind(R.id.button1) Button button1;\n  @Bind(R.id.button2) Button button2;\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    View view = inflater.inflate(R.layout.fancy_fragment, container, false);\n    ButterKnife.bind(this, view);\n    // TODO Use fields...\n    return view;\n  }\n}\n```\n\n*after*\n```java\npublic class FancyFragment extends Fragment {\n  private FragmentFancyBinding binding;\n\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    binding = DataBindingUtil.inflate(inflater,R.layout.fragment_fancy, container, false);\n\t  return binding.getRoot();\n  }\n\n}\n```\n\n# 3.在ViewHolder中使用\n\n*before*\n```java\npublic class MyAdapter extends BaseAdapter {\n  @Override\n  public View getView(int position, View view, ViewGroup parent) {\n    ViewHolder holder;\n    if (view != null) {\n      holder = (ViewHolder) view.getTag();\n    } else {\n      view = inflater.inflate(R.layout.list_item_sample, parent, false);\n      holder = new ViewHolder(view);\n      view.setTag(holder);\n    }\n\n    holder.name.setText(\"John Doe\");\n    // etc...\n\n    return view;\n  }\n\n  static class ViewHolder {\n    @Bind(R.id.title) TextView name;\n    @Bind(R.id.job_title) TextView jobTitle;\n    public ViewHolder(View view) {\n      ButterKnife.bind(this, view);\n    }\n  }\n}\n```\n\n*after*\n### ListView \n```java\npublic class MyAdapter extends BaseAdapter {\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n      ListItemSampleBinding binding;\n      if (convertView == null) {\n          binding = DataBindingUtil.inflate(inflater, R.layout.list_item_sample, parent, false);\n          convertView = binding.getRoot();\n          convertView.setTag(binding);\n      } else {\n          binding = (ListItemSampleBinding) convertView.getTag();\n      }\n      binding.setUser(getItem(position));\n      // binding.name.setText(\"John Doe\");\n\n      return convertView;\n  }\n}\n```\n\n### recyclerView\n```java\npublic class SampleRecyclerAdapter extends RecyclerView.Adapter<SampleRecyclerAdapter.BindingHolder> {\n\n    @Override\n    public RegisterableDeviceListAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n      final View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_sample, parent, false);\n      return new BindingHolder(v);\n    }\n\n  @Override\n  public void onBindViewHolder(BindingHolder holder, int position) {\n    holder.getBinding().setVariable(BR.user, getItem(position));\n  }\n\n  static class BindingHolder extends RecyclerView.ViewHolder {\n    private final ViewDataBinding binding;\n\n    public BindingHolder(View itemView) {\n      super(itemView);\n      binding = DataBindingUtil.bind(itemView)\n    }\n\n    public ViewDataBinding getBinding() {\n      return binding;\n    }\n  }\n}\n```\n\n# 4.在CustomView中使用\n在自定义View(ViewGroup)的时候，可以用ButterKnife减少自定义ViewGroup中的findViewById,使用Databinding之后是这样的。\n```java\npublic class Pagination extends RelativeLayout {\n  private ViewPaginationBinding binding;\n\n  public Pagination(Context context) {\n    this(context, null);\n  }\n\n  public Pagination(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    binding = DataBindingUtil.inflate(LayoutInflater.from(context), R.layout.view_pagination, this, true);\n  }\n\n  public static void setListener(Pagination paginate, View target, OnPaginationClickListener listener) {\n    if (listener != null) {\n      target.setOnClickListener(_v -> listener.onClick(paginate));\n    }\n  }\n\n  @BindingAdapter({\"android:onPrevButtonClicked\"})\n  public static void setPrevClickListener(Pagination view, OnPaginationClickListener listener) {\n    setListener(view, view.binding.btnPrevPage, listener);\n  }\n\n  @BindingAdapter({\"android:onNextButtonClicked\"})\n  public static void setNextClickListener(Pagination view, OnPaginationClickListener listener) {\n    setListener(view, view.binding.btnNextPage, listener);\n  }\n\n  public interface OnPaginationClickListener {\n    void onClick(Pagination pagination);\n  }\n}\n```\n\n# 5.EventHandler, setDefaultComponent...</br>\nDatabinding还有很多高级用法，目前给我带来的好处就是明显减少了boilerplate code </br>\nSo ,感谢ButterKnife给我们带来的便利，Googbye ButterKnife，Hello DataBinding!\n\n＊todo＊ \n###　how did ButterKnife work?\n\n# Reference\n\n 1. [Data Binding Library](https://developer.android.com/topic/libraries/data-binding/index.html)\n 2. [data-binding-android-boyar-mount](https://realm.io/cn/news/data-binding-android-boyar-mount/) \n 3. [Advanced Data Bindinding](https://www.youtube.com/watch?v=DAmMN7m3wLU) Two-Way Data Binding at google io 2016\n 4. [Android Dev Summit 2015](https://www.youtube.com/watch?v=NBbeQMOcnZ0)\n 5. [Goodbye Butter Knife](http://qiita.com/izumin5210/items/2784576d86ce6b9b51e6)\n 6. [Google Sample](https://github.com/google/android-ui-toolkit-demos)\n \n","slug":"replace-butterKnife-with-databinding","published":1,"updated":"2017-07-01T16:07:10.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnl7003dbovrsbk0n8o8","content":"<p>Yigit Boyar 在2015年的android Dev summit上介绍了Databinding，当时好像提到一句:<br>“no binding libraries will be created from now on “，大意如此。<br>本文介绍使用Databinding替代ButterKnife的用法</p>\n<h2 id=\"本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\"><a href=\"#本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\" class=\"headerlink\" title=\"本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\"></a>本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。</h2><a id=\"more\"></a>\n<h1 id=\"1-在Activity中使用\"><a href=\"#1-在Activity中使用\" class=\"headerlink\" title=\"1.在Activity中使用\"></a>1.在Activity中使用</h1><p><em>before</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.title) TextView title;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.subtitle) TextView subtitle;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.footer) TextView footer;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.simple_activity);</div><div class=\"line\">    ButterKnife.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><em>after</em><br>首先需要将xml文件添加 <strong>Layout</strong> tag<br><code>R.layout.smple_activity</code><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span> <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/title\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span> <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/subtitle\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span> <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/footer\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> ActivitySampleBinding binding;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    binding = DataBindingUtils.setContentView(<span class=\"keyword\">this</span>, R.layout.simple_activity);</div><div class=\"line\">    binding.title.setText(<span class=\"string\">\"I am Title\"</span>);</div><div class=\"line\">    <span class=\"comment\">//no more findViewById!!!</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"2-在Fragment中使用\"><a href=\"#2-在Fragment中使用\" class=\"headerlink\" title=\"2.在Fragment中使用\"></a>2.在Fragment中使用</h1><p><em>before</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FancyFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.button1) Button button1;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.button2) Button button2;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    View view = inflater.inflate(R.layout.fancy_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">    ButterKnife.bind(<span class=\"keyword\">this</span>, view);</div><div class=\"line\">    <span class=\"comment\">// TODO Use fields...</span></div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><em>after</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FancyFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> FragmentFancyBinding binding;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    binding = DataBindingUtil.inflate(inflater,R.layout.fragment_fancy, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">true  <span class=\"keyword\">return</span> binding.getRoot();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"3-在ViewHolder中使用\"><a href=\"#3-在ViewHolder中使用\" class=\"headerlink\" title=\"3.在ViewHolder中使用\"></a>3.在ViewHolder中使用</h1><p><em>before</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseAdapter</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> position, View view, ViewGroup parent)</span> </span>&#123;</div><div class=\"line\">    ViewHolder holder;</div><div class=\"line\">    <span class=\"keyword\">if</span> (view != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      holder = (ViewHolder) view.getTag();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      view = inflater.inflate(R.layout.list_item_sample, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">      holder = <span class=\"keyword\">new</span> ViewHolder(view);</div><div class=\"line\">      view.setTag(holder);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    holder.name.setText(<span class=\"string\">\"John Doe\"</span>);</div><div class=\"line\">    <span class=\"comment\">// etc...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewHolder</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Bind</span>(R.id.title) TextView name;</div><div class=\"line\">    <span class=\"meta\">@Bind</span>(R.id.job_title) TextView jobTitle;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewHolder</span><span class=\"params\">(View view)</span> </span>&#123;</div><div class=\"line\">      ButterKnife.bind(<span class=\"keyword\">this</span>, view);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><em>after</em></p>\n<h3 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseAdapter</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class=\"line\">      ListItemSampleBinding binding;</div><div class=\"line\">      <span class=\"keyword\">if</span> (convertView == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          binding = DataBindingUtil.inflate(inflater, R.layout.list_item_sample, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">          convertView = binding.getRoot();</div><div class=\"line\">          convertView.setTag(binding);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          binding = (ListItemSampleBinding) convertView.getTag();</div><div class=\"line\">      &#125;</div><div class=\"line\">      binding.setUser(getItem(position));</div><div class=\"line\">      <span class=\"comment\">// binding.name.setText(\"John Doe\");</span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> convertView;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"recyclerView\"><a href=\"#recyclerView\" class=\"headerlink\" title=\"recyclerView\"></a>recyclerView</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleRecyclerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">SampleRecyclerAdapter</span>.<span class=\"title\">BindingHolder</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> RegisterableDeviceListAdapter.<span class=\"function\">ViewHolder <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">final</span> View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_sample, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BindingHolder(v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(BindingHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">    holder.getBinding().setVariable(BR.user, getItem(position));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BindingHolder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewDataBinding binding;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BindingHolder</span><span class=\"params\">(View itemView)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>(itemView);</div><div class=\"line\">      binding = DataBindingUtil.bind(itemView)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewDataBinding <span class=\"title\">getBinding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> binding;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"4-在CustomView中使用\"><a href=\"#4-在CustomView中使用\" class=\"headerlink\" title=\"4.在CustomView中使用\"></a>4.在CustomView中使用</h1><p>在自定义View(ViewGroup)的时候，可以用ButterKnife减少自定义ViewGroup中的findViewById,使用Databinding之后是这样的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pagination</span> <span class=\"keyword\">extends</span> <span class=\"title\">RelativeLayout</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> ViewPaginationBinding binding;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pagination</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pagination</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">    binding = DataBindingUtil.inflate(LayoutInflater.from(context), R.layout.view_pagination, <span class=\"keyword\">this</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setListener</span><span class=\"params\">(Pagination paginate, View target, OnPaginationClickListener listener)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      target.setOnClickListener(_v -&gt; listener.onClick(paginate));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@BindingAdapter</span>(&#123;<span class=\"string\">\"android:onPrevButtonClicked\"</span>&#125;)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setPrevClickListener</span><span class=\"params\">(Pagination view, OnPaginationClickListener listener)</span> </span>&#123;</div><div class=\"line\">    setListener(view, view.binding.btnPrevPage, listener);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@BindingAdapter</span>(&#123;<span class=\"string\">\"android:onNextButtonClicked\"</span>&#125;)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextClickListener</span><span class=\"params\">(Pagination view, OnPaginationClickListener listener)</span> </span>&#123;</div><div class=\"line\">    setListener(view, view.binding.btnNextPage, listener);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnPaginationClickListener</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(Pagination pagination)</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"5-EventHandler-setDefaultComponent…\"><a href=\"#5-EventHandler-setDefaultComponent…\" class=\"headerlink\" title=\"5.EventHandler, setDefaultComponent…\"></a>5.EventHandler, setDefaultComponent…</br></h1><p>Databinding还有很多高级用法，目前给我带来的好处就是明显减少了boilerplate code </br><br>So ,感谢ButterKnife给我们带来的便利，Googbye ButterKnife，Hello DataBinding!</p>\n<p>＊todo＊ </p>\n<p>###　how did ButterKnife work?</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ol>\n<li><a href=\"https://developer.android.com/topic/libraries/data-binding/index.html\">Data Binding Library</a></li>\n<li><a href=\"https://realm.io/cn/news/data-binding-android-boyar-mount/\">data-binding-android-boyar-mount</a> </li>\n<li><a href=\"https://www.youtube.com/watch?v=DAmMN7m3wLU\">Advanced Data Bindinding</a> Two-Way Data Binding at google io 2016</li>\n<li><a href=\"https://www.youtube.com/watch?v=NBbeQMOcnZ0\">Android Dev Summit 2015</a></li>\n<li><a href=\"http://qiita.com/izumin5210/items/2784576d86ce6b9b51e6\">Goodbye Butter Knife</a></li>\n<li><a href=\"https://github.com/google/android-ui-toolkit-demos\">Google Sample</a></li>\n</ol>\n","excerpt":"<p>Yigit Boyar 在2015年的android Dev summit上介绍了Databinding，当时好像提到一句:<br>“no binding libraries will be created from now on “，大意如此。<br>本文介绍使用Databinding替代ButterKnife的用法</p>\n<h2 id=\"本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\"><a href=\"#本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\" class=\"headerlink\" title=\"本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。\"></a>本文大部分代码来自网络，我只是觉得简单的代码直接复制粘贴可能会比较好。</h2>","more":"<h1 id=\"1-在Activity中使用\"><a href=\"#1-在Activity中使用\" class=\"headerlink\" title=\"1.在Activity中使用\"></a>1.在Activity中使用</h1><p><em>before</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.title) TextView title;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.subtitle) TextView subtitle;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.footer) TextView footer;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.simple_activity);</div><div class=\"line\">    ButterKnife.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><em>after</em><br>首先需要将xml文件添加 <strong>Layout</strong> tag<br><code>R.layout.smple_activity</code><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span> <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/title\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span> <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/subtitle\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TextView</span> <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/footer\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> ActivitySampleBinding binding;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    binding = DataBindingUtils.setContentView(<span class=\"keyword\">this</span>, R.layout.simple_activity);</div><div class=\"line\">    binding.title.setText(<span class=\"string\">\"I am Title\"</span>);</div><div class=\"line\">    <span class=\"comment\">//no more findViewById!!!</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"2-在Fragment中使用\"><a href=\"#2-在Fragment中使用\" class=\"headerlink\" title=\"2.在Fragment中使用\"></a>2.在Fragment中使用</h1><p><em>before</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FancyFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.button1) Button button1;</div><div class=\"line\">  <span class=\"meta\">@Bind</span>(R.id.button2) Button button2;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    View view = inflater.inflate(R.layout.fancy_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">    ButterKnife.bind(<span class=\"keyword\">this</span>, view);</div><div class=\"line\">    <span class=\"comment\">// TODO Use fields...</span></div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><em>after</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FancyFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> FragmentFancyBinding binding;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    binding = DataBindingUtil.inflate(inflater,R.layout.fragment_fancy, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">true  <span class=\"keyword\">return</span> binding.getRoot();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"3-在ViewHolder中使用\"><a href=\"#3-在ViewHolder中使用\" class=\"headerlink\" title=\"3.在ViewHolder中使用\"></a>3.在ViewHolder中使用</h1><p><em>before</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseAdapter</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> position, View view, ViewGroup parent)</span> </span>&#123;</div><div class=\"line\">    ViewHolder holder;</div><div class=\"line\">    <span class=\"keyword\">if</span> (view != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      holder = (ViewHolder) view.getTag();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      view = inflater.inflate(R.layout.list_item_sample, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">      holder = <span class=\"keyword\">new</span> ViewHolder(view);</div><div class=\"line\">      view.setTag(holder);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    holder.name.setText(<span class=\"string\">\"John Doe\"</span>);</div><div class=\"line\">    <span class=\"comment\">// etc...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewHolder</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Bind</span>(R.id.title) TextView name;</div><div class=\"line\">    <span class=\"meta\">@Bind</span>(R.id.job_title) TextView jobTitle;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewHolder</span><span class=\"params\">(View view)</span> </span>&#123;</div><div class=\"line\">      ButterKnife.bind(<span class=\"keyword\">this</span>, view);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><em>after</em></p>\n<h3 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseAdapter</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class=\"line\">      ListItemSampleBinding binding;</div><div class=\"line\">      <span class=\"keyword\">if</span> (convertView == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          binding = DataBindingUtil.inflate(inflater, R.layout.list_item_sample, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">          convertView = binding.getRoot();</div><div class=\"line\">          convertView.setTag(binding);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          binding = (ListItemSampleBinding) convertView.getTag();</div><div class=\"line\">      &#125;</div><div class=\"line\">      binding.setUser(getItem(position));</div><div class=\"line\">      <span class=\"comment\">// binding.name.setText(\"John Doe\");</span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> convertView;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"recyclerView\"><a href=\"#recyclerView\" class=\"headerlink\" title=\"recyclerView\"></a>recyclerView</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleRecyclerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">SampleRecyclerAdapter</span>.<span class=\"title\">BindingHolder</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> RegisterableDeviceListAdapter.<span class=\"function\">ViewHolder <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">final</span> View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_sample, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BindingHolder(v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(BindingHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">    holder.getBinding().setVariable(BR.user, getItem(position));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BindingHolder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewDataBinding binding;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BindingHolder</span><span class=\"params\">(View itemView)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>(itemView);</div><div class=\"line\">      binding = DataBindingUtil.bind(itemView)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewDataBinding <span class=\"title\">getBinding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> binding;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"4-在CustomView中使用\"><a href=\"#4-在CustomView中使用\" class=\"headerlink\" title=\"4.在CustomView中使用\"></a>4.在CustomView中使用</h1><p>在自定义View(ViewGroup)的时候，可以用ButterKnife减少自定义ViewGroup中的findViewById,使用Databinding之后是这样的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pagination</span> <span class=\"keyword\">extends</span> <span class=\"title\">RelativeLayout</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> ViewPaginationBinding binding;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pagination</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pagination</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">    binding = DataBindingUtil.inflate(LayoutInflater.from(context), R.layout.view_pagination, <span class=\"keyword\">this</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setListener</span><span class=\"params\">(Pagination paginate, View target, OnPaginationClickListener listener)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      target.setOnClickListener(_v -&gt; listener.onClick(paginate));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@BindingAdapter</span>(&#123;<span class=\"string\">\"android:onPrevButtonClicked\"</span>&#125;)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setPrevClickListener</span><span class=\"params\">(Pagination view, OnPaginationClickListener listener)</span> </span>&#123;</div><div class=\"line\">    setListener(view, view.binding.btnPrevPage, listener);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@BindingAdapter</span>(&#123;<span class=\"string\">\"android:onNextButtonClicked\"</span>&#125;)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextClickListener</span><span class=\"params\">(Pagination view, OnPaginationClickListener listener)</span> </span>&#123;</div><div class=\"line\">    setListener(view, view.binding.btnNextPage, listener);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnPaginationClickListener</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(Pagination pagination)</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"5-EventHandler-setDefaultComponent…\"><a href=\"#5-EventHandler-setDefaultComponent…\" class=\"headerlink\" title=\"5.EventHandler, setDefaultComponent…\"></a>5.EventHandler, setDefaultComponent…</br></h1><p>Databinding还有很多高级用法，目前给我带来的好处就是明显减少了boilerplate code </br><br>So ,感谢ButterKnife给我们带来的便利，Googbye ButterKnife，Hello DataBinding!</p>\n<p>＊todo＊ </p>\n<p>###　how did ButterKnife work?</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ol>\n<li><a href=\"https://developer.android.com/topic/libraries/data-binding/index.html\">Data Binding Library</a></li>\n<li><a href=\"https://realm.io/cn/news/data-binding-android-boyar-mount/\">data-binding-android-boyar-mount</a> </li>\n<li><a href=\"https://www.youtube.com/watch?v=DAmMN7m3wLU\">Advanced Data Bindinding</a> Two-Way Data Binding at google io 2016</li>\n<li><a href=\"https://www.youtube.com/watch?v=NBbeQMOcnZ0\">Android Dev Summit 2015</a></li>\n<li><a href=\"http://qiita.com/izumin5210/items/2784576d86ce6b9b51e6\">Goodbye Butter Knife</a></li>\n<li><a href=\"https://github.com/google/android-ui-toolkit-demos\">Google Sample</a></li>\n</ol>"},{"title":"service和activity的通信方式","date":"2016-09-30T07:25:28.000Z","_content":"\n![](http://odzl05jxx.bkt.clouddn.com/service_lifecycle.png)\n\n一年以前写过一篇关于service和Activity相互通信的很详细的博客，当时真的是费了很大心思在上面。现在回过头来看，还是有些不完善的地方，比如aidl没有给，demo不够全面。现在补上。\n\n<!--more-->\n\n1. 关于Android的Service，[官方文档](https://developer.android.com/guide/components/services.html)是这样描述的\n\n> `Service` 是一个可以在后台执行长时间运行操作而不使用用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。\n\n这其中也能看出Android对于Service角色的定位，后台工作，不涉及UI。\n\nService本身包含started Service和Binded Service\n\n对于Binded Service 使用\n\n![](http://odzl05jxx.bkt.clouddn.com/service_binding_tree_lifecycle.png)\n\n\n\n## 待续\n\n### reference\n\n[csdn](http://blog.csdn.net/javazejian/article/details/52709857)\n\n\n\n","source":"_posts/service-activity-communication.md","raw":"---\ntitle: service和activity的通信方式\ndate: 2016-09-30 15:25:28\ncategories: blog\ntags: [service,android]\n---\n\n![](http://odzl05jxx.bkt.clouddn.com/service_lifecycle.png)\n\n一年以前写过一篇关于service和Activity相互通信的很详细的博客，当时真的是费了很大心思在上面。现在回过头来看，还是有些不完善的地方，比如aidl没有给，demo不够全面。现在补上。\n\n<!--more-->\n\n1. 关于Android的Service，[官方文档](https://developer.android.com/guide/components/services.html)是这样描述的\n\n> `Service` 是一个可以在后台执行长时间运行操作而不使用用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。\n\n这其中也能看出Android对于Service角色的定位，后台工作，不涉及UI。\n\nService本身包含started Service和Binded Service\n\n对于Binded Service 使用\n\n![](http://odzl05jxx.bkt.clouddn.com/service_binding_tree_lifecycle.png)\n\n\n\n## 待续\n\n### reference\n\n[csdn](http://blog.csdn.net/javazejian/article/details/52709857)\n\n\n\n","slug":"service-activity-communication","published":1,"updated":"2017-04-23T10:52:32.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnlc003hbovrn6hponqd","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/service_lifecycle.png\" alt=\"\"></p>\n<p>一年以前写过一篇关于service和Activity相互通信的很详细的博客，当时真的是费了很大心思在上面。现在回过头来看，还是有些不完善的地方，比如aidl没有给，demo不够全面。现在补上。</p>\n<a id=\"more\"></a>\n<ol>\n<li>关于Android的Service，<a href=\"https://developer.android.com/guide/components/services.html\">官方文档</a>是这样描述的</li>\n</ol>\n<blockquote>\n<p><code>Service</code> 是一个可以在后台执行长时间运行操作而不使用用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p>\n</blockquote>\n<p>这其中也能看出Android对于Service角色的定位，后台工作，不涉及UI。</p>\n<p>Service本身包含started Service和Binded Service</p>\n<p>对于Binded Service 使用</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/service_binding_tree_lifecycle.png\" alt=\"\"></p>\n<h2 id=\"待续\"><a href=\"#待续\" class=\"headerlink\" title=\"待续\"></a>待续</h2><h3 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h3><p><a href=\"http://blog.csdn.net/javazejian/article/details/52709857\">csdn</a></p>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/service_lifecycle.png\" alt=\"\"></p>\n<p>一年以前写过一篇关于service和Activity相互通信的很详细的博客，当时真的是费了很大心思在上面。现在回过头来看，还是有些不完善的地方，比如aidl没有给，demo不够全面。现在补上。</p>","more":"<ol>\n<li>关于Android的Service，<a href=\"https://developer.android.com/guide/components/services.html\">官方文档</a>是这样描述的</li>\n</ol>\n<blockquote>\n<p><code>Service</code> 是一个可以在后台执行长时间运行操作而不使用用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p>\n</blockquote>\n<p>这其中也能看出Android对于Service角色的定位，后台工作，不涉及UI。</p>\n<p>Service本身包含started Service和Binded Service</p>\n<p>对于Binded Service 使用</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/service_binding_tree_lifecycle.png\" alt=\"\"></p>\n<h2 id=\"待续\"><a href=\"#待续\" class=\"headerlink\" title=\"待续\"></a>待续</h2><h3 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h3><p><a href=\"http://blog.csdn.net/javazejian/article/details/52709857\">csdn</a></p>"},{"title":"android使用selectableItemBackground的一些坑","date":"2016-09-23T11:56:39.000Z","_content":"\n> android:foreground=\"?android:attr/selectableItemBackground\"\n\n或是\n> android:background=\"?android:attr/selectableItemBackground\"\n\n这个xml属性最早是我学着写recyclerVeiw的item xml的时候接触到的，简单来说就是，在API 21及以上，用户点击这个itemView时候会出现一个Ripple效果\n非常好看，而在API 21以下则会表现为MonoChrome的类似按压色的效果![](https://cloud.githubusercontent.com/assets/12274855/18787855/2a6d93f2-81d7-11e6-8026-58cdbd8583d4.JPG) </br> \n而这个点击时的水波纹颜色也是可以Customize的\n```\n<item name=\"android:colorControlHighlight\">@color/my_ripple_color</item>\n```\n//这个要写在自己的Activity的Theme(style-v21)里，注意，当前Activity的Theme必须继承自Appcompat!!\n于是，我写了这样的xml\n```xml\n<LinearLayout\n        android:id=\"@+id/item_root\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?android:attr/listPreferredItemHeight\"\n        android:orientation=\"vertical\"\n        android:gravity=\"center\"\n        android:onClick=\"@{(view) -> callback.onClick(view,data)}\"\n        android:elevation=\"2dp\"\n        android:background=\"@color/md_amber_200\"\n        android:foreground=\"?android:attr/selectableItemBackground\"\n        />\n```\n然而，点击之后并没有出现水波纹(模拟器 API 21)，换成CardView或是将foreground改为background之后才有效。查了很多博客，最后得出结论:\nandroid:foreground在API 23之前只对FrameLayout有效(CardView继承自FrameLayout当然有效)。\n<!--more-->\n\n##所以正确的做法是\n\n> android:foreground=\"?android:attr/selectableItemBackground\"\n\n改为\n> android:background=\"?android:attr/selectableItemBackground\"\n\n或者使用FrameLayout。\n\n- 关于foreground \n 之前看google io2016时，[Chris Banes](https://github.com/chrisbanes)给了这样的解释。\n ![](https://cloud.githubusercontent.com/assets/12274855/18787841/1d0b2d82-81d7-11e6-916e-b4113772c3a2.JPG),\nandroid:foreground在API 1 的FrameLayout中就有了，但直到API 23才将这个属性添加到View中。\n所以，换成API 23的手机上面那段代码foreground也是可以出现Ripple的,至于23之前为什么foreground无效，并不清楚为什么\n\n- 首先是一种简单的模拟这种视觉效果的尝试：[如何创建兼容的Forefround drawable selector](http://effmx.com/articles/ru-he-chuang-jian-jian-rong-de-foreground-drawable-selectorshi-xian-layoutdian-ji-xiao-guo/) 这篇文章提到了:\n    > 简单来讲，Foreground 定义了绘制于当前内容之上的 Drawable，类似一层覆盖物。所以我们可以为设置 Foreground 的值为 drawable或者color， 那如果将 Froeground 设置为 drawable selector，自然就可以为控件实现点击响应效果了。 比较奇怪的是在 sdk 23 以前，foregrond 属性只对 Framelayout 生效，但这个问题现在得到了解决，所以也请确保你的 compileSdkVersion 大于等于23\n    这篇文章的做法是针对21以下的版本使用slelector Drawable实现类似的效果\n\n- 如何真正实现为API23之前的View,ViewGroup添加foreground?\n随后我找到了[这篇博客](https://dzone.com/articles/adding-foreground-selector)，具体的逻辑并不太多。\n这里插一句，任何Drawable对象，在你调用setDrawable之后，该Drawable都会保留一个最后一个调用对象的callback\n> Drawable->View->Context //leak!\n//所以Drawable也有可能导致Activity leak\n\n- 随后我发现了更多有意思的讨论\n首先是[Chris Banes](https://github.com/chrisbanes)在G+上的Post : [Foreground Doge](https://plus.google.com/+ChrisBanes/posts/DRerZ8wEFuF)\n他给出了两种方案,Chris作为Google员工，给出的解决方案应该是比较官方的了\n1. 如果想利用FrameLayout的foreground特性来实现点击特效的话，完全可以在自己的xml外面再包裹一层FrameLayout\n2. 自己动手写一个实现foreground的Viewgroup , [代码](https://gist.github.com/chrisbanes/9091754)\n- attrs:\n```<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <declare-styleable name=\"ForegroundLinearLayout\">\n        <attr name=\"android:foreground\" />\n        <attr name=\"android:foregroundInsidePadding\" />\n        <attr name=\"android:foregroundGravity\" />\n    </declare-styleable>\n</resources>```\n\n```java\n/* \n * Copyright (C) 2006 The Android Open Source Project \n * \n * Licensed under the Apache License, Version 2.0 (the \"License\"); \n * you may not use this file except in compliance with the License. \n * You may obtain a copy of the License at \n * \n *      http://www.apache.org/licenses/LICENSE-2.0 \n * \n * Unless required by applicable law or agreed to in writing, software \n * distributed under the License is distributed on an \"AS IS\" BASIS, \n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n * See the License for the specific language governing permissions and \n * limitations under the License. \n */ \n \npackage your.package; \n \nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.drawable.Drawable;\nimport android.util.AttributeSet;\nimport android.view.Gravity;\nimport android.widget.LinearLayout;\n \nimport your.package.R; \n \npublic class ForegroundLinearLayout extends LinearLayout {\n \n    private Drawable mForeground;\n \n    private final Rect mSelfBounds = new Rect();\n    private final Rect mOverlayBounds = new Rect();\n \n    private int mForegroundGravity = Gravity.FILL;\n \n    protected boolean mForegroundInPadding = true;\n \n    boolean mForegroundBoundsChanged = false;\n \n    public ForegroundLinearLayout(Context context) {\n        super(context);\n    } \n \n    public ForegroundLinearLayout(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    } \n \n    public ForegroundLinearLayout(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n \n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundLinearLayout,\n                defStyle, 0);\n \n        mForegroundGravity = a.getInt(\n                R.styleable.ForegroundLinearLayout_android_foregroundGravity, mForegroundGravity);\n \n        final Drawable d = a.getDrawable(R.styleable.ForegroundLinearLayout_android_foreground);\n        if (d != null) {\n            setForeground(d);\n        } \n \n        mForegroundInPadding = a.getBoolean(\n                R.styleable.ForegroundLinearLayout_android_foregroundInsidePadding, true);\n \n        a.recycle();\n    } \n \n    /** \n     * Describes how the foreground is positioned. \n     * \n     * @return foreground gravity. \n     * \n     * @see #setForegroundGravity(int) \n     */ \n    public int getForegroundGravity() { \n        return mForegroundGravity;\n    } \n \n    /** \n     * Describes how the foreground is positioned. Defaults to START and TOP. \n     * \n     * @param foregroundGravity See {@link android.view.Gravity} \n     * \n     * @see #getForegroundGravity() \n     */ \n    public void setForegroundGravity(int foregroundGravity) {\n        if (mForegroundGravity != foregroundGravity) {\n            if ((foregroundGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) == 0) {\n                foregroundGravity |= Gravity.START;\n            } \n \n            if ((foregroundGravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {\n                foregroundGravity |= Gravity.TOP;\n            } \n \n            mForegroundGravity = foregroundGravity;\n \n \n            if (mForegroundGravity == Gravity.FILL && mForeground != null) {\n                Rect padding = new Rect();\n                mForeground.getPadding(padding);\n            } \n \n            requestLayout();\n        } \n    } \n \n    @Override \n    protected boolean verifyDrawable(Drawable who) {\n        return super.verifyDrawable(who) || (who == mForeground);\n    } \n \n    @Override \n    public void jumpDrawablesToCurrentState() { \n        super.jumpDrawablesToCurrentState(); \n        if (mForeground != null) mForeground.jumpToCurrentState();\n    } \n \n    @Override \n    protected void drawableStateChanged() { \n        super.drawableStateChanged(); \n        if (mForeground != null && mForeground.isStateful()) {\n            mForeground.setState(getDrawableState());\n        } \n    } \n \n    /** \n     * Supply a Drawable that is to be rendered on top of all of the child \n     * views in the frame layout.  Any padding in the Drawable will be taken \n     * into account by ensuring that the children are inset to be placed \n     * inside of the padding area. \n     * \n     * @param drawable The Drawable to be drawn on top of the children. \n     */ \n    public void setForeground(Drawable drawable) {\n        if (mForeground != drawable) {\n            if (mForeground != null) {\n                mForeground.setCallback(null);\n                unscheduleDrawable(mForeground);\n            } \n \n            mForeground = drawable;\n \n            if (drawable != null) {\n                setWillNotDraw(false);\n                drawable.setCallback(this);\n                if (drawable.isStateful()) {\n                    drawable.setState(getDrawableState());\n                } \n                if (mForegroundGravity == Gravity.FILL) {\n                    Rect padding = new Rect();\n                    drawable.getPadding(padding);\n                } \n            }  else { \n                setWillNotDraw(true);\n            } \n            requestLayout();\n            invalidate();\n        } \n    } \n \n    /** \n     * Returns the drawable used as the foreground of this FrameLayout. The \n     * foreground drawable, if non-null, is always drawn on top of the children. \n     * \n     * @return A Drawable or null if no foreground was set. \n     */ \n    public Drawable getForeground() {\n        return mForeground;\n    } \n \n    @Override \n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        mForegroundBoundsChanged = changed;\n    } \n \n    @Override \n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        mForegroundBoundsChanged = true;\n    } \n \n    @Override \n    public void draw(Canvas canvas) {\n        super.draw(canvas);\n \n        if (mForeground != null) {\n            final Drawable foreground = mForeground;\n \n            if (mForegroundBoundsChanged) {\n                mForegroundBoundsChanged = false;\n                final Rect selfBounds = mSelfBounds;\n                final Rect overlayBounds = mOverlayBounds;\n \n                final int w = getRight() - getLeft();\n                final int h = getBottom() - getTop();\n \n                if (mForegroundInPadding) {\n                    selfBounds.set(0, 0, w, h);\n                } else { \n                    selfBounds.set(getPaddingLeft(), getPaddingTop(),\n                            w - getPaddingRight(), h - getPaddingBottom());\n                } \n \n                Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(),\n                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds);\n                foreground.setBounds(overlayBounds);\n            } \n \n            foreground.draw(canvas);\n        } \n    } \n} \n```\n- 使用方式\n``` xml \n<your.package.ForegroundLinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:foreground=\"?android:selectableItemBackground\">\n\n    <ImageView\n        android:id=”@+id/imageview_opaque”\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n\n    ... other views ...\n/>\n```\n\n- 接着是[Jack Wharton](https://github.com/JakeWharton)的[ForegroundImageView](https://gist.github.com/JakeWharton/0a251d67649305d84e8a)</br>\n\n- attrs\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n  <declare-styleable name=\"ForegroundImageView\">\n    <attr name=\"android:foreground\"/>\n  </declare-styleable>\n</resources>\n```\n\n```java\n    import android.content.Context;\n    import android.content.res.TypedArray;\n    import android.graphics.Canvas;\n    import android.graphics.drawable.Drawable;\n    import android.util.AttributeSet;\n    import android.widget.ImageView;\n     \n    public class ForegroundImageView extends ImageView {\n      private Drawable foreground;\n     \n      public ForegroundImageView(Context context) {\n        this(context, null);\n      } \n     \n      public ForegroundImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n     \n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundImageView);\n        Drawable foreground = a.getDrawable(R.styleable.ForegroundImageView_android_foreground);\n        if (foreground != null) {\n          setForeground(foreground);\n        } \n        a.recycle();\n      } \n     \n      /** \n       * Supply a drawable resource that is to be rendered on top of all of the child \n       * views in the frame layout. \n       * \n       * @param drawableResId The drawable resource to be drawn on top of the children. \n       */ \n      public void setForegroundResource(int drawableResId) {\n        setForeground(getContext().getResources().getDrawable(drawableResId));\n      } \n     \n      /** \n       * Supply a Drawable that is to be rendered on top of all of the child \n       * views in the frame layout. \n       * \n       * @param drawable The Drawable to be drawn on top of the children. \n       */ \n      public void setForeground(Drawable drawable) {\n        if (foreground == drawable) {\n          return; \n        } \n        if (foreground != null) {\n          foreground.setCallback(null);\n          unscheduleDrawable(foreground);\n        } \n     \n        foreground = drawable;\n     \n        if (drawable != null) {\n          drawable.setCallback(this);\n          if (drawable.isStateful()) {\n            drawable.setState(getDrawableState());\n          } \n        } \n        requestLayout();\n        invalidate();\n      } \n     \n      @Override protected boolean verifyDrawable(Drawable who) {\n        return super.verifyDrawable(who) || who == foreground;\n      } \n     \n      @Override public void jumpDrawablesToCurrentState() { \n        super.jumpDrawablesToCurrentState(); \n        if (foreground != null) foreground.jumpToCurrentState();\n      } \n     \n      @Override protected void drawableStateChanged() { \n        super.drawableStateChanged(); \n        if (foreground != null && foreground.isStateful()) {\n          foreground.setState(getDrawableState());\n        } \n      } \n     \n      @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        if (foreground != null) {\n          foreground.setBounds(0, 0, getMeasuredWidth(), getMeasuredHeight());\n          invalidate();\n        } \n      } \n     \n      @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        if (foreground != null) {\n          foreground.setBounds(0, 0, w, h);\n          invalidate();\n        } \n      } \n     \n      @Override public void draw(Canvas canvas) {\n        super.draw(canvas);\n     \n        if (foreground != null) {\n          foreground.draw(canvas);\n        } \n      } \n    } \n```\n\n\n----------\n\n最后，还有人给出据说更好的[解决方案](https://github.com/cesards/ForegroundViews)\n没有测试过，不了解\n\n## reference\n - [Android themes and styles demisfied](https://www.youtube.com/watch?v=TIHXGwRTMWI) 关于Theme和Style的区别的很好的学习资料\n - [Chris Banes G+ post](https://plus.google.com/108967384991768947849/posts/aHPVDtr6mcp) 评论很精彩\n - [RelativeLayout with foreGround](https://gist.github.com/shakalaca/6199283) 没测试过\n - [Ripple Effect](https://github.com/traex/RippleEffect) 将Ripple的动画兼容到API 9+ ，很出色的一个库。之前项目中用过，就是一个继承自RelativeLayout的自定义ViewGroup。\n\n \n","source":"_posts/selectableItemBackground-foreground.md","raw":"---\ntitle: android使用selectableItemBackground的一些坑\ndate: 2016-09-23 19:56:39\ncategories: blog\ntags: [foreground,android]\n---\n\n> android:foreground=\"?android:attr/selectableItemBackground\"\n\n或是\n> android:background=\"?android:attr/selectableItemBackground\"\n\n这个xml属性最早是我学着写recyclerVeiw的item xml的时候接触到的，简单来说就是，在API 21及以上，用户点击这个itemView时候会出现一个Ripple效果\n非常好看，而在API 21以下则会表现为MonoChrome的类似按压色的效果![](https://cloud.githubusercontent.com/assets/12274855/18787855/2a6d93f2-81d7-11e6-8026-58cdbd8583d4.JPG) </br> \n而这个点击时的水波纹颜色也是可以Customize的\n```\n<item name=\"android:colorControlHighlight\">@color/my_ripple_color</item>\n```\n//这个要写在自己的Activity的Theme(style-v21)里，注意，当前Activity的Theme必须继承自Appcompat!!\n于是，我写了这样的xml\n```xml\n<LinearLayout\n        android:id=\"@+id/item_root\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?android:attr/listPreferredItemHeight\"\n        android:orientation=\"vertical\"\n        android:gravity=\"center\"\n        android:onClick=\"@{(view) -> callback.onClick(view,data)}\"\n        android:elevation=\"2dp\"\n        android:background=\"@color/md_amber_200\"\n        android:foreground=\"?android:attr/selectableItemBackground\"\n        />\n```\n然而，点击之后并没有出现水波纹(模拟器 API 21)，换成CardView或是将foreground改为background之后才有效。查了很多博客，最后得出结论:\nandroid:foreground在API 23之前只对FrameLayout有效(CardView继承自FrameLayout当然有效)。\n<!--more-->\n\n##所以正确的做法是\n\n> android:foreground=\"?android:attr/selectableItemBackground\"\n\n改为\n> android:background=\"?android:attr/selectableItemBackground\"\n\n或者使用FrameLayout。\n\n- 关于foreground \n 之前看google io2016时，[Chris Banes](https://github.com/chrisbanes)给了这样的解释。\n ![](https://cloud.githubusercontent.com/assets/12274855/18787841/1d0b2d82-81d7-11e6-916e-b4113772c3a2.JPG),\nandroid:foreground在API 1 的FrameLayout中就有了，但直到API 23才将这个属性添加到View中。\n所以，换成API 23的手机上面那段代码foreground也是可以出现Ripple的,至于23之前为什么foreground无效，并不清楚为什么\n\n- 首先是一种简单的模拟这种视觉效果的尝试：[如何创建兼容的Forefround drawable selector](http://effmx.com/articles/ru-he-chuang-jian-jian-rong-de-foreground-drawable-selectorshi-xian-layoutdian-ji-xiao-guo/) 这篇文章提到了:\n    > 简单来讲，Foreground 定义了绘制于当前内容之上的 Drawable，类似一层覆盖物。所以我们可以为设置 Foreground 的值为 drawable或者color， 那如果将 Froeground 设置为 drawable selector，自然就可以为控件实现点击响应效果了。 比较奇怪的是在 sdk 23 以前，foregrond 属性只对 Framelayout 生效，但这个问题现在得到了解决，所以也请确保你的 compileSdkVersion 大于等于23\n    这篇文章的做法是针对21以下的版本使用slelector Drawable实现类似的效果\n\n- 如何真正实现为API23之前的View,ViewGroup添加foreground?\n随后我找到了[这篇博客](https://dzone.com/articles/adding-foreground-selector)，具体的逻辑并不太多。\n这里插一句，任何Drawable对象，在你调用setDrawable之后，该Drawable都会保留一个最后一个调用对象的callback\n> Drawable->View->Context //leak!\n//所以Drawable也有可能导致Activity leak\n\n- 随后我发现了更多有意思的讨论\n首先是[Chris Banes](https://github.com/chrisbanes)在G+上的Post : [Foreground Doge](https://plus.google.com/+ChrisBanes/posts/DRerZ8wEFuF)\n他给出了两种方案,Chris作为Google员工，给出的解决方案应该是比较官方的了\n1. 如果想利用FrameLayout的foreground特性来实现点击特效的话，完全可以在自己的xml外面再包裹一层FrameLayout\n2. 自己动手写一个实现foreground的Viewgroup , [代码](https://gist.github.com/chrisbanes/9091754)\n- attrs:\n```<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <declare-styleable name=\"ForegroundLinearLayout\">\n        <attr name=\"android:foreground\" />\n        <attr name=\"android:foregroundInsidePadding\" />\n        <attr name=\"android:foregroundGravity\" />\n    </declare-styleable>\n</resources>```\n\n```java\n/* \n * Copyright (C) 2006 The Android Open Source Project \n * \n * Licensed under the Apache License, Version 2.0 (the \"License\"); \n * you may not use this file except in compliance with the License. \n * You may obtain a copy of the License at \n * \n *      http://www.apache.org/licenses/LICENSE-2.0 \n * \n * Unless required by applicable law or agreed to in writing, software \n * distributed under the License is distributed on an \"AS IS\" BASIS, \n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n * See the License for the specific language governing permissions and \n * limitations under the License. \n */ \n \npackage your.package; \n \nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.drawable.Drawable;\nimport android.util.AttributeSet;\nimport android.view.Gravity;\nimport android.widget.LinearLayout;\n \nimport your.package.R; \n \npublic class ForegroundLinearLayout extends LinearLayout {\n \n    private Drawable mForeground;\n \n    private final Rect mSelfBounds = new Rect();\n    private final Rect mOverlayBounds = new Rect();\n \n    private int mForegroundGravity = Gravity.FILL;\n \n    protected boolean mForegroundInPadding = true;\n \n    boolean mForegroundBoundsChanged = false;\n \n    public ForegroundLinearLayout(Context context) {\n        super(context);\n    } \n \n    public ForegroundLinearLayout(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    } \n \n    public ForegroundLinearLayout(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n \n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundLinearLayout,\n                defStyle, 0);\n \n        mForegroundGravity = a.getInt(\n                R.styleable.ForegroundLinearLayout_android_foregroundGravity, mForegroundGravity);\n \n        final Drawable d = a.getDrawable(R.styleable.ForegroundLinearLayout_android_foreground);\n        if (d != null) {\n            setForeground(d);\n        } \n \n        mForegroundInPadding = a.getBoolean(\n                R.styleable.ForegroundLinearLayout_android_foregroundInsidePadding, true);\n \n        a.recycle();\n    } \n \n    /** \n     * Describes how the foreground is positioned. \n     * \n     * @return foreground gravity. \n     * \n     * @see #setForegroundGravity(int) \n     */ \n    public int getForegroundGravity() { \n        return mForegroundGravity;\n    } \n \n    /** \n     * Describes how the foreground is positioned. Defaults to START and TOP. \n     * \n     * @param foregroundGravity See {@link android.view.Gravity} \n     * \n     * @see #getForegroundGravity() \n     */ \n    public void setForegroundGravity(int foregroundGravity) {\n        if (mForegroundGravity != foregroundGravity) {\n            if ((foregroundGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) == 0) {\n                foregroundGravity |= Gravity.START;\n            } \n \n            if ((foregroundGravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {\n                foregroundGravity |= Gravity.TOP;\n            } \n \n            mForegroundGravity = foregroundGravity;\n \n \n            if (mForegroundGravity == Gravity.FILL && mForeground != null) {\n                Rect padding = new Rect();\n                mForeground.getPadding(padding);\n            } \n \n            requestLayout();\n        } \n    } \n \n    @Override \n    protected boolean verifyDrawable(Drawable who) {\n        return super.verifyDrawable(who) || (who == mForeground);\n    } \n \n    @Override \n    public void jumpDrawablesToCurrentState() { \n        super.jumpDrawablesToCurrentState(); \n        if (mForeground != null) mForeground.jumpToCurrentState();\n    } \n \n    @Override \n    protected void drawableStateChanged() { \n        super.drawableStateChanged(); \n        if (mForeground != null && mForeground.isStateful()) {\n            mForeground.setState(getDrawableState());\n        } \n    } \n \n    /** \n     * Supply a Drawable that is to be rendered on top of all of the child \n     * views in the frame layout.  Any padding in the Drawable will be taken \n     * into account by ensuring that the children are inset to be placed \n     * inside of the padding area. \n     * \n     * @param drawable The Drawable to be drawn on top of the children. \n     */ \n    public void setForeground(Drawable drawable) {\n        if (mForeground != drawable) {\n            if (mForeground != null) {\n                mForeground.setCallback(null);\n                unscheduleDrawable(mForeground);\n            } \n \n            mForeground = drawable;\n \n            if (drawable != null) {\n                setWillNotDraw(false);\n                drawable.setCallback(this);\n                if (drawable.isStateful()) {\n                    drawable.setState(getDrawableState());\n                } \n                if (mForegroundGravity == Gravity.FILL) {\n                    Rect padding = new Rect();\n                    drawable.getPadding(padding);\n                } \n            }  else { \n                setWillNotDraw(true);\n            } \n            requestLayout();\n            invalidate();\n        } \n    } \n \n    /** \n     * Returns the drawable used as the foreground of this FrameLayout. The \n     * foreground drawable, if non-null, is always drawn on top of the children. \n     * \n     * @return A Drawable or null if no foreground was set. \n     */ \n    public Drawable getForeground() {\n        return mForeground;\n    } \n \n    @Override \n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        mForegroundBoundsChanged = changed;\n    } \n \n    @Override \n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        mForegroundBoundsChanged = true;\n    } \n \n    @Override \n    public void draw(Canvas canvas) {\n        super.draw(canvas);\n \n        if (mForeground != null) {\n            final Drawable foreground = mForeground;\n \n            if (mForegroundBoundsChanged) {\n                mForegroundBoundsChanged = false;\n                final Rect selfBounds = mSelfBounds;\n                final Rect overlayBounds = mOverlayBounds;\n \n                final int w = getRight() - getLeft();\n                final int h = getBottom() - getTop();\n \n                if (mForegroundInPadding) {\n                    selfBounds.set(0, 0, w, h);\n                } else { \n                    selfBounds.set(getPaddingLeft(), getPaddingTop(),\n                            w - getPaddingRight(), h - getPaddingBottom());\n                } \n \n                Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(),\n                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds);\n                foreground.setBounds(overlayBounds);\n            } \n \n            foreground.draw(canvas);\n        } \n    } \n} \n```\n- 使用方式\n``` xml \n<your.package.ForegroundLinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:foreground=\"?android:selectableItemBackground\">\n\n    <ImageView\n        android:id=”@+id/imageview_opaque”\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n\n    ... other views ...\n/>\n```\n\n- 接着是[Jack Wharton](https://github.com/JakeWharton)的[ForegroundImageView](https://gist.github.com/JakeWharton/0a251d67649305d84e8a)</br>\n\n- attrs\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n  <declare-styleable name=\"ForegroundImageView\">\n    <attr name=\"android:foreground\"/>\n  </declare-styleable>\n</resources>\n```\n\n```java\n    import android.content.Context;\n    import android.content.res.TypedArray;\n    import android.graphics.Canvas;\n    import android.graphics.drawable.Drawable;\n    import android.util.AttributeSet;\n    import android.widget.ImageView;\n     \n    public class ForegroundImageView extends ImageView {\n      private Drawable foreground;\n     \n      public ForegroundImageView(Context context) {\n        this(context, null);\n      } \n     \n      public ForegroundImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n     \n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundImageView);\n        Drawable foreground = a.getDrawable(R.styleable.ForegroundImageView_android_foreground);\n        if (foreground != null) {\n          setForeground(foreground);\n        } \n        a.recycle();\n      } \n     \n      /** \n       * Supply a drawable resource that is to be rendered on top of all of the child \n       * views in the frame layout. \n       * \n       * @param drawableResId The drawable resource to be drawn on top of the children. \n       */ \n      public void setForegroundResource(int drawableResId) {\n        setForeground(getContext().getResources().getDrawable(drawableResId));\n      } \n     \n      /** \n       * Supply a Drawable that is to be rendered on top of all of the child \n       * views in the frame layout. \n       * \n       * @param drawable The Drawable to be drawn on top of the children. \n       */ \n      public void setForeground(Drawable drawable) {\n        if (foreground == drawable) {\n          return; \n        } \n        if (foreground != null) {\n          foreground.setCallback(null);\n          unscheduleDrawable(foreground);\n        } \n     \n        foreground = drawable;\n     \n        if (drawable != null) {\n          drawable.setCallback(this);\n          if (drawable.isStateful()) {\n            drawable.setState(getDrawableState());\n          } \n        } \n        requestLayout();\n        invalidate();\n      } \n     \n      @Override protected boolean verifyDrawable(Drawable who) {\n        return super.verifyDrawable(who) || who == foreground;\n      } \n     \n      @Override public void jumpDrawablesToCurrentState() { \n        super.jumpDrawablesToCurrentState(); \n        if (foreground != null) foreground.jumpToCurrentState();\n      } \n     \n      @Override protected void drawableStateChanged() { \n        super.drawableStateChanged(); \n        if (foreground != null && foreground.isStateful()) {\n          foreground.setState(getDrawableState());\n        } \n      } \n     \n      @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        if (foreground != null) {\n          foreground.setBounds(0, 0, getMeasuredWidth(), getMeasuredHeight());\n          invalidate();\n        } \n      } \n     \n      @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        if (foreground != null) {\n          foreground.setBounds(0, 0, w, h);\n          invalidate();\n        } \n      } \n     \n      @Override public void draw(Canvas canvas) {\n        super.draw(canvas);\n     \n        if (foreground != null) {\n          foreground.draw(canvas);\n        } \n      } \n    } \n```\n\n\n----------\n\n最后，还有人给出据说更好的[解决方案](https://github.com/cesards/ForegroundViews)\n没有测试过，不了解\n\n## reference\n - [Android themes and styles demisfied](https://www.youtube.com/watch?v=TIHXGwRTMWI) 关于Theme和Style的区别的很好的学习资料\n - [Chris Banes G+ post](https://plus.google.com/108967384991768947849/posts/aHPVDtr6mcp) 评论很精彩\n - [RelativeLayout with foreGround](https://gist.github.com/shakalaca/6199283) 没测试过\n - [Ripple Effect](https://github.com/traex/RippleEffect) 将Ripple的动画兼容到API 9+ ，很出色的一个库。之前项目中用过，就是一个继承自RelativeLayout的自定义ViewGroup。\n\n \n","slug":"selectableItemBackground-foreground","published":1,"updated":"2017-07-15T08:56:34.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnlw003kbovrpa12cp6i","content":"<blockquote>\n<p>android:foreground=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>或是</p>\n<blockquote>\n<p>android:background=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>这个xml属性最早是我学着写recyclerVeiw的item xml的时候接触到的，简单来说就是，在API 21及以上，用户点击这个itemView时候会出现一个Ripple效果<br>非常好看，而在API 21以下则会表现为MonoChrome的类似按压色的效果<img src=\"https://cloud.githubusercontent.com/assets/12274855/18787855/2a6d93f2-81d7-11e6-8026-58cdbd8583d4.JPG\" alt=\"\"> </br><br>而这个点击时的水波纹颜色也是可以Customize的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;item name=&quot;android:colorControlHighlight&quot;&gt;@color/my_ripple_color&lt;/item&gt;</div></pre></td></tr></table></figure></p>\n<p>//这个要写在自己的Activity的Theme(style-v21)里，注意，当前Activity的Theme必须继承自Appcompat!!<br>于是，我写了这样的xml<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/item_root\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"?android:attr/listPreferredItemHeight\"</span></div><div class=\"line\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span></div><div class=\"line\">        <span class=\"attr\">android:gravity</span>=<span class=\"string\">\"center\"</span></div><div class=\"line\">        <span class=\"attr\">android:onClick</span>=<span class=\"string\">\"@&#123;(view) -&gt; callback.onClick(view,data)&#125;\"</span></div><div class=\"line\">        <span class=\"attr\">android:elevation</span>=<span class=\"string\">\"2dp\"</span></div><div class=\"line\">        <span class=\"attr\">android:background</span>=<span class=\"string\">\"@color/md_amber_200\"</span></div><div class=\"line\">        <span class=\"attr\">android:foreground</span>=<span class=\"string\">\"?android:attr/selectableItemBackground\"</span></div><div class=\"line\">        /&gt;</span></div></pre></td></tr></table></figure></p>\n<p>然而，点击之后并没有出现水波纹(模拟器 API 21)，换成CardView或是将foreground改为background之后才有效。查了很多博客，最后得出结论:<br>android:foreground在API 23之前只对FrameLayout有效(CardView继承自FrameLayout当然有效)。<br><a id=\"more\"></a></p>\n<p>##所以正确的做法是</p>\n<blockquote>\n<p>android:foreground=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>改为</p>\n<blockquote>\n<p>android:background=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>或者使用FrameLayout。</p>\n<ul>\n<li><p>关于foreground<br>之前看google io2016时，<a href=\"https://github.com/chrisbanes\">Chris Banes</a>给了这样的解释。<br><img src=\"https://cloud.githubusercontent.com/assets/12274855/18787841/1d0b2d82-81d7-11e6-916e-b4113772c3a2.JPG\" alt=\"\">,<br>android:foreground在API 1 的FrameLayout中就有了，但直到API 23才将这个属性添加到View中。<br>所以，换成API 23的手机上面那段代码foreground也是可以出现Ripple的,至于23之前为什么foreground无效，并不清楚为什么</p>\n</li>\n<li><p>首先是一种简单的模拟这种视觉效果的尝试：<a href=\"http://effmx.com/articles/ru-he-chuang-jian-jian-rong-de-foreground-drawable-selectorshi-xian-layoutdian-ji-xiao-guo/\">如何创建兼容的Forefround drawable selector</a> 这篇文章提到了:</p>\n<blockquote>\n<p>简单来讲，Foreground 定义了绘制于当前内容之上的 Drawable，类似一层覆盖物。所以我们可以为设置 Foreground 的值为 drawable或者color， 那如果将 Froeground 设置为 drawable selector，自然就可以为控件实现点击响应效果了。 比较奇怪的是在 sdk 23 以前，foregrond 属性只对 Framelayout 生效，但这个问题现在得到了解决，所以也请确保你的 compileSdkVersion 大于等于23<br>  这篇文章的做法是针对21以下的版本使用slelector Drawable实现类似的效果</p>\n</blockquote>\n</li>\n<li><p>如何真正实现为API23之前的View,ViewGroup添加foreground?<br>随后我找到了<a href=\"https://dzone.com/articles/adding-foreground-selector\">这篇博客</a>，具体的逻辑并不太多。<br>这里插一句，任何Drawable对象，在你调用setDrawable之后，该Drawable都会保留一个最后一个调用对象的callback</p>\n<blockquote>\n<p>Drawable-&gt;View-&gt;Context //leak!<br>//所以Drawable也有可能导致Activity leak</p>\n</blockquote>\n</li>\n<li><p>随后我发现了更多有意思的讨论<br>首先是<a href=\"https://github.com/chrisbanes\">Chris Banes</a>在G+上的Post : <a href=\"https://plus.google.com/+ChrisBanes/posts/DRerZ8wEFuF\">Foreground Doge</a><br>他给出了两种方案,Chris作为Google员工，给出的解决方案应该是比较官方的了</p>\n</li>\n</ul>\n<ol>\n<li>如果想利用FrameLayout的foreground特性来实现点击特效的话，完全可以在自己的xml外面再包裹一层FrameLayout</li>\n<li>自己动手写一个实现foreground的Viewgroup , <a href=\"https://gist.github.com/chrisbanes/9091754\">代码</a></li>\n</ol>\n<ul>\n<li>attrs:<figure class=\"highlight plain\"><figcaption><span>version=\"1.0\" encoding=\"utf-8\"?></span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;declare-styleable name=&quot;ForegroundLinearLayout&quot;&gt;</div><div class=\"line\">        &lt;attr name=&quot;android:foreground&quot; /&gt;</div><div class=\"line\">        &lt;attr name=&quot;android:foregroundInsidePadding&quot; /&gt;</div><div class=\"line\">        &lt;attr name=&quot;android:foregroundGravity&quot; /&gt;</div><div class=\"line\">    &lt;/declare-styleable&gt;</div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* </div><div class=\"line\"> * Copyright (C) 2006 The Android Open Source Project </div><div class=\"line\"> * </div><div class=\"line\"> * Licensed under the Apache License, Version 2.0 (the \"License\"); </div><div class=\"line\"> * you may not use this file except in compliance with the License. </div><div class=\"line\"> * You may obtain a copy of the License at </div><div class=\"line\"> * </div><div class=\"line\"> *      http://www.apache.org/licenses/LICENSE-2.0 </div><div class=\"line\"> * </div><div class=\"line\"> * Unless required by applicable law or agreed to in writing, software </div><div class=\"line\"> * distributed under the License is distributed on an \"AS IS\" BASIS, </div><div class=\"line\"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. </div><div class=\"line\"> * See the License for the specific language governing permissions and </div><div class=\"line\"> * limitations under the License. </div><div class=\"line\"> */</span> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">package</span> your.<span class=\"keyword\">package</span>; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</div><div class=\"line\"><span class=\"keyword\">import</span> android.content.res.TypedArray;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Canvas;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Rect;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.drawable.Drawable;</div><div class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</div><div class=\"line\"><span class=\"keyword\">import</span> android.view.Gravity;</div><div class=\"line\"><span class=\"keyword\">import</span> android.widget.LinearLayout;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> your.<span class=\"keyword\">package</span>.R; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForegroundLinearLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">private</span> Drawable mForeground;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Rect mSelfBounds = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Rect mOverlayBounds = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mForegroundGravity = Gravity.FILL;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> mForegroundInPadding = <span class=\"keyword\">true</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">boolean</span> mForegroundBoundsChanged = <span class=\"keyword\">false</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundLinearLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundLinearLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(context, attrs, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundLinearLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyle)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyle);</div><div class=\"line\"> </div><div class=\"line\">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundLinearLayout,</div><div class=\"line\">                defStyle, <span class=\"number\">0</span>);</div><div class=\"line\"> </div><div class=\"line\">        mForegroundGravity = a.getInt(</div><div class=\"line\">                R.styleable.ForegroundLinearLayout_android_foregroundGravity, mForegroundGravity);</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">final</span> Drawable d = a.getDrawable(R.styleable.ForegroundLinearLayout_android_foreground);</div><div class=\"line\">        <span class=\"keyword\">if</span> (d != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            setForeground(d);</div><div class=\"line\">        &#125; </div><div class=\"line\"> </div><div class=\"line\">        mForegroundInPadding = a.getBoolean(</div><div class=\"line\">                R.styleable.ForegroundLinearLayout_android_foregroundInsidePadding, <span class=\"keyword\">true</span>);</div><div class=\"line\"> </div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Describes how the foreground is positioned. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@return</span> foreground gravity. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@see</span> #setForegroundGravity(int) </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getForegroundGravity</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> mForegroundGravity;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Describes how the foreground is positioned. Defaults to START and TOP. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@param</span> foregroundGravity See &#123;<span class=\"doctag\">@link</span> android.view.Gravity&#125; </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@see</span> #getForegroundGravity() </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForegroundGravity</span><span class=\"params\">(<span class=\"keyword\">int</span> foregroundGravity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mForegroundGravity != foregroundGravity) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((foregroundGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                foregroundGravity |= Gravity.START;</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> ((foregroundGravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                foregroundGravity |= Gravity.TOP;</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            mForegroundGravity = foregroundGravity;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (mForegroundGravity == Gravity.FILL &amp;&amp; mForeground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                Rect padding = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\">                mForeground.getPadding(padding);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            requestLayout();</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">verifyDrawable</span><span class=\"params\">(Drawable who)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.verifyDrawable(who) || (who == mForeground);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">jumpDrawablesToCurrentState</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">super</span>.jumpDrawablesToCurrentState(); </div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span>) mForeground.jumpToCurrentState();</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">drawableStateChanged</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">super</span>.drawableStateChanged(); </div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span> &amp;&amp; mForeground.isStateful()) &#123;</div><div class=\"line\">            mForeground.setState(getDrawableState());</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Supply a Drawable that is to be rendered on top of all of the child </div><div class=\"line\">     * views in the frame layout.  Any padding in the Drawable will be taken </div><div class=\"line\">     * into account by ensuring that the children are inset to be placed </div><div class=\"line\">     * inside of the padding area. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@param</span> drawable The Drawable to be drawn on top of the children. </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForeground</span><span class=\"params\">(Drawable drawable)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != drawable) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                mForeground.setCallback(<span class=\"keyword\">null</span>);</div><div class=\"line\">                unscheduleDrawable(mForeground);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            mForeground = drawable;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (drawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                setWillNotDraw(<span class=\"keyword\">false</span>);</div><div class=\"line\">                drawable.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (drawable.isStateful()) &#123;</div><div class=\"line\">                    drawable.setState(getDrawableState());</div><div class=\"line\">                &#125; </div><div class=\"line\">                <span class=\"keyword\">if</span> (mForegroundGravity == Gravity.FILL) &#123;</div><div class=\"line\">                    Rect padding = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\">                    drawable.getPadding(padding);</div><div class=\"line\">                &#125; </div><div class=\"line\">            &#125;  <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">                setWillNotDraw(<span class=\"keyword\">true</span>);</div><div class=\"line\">            &#125; </div><div class=\"line\">            requestLayout();</div><div class=\"line\">            invalidate();</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Returns the drawable used as the foreground of this FrameLayout. The </div><div class=\"line\">     * foreground drawable, if non-null, is always drawn on top of the children. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@return</span> A Drawable or null if no foreground was set. </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Drawable <span class=\"title\">getForeground</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mForeground;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onLayout(changed, left, top, right, bottom);</div><div class=\"line\">        mForegroundBoundsChanged = changed;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> oldw, <span class=\"keyword\">int</span> oldh)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class=\"line\">        mForegroundBoundsChanged = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.draw(canvas);</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> Drawable foreground = mForeground;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (mForegroundBoundsChanged) &#123;</div><div class=\"line\">                mForegroundBoundsChanged = <span class=\"keyword\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">final</span> Rect selfBounds = mSelfBounds;</div><div class=\"line\">                <span class=\"keyword\">final</span> Rect overlayBounds = mOverlayBounds;</div><div class=\"line\"> </div><div class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> w = getRight() - getLeft();</div><div class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> h = getBottom() - getTop();</div><div class=\"line\"> </div><div class=\"line\">                <span class=\"keyword\">if</span> (mForegroundInPadding) &#123;</div><div class=\"line\">                    selfBounds.set(<span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">                    selfBounds.set(getPaddingLeft(), getPaddingTop(),</div><div class=\"line\">                            w - getPaddingRight(), h - getPaddingBottom());</div><div class=\"line\">                &#125; </div><div class=\"line\"> </div><div class=\"line\">                Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(),</div><div class=\"line\">                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds);</div><div class=\"line\">                foreground.setBounds(overlayBounds);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            foreground.draw(canvas);</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">your.package.ForegroundLinearLayout</span></div><div class=\"line\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">    <span class=\"attr\">android:foreground</span>=<span class=\"string\">\"?android:selectableItemBackground\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">”@+id/imageview_opaque”</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">    ... other views ...</div><div class=\"line\">/&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>接着是<a href=\"https://github.com/JakeWharton\">Jack Wharton</a>的<a href=\"https://gist.github.com/JakeWharton/0a251d67649305d84e8a\">ForegroundImageView</a></br></p>\n</li>\n<li><p>attrs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">declare-styleable</span> <span class=\"attr\">name</span>=<span class=\"string\">\"ForegroundImageView\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">attr</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:foreground\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">declare-styleable</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</div><div class=\"line\"><span class=\"keyword\">import</span> android.content.res.TypedArray;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Canvas;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.drawable.Drawable;</div><div class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</div><div class=\"line\"><span class=\"keyword\">import</span> android.widget.ImageView;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForegroundImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImageView</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> Drawable foreground;</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundImageView</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundImageView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\"> </div><div class=\"line\">    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundImageView);</div><div class=\"line\">    Drawable foreground = a.getDrawable(R.styleable.ForegroundImageView_android_foreground);</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      setForeground(foreground);</div><div class=\"line\">    &#125; </div><div class=\"line\">    a.recycle();</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"comment\">/** </div><div class=\"line\">   * Supply a drawable resource that is to be rendered on top of all of the child </div><div class=\"line\">   * views in the frame layout. </div><div class=\"line\">   * </div><div class=\"line\">   * <span class=\"doctag\">@param</span> drawableResId The drawable resource to be drawn on top of the children. </div><div class=\"line\">   */</span> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForegroundResource</span><span class=\"params\">(<span class=\"keyword\">int</span> drawableResId)</span> </span>&#123;</div><div class=\"line\">    setForeground(getContext().getResources().getDrawable(drawableResId));</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"comment\">/** </div><div class=\"line\">   * Supply a Drawable that is to be rendered on top of all of the child </div><div class=\"line\">   * views in the frame layout. </div><div class=\"line\">   * </div><div class=\"line\">   * <span class=\"doctag\">@param</span> drawable The Drawable to be drawn on top of the children. </div><div class=\"line\">   */</span> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForeground</span><span class=\"params\">(Drawable drawable)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground == drawable) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.setCallback(<span class=\"keyword\">null</span>);</div><div class=\"line\">      unscheduleDrawable(foreground);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    foreground = drawable;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (drawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      drawable.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">if</span> (drawable.isStateful()) &#123;</div><div class=\"line\">        drawable.setState(getDrawableState());</div><div class=\"line\">      &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\">    requestLayout();</div><div class=\"line\">    invalidate();</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">verifyDrawable</span><span class=\"params\">(Drawable who)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.verifyDrawable(who) || who == foreground;</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">jumpDrawablesToCurrentState</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">super</span>.jumpDrawablesToCurrentState(); </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) foreground.jumpToCurrentState();</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">drawableStateChanged</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">super</span>.drawableStateChanged(); </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span> &amp;&amp; foreground.isStateful()) &#123;</div><div class=\"line\">      foreground.setState(getDrawableState());</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.setBounds(<span class=\"number\">0</span>, <span class=\"number\">0</span>, getMeasuredWidth(), getMeasuredHeight());</div><div class=\"line\">      invalidate();</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> oldw, <span class=\"keyword\">int</span> oldh)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.setBounds(<span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h);</div><div class=\"line\">      invalidate();</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.draw(canvas);</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.draw(canvas);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>最后，还有人给出据说更好的<a href=\"https://github.com/cesards/ForegroundViews\">解决方案</a><br>没有测试过，不了解</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=TIHXGwRTMWI\">Android themes and styles demisfied</a> 关于Theme和Style的区别的很好的学习资料</li>\n<li><a href=\"https://plus.google.com/108967384991768947849/posts/aHPVDtr6mcp\">Chris Banes G+ post</a> 评论很精彩</li>\n<li><a href=\"https://gist.github.com/shakalaca/6199283\">RelativeLayout with foreGround</a> 没测试过</li>\n<li><a href=\"https://github.com/traex/RippleEffect\">Ripple Effect</a> 将Ripple的动画兼容到API 9+ ，很出色的一个库。之前项目中用过，就是一个继承自RelativeLayout的自定义ViewGroup。</li>\n</ul>\n","excerpt":"<blockquote>\n<p>android:foreground=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>或是</p>\n<blockquote>\n<p>android:background=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>这个xml属性最早是我学着写recyclerVeiw的item xml的时候接触到的，简单来说就是，在API 21及以上，用户点击这个itemView时候会出现一个Ripple效果<br>非常好看，而在API 21以下则会表现为MonoChrome的类似按压色的效果<img src=\"https://cloud.githubusercontent.com/assets/12274855/18787855/2a6d93f2-81d7-11e6-8026-58cdbd8583d4.JPG\" alt=\"\"> </br><br>而这个点击时的水波纹颜色也是可以Customize的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;item name=&quot;android:colorControlHighlight&quot;&gt;@color/my_ripple_color&lt;/item&gt;</div></pre></td></tr></table></figure></p>\n<p>//这个要写在自己的Activity的Theme(style-v21)里，注意，当前Activity的Theme必须继承自Appcompat!!<br>于是，我写了这样的xml<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/item_root\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"?android:attr/listPreferredItemHeight\"</span></div><div class=\"line\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span></div><div class=\"line\">        <span class=\"attr\">android:gravity</span>=<span class=\"string\">\"center\"</span></div><div class=\"line\">        <span class=\"attr\">android:onClick</span>=<span class=\"string\">\"@&#123;(view) -&gt; callback.onClick(view,data)&#125;\"</span></div><div class=\"line\">        <span class=\"attr\">android:elevation</span>=<span class=\"string\">\"2dp\"</span></div><div class=\"line\">        <span class=\"attr\">android:background</span>=<span class=\"string\">\"@color/md_amber_200\"</span></div><div class=\"line\">        <span class=\"attr\">android:foreground</span>=<span class=\"string\">\"?android:attr/selectableItemBackground\"</span></div><div class=\"line\">        /&gt;</span></div></pre></td></tr></table></figure></p>\n<p>然而，点击之后并没有出现水波纹(模拟器 API 21)，换成CardView或是将foreground改为background之后才有效。查了很多博客，最后得出结论:<br>android:foreground在API 23之前只对FrameLayout有效(CardView继承自FrameLayout当然有效)。<br>","more":"</p>\n<p>##所以正确的做法是</p>\n<blockquote>\n<p>android:foreground=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>改为</p>\n<blockquote>\n<p>android:background=”?android:attr/selectableItemBackground”</p>\n</blockquote>\n<p>或者使用FrameLayout。</p>\n<ul>\n<li><p>关于foreground<br>之前看google io2016时，<a href=\"https://github.com/chrisbanes\">Chris Banes</a>给了这样的解释。<br><img src=\"https://cloud.githubusercontent.com/assets/12274855/18787841/1d0b2d82-81d7-11e6-916e-b4113772c3a2.JPG\" alt=\"\">,<br>android:foreground在API 1 的FrameLayout中就有了，但直到API 23才将这个属性添加到View中。<br>所以，换成API 23的手机上面那段代码foreground也是可以出现Ripple的,至于23之前为什么foreground无效，并不清楚为什么</p>\n</li>\n<li><p>首先是一种简单的模拟这种视觉效果的尝试：<a href=\"http://effmx.com/articles/ru-he-chuang-jian-jian-rong-de-foreground-drawable-selectorshi-xian-layoutdian-ji-xiao-guo/\">如何创建兼容的Forefround drawable selector</a> 这篇文章提到了:</p>\n<blockquote>\n<p>简单来讲，Foreground 定义了绘制于当前内容之上的 Drawable，类似一层覆盖物。所以我们可以为设置 Foreground 的值为 drawable或者color， 那如果将 Froeground 设置为 drawable selector，自然就可以为控件实现点击响应效果了。 比较奇怪的是在 sdk 23 以前，foregrond 属性只对 Framelayout 生效，但这个问题现在得到了解决，所以也请确保你的 compileSdkVersion 大于等于23<br>  这篇文章的做法是针对21以下的版本使用slelector Drawable实现类似的效果</p>\n</blockquote>\n</li>\n<li><p>如何真正实现为API23之前的View,ViewGroup添加foreground?<br>随后我找到了<a href=\"https://dzone.com/articles/adding-foreground-selector\">这篇博客</a>，具体的逻辑并不太多。<br>这里插一句，任何Drawable对象，在你调用setDrawable之后，该Drawable都会保留一个最后一个调用对象的callback</p>\n<blockquote>\n<p>Drawable-&gt;View-&gt;Context //leak!<br>//所以Drawable也有可能导致Activity leak</p>\n</blockquote>\n</li>\n<li><p>随后我发现了更多有意思的讨论<br>首先是<a href=\"https://github.com/chrisbanes\">Chris Banes</a>在G+上的Post : <a href=\"https://plus.google.com/+ChrisBanes/posts/DRerZ8wEFuF\">Foreground Doge</a><br>他给出了两种方案,Chris作为Google员工，给出的解决方案应该是比较官方的了</p>\n</li>\n</ul>\n<ol>\n<li>如果想利用FrameLayout的foreground特性来实现点击特效的话，完全可以在自己的xml外面再包裹一层FrameLayout</li>\n<li>自己动手写一个实现foreground的Viewgroup , <a href=\"https://gist.github.com/chrisbanes/9091754\">代码</a></li>\n</ol>\n<ul>\n<li>attrs:<figure class=\"highlight plain\"><figcaption><span>version=\"1.0\" encoding=\"utf-8\"?></span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;declare-styleable name=&quot;ForegroundLinearLayout&quot;&gt;</div><div class=\"line\">        &lt;attr name=&quot;android:foreground&quot; /&gt;</div><div class=\"line\">        &lt;attr name=&quot;android:foregroundInsidePadding&quot; /&gt;</div><div class=\"line\">        &lt;attr name=&quot;android:foregroundGravity&quot; /&gt;</div><div class=\"line\">    &lt;/declare-styleable&gt;</div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* </div><div class=\"line\"> * Copyright (C) 2006 The Android Open Source Project </div><div class=\"line\"> * </div><div class=\"line\"> * Licensed under the Apache License, Version 2.0 (the \"License\"); </div><div class=\"line\"> * you may not use this file except in compliance with the License. </div><div class=\"line\"> * You may obtain a copy of the License at </div><div class=\"line\"> * </div><div class=\"line\"> *      http://www.apache.org/licenses/LICENSE-2.0 </div><div class=\"line\"> * </div><div class=\"line\"> * Unless required by applicable law or agreed to in writing, software </div><div class=\"line\"> * distributed under the License is distributed on an \"AS IS\" BASIS, </div><div class=\"line\"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. </div><div class=\"line\"> * See the License for the specific language governing permissions and </div><div class=\"line\"> * limitations under the License. </div><div class=\"line\"> */</span> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">package</span> your.<span class=\"keyword\">package</span>; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</div><div class=\"line\"><span class=\"keyword\">import</span> android.content.res.TypedArray;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Canvas;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Rect;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.drawable.Drawable;</div><div class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</div><div class=\"line\"><span class=\"keyword\">import</span> android.view.Gravity;</div><div class=\"line\"><span class=\"keyword\">import</span> android.widget.LinearLayout;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> your.<span class=\"keyword\">package</span>.R; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForegroundLinearLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">private</span> Drawable mForeground;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Rect mSelfBounds = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Rect mOverlayBounds = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mForegroundGravity = Gravity.FILL;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> mForegroundInPadding = <span class=\"keyword\">true</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">boolean</span> mForegroundBoundsChanged = <span class=\"keyword\">false</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundLinearLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundLinearLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(context, attrs, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundLinearLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyle)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyle);</div><div class=\"line\"> </div><div class=\"line\">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundLinearLayout,</div><div class=\"line\">                defStyle, <span class=\"number\">0</span>);</div><div class=\"line\"> </div><div class=\"line\">        mForegroundGravity = a.getInt(</div><div class=\"line\">                R.styleable.ForegroundLinearLayout_android_foregroundGravity, mForegroundGravity);</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">final</span> Drawable d = a.getDrawable(R.styleable.ForegroundLinearLayout_android_foreground);</div><div class=\"line\">        <span class=\"keyword\">if</span> (d != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            setForeground(d);</div><div class=\"line\">        &#125; </div><div class=\"line\"> </div><div class=\"line\">        mForegroundInPadding = a.getBoolean(</div><div class=\"line\">                R.styleable.ForegroundLinearLayout_android_foregroundInsidePadding, <span class=\"keyword\">true</span>);</div><div class=\"line\"> </div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Describes how the foreground is positioned. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@return</span> foreground gravity. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@see</span> #setForegroundGravity(int) </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getForegroundGravity</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> mForegroundGravity;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Describes how the foreground is positioned. Defaults to START and TOP. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@param</span> foregroundGravity See &#123;<span class=\"doctag\">@link</span> android.view.Gravity&#125; </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@see</span> #getForegroundGravity() </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForegroundGravity</span><span class=\"params\">(<span class=\"keyword\">int</span> foregroundGravity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mForegroundGravity != foregroundGravity) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((foregroundGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                foregroundGravity |= Gravity.START;</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> ((foregroundGravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                foregroundGravity |= Gravity.TOP;</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            mForegroundGravity = foregroundGravity;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (mForegroundGravity == Gravity.FILL &amp;&amp; mForeground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                Rect padding = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\">                mForeground.getPadding(padding);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            requestLayout();</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">verifyDrawable</span><span class=\"params\">(Drawable who)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.verifyDrawable(who) || (who == mForeground);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">jumpDrawablesToCurrentState</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">super</span>.jumpDrawablesToCurrentState(); </div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span>) mForeground.jumpToCurrentState();</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">drawableStateChanged</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">        <span class=\"keyword\">super</span>.drawableStateChanged(); </div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span> &amp;&amp; mForeground.isStateful()) &#123;</div><div class=\"line\">            mForeground.setState(getDrawableState());</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Supply a Drawable that is to be rendered on top of all of the child </div><div class=\"line\">     * views in the frame layout.  Any padding in the Drawable will be taken </div><div class=\"line\">     * into account by ensuring that the children are inset to be placed </div><div class=\"line\">     * inside of the padding area. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@param</span> drawable The Drawable to be drawn on top of the children. </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForeground</span><span class=\"params\">(Drawable drawable)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != drawable) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                mForeground.setCallback(<span class=\"keyword\">null</span>);</div><div class=\"line\">                unscheduleDrawable(mForeground);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            mForeground = drawable;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (drawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                setWillNotDraw(<span class=\"keyword\">false</span>);</div><div class=\"line\">                drawable.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (drawable.isStateful()) &#123;</div><div class=\"line\">                    drawable.setState(getDrawableState());</div><div class=\"line\">                &#125; </div><div class=\"line\">                <span class=\"keyword\">if</span> (mForegroundGravity == Gravity.FILL) &#123;</div><div class=\"line\">                    Rect padding = <span class=\"keyword\">new</span> Rect();</div><div class=\"line\">                    drawable.getPadding(padding);</div><div class=\"line\">                &#125; </div><div class=\"line\">            &#125;  <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">                setWillNotDraw(<span class=\"keyword\">true</span>);</div><div class=\"line\">            &#125; </div><div class=\"line\">            requestLayout();</div><div class=\"line\">            invalidate();</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/** </div><div class=\"line\">     * Returns the drawable used as the foreground of this FrameLayout. The </div><div class=\"line\">     * foreground drawable, if non-null, is always drawn on top of the children. </div><div class=\"line\">     * </div><div class=\"line\">     * <span class=\"doctag\">@return</span> A Drawable or null if no foreground was set. </div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Drawable <span class=\"title\">getForeground</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mForeground;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onLayout(changed, left, top, right, bottom);</div><div class=\"line\">        mForegroundBoundsChanged = changed;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> oldw, <span class=\"keyword\">int</span> oldh)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class=\"line\">        mForegroundBoundsChanged = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.draw(canvas);</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">if</span> (mForeground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> Drawable foreground = mForeground;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (mForegroundBoundsChanged) &#123;</div><div class=\"line\">                mForegroundBoundsChanged = <span class=\"keyword\">false</span>;</div><div class=\"line\">                <span class=\"keyword\">final</span> Rect selfBounds = mSelfBounds;</div><div class=\"line\">                <span class=\"keyword\">final</span> Rect overlayBounds = mOverlayBounds;</div><div class=\"line\"> </div><div class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> w = getRight() - getLeft();</div><div class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> h = getBottom() - getTop();</div><div class=\"line\"> </div><div class=\"line\">                <span class=\"keyword\">if</span> (mForegroundInPadding) &#123;</div><div class=\"line\">                    selfBounds.set(<span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">                    selfBounds.set(getPaddingLeft(), getPaddingTop(),</div><div class=\"line\">                            w - getPaddingRight(), h - getPaddingBottom());</div><div class=\"line\">                &#125; </div><div class=\"line\"> </div><div class=\"line\">                Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(),</div><div class=\"line\">                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds);</div><div class=\"line\">                foreground.setBounds(overlayBounds);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            foreground.draw(canvas);</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">your.package.ForegroundLinearLayout</span></div><div class=\"line\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">    <span class=\"attr\">android:foreground</span>=<span class=\"string\">\"?android:selectableItemBackground\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ImageView</span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">”@+id/imageview_opaque”</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">    ... other views ...</div><div class=\"line\">/&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>接着是<a href=\"https://github.com/JakeWharton\">Jack Wharton</a>的<a href=\"https://gist.github.com/JakeWharton/0a251d67649305d84e8a\">ForegroundImageView</a></br></p>\n</li>\n<li><p>attrs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">declare-styleable</span> <span class=\"attr\">name</span>=<span class=\"string\">\"ForegroundImageView\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">attr</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:foreground\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">declare-styleable</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</div><div class=\"line\"><span class=\"keyword\">import</span> android.content.res.TypedArray;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Canvas;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.drawable.Drawable;</div><div class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</div><div class=\"line\"><span class=\"keyword\">import</span> android.widget.ImageView;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForegroundImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImageView</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> Drawable foreground;</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundImageView</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForegroundImageView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\"> </div><div class=\"line\">    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ForegroundImageView);</div><div class=\"line\">    Drawable foreground = a.getDrawable(R.styleable.ForegroundImageView_android_foreground);</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      setForeground(foreground);</div><div class=\"line\">    &#125; </div><div class=\"line\">    a.recycle();</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"comment\">/** </div><div class=\"line\">   * Supply a drawable resource that is to be rendered on top of all of the child </div><div class=\"line\">   * views in the frame layout. </div><div class=\"line\">   * </div><div class=\"line\">   * <span class=\"doctag\">@param</span> drawableResId The drawable resource to be drawn on top of the children. </div><div class=\"line\">   */</span> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForegroundResource</span><span class=\"params\">(<span class=\"keyword\">int</span> drawableResId)</span> </span>&#123;</div><div class=\"line\">    setForeground(getContext().getResources().getDrawable(drawableResId));</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"comment\">/** </div><div class=\"line\">   * Supply a Drawable that is to be rendered on top of all of the child </div><div class=\"line\">   * views in the frame layout. </div><div class=\"line\">   * </div><div class=\"line\">   * <span class=\"doctag\">@param</span> drawable The Drawable to be drawn on top of the children. </div><div class=\"line\">   */</span> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForeground</span><span class=\"params\">(Drawable drawable)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground == drawable) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.setCallback(<span class=\"keyword\">null</span>);</div><div class=\"line\">      unscheduleDrawable(foreground);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    foreground = drawable;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (drawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      drawable.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">if</span> (drawable.isStateful()) &#123;</div><div class=\"line\">        drawable.setState(getDrawableState());</div><div class=\"line\">      &#125; </div><div class=\"line\">    &#125; </div><div class=\"line\">    requestLayout();</div><div class=\"line\">    invalidate();</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">verifyDrawable</span><span class=\"params\">(Drawable who)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.verifyDrawable(who) || who == foreground;</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">jumpDrawablesToCurrentState</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">super</span>.jumpDrawablesToCurrentState(); </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) foreground.jumpToCurrentState();</div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">drawableStateChanged</span><span class=\"params\">()</span> </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">super</span>.drawableStateChanged(); </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span> &amp;&amp; foreground.isStateful()) &#123;</div><div class=\"line\">      foreground.setState(getDrawableState());</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.setBounds(<span class=\"number\">0</span>, <span class=\"number\">0</span>, getMeasuredWidth(), getMeasuredHeight());</div><div class=\"line\">      invalidate();</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> oldw, <span class=\"keyword\">int</span> oldh)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.setBounds(<span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h);</div><div class=\"line\">      invalidate();</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\"> </div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.draw(canvas);</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (foreground != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      foreground.draw(canvas);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>最后，还有人给出据说更好的<a href=\"https://github.com/cesards/ForegroundViews\">解决方案</a><br>没有测试过，不了解</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=TIHXGwRTMWI\">Android themes and styles demisfied</a> 关于Theme和Style的区别的很好的学习资料</li>\n<li><a href=\"https://plus.google.com/108967384991768947849/posts/aHPVDtr6mcp\">Chris Banes G+ post</a> 评论很精彩</li>\n<li><a href=\"https://gist.github.com/shakalaca/6199283\">RelativeLayout with foreGround</a> 没测试过</li>\n<li><a href=\"https://github.com/traex/RippleEffect\">Ripple Effect</a> 将Ripple的动画兼容到API 9+ ，很出色的一个库。之前项目中用过，就是一个继承自RelativeLayout的自定义ViewGroup。</li>\n</ul>"},{"title":"Theme和Style的区别","date":"2016-10-10T11:35:32.000Z","_content":"\n\n\n认识Theme和Styles\n\n重新看一遍Using Themes and styles without going crazy，大部分属于直接翻译\n\n## 1. Styles\n\n### 1.1 首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\n\n```xml\n<View android:background= \"#ff0000\" />\n```\n\n变成\n\n```xml\n<View style= \"@Style/MyStyle\" />\n\n<Style name = \"MyStyle\">\n\t<item name = \"android:background\">#ff0000</item>\n</Style>\n```\n\n这种形式，对于大量的具有相同属性的且具有*共性*的View，可以直接使用对应的Style，这能够让layout文件更加整洁。前提是确信layout文件中使用的View具有相同的属性。\n\n<!--more-->\n\n### 1.2 Style Inheritance\n\nStyle可以继承，两种方式：\n\n假设有parent style ，一种在name中使用前缀的方式指明parent，另一种在后面显式的声明parent\n\n```xml\n<style name = \"Parent\"/>\n```\n\nExplicit child\n\n```xml\n<style name = \"Child\" parent = \"Parent\">\n```\n\n  Implicit Child\n\n```xml\n<style name = \"Parent.Child\"/>\n```\n\n同时使用两种方式时，默认使用Explicit Parent  \n\n为避免混淆，推荐使用Explicit Child且Child name不带前缀  \n\nView不能拥有两个Style,除了TextView及其子类，例如\n\n```xml\n<TextView>\n  android:textColor = \"#ffffff\"\n\tstyle=\"@style/SomeStyle\"\n  android:textAppearance = \"@style/MyText\"\n</TextView>\n```\n\n如上所示，TextView中可以定义TextAppearance，后者包含了常见的textColor，textSize等attributes，而在一个View中可以同时定义两个Style。如果出现冲突，styles之间相同attributes的应用优先级为：\n\n> android:textColor >> SomeStyle中的android:textColor>>MyText中的android:textColor\n\n> 使用TextAppearance 时一定要有一个parent\n\n```xml\n<style name = \"MyText\" parent=\"TextAppearance.Appcompat\">\n\t<item name = \"android:TextColor\">#F08</item>\n</style>\n```\n\n因为使用style时，系统将把style中定义的attribute和当前View的默认attribute融合起来，而TextView默认attribute 中什么也没有，造成textSize = 0的情况，所以务必选择parent，在parent style已经定义好大多数属性的情况下再去修改小部分属性将简单得多。TextAppearance可以在Theme中定义，也可以写在单一的TextView上。\n\n## 2. Themes\n  在Android中，Theme名字以\"Theme.\"开头，查看源码会发现只是定义了一大堆color attributes 和Window attributes。Themes比Styles的作用范围更广，themes可以在Application,Activity层面管理Widget外观，Theme还可以实现夜间模式切换\n\n  来看如何定义一个Theme\n\n  ```xml\n  <style name = \"Theme\">\n  \t<item name = android:statusBarColor>#ff0000</item>\n  </style>\n  ```\n\n  回头看一下Style\n\n  ```xml\n  <Style name = \"Style\">\n  \t<item name = \"android:background\">#ff0000</item>\n  </Style>\n  ```\n\n  语法看起来完全一样。\n\n  区别：styles中的属性被直接送到View的构造函数中，记得在自定义View时写的那些attrs吗，其实就是两个参数的构造函数中的AttributeSets\n\n  Theme应用范围更广，定义的属性和Style也不尽相同。\n\n  两者之间有一些联系：例如Theme中可以定义default widget style，Style可以引用Theme中定义的属性(?attr:selectableItemBackground还记得吗)\n  上面提到了Theme中可以定义default widget style，具体做法无非就是这样:\n\n  ```xml\n  <style name= \"MyTheme\" parent=\"Theme.AppCompat.Light\">\n    <item name=\"android:editTextStyle\">@style/MyEditTextStyle</item>\n  </style>\n  ```\n  所以，只要在AppTheme中点进去，找一下这个键对应的值就可以了\n\n\n### 2.1 使用Theme\n\n  两种方式:\n\n  1.在Manifest中，例如\n\n```xml\n  <application\n    android:theme=\"@style/Theme.AppCompat\" />\n\n  或者\n  <activity\n    android:theme=\"@style/Theme.AppCompat.Light\"        />\n```\n\n  activty中Theme override Application的Theme\n\n  2. 应用于View\n\n  Lollipop开始引入View Theming的概念\n\n```xml\n  <Toolbar\n     android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"\n     app:popupTheme=\"@style/ThemeOverlay.AppCompa.Light\"/>      \n```\n\n  应用在View上的Theme将能够作用在该View及其所有的Children，这样做的好处在于没有必要专门为了一个View而去选择其他的Theme。\n\n  例如在Holo中有Holo.Light.DarkActionBar，为了专门适配ActionBar需要一个专门的Theme。目前看来主要应用在Toolbar上。\n\n## 3 .墙裂推荐使用AppCompat\n\n  好处:\n\n- Material on all devices ,记得以前听说AppCompat在21以上继承自Theme.Material。\n- Baseline themes/styles AppCompat 预设了一系列样式标准，只需要继承AppCompat，改动一小部分样式就能完成设计\n    - Enable View theming pre-Lollipop\n    - 使用ColorPrimary , ColorAccent等attributes(backPorted by AppCompat)设置Widget样式\n    - 在Theme中可以定义默认的Widget样式，例如\n\n```xml\n<style name=\"AppTheme\" parent = \"Theme.AppCompat\">\n<item name=\"android:spinnerItemStyle\">@sytle/MySpinnerStyle</item>\n</style>\n```\n\n还可以更改默认样式：\n\n```xml\n<style name = \"AttrTheme\" parent =\"Theme.AppCompat\">\n<item name =\"selectableItemBackground\">@drawable/bg</item>\n</style>\n<Button android:background=?attr/selectableItemBackground\"/>\n```\n这样就可以自定义点击时的Drawable了。\n\n- 支持android:theme: API 7+(只应用于该View)，API 11+(View及其子View)\n\nView theming原本只是API 21才引入的概念，AppCompat实现了向前兼容\n\n\n## 4 .  ?attr的问题\n\n> ?android:attr/selectableItemBackground\n\n一个个来解释：\n\n?  :  we're doing a theme lookup\n\nandroid:  we’re looking up something within the android namespace\n\nattr/  : we're looking for an attribute(可省略)\n\nselectableItemBackground: The name of the atribute we're looking up\n\n把attr/省略掉后变成\n\n> ?android:selectableItemBackground\n\n效果完全一样\n\n```xml\n<style name=\"MyTheme\">\n\t<item name = \"android:colorPrimary\">@color/red</item>\n</style>\n```\n\n问题在于android:ColorPromary是Lollipop才引入的，解决方案\n\n```xml\n<syle name = \"MyTheme\" parent=\"Theme.AppCompat\">\n\t<item name = \"colorPrimary\">@color/red</item>\n</syle>\n```\n\n注意这里没有android: 前缀，AppCompat针对API21之前的版本定义了自己的一套资源。\n\n再举个例子\n\n```xml\n在values/attrs.xml中\n<attr name:\"myAttribute\" format=\"dimension\"/>\n\n在values/themes.xml中\n<style name = \"MyTheme\" parent = \"Theme.AppCompat\">\n\t<item name=\"myAttribute\">4dp</item>  这就是实际使用的Theme\n</style>\n\n在values/styles.xml中\n<style name=\"MyStyle\">\n\t<item name=\"android:padding\">?attr/myAttribute</item>\n</style>\n\n实际操作中\n在layout文件中，通过将一个长度，颜色定义为?attr的方式，就会去当前的Theme中寻找相对应的attribute，这就是黑夜模式切换的原理\n```\n\n要注意的是，所有非android nameSpace的attribute Name都是global的，所以如果两个library定义了相同的attribute Name，将无法编译通过。\n\nStyle可以通过?attr的方式引用Theme中的资源\n\n\n\n## 5 .获取Theme\n\n```java\ncontext.getTheme().resolveAttribute(R.attr.dialogTheme,outValue,true)\n\n在View中\n  TypedArray a = context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.ImageView,defStyleAttr,defStyleRes)\n\nint alpha = a.getInt(\n  com.android.internal.R.styleable.ImageView_drawableAlpha,255)   \n```\n\nActivity有一个setTheme(int themeResId)方法，注意，这个方法并不是取代原先的Theme,只是在原有的Theme上apply了。所以这个命名不算太好。Activity内部会在onCreate()前调用setTheme(你写在manifest里面的Theme)\n\n\n\n## 6. v21的问题\n\n```xml\n在values/styles.xml中\n<style name=\"BaseToolbar\"/>\n\n在values-v21/styles.xml中\n<style name= \"BaseToolbar\">\n\t<item name = \"android:elevation\">4dp</item>\n</style>\nelevation是21以上api才有的属性，lint会提示问题\n这样，在values/styles.xml中\n<style name = \"Toolbar\" parent = \"BaseToolbar\"/>\nlint就不会飙黄了，直接引用Toolbar即可\n```\n\n通过这种继承的方式能够在自己的Theme中使用统一的theme，针对不同的运行时版本确定最终运行的Theme。\n\n## 7 . ThemeOverlay\n\n```JAVA\nThemeOverlay.Material.Light\nThemeOverlay.Material.Dark\n//etc ...   \n```\n\n用于添加到现有的Theme上，例如Theme.Material.Light只包含color relevant to a light Theme，不会改变原有Theme的window Attributes。查看源码，只是完整的Theme中的一小部分attribute。\n\n## 8. 常见错误\n\n1. 作为Theme中引用的style必须要有一个parent\n\n例如\n```xml\n在AppTheme中\n<item name = \"android:editTextStyle\">@style/MyEditTextStyle</item>\n\n<style name= \"MyEditTextStyle\">\n\t<item name= \"android:fontFamily\">\n  sans-serif-medium\n  </item>\n</style>\n```\n这样做的结果将是所有的EditText都会失去基本的属性\n\n2. defStyleAttr vs defStyleRes\n\n常见于\n\n```java\nObtainStyledAttributes(AttributeSet set,int []attrs,\n int defStyleAttr,int defStyleRes)\n```\n\n直接解释：\n\n>  defStyleAttr: The attr in your theme which points to the default style\n>\n>  eg: R.attr.editTextStyle\n>\n>  defStyleRes: The resource ID of the default style\n>\n>  eg:R.style.Widget_Material_EditText\n\nObtainStyledAttributes查找Value时读取的顺序如下\n\n```java\n1. Value in the AttributeSet\n2. Value in the explicit style\n3. Default style specified in defStyleRes\n4. Default style specified in defStyleAttr\n5. Base value in this theme     \n```\n注意最后一条，万一在manifests文件中出现这种东西\n\n```xml\n<Style name = \"AppTheme\" parent = \"Theme.AppCompat\">\n\t<item name = \"android:background\">...</item>\n</Style>\n```\n\n这意味着\n\n> Any View which doesn't have a background set ,will use the theme's value ,  SHIT!\n\n\n\n\n## 9. 容易遇到的错误\n编译不通过的情况\n```java\nError retrieving parent for item: No resource found that matches the given name\n '@android:style/TextAppearance.Holo.Widget.ActionBar.Title'\n```\n\n\n\n## 10. 最后，一点好玩的\n\n```java\nContext themedContext =\n  new ContextThemeWrapper(baseContext,R.style.MyTheme);\n\nView view = LayoutInflator.form(themedContext)\n  \t\t.inflate(R.layout.some_layout,null);\n//或者\nView view = new View(themedContext);\n//生成的View就会带有MyTheme中的属性，动态设置。\n```\n\n而这也是AppComPat对于API 21以下版本进行兼容的原理\n翻了一下文档：\nContextThemeWrapper : Added in API level 1\n\n这一点AppCompat的作者也在2014年的一篇 [博客](https://chris.banes.me/2014/11/12/theme-vs-style/)中提到了。\n\n## reference\n\n- [Daniel Lew](https://www.youtube.com/watch?v=Jr8hJdVGHAk)\n- [View Constructor](http://blog.danlew.net/2016/07/19/a-deep-dive-into-android-view-constructors/)\n- [IO 2016](https://www.youtube.com/watch?v=TIHXGwRTMWI)\n","source":"_posts/theme-versus-style.md","raw":"---\ntitle: Theme和Style的区别\ndate: 2016-10-10 19:35:32\ncategories: blog\ntags: [android]\n---\n\n\n\n认识Theme和Styles\n\n重新看一遍Using Themes and styles without going crazy，大部分属于直接翻译\n\n## 1. Styles\n\n### 1.1 首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\n\n```xml\n<View android:background= \"#ff0000\" />\n```\n\n变成\n\n```xml\n<View style= \"@Style/MyStyle\" />\n\n<Style name = \"MyStyle\">\n\t<item name = \"android:background\">#ff0000</item>\n</Style>\n```\n\n这种形式，对于大量的具有相同属性的且具有*共性*的View，可以直接使用对应的Style，这能够让layout文件更加整洁。前提是确信layout文件中使用的View具有相同的属性。\n\n<!--more-->\n\n### 1.2 Style Inheritance\n\nStyle可以继承，两种方式：\n\n假设有parent style ，一种在name中使用前缀的方式指明parent，另一种在后面显式的声明parent\n\n```xml\n<style name = \"Parent\"/>\n```\n\nExplicit child\n\n```xml\n<style name = \"Child\" parent = \"Parent\">\n```\n\n  Implicit Child\n\n```xml\n<style name = \"Parent.Child\"/>\n```\n\n同时使用两种方式时，默认使用Explicit Parent  \n\n为避免混淆，推荐使用Explicit Child且Child name不带前缀  \n\nView不能拥有两个Style,除了TextView及其子类，例如\n\n```xml\n<TextView>\n  android:textColor = \"#ffffff\"\n\tstyle=\"@style/SomeStyle\"\n  android:textAppearance = \"@style/MyText\"\n</TextView>\n```\n\n如上所示，TextView中可以定义TextAppearance，后者包含了常见的textColor，textSize等attributes，而在一个View中可以同时定义两个Style。如果出现冲突，styles之间相同attributes的应用优先级为：\n\n> android:textColor >> SomeStyle中的android:textColor>>MyText中的android:textColor\n\n> 使用TextAppearance 时一定要有一个parent\n\n```xml\n<style name = \"MyText\" parent=\"TextAppearance.Appcompat\">\n\t<item name = \"android:TextColor\">#F08</item>\n</style>\n```\n\n因为使用style时，系统将把style中定义的attribute和当前View的默认attribute融合起来，而TextView默认attribute 中什么也没有，造成textSize = 0的情况，所以务必选择parent，在parent style已经定义好大多数属性的情况下再去修改小部分属性将简单得多。TextAppearance可以在Theme中定义，也可以写在单一的TextView上。\n\n## 2. Themes\n  在Android中，Theme名字以\"Theme.\"开头，查看源码会发现只是定义了一大堆color attributes 和Window attributes。Themes比Styles的作用范围更广，themes可以在Application,Activity层面管理Widget外观，Theme还可以实现夜间模式切换\n\n  来看如何定义一个Theme\n\n  ```xml\n  <style name = \"Theme\">\n  \t<item name = android:statusBarColor>#ff0000</item>\n  </style>\n  ```\n\n  回头看一下Style\n\n  ```xml\n  <Style name = \"Style\">\n  \t<item name = \"android:background\">#ff0000</item>\n  </Style>\n  ```\n\n  语法看起来完全一样。\n\n  区别：styles中的属性被直接送到View的构造函数中，记得在自定义View时写的那些attrs吗，其实就是两个参数的构造函数中的AttributeSets\n\n  Theme应用范围更广，定义的属性和Style也不尽相同。\n\n  两者之间有一些联系：例如Theme中可以定义default widget style，Style可以引用Theme中定义的属性(?attr:selectableItemBackground还记得吗)\n  上面提到了Theme中可以定义default widget style，具体做法无非就是这样:\n\n  ```xml\n  <style name= \"MyTheme\" parent=\"Theme.AppCompat.Light\">\n    <item name=\"android:editTextStyle\">@style/MyEditTextStyle</item>\n  </style>\n  ```\n  所以，只要在AppTheme中点进去，找一下这个键对应的值就可以了\n\n\n### 2.1 使用Theme\n\n  两种方式:\n\n  1.在Manifest中，例如\n\n```xml\n  <application\n    android:theme=\"@style/Theme.AppCompat\" />\n\n  或者\n  <activity\n    android:theme=\"@style/Theme.AppCompat.Light\"        />\n```\n\n  activty中Theme override Application的Theme\n\n  2. 应用于View\n\n  Lollipop开始引入View Theming的概念\n\n```xml\n  <Toolbar\n     android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"\n     app:popupTheme=\"@style/ThemeOverlay.AppCompa.Light\"/>      \n```\n\n  应用在View上的Theme将能够作用在该View及其所有的Children，这样做的好处在于没有必要专门为了一个View而去选择其他的Theme。\n\n  例如在Holo中有Holo.Light.DarkActionBar，为了专门适配ActionBar需要一个专门的Theme。目前看来主要应用在Toolbar上。\n\n## 3 .墙裂推荐使用AppCompat\n\n  好处:\n\n- Material on all devices ,记得以前听说AppCompat在21以上继承自Theme.Material。\n- Baseline themes/styles AppCompat 预设了一系列样式标准，只需要继承AppCompat，改动一小部分样式就能完成设计\n    - Enable View theming pre-Lollipop\n    - 使用ColorPrimary , ColorAccent等attributes(backPorted by AppCompat)设置Widget样式\n    - 在Theme中可以定义默认的Widget样式，例如\n\n```xml\n<style name=\"AppTheme\" parent = \"Theme.AppCompat\">\n<item name=\"android:spinnerItemStyle\">@sytle/MySpinnerStyle</item>\n</style>\n```\n\n还可以更改默认样式：\n\n```xml\n<style name = \"AttrTheme\" parent =\"Theme.AppCompat\">\n<item name =\"selectableItemBackground\">@drawable/bg</item>\n</style>\n<Button android:background=?attr/selectableItemBackground\"/>\n```\n这样就可以自定义点击时的Drawable了。\n\n- 支持android:theme: API 7+(只应用于该View)，API 11+(View及其子View)\n\nView theming原本只是API 21才引入的概念，AppCompat实现了向前兼容\n\n\n## 4 .  ?attr的问题\n\n> ?android:attr/selectableItemBackground\n\n一个个来解释：\n\n?  :  we're doing a theme lookup\n\nandroid:  we’re looking up something within the android namespace\n\nattr/  : we're looking for an attribute(可省略)\n\nselectableItemBackground: The name of the atribute we're looking up\n\n把attr/省略掉后变成\n\n> ?android:selectableItemBackground\n\n效果完全一样\n\n```xml\n<style name=\"MyTheme\">\n\t<item name = \"android:colorPrimary\">@color/red</item>\n</style>\n```\n\n问题在于android:ColorPromary是Lollipop才引入的，解决方案\n\n```xml\n<syle name = \"MyTheme\" parent=\"Theme.AppCompat\">\n\t<item name = \"colorPrimary\">@color/red</item>\n</syle>\n```\n\n注意这里没有android: 前缀，AppCompat针对API21之前的版本定义了自己的一套资源。\n\n再举个例子\n\n```xml\n在values/attrs.xml中\n<attr name:\"myAttribute\" format=\"dimension\"/>\n\n在values/themes.xml中\n<style name = \"MyTheme\" parent = \"Theme.AppCompat\">\n\t<item name=\"myAttribute\">4dp</item>  这就是实际使用的Theme\n</style>\n\n在values/styles.xml中\n<style name=\"MyStyle\">\n\t<item name=\"android:padding\">?attr/myAttribute</item>\n</style>\n\n实际操作中\n在layout文件中，通过将一个长度，颜色定义为?attr的方式，就会去当前的Theme中寻找相对应的attribute，这就是黑夜模式切换的原理\n```\n\n要注意的是，所有非android nameSpace的attribute Name都是global的，所以如果两个library定义了相同的attribute Name，将无法编译通过。\n\nStyle可以通过?attr的方式引用Theme中的资源\n\n\n\n## 5 .获取Theme\n\n```java\ncontext.getTheme().resolveAttribute(R.attr.dialogTheme,outValue,true)\n\n在View中\n  TypedArray a = context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.ImageView,defStyleAttr,defStyleRes)\n\nint alpha = a.getInt(\n  com.android.internal.R.styleable.ImageView_drawableAlpha,255)   \n```\n\nActivity有一个setTheme(int themeResId)方法，注意，这个方法并不是取代原先的Theme,只是在原有的Theme上apply了。所以这个命名不算太好。Activity内部会在onCreate()前调用setTheme(你写在manifest里面的Theme)\n\n\n\n## 6. v21的问题\n\n```xml\n在values/styles.xml中\n<style name=\"BaseToolbar\"/>\n\n在values-v21/styles.xml中\n<style name= \"BaseToolbar\">\n\t<item name = \"android:elevation\">4dp</item>\n</style>\nelevation是21以上api才有的属性，lint会提示问题\n这样，在values/styles.xml中\n<style name = \"Toolbar\" parent = \"BaseToolbar\"/>\nlint就不会飙黄了，直接引用Toolbar即可\n```\n\n通过这种继承的方式能够在自己的Theme中使用统一的theme，针对不同的运行时版本确定最终运行的Theme。\n\n## 7 . ThemeOverlay\n\n```JAVA\nThemeOverlay.Material.Light\nThemeOverlay.Material.Dark\n//etc ...   \n```\n\n用于添加到现有的Theme上，例如Theme.Material.Light只包含color relevant to a light Theme，不会改变原有Theme的window Attributes。查看源码，只是完整的Theme中的一小部分attribute。\n\n## 8. 常见错误\n\n1. 作为Theme中引用的style必须要有一个parent\n\n例如\n```xml\n在AppTheme中\n<item name = \"android:editTextStyle\">@style/MyEditTextStyle</item>\n\n<style name= \"MyEditTextStyle\">\n\t<item name= \"android:fontFamily\">\n  sans-serif-medium\n  </item>\n</style>\n```\n这样做的结果将是所有的EditText都会失去基本的属性\n\n2. defStyleAttr vs defStyleRes\n\n常见于\n\n```java\nObtainStyledAttributes(AttributeSet set,int []attrs,\n int defStyleAttr,int defStyleRes)\n```\n\n直接解释：\n\n>  defStyleAttr: The attr in your theme which points to the default style\n>\n>  eg: R.attr.editTextStyle\n>\n>  defStyleRes: The resource ID of the default style\n>\n>  eg:R.style.Widget_Material_EditText\n\nObtainStyledAttributes查找Value时读取的顺序如下\n\n```java\n1. Value in the AttributeSet\n2. Value in the explicit style\n3. Default style specified in defStyleRes\n4. Default style specified in defStyleAttr\n5. Base value in this theme     \n```\n注意最后一条，万一在manifests文件中出现这种东西\n\n```xml\n<Style name = \"AppTheme\" parent = \"Theme.AppCompat\">\n\t<item name = \"android:background\">...</item>\n</Style>\n```\n\n这意味着\n\n> Any View which doesn't have a background set ,will use the theme's value ,  SHIT!\n\n\n\n\n## 9. 容易遇到的错误\n编译不通过的情况\n```java\nError retrieving parent for item: No resource found that matches the given name\n '@android:style/TextAppearance.Holo.Widget.ActionBar.Title'\n```\n\n\n\n## 10. 最后，一点好玩的\n\n```java\nContext themedContext =\n  new ContextThemeWrapper(baseContext,R.style.MyTheme);\n\nView view = LayoutInflator.form(themedContext)\n  \t\t.inflate(R.layout.some_layout,null);\n//或者\nView view = new View(themedContext);\n//生成的View就会带有MyTheme中的属性，动态设置。\n```\n\n而这也是AppComPat对于API 21以下版本进行兼容的原理\n翻了一下文档：\nContextThemeWrapper : Added in API level 1\n\n这一点AppCompat的作者也在2014年的一篇 [博客](https://chris.banes.me/2014/11/12/theme-vs-style/)中提到了。\n\n## reference\n\n- [Daniel Lew](https://www.youtube.com/watch?v=Jr8hJdVGHAk)\n- [View Constructor](http://blog.danlew.net/2016/07/19/a-deep-dive-into-android-view-constructors/)\n- [IO 2016](https://www.youtube.com/watch?v=TIHXGwRTMWI)\n","slug":"theme-versus-style","published":1,"updated":"2017-07-23T10:43:10.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnm2003obovrm5qeb5xa","content":"<p>认识Theme和Styles</p>\n<p>重新看一遍Using Themes and styles without going crazy，大部分属于直接翻译</p>\n<h2 id=\"1-Styles\"><a href=\"#1-Styles\" class=\"headerlink\" title=\"1. Styles\"></a>1. Styles</h2><h3 id=\"1-1-首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\"><a href=\"#1-1-首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\" class=\"headerlink\" title=\"1.1 首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\"></a>1.1 首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">android:background</span>= <span class=\"string\">\"#ff0000\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p>变成</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>= <span class=\"string\">\"@Style/MyStyle\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyStyle\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:background\"</span>&gt;</span>#ff0000<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">Style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这种形式，对于大量的具有相同属性的且具有<em>共性</em>的View，可以直接使用对应的Style，这能够让layout文件更加整洁。前提是确信layout文件中使用的View具有相同的属性。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-2-Style-Inheritance\"><a href=\"#1-2-Style-Inheritance\" class=\"headerlink\" title=\"1.2 Style Inheritance\"></a>1.2 Style Inheritance</h3><p>Style可以继承，两种方式：</p>\n<p>假设有parent style ，一种在name中使用前缀的方式指明parent，另一种在后面显式的声明parent</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Parent\"</span>/&gt;</span><span class=\"undefined\"></span></div></pre></td></tr></table></figure>\n<p>Explicit child</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Child\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Parent\"</span>&gt;</span><span class=\"undefined\"></span></div></pre></td></tr></table></figure>\n<p>  Implicit Child</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Parent.Child\"</span>/&gt;</span><span class=\"undefined\"></span></div></pre></td></tr></table></figure>\n<p>同时使用两种方式时，默认使用Explicit Parent  </p>\n<p>为避免混淆，推荐使用Explicit Child且Child name不带前缀  </p>\n<p>View不能拥有两个Style,除了TextView及其子类，例如</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span>&gt;</span></div><div class=\"line\">  android:textColor = \"#ffffff\"</div><div class=\"line\">truestyle=\"@style/SomeStyle\"</div><div class=\"line\">  android:textAppearance = \"@style/MyText\"</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">TextView</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如上所示，TextView中可以定义TextAppearance，后者包含了常见的textColor，textSize等attributes，而在一个View中可以同时定义两个Style。如果出现冲突，styles之间相同attributes的应用优先级为：</p>\n<blockquote>\n<p>android:textColor &gt;&gt; SomeStyle中的android:textColor&gt;&gt;MyText中的android:textColor</p>\n<p>使用TextAppearance 时一定要有一个parent</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyText\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"TextAppearance.Appcompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:TextColor\"</span>&gt;</span>#F08<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>因为使用style时，系统将把style中定义的attribute和当前View的默认attribute融合起来，而TextView默认attribute 中什么也没有，造成textSize = 0的情况，所以务必选择parent，在parent style已经定义好大多数属性的情况下再去修改小部分属性将简单得多。TextAppearance可以在Theme中定义，也可以写在单一的TextView上。</p>\n<h2 id=\"2-Themes\"><a href=\"#2-Themes\" class=\"headerlink\" title=\"2. Themes\"></a>2. Themes</h2><p>  在Android中，Theme名字以”Theme.”开头，查看源码会发现只是定义了一大堆color attributes 和Window attributes。Themes比Styles的作用范围更广，themes可以在Application,Activity层面管理Widget外观，Theme还可以实现夜间模式切换</p>\n<p>  来看如何定义一个Theme</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Theme\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">android:statusBarColor</span>&gt;</span>#ff0000<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>  回头看一下Style</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Style\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:background\"</span>&gt;</span>#ff0000<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">Style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>  语法看起来完全一样。</p>\n<p>  区别：styles中的属性被直接送到View的构造函数中，记得在自定义View时写的那些attrs吗，其实就是两个参数的构造函数中的AttributeSets</p>\n<p>  Theme应用范围更广，定义的属性和Style也不尽相同。</p>\n<p>  两者之间有一些联系：例如Theme中可以定义default widget style，Style可以引用Theme中定义的属性(?attr:selectableItemBackground还记得吗)<br>  上面提到了Theme中可以定义default widget style，具体做法无非就是这样:</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>= <span class=\"string\">\"MyTheme\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"Theme.AppCompat.Light\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:editTextStyle\"</span>&gt;</span>@style/MyEditTextStyle<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>  所以，只要在AppTheme中点进去，找一下这个键对应的值就可以了</p>\n<h3 id=\"2-1-使用Theme\"><a href=\"#2-1-使用Theme\" class=\"headerlink\" title=\"2.1 使用Theme\"></a>2.1 使用Theme</h3><p>  两种方式:</p>\n<p>  1.在Manifest中，例如</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">application</span></div><div class=\"line\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/Theme.AppCompat\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">或者</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></div><div class=\"line\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/Theme.AppCompat.Light\"</span>        /&gt;</span></div></pre></td></tr></table></figure>\n<p>  activty中Theme override Application的Theme</p>\n<ol>\n<li><p>应用于View</p>\n<p>Lollipop开始引入View Theming的概念</p>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Toolbar</span></div><div class=\"line\">   <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"</span></div><div class=\"line\">   <span class=\"attr\">app:popupTheme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompa.Light\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>  应用在View上的Theme将能够作用在该View及其所有的Children，这样做的好处在于没有必要专门为了一个View而去选择其他的Theme。</p>\n<p>  例如在Holo中有Holo.Light.DarkActionBar，为了专门适配ActionBar需要一个专门的Theme。目前看来主要应用在Toolbar上。</p>\n<h2 id=\"3-墙裂推荐使用AppCompat\"><a href=\"#3-墙裂推荐使用AppCompat\" class=\"headerlink\" title=\"3 .墙裂推荐使用AppCompat\"></a>3 .墙裂推荐使用AppCompat</h2><p>  好处:</p>\n<ul>\n<li>Material on all devices ,记得以前听说AppCompat在21以上继承自Theme.Material。</li>\n<li>Baseline themes/styles AppCompat 预设了一系列样式标准，只需要继承AppCompat，改动一小部分样式就能完成设计<ul>\n<li>Enable View theming pre-Lollipop</li>\n<li>使用ColorPrimary , ColorAccent等attributes(backPorted by AppCompat)设置Widget样式</li>\n<li>在Theme中可以定义默认的Widget样式，例如</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AppTheme\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:spinnerItemStyle\"</span>&gt;</span>@sytle/MySpinnerStyle<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>还可以更改默认样式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"AttrTheme\"</span> <span class=\"attr\">parent</span> =<span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> =<span class=\"string\">\"selectableItemBackground\"</span>&gt;</span>@drawable/bg<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">android:background</span>=<span class=\"string\">?attr/selectableItemBackground</span>\"/&gt;</span></div></pre></td></tr></table></figure>\n<p>这样就可以自定义点击时的Drawable了。</p>\n<ul>\n<li>支持android:theme: API 7+(只应用于该View)，API 11+(View及其子View)</li>\n</ul>\n<p>View theming原本只是API 21才引入的概念，AppCompat实现了向前兼容</p>\n<h2 id=\"4-attr的问题\"><a href=\"#4-attr的问题\" class=\"headerlink\" title=\"4 .  ?attr的问题\"></a>4 .  ?attr的问题</h2><blockquote>\n<p>?android:attr/selectableItemBackground</p>\n</blockquote>\n<p>一个个来解释：</p>\n<p>?  :  we’re doing a theme lookup</p>\n<p>android:  we’re looking up something within the android namespace</p>\n<p>attr/  : we’re looking for an attribute(可省略)</p>\n<p>selectableItemBackground: The name of the atribute we’re looking up</p>\n<p>把attr/省略掉后变成</p>\n<blockquote>\n<p>?android:selectableItemBackground</p>\n</blockquote>\n<p>效果完全一样</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"MyTheme\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:colorPrimary\"</span>&gt;</span>@color/red<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>问题在于android:ColorPromary是Lollipop才引入的，解决方案</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">syle</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyTheme\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"colorPrimary\"</span>&gt;</span>@color/red<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">syle</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>注意这里没有android: 前缀，AppCompat针对API21之前的版本定义了自己的一套资源。</p>\n<p>再举个例子</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">在values/attrs.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">attr</span> <span class=\"attr\">name:</span>\"<span class=\"attr\">myAttribute</span>\" <span class=\"attr\">format</span>=<span class=\"string\">\"dimension\"</span>/&gt;</span></div><div class=\"line\"></div><div class=\"line\">在values/themes.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyTheme\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myAttribute\"</span>&gt;</span>4dp<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span>  这就是实际使用的Theme</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">在values/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"MyStyle\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:padding\"</span>&gt;</span>?attr/myAttribute<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">实际操作中</div><div class=\"line\">在layout文件中，通过将一个长度，颜色定义为?attr的方式，就会去当前的Theme中寻找相对应的attribute，这就是黑夜模式切换的原理</div></pre></td></tr></table></figure>\n<p>要注意的是，所有非android nameSpace的attribute Name都是global的，所以如果两个library定义了相同的attribute Name，将无法编译通过。</p>\n<p>Style可以通过?attr的方式引用Theme中的资源</p>\n<h2 id=\"5-获取Theme\"><a href=\"#5-获取Theme\" class=\"headerlink\" title=\"5 .获取Theme\"></a>5 .获取Theme</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">context.getTheme().resolveAttribute(R.attr.dialogTheme,outValue,<span class=\"keyword\">true</span>)</div><div class=\"line\"></div><div class=\"line\">在View中</div><div class=\"line\">  TypedArray a = context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.ImageView,defStyleAttr,defStyleRes)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> alpha = a.getInt(</div><div class=\"line\">  com.android.internal.R.styleable.ImageView_drawableAlpha,<span class=\"number\">255</span>)</div></pre></td></tr></table></figure>\n<p>Activity有一个setTheme(int themeResId)方法，注意，这个方法并不是取代原先的Theme,只是在原有的Theme上apply了。所以这个命名不算太好。Activity内部会在onCreate()前调用setTheme(你写在manifest里面的Theme)</p>\n<h2 id=\"6-v21的问题\"><a href=\"#6-v21的问题\" class=\"headerlink\" title=\"6. v21的问题\"></a>6. v21的问题</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">在values/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"BaseToolbar\"</span>/&gt;</span><span class=\"xml\"></div><div class=\"line\"></div><div class=\"line\">在values-v21/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>= <span class=\"string\">\"BaseToolbar\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:elevation\"</span>&gt;</span>4dp<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">elevation是21以上api才有的属性，lint会提示问题</div><div class=\"line\">这样，在values/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Toolbar\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"BaseToolbar\"</span>/&gt;</span><span class=\"undefined\"></div><div class=\"line\">lint就不会飙黄了，直接引用Toolbar即可</span></div></pre></td></tr></table></figure>\n<p>通过这种继承的方式能够在自己的Theme中使用统一的theme，针对不同的运行时版本确定最终运行的Theme。</p>\n<h2 id=\"7-ThemeOverlay\"><a href=\"#7-ThemeOverlay\" class=\"headerlink\" title=\"7 . ThemeOverlay\"></a>7 . ThemeOverlay</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ThemeOverlay.Material.Light</div><div class=\"line\">ThemeOverlay.Material.Dark</div><div class=\"line\"><span class=\"comment\">//etc ...</span></div></pre></td></tr></table></figure>\n<p>用于添加到现有的Theme上，例如Theme.Material.Light只包含color relevant to a light Theme，不会改变原有Theme的window Attributes。查看源码，只是完整的Theme中的一小部分attribute。</p>\n<h2 id=\"8-常见错误\"><a href=\"#8-常见错误\" class=\"headerlink\" title=\"8. 常见错误\"></a>8. 常见错误</h2><ol>\n<li>作为Theme中引用的style必须要有一个parent</li>\n</ol>\n<p>例如<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">在AppTheme中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:editTextStyle\"</span>&gt;</span>@style/MyEditTextStyle<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>= <span class=\"string\">\"MyEditTextStyle\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>= <span class=\"string\">\"android:fontFamily\"</span>&gt;</span></div><div class=\"line\">  sans-serif-medium</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这样做的结果将是所有的EditText都会失去基本的属性</p>\n<ol>\n<li>defStyleAttr vs defStyleRes</li>\n</ol>\n<p>常见于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ObtainStyledAttributes(AttributeSet set,<span class=\"keyword\">int</span> []attrs,</div><div class=\"line\"> <span class=\"keyword\">int</span> defStyleAttr,<span class=\"keyword\">int</span> defStyleRes)</div></pre></td></tr></table></figure>\n<p>直接解释：</p>\n<blockquote>\n<p> defStyleAttr: The attr in your theme which points to the default style</p>\n<p> eg: R.attr.editTextStyle</p>\n<p> defStyleRes: The resource ID of the default style</p>\n<p> eg:R.style.Widget_Material_EditText</p>\n</blockquote>\n<p>ObtainStyledAttributes查找Value时读取的顺序如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>. Value in the AttributeSet</div><div class=\"line\"><span class=\"number\">2</span>. Value in the explicit style</div><div class=\"line\"><span class=\"number\">3</span>. Default style specified in defStyleRes</div><div class=\"line\"><span class=\"number\">4</span>. Default style specified in defStyleAttr</div><div class=\"line\"><span class=\"number\">5</span>. Base value in <span class=\"keyword\">this</span> theme</div></pre></td></tr></table></figure>\n<p>注意最后一条，万一在manifests文件中出现这种东西</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"AppTheme\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:background\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">Style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这意味着</p>\n<blockquote>\n<p>Any View which doesn’t have a background set ,will use the theme’s value ,  SHIT!</p>\n</blockquote>\n<h2 id=\"9-容易遇到的错误\"><a href=\"#9-容易遇到的错误\" class=\"headerlink\" title=\"9. 容易遇到的错误\"></a>9. 容易遇到的错误</h2><p>编译不通过的情况<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Error retrieving parent <span class=\"keyword\">for</span> item: No resource found that matches the given name</div><div class=\"line\"> <span class=\"string\">'@android:style/TextAppearance.Holo.Widget.ActionBar.Title'</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"10-最后，一点好玩的\"><a href=\"#10-最后，一点好玩的\" class=\"headerlink\" title=\"10. 最后，一点好玩的\"></a>10. 最后，一点好玩的</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Context themedContext =</div><div class=\"line\">  <span class=\"keyword\">new</span> ContextThemeWrapper(baseContext,R.style.MyTheme);</div><div class=\"line\"></div><div class=\"line\">View view = LayoutInflator.form(themedContext)</div><div class=\"line\">  \t\t.inflate(R.layout.some_layout,<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"comment\">//或者</span></div><div class=\"line\">View view = <span class=\"keyword\">new</span> View(themedContext);</div><div class=\"line\"><span class=\"comment\">//生成的View就会带有MyTheme中的属性，动态设置。</span></div></pre></td></tr></table></figure>\n<p>而这也是AppComPat对于API 21以下版本进行兼容的原理<br>翻了一下文档：<br>ContextThemeWrapper : Added in API level 1</p>\n<p>这一点AppCompat的作者也在2014年的一篇 <a href=\"https://chris.banes.me/2014/11/12/theme-vs-style/\">博客</a>中提到了。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=Jr8hJdVGHAk\">Daniel Lew</a></li>\n<li><a href=\"http://blog.danlew.net/2016/07/19/a-deep-dive-into-android-view-constructors/\">View Constructor</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=TIHXGwRTMWI\">IO 2016</a></li>\n</ul>\n","excerpt":"<p>认识Theme和Styles</p>\n<p>重新看一遍Using Themes and styles without going crazy，大部分属于直接翻译</p>\n<h2 id=\"1-Styles\"><a href=\"#1-Styles\" class=\"headerlink\" title=\"1. Styles\"></a>1. Styles</h2><h3 id=\"1-1-首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\"><a href=\"#1-1-首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\" class=\"headerlink\" title=\"1.1 首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来\"></a>1.1 首先，在layout文件中，Style可以将一些重复的，具有共性的属性提取出来</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">android:background</span>= <span class=\"string\">\"#ff0000\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p>变成</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>= <span class=\"string\">\"@Style/MyStyle\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyStyle\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:background\"</span>&gt;</span>#ff0000<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">Style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这种形式，对于大量的具有相同属性的且具有<em>共性</em>的View，可以直接使用对应的Style，这能够让layout文件更加整洁。前提是确信layout文件中使用的View具有相同的属性。</p>","more":"<h3 id=\"1-2-Style-Inheritance\"><a href=\"#1-2-Style-Inheritance\" class=\"headerlink\" title=\"1.2 Style Inheritance\"></a>1.2 Style Inheritance</h3><p>Style可以继承，两种方式：</p>\n<p>假设有parent style ，一种在name中使用前缀的方式指明parent，另一种在后面显式的声明parent</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Parent\"</span>/&gt;</span><span class=\"undefined\"></span></div></pre></td></tr></table></figure>\n<p>Explicit child</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Child\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Parent\"</span>&gt;</span><span class=\"undefined\"></span></div></pre></td></tr></table></figure>\n<p>  Implicit Child</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Parent.Child\"</span>/&gt;</span><span class=\"undefined\"></span></div></pre></td></tr></table></figure>\n<p>同时使用两种方式时，默认使用Explicit Parent  </p>\n<p>为避免混淆，推荐使用Explicit Child且Child name不带前缀  </p>\n<p>View不能拥有两个Style,除了TextView及其子类，例如</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span>&gt;</span></div><div class=\"line\">  android:textColor = \"#ffffff\"</div><div class=\"line\">truestyle=\"@style/SomeStyle\"</div><div class=\"line\">  android:textAppearance = \"@style/MyText\"</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">TextView</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如上所示，TextView中可以定义TextAppearance，后者包含了常见的textColor，textSize等attributes，而在一个View中可以同时定义两个Style。如果出现冲突，styles之间相同attributes的应用优先级为：</p>\n<blockquote>\n<p>android:textColor &gt;&gt; SomeStyle中的android:textColor&gt;&gt;MyText中的android:textColor</p>\n<p>使用TextAppearance 时一定要有一个parent</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyText\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"TextAppearance.Appcompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:TextColor\"</span>&gt;</span>#F08<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>因为使用style时，系统将把style中定义的attribute和当前View的默认attribute融合起来，而TextView默认attribute 中什么也没有，造成textSize = 0的情况，所以务必选择parent，在parent style已经定义好大多数属性的情况下再去修改小部分属性将简单得多。TextAppearance可以在Theme中定义，也可以写在单一的TextView上。</p>\n<h2 id=\"2-Themes\"><a href=\"#2-Themes\" class=\"headerlink\" title=\"2. Themes\"></a>2. Themes</h2><p>  在Android中，Theme名字以”Theme.”开头，查看源码会发现只是定义了一大堆color attributes 和Window attributes。Themes比Styles的作用范围更广，themes可以在Application,Activity层面管理Widget外观，Theme还可以实现夜间模式切换</p>\n<p>  来看如何定义一个Theme</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Theme\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">android:statusBarColor</span>&gt;</span>#ff0000<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>  回头看一下Style</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Style\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:background\"</span>&gt;</span>#ff0000<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">Style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>  语法看起来完全一样。</p>\n<p>  区别：styles中的属性被直接送到View的构造函数中，记得在自定义View时写的那些attrs吗，其实就是两个参数的构造函数中的AttributeSets</p>\n<p>  Theme应用范围更广，定义的属性和Style也不尽相同。</p>\n<p>  两者之间有一些联系：例如Theme中可以定义default widget style，Style可以引用Theme中定义的属性(?attr:selectableItemBackground还记得吗)<br>  上面提到了Theme中可以定义default widget style，具体做法无非就是这样:</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>= <span class=\"string\">\"MyTheme\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"Theme.AppCompat.Light\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:editTextStyle\"</span>&gt;</span>@style/MyEditTextStyle<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>  所以，只要在AppTheme中点进去，找一下这个键对应的值就可以了</p>\n<h3 id=\"2-1-使用Theme\"><a href=\"#2-1-使用Theme\" class=\"headerlink\" title=\"2.1 使用Theme\"></a>2.1 使用Theme</h3><p>  两种方式:</p>\n<p>  1.在Manifest中，例如</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">application</span></div><div class=\"line\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/Theme.AppCompat\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">或者</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></div><div class=\"line\">  <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/Theme.AppCompat.Light\"</span>        /&gt;</span></div></pre></td></tr></table></figure>\n<p>  activty中Theme override Application的Theme</p>\n<ol>\n<li><p>应用于View</p>\n<p>Lollipop开始引入View Theming的概念</p>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Toolbar</span></div><div class=\"line\">   <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"</span></div><div class=\"line\">   <span class=\"attr\">app:popupTheme</span>=<span class=\"string\">\"@style/ThemeOverlay.AppCompa.Light\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>  应用在View上的Theme将能够作用在该View及其所有的Children，这样做的好处在于没有必要专门为了一个View而去选择其他的Theme。</p>\n<p>  例如在Holo中有Holo.Light.DarkActionBar，为了专门适配ActionBar需要一个专门的Theme。目前看来主要应用在Toolbar上。</p>\n<h2 id=\"3-墙裂推荐使用AppCompat\"><a href=\"#3-墙裂推荐使用AppCompat\" class=\"headerlink\" title=\"3 .墙裂推荐使用AppCompat\"></a>3 .墙裂推荐使用AppCompat</h2><p>  好处:</p>\n<ul>\n<li>Material on all devices ,记得以前听说AppCompat在21以上继承自Theme.Material。</li>\n<li>Baseline themes/styles AppCompat 预设了一系列样式标准，只需要继承AppCompat，改动一小部分样式就能完成设计<ul>\n<li>Enable View theming pre-Lollipop</li>\n<li>使用ColorPrimary , ColorAccent等attributes(backPorted by AppCompat)设置Widget样式</li>\n<li>在Theme中可以定义默认的Widget样式，例如</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"AppTheme\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:spinnerItemStyle\"</span>&gt;</span>@sytle/MySpinnerStyle<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>还可以更改默认样式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"AttrTheme\"</span> <span class=\"attr\">parent</span> =<span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> =<span class=\"string\">\"selectableItemBackground\"</span>&gt;</span>@drawable/bg<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">android:background</span>=<span class=\"string\">?attr/selectableItemBackground</span>\"/&gt;</span></div></pre></td></tr></table></figure>\n<p>这样就可以自定义点击时的Drawable了。</p>\n<ul>\n<li>支持android:theme: API 7+(只应用于该View)，API 11+(View及其子View)</li>\n</ul>\n<p>View theming原本只是API 21才引入的概念，AppCompat实现了向前兼容</p>\n<h2 id=\"4-attr的问题\"><a href=\"#4-attr的问题\" class=\"headerlink\" title=\"4 .  ?attr的问题\"></a>4 .  ?attr的问题</h2><blockquote>\n<p>?android:attr/selectableItemBackground</p>\n</blockquote>\n<p>一个个来解释：</p>\n<p>?  :  we’re doing a theme lookup</p>\n<p>android:  we’re looking up something within the android namespace</p>\n<p>attr/  : we’re looking for an attribute(可省略)</p>\n<p>selectableItemBackground: The name of the atribute we’re looking up</p>\n<p>把attr/省略掉后变成</p>\n<blockquote>\n<p>?android:selectableItemBackground</p>\n</blockquote>\n<p>效果完全一样</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"MyTheme\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:colorPrimary\"</span>&gt;</span>@color/red<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>问题在于android:ColorPromary是Lollipop才引入的，解决方案</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">syle</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyTheme\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"colorPrimary\"</span>&gt;</span>@color/red<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">syle</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>注意这里没有android: 前缀，AppCompat针对API21之前的版本定义了自己的一套资源。</p>\n<p>再举个例子</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">在values/attrs.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">attr</span> <span class=\"attr\">name:</span>\"<span class=\"attr\">myAttribute</span>\" <span class=\"attr\">format</span>=<span class=\"string\">\"dimension\"</span>/&gt;</span></div><div class=\"line\"></div><div class=\"line\">在values/themes.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"MyTheme\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myAttribute\"</span>&gt;</span>4dp<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span>  这就是实际使用的Theme</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">在values/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"MyStyle\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:padding\"</span>&gt;</span>?attr/myAttribute<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">实际操作中</div><div class=\"line\">在layout文件中，通过将一个长度，颜色定义为?attr的方式，就会去当前的Theme中寻找相对应的attribute，这就是黑夜模式切换的原理</div></pre></td></tr></table></figure>\n<p>要注意的是，所有非android nameSpace的attribute Name都是global的，所以如果两个library定义了相同的attribute Name，将无法编译通过。</p>\n<p>Style可以通过?attr的方式引用Theme中的资源</p>\n<h2 id=\"5-获取Theme\"><a href=\"#5-获取Theme\" class=\"headerlink\" title=\"5 .获取Theme\"></a>5 .获取Theme</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">context.getTheme().resolveAttribute(R.attr.dialogTheme,outValue,<span class=\"keyword\">true</span>)</div><div class=\"line\"></div><div class=\"line\">在View中</div><div class=\"line\">  TypedArray a = context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.ImageView,defStyleAttr,defStyleRes)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> alpha = a.getInt(</div><div class=\"line\">  com.android.internal.R.styleable.ImageView_drawableAlpha,<span class=\"number\">255</span>)</div></pre></td></tr></table></figure>\n<p>Activity有一个setTheme(int themeResId)方法，注意，这个方法并不是取代原先的Theme,只是在原有的Theme上apply了。所以这个命名不算太好。Activity内部会在onCreate()前调用setTheme(你写在manifest里面的Theme)</p>\n<h2 id=\"6-v21的问题\"><a href=\"#6-v21的问题\" class=\"headerlink\" title=\"6. v21的问题\"></a>6. v21的问题</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">在values/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"BaseToolbar\"</span>/&gt;</span><span class=\"xml\"></div><div class=\"line\"></div><div class=\"line\">在values-v21/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>= <span class=\"string\">\"BaseToolbar\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:elevation\"</span>&gt;</span>4dp<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">elevation是21以上api才有的属性，lint会提示问题</div><div class=\"line\">这样，在values/styles.xml中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"Toolbar\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"BaseToolbar\"</span>/&gt;</span><span class=\"undefined\"></div><div class=\"line\">lint就不会飙黄了，直接引用Toolbar即可</span></div></pre></td></tr></table></figure>\n<p>通过这种继承的方式能够在自己的Theme中使用统一的theme，针对不同的运行时版本确定最终运行的Theme。</p>\n<h2 id=\"7-ThemeOverlay\"><a href=\"#7-ThemeOverlay\" class=\"headerlink\" title=\"7 . ThemeOverlay\"></a>7 . ThemeOverlay</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ThemeOverlay.Material.Light</div><div class=\"line\">ThemeOverlay.Material.Dark</div><div class=\"line\"><span class=\"comment\">//etc ...</span></div></pre></td></tr></table></figure>\n<p>用于添加到现有的Theme上，例如Theme.Material.Light只包含color relevant to a light Theme，不会改变原有Theme的window Attributes。查看源码，只是完整的Theme中的一小部分attribute。</p>\n<h2 id=\"8-常见错误\"><a href=\"#8-常见错误\" class=\"headerlink\" title=\"8. 常见错误\"></a>8. 常见错误</h2><ol>\n<li>作为Theme中引用的style必须要有一个parent</li>\n</ol>\n<p>例如<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">在AppTheme中</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:editTextStyle\"</span>&gt;</span>@style/MyEditTextStyle<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>= <span class=\"string\">\"MyEditTextStyle\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>= <span class=\"string\">\"android:fontFamily\"</span>&gt;</span></div><div class=\"line\">  sans-serif-medium</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这样做的结果将是所有的EditText都会失去基本的属性</p>\n<ol>\n<li>defStyleAttr vs defStyleRes</li>\n</ol>\n<p>常见于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ObtainStyledAttributes(AttributeSet set,<span class=\"keyword\">int</span> []attrs,</div><div class=\"line\"> <span class=\"keyword\">int</span> defStyleAttr,<span class=\"keyword\">int</span> defStyleRes)</div></pre></td></tr></table></figure>\n<p>直接解释：</p>\n<blockquote>\n<p> defStyleAttr: The attr in your theme which points to the default style</p>\n<p> eg: R.attr.editTextStyle</p>\n<p> defStyleRes: The resource ID of the default style</p>\n<p> eg:R.style.Widget_Material_EditText</p>\n</blockquote>\n<p>ObtainStyledAttributes查找Value时读取的顺序如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>. Value in the AttributeSet</div><div class=\"line\"><span class=\"number\">2</span>. Value in the explicit style</div><div class=\"line\"><span class=\"number\">3</span>. Default style specified in defStyleRes</div><div class=\"line\"><span class=\"number\">4</span>. Default style specified in defStyleAttr</div><div class=\"line\"><span class=\"number\">5</span>. Base value in <span class=\"keyword\">this</span> theme</div></pre></td></tr></table></figure>\n<p>注意最后一条，万一在manifests文件中出现这种东西</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Style</span> <span class=\"attr\">name</span> = <span class=\"string\">\"AppTheme\"</span> <span class=\"attr\">parent</span> = <span class=\"string\">\"Theme.AppCompat\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">true<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span> = <span class=\"string\">\"android:background\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">Style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这意味着</p>\n<blockquote>\n<p>Any View which doesn’t have a background set ,will use the theme’s value ,  SHIT!</p>\n</blockquote>\n<h2 id=\"9-容易遇到的错误\"><a href=\"#9-容易遇到的错误\" class=\"headerlink\" title=\"9. 容易遇到的错误\"></a>9. 容易遇到的错误</h2><p>编译不通过的情况<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Error retrieving parent <span class=\"keyword\">for</span> item: No resource found that matches the given name</div><div class=\"line\"> <span class=\"string\">'@android:style/TextAppearance.Holo.Widget.ActionBar.Title'</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"10-最后，一点好玩的\"><a href=\"#10-最后，一点好玩的\" class=\"headerlink\" title=\"10. 最后，一点好玩的\"></a>10. 最后，一点好玩的</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Context themedContext =</div><div class=\"line\">  <span class=\"keyword\">new</span> ContextThemeWrapper(baseContext,R.style.MyTheme);</div><div class=\"line\"></div><div class=\"line\">View view = LayoutInflator.form(themedContext)</div><div class=\"line\">  \t\t.inflate(R.layout.some_layout,<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"comment\">//或者</span></div><div class=\"line\">View view = <span class=\"keyword\">new</span> View(themedContext);</div><div class=\"line\"><span class=\"comment\">//生成的View就会带有MyTheme中的属性，动态设置。</span></div></pre></td></tr></table></figure>\n<p>而这也是AppComPat对于API 21以下版本进行兼容的原理<br>翻了一下文档：<br>ContextThemeWrapper : Added in API level 1</p>\n<p>这一点AppCompat的作者也在2014年的一篇 <a href=\"https://chris.banes.me/2014/11/12/theme-vs-style/\">博客</a>中提到了。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=Jr8hJdVGHAk\">Daniel Lew</a></li>\n<li><a href=\"http://blog.danlew.net/2016/07/19/a-deep-dive-into-android-view-constructors/\">View Constructor</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=TIHXGwRTMWI\">IO 2016</a></li>\n</ul>"},{"title":"安卓事件分发流程","date":"2016-10-06T15:32:30.000Z","_content":"\n![](http://odzl05jxx.bkt.clouddn.com/dispatch_touch_event_video.JPG)\n\n图1 默认情况下事件传递的路径 \n\n> Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。\n<!--more-->\n\n- 首先来关注ACTION_DOWN，用户触摸屏幕，MotionEvent开始传递：\n\n> 1. Activity.dispatchTouchEvent\n>\n> 2. ViewGroup.dispatchTouchEvent\n>\n> 3. ViewGroup.onInterceptTouchEvent\n>\n>    .....中间省略n个视图层级 ....>>>\n>\n> 4. View.dispatchTouchEvent\n>\n> 5. View.onTouchEvent\n>\n> ​      ....中间省略n个视图层级....>>>\n>\n> 6. ViewGroup.onTouchEvent\n> 7. Activity.onTouchEvent\n\n这也就是本文最开始的图1内描述的内容，注意，在默认情况下(各个函数都返回super的情况下)才能将这个从上到下，再从下到上的循环走完整。这里讨论的还只是ACTION_DOWN。\n\n- 接下来看ACTION_DOWN下发过程中各个函数返回值对于整个传递链走向的影响，我们在override这些函数的时候，返回值无非三种：\n\n  > true , false ,super\n\n  - return true：ACTION_DOWN事件分发到此结束(消费掉)，这里有一个要注意的是onInterceptTouchEvent,返回true表示该ViewGroup打算将事件拦截下来，底层View将接收到一个ACTION_CANCEL，事件传递给该ViewGroup的onTouchEvent\n  - return false: 对于dispatchTouchEvent，返回false表明不再向下分发，ACTION_DOWN发送到上一层ViewGroup(Activity)的OnTouchEvent；对于onInterceptTouchEvent,返回false表明该ViewGroup不打算拦截，继续下发，对于onTouchEvent，返回false，事件继续上传至上一层级ViewGroup的OnTouchEvent 。\n  - return super : 完成整个传递链，就像图1中展示的一样。\n\n![](http://odzl05jxx.bkt.clouddn.com/touch_event_1.png)\n\n图2 来自[图解安卓事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)  完美地解释了事件分发各个流程中返回值对于事件传递的影响。\n\n![](http://odzl05jxx.bkt.clouddn.com/touch_event_2.png)\n\n图3 来自[图解安卓事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b) \n\n接下来看ACTION_DOWN时返回值对于后续ACTION_MOVE,ACTION_UP等传递路径的影响：\n\n首先介绍概念：\n\n> gesture = ACTION_DOWN+ a bounch of ACTIONS +ACTION_UP\n\n一个gesture(手势)即从手指按下到手指离开这段过程中所有的事件的集合,swipe,click,fling等等\n\nACTION_DWON发生时，android将会在当前touch区域所有的View中确定一个Touch Target,后者将接管此次gesture中的所有ACTION_MOVE,ACTION_UP。（这样做有两点好处：1.一旦确定了Touch Target，系统将会把所有的后续事件全部传递到这个target为止，这就避免了复杂的view traversing，有助于提升性能; 2：传递链中第一个能够成为Touch Target的View将独立处理后续事件，不需要考虑其他View受到影响）。在在一个gesture开始时，OnTouchEvent（ACTION_DOWN）返回true,就意味着成为TouchTarget。借用简书[作者](http://www.jianshu.com/p/e99b5e8bd67b)的总结:\n\n> ACTION_DOWN事件在哪个控件消费了（return true），  那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n\n这里可以看到，事件依旧是从上往下一直分发到TouchTarget这一层，只是在TouchTarget这一层被消费了，***且不再往上传递***(有助于性能提升)。父ViewGroup的dispatchTouchEvent和onInterceptTouchEvent依旧会先于TouchTarget接收到ACTION_MOVE等事件。所以此时如果父ViewGroup在onInterceptTouchEvent中返回true，父ViewGroup将取代原有的子View成为新的ViewTarget,后续事件(ACTION_MOVE等)将传递到该父ViewGroup中，而子View将收到ACTION_CANCEL(可以在这里做一些恢复状态的工作，比如从foucused变成unfocused)。举一个例子：在ScrollView(不是Android自带的那个)中放一个Button，ACTION_DOWN时，BUTTON表示可以处理ACTION_DOWN,因为这可能会是一次click，于是Button就成了TouchTarget，后续事件将不会传递到ScrollView中，ScrollView也就无法滑动。为解决这个问题，在ScrollView的onInterceptTouchEvent中，如果看到ACTION_DWON，返回false(点击事件对于滑动毫无意义)，但如果看到ACTION_MOVE(滑动事件),返回true并成为新的TouchTarget。注意是在OnInterceptTouchEvent中拦截而不是dispatchTouchEvent中拦截，后者会将事件传递到上层ViewGroup的onTouchEvent中。想想看，不去dispatch了、、、android这种Api起名还是可以的。\n\n### #onClick事件\n\n接下来看onClick和onLongClick，onTouchListener这类事件何时触发\n\n首先是View的dispatchTouchEvent源码部分\n\n```java\ncase MotionEvent.ACTION_UP:\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n\n                        if (prepressed) {\n                            // The button is being released before we actually\n                            // showed it as pressed.  Make it show the pressed\n                            // state now (before scheduling the click) to ensure\n                            // the user sees it.\n                            setPressed(true, x, y);\n                       }\n\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n\n                        if (mUnsetPressedState == null) {\n                            mUnsetPressedState = new UnsetPressedState();\n                        }\n\n                        if (prepressed) {\n                            postDelayed(mUnsetPressedState,\n                                    ViewConfiguration.getPressedStateDuration());\n                        } else if (!post(mUnsetPressedState)) {\n                            // If the post failed, unpress right now\n                            mUnsetPressedState.run();\n                        }\n\n                        removeTapCallback();\n                    }\n                    mIgnoreNextUpEvent = false;\n                    break;\n```\n\n所以onClick事件是在ACTION_UP中执行的\n\n而LongClick事件要看ACTION_DOWN了\n\n```java\n  case MotionEvent.ACTION_DOWN:\n                    mHasPerformedLongPress = false;\n\n                    if (performButtonActionOnTouchDown(event)) {\n                        break;\n                    }\n\n                    // Walk up the hierarchy to determine if we're inside a scrolling container.\n                    boolean isInScrollingContainer = isInScrollingContainer();\n\n                    // For views inside a scrolling container, delay the pressed feedback for\n                    // a short period in case this is a scroll.\n                    if (isInScrollingContainer) {\n                        mPrivateFlags |= PFLAG_PREPRESSED;\n                        if (mPendingCheckForTap == null) {\n                            mPendingCheckForTap = new CheckForTap();\n                        }\n                        mPendingCheckForTap.x = event.getX();\n                        mPendingCheckForTap.y = event.getY();\n                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());\n                    } else {\n                        // Not inside a scrolling container, so show the feedback right away\n                        setPressed(true, x, y);\n                        checkForLongClick(0, x, y);\n                    }\n                    break;\n```\n\n关键看checkForLongClick, 不贴代码了，结论是：在ACTION_DOWN事件被捕捉后，系统会开始触发一个postDelayed操作，delay的时间为\n\n> ```\n> ViewConfiguration.getLongPressTimeout() - delayOffset\n> ```\n\n（这个值在Eclair2.1上为500ms），500ms后会触发CheckForLongPress线程的执行：\n\n想想看，LongClick事件是在DOWN时开始计时，500ms假设，OnClick是在UP是发生，所以完全有可能同时发生OnClick和OnLongClick。这里看到当onLongClick的返回值为true时， *mHasPerformedLongPress* = true ,仔细看ACTION_UP中，如果HasPerformLongPress==true，就不会走到onClick事件里。所以在onLongClickListener里需要返回一个boolean值的原因就这么简单。\n\n```java\n if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n```\n\n接下来是OnTouchListener，直接上结论: onTouchListener里面的方法是在dispatchTouchEvent里面调用的，并且如果listener里面的onTouch返回true，事件将不会发送给onTouchEvent，因此OnTouchListener势必会优先级高于onClick和onLongClick。\n\n## VelocityTracker\n\n```java\nvelocityTracker = VelocityTracker.obtain()；\nvelocityTracker.addMovement(event);\nvelocityTracker.computeCurrentVelocity(1);  \nvelocityTracker.getXVelocity();\nvelocityTracker.recycle();\n```\n\n值得注意的是，VelocityTracker内部使用了大量的native方法，所以执行速度比java要快很多。\n\n### 实现Fling效果 \n\n```java\nprivate void onFling(float velocityX,float velocityY){\n  scroller.fling(getScrollX(),getScrollY(),(int)-velocityX\n                (int)-velocityY,minScrollX,maxScrollX,\n                minScrollY,maxScrollY);\n  invalidate();\n}\n@overdide// 这是每个View都有的方法\nprivate void computeScroll(){\n  if(scroller.isFinished()){\n    scroller.computeScrollOffset();\n    scrollTo(scroller.getCurrX(),scroller.getCurrY());\n    postInvalidateOnAnimation();\n  }\n}\n\n\n```\n\n### 捕获双击事件\n\n```java\npublic class MyView extends View {\n \nGestureDetector gestureDetector;\n \npublic MyView(Context context, AttributeSet attrs) {\n    super(context, attrs);\n            // creating new gesture detector \n    gestureDetector = new GestureDetector(context, new GestureListener());\n} \n \n// skipping measure calculation and drawing \n \n    // delegate the event to the gesture detector \n@Override \npublic boolean onTouchEvent(MotionEvent e) {\n    return gestureDetector.onTouchEvent(e);\n} \n \n \nprivate class GestureListener extends GestureDetector.SimpleOnGestureListener {\n \n    @Override \n    public boolean onDown(MotionEvent e) {\n        return true; \n    } \n    // event when double tap occurs \n    @Override \n    public boolean onDoubleTap(MotionEvent e) {\n        float x = e.getX();\n        float y = e.getY();\n \n        Log.d(\"Double Tap\", \"Tapped at: (\" + x + \",\" + y + \")\");\n \n        return true; \n    } \n} \n} \n```\n\n 最后是关于ViewConfiguration的一些常量获取的静态方法：\n\nint getScaledTouchSlop(); (if Math.abs(x*x+y*y)>mTouchSlop 就可以认为是滑动事件了)\n\n```java\n/**    \n  * 包含了方法和标准的常量用来设置UI的超时、大小和距离    \n  */ \n public class ViewConfiguration {     \n     // 设定水平滚动条的宽度和垂直滚动条的高度，单位是像素px     \n     private static final int SCROLL_BAR_SIZE = 10;     \n          \n     //定义滚动条逐渐消失的时间，单位是毫秒     \n     private static final int SCROLL_BAR_FADE_DURATION = 250;     \n          \n     // 默认的滚动条多少秒之后消失，单位是毫秒     \n     private static final int SCROLL_BAR_DEFAULT_DELAY = 300;     \n          \n     // 定义边缘地方褪色的长度     \n     private static final int FADING_EDGE_LENGTH = 12;     \n          \n     //定义子控件按下状态的持续事件     \n     private static final int PRESSED_STATE_DURATION = 125;     \n              \n     //定义一个按下状态转变成长按状态的转变时间     \n     private static final int LONG_PRESS_TIMEOUT = 500;     \n              \n     //定义用户在按住适当按钮，弹出全局的对话框的持续时间     \n     private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;     \n              \n     //定义一个touch事件中是点击事件还是一个滑动事件所需的时间，如果用户在这个时间之内滑动，那么就认为是一个点击事件     \n     private static final int TAP_TIMEOUT = 115;     \n              \n     /**    \n      * Defines the duration in milliseconds we will wait to see if a touch event     \n      * is a jump tap. If the user does not complete the jump tap within this interval, it is    \n      * considered to be a tap.     \n      */ \n     //定义一个touch事件时候是一个点击事件。如果用户在这个时间内没有完成这个点击，那么就认为是一个点击事件     \n     private static final int JUMP_TAP_TIMEOUT = 500;     \n          \n     //定义双击事件的间隔时间     \n     private static final int DOUBLE_TAP_TIMEOUT = 300;     \n              \n     //定义一个缩放控制反馈到用户界面的时间     \n     private static final int ZOOM_CONTROLS_TIMEOUT = 3000;     \n          \n     /**    \n      * Inset in pixels to look for touchable content when the user touches the edge of the screen    \n      */ \n     private static final int EDGE_SLOP = 12;     \n              \n     /**    \n      * Distance a touch can wander before we think the user is scrolling in pixels    \n      */ \n     private static final int TOUCH_SLOP = 16;     \n              \n     /**    \n      * Distance a touch can wander before we think the user is attempting a paged scroll    \n      * (in dips)    \n      */ \n     private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;     \n              \n     /**    \n      * Distance between the first touch and second touch to still be considered a double tap    \n      */ \n     private static final int DOUBLE_TAP_SLOP = 100;     \n              \n     /**    \n      * Distance a touch needs to be outside of a window's bounds for it to    \n      * count as outside for purposes of dismissing the window.    \n      */ \n     private static final int WINDOW_TOUCH_SLOP = 16;     \n          \n    //用来初始化fling的最小速度，单位是每秒多少像素     \n     private static final int MINIMUM_FLING_VELOCITY = 50;     \n              \n     //用来初始化fling的最大速度，单位是每秒多少像素     \n     private static final int MAXIMUM_FLING_VELOCITY = 4000;     \n          \n     //视图绘图缓存的最大尺寸，以字节表示。在ARGB888格式下，这个尺寸应至少等于屏幕的大小     \n     @Deprecated     \n     private static final int MAXIMUM_DRAWING_CACHE_SIZE = 320 * 480 * 4; // HVGA screen, ARGB8888     \n          \n     //flings和scrolls摩擦力度大小的系数     \n     private static float SCROLL_FRICTION = 0.015f;     \n          \n     /**    \n      * Max distance to over scroll for edge effects    \n      */ \n     private static final int OVERSCROLL_DISTANCE = 0;     \n          \n     /**    \n      * Max distance to over fling for edge effects    \n      */ \n     private static final int OVERFLING_DISTANCE = 4;     \n          \n }\n```\n\n\n\n\n\n- ## Reference\n\n1. [图解安卓事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)\n2. [making sense of the touch system](https://www.youtube.com/watch?v=usBaTHZdXSI)\n3. [Android onTouchEvent, onClick及onLongClick的调用机制](http://blog.csdn.net/ddna/article/details/5451722)\n4. [Android触摸事件机制(三)](http://wangkuiwu.github.io/2015/01/03/TouchEvent-View/)\n5. [ViewConfiguration用法](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0225/907.html)\n6. [触摸事件的分析与总结](http://glblong.blog.51cto.com/3058613/1559320)\n\n   ​","source":"_posts/touch-event-distribution.md","raw":"---\ntitle: 安卓事件分发流程\ndate: 2016-10-06 23:32:30\ncategories: blog \ntags: [android]\n---\n\n![](http://odzl05jxx.bkt.clouddn.com/dispatch_touch_event_video.JPG)\n\n图1 默认情况下事件传递的路径 \n\n> Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。\n<!--more-->\n\n- 首先来关注ACTION_DOWN，用户触摸屏幕，MotionEvent开始传递：\n\n> 1. Activity.dispatchTouchEvent\n>\n> 2. ViewGroup.dispatchTouchEvent\n>\n> 3. ViewGroup.onInterceptTouchEvent\n>\n>    .....中间省略n个视图层级 ....>>>\n>\n> 4. View.dispatchTouchEvent\n>\n> 5. View.onTouchEvent\n>\n> ​      ....中间省略n个视图层级....>>>\n>\n> 6. ViewGroup.onTouchEvent\n> 7. Activity.onTouchEvent\n\n这也就是本文最开始的图1内描述的内容，注意，在默认情况下(各个函数都返回super的情况下)才能将这个从上到下，再从下到上的循环走完整。这里讨论的还只是ACTION_DOWN。\n\n- 接下来看ACTION_DOWN下发过程中各个函数返回值对于整个传递链走向的影响，我们在override这些函数的时候，返回值无非三种：\n\n  > true , false ,super\n\n  - return true：ACTION_DOWN事件分发到此结束(消费掉)，这里有一个要注意的是onInterceptTouchEvent,返回true表示该ViewGroup打算将事件拦截下来，底层View将接收到一个ACTION_CANCEL，事件传递给该ViewGroup的onTouchEvent\n  - return false: 对于dispatchTouchEvent，返回false表明不再向下分发，ACTION_DOWN发送到上一层ViewGroup(Activity)的OnTouchEvent；对于onInterceptTouchEvent,返回false表明该ViewGroup不打算拦截，继续下发，对于onTouchEvent，返回false，事件继续上传至上一层级ViewGroup的OnTouchEvent 。\n  - return super : 完成整个传递链，就像图1中展示的一样。\n\n![](http://odzl05jxx.bkt.clouddn.com/touch_event_1.png)\n\n图2 来自[图解安卓事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)  完美地解释了事件分发各个流程中返回值对于事件传递的影响。\n\n![](http://odzl05jxx.bkt.clouddn.com/touch_event_2.png)\n\n图3 来自[图解安卓事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b) \n\n接下来看ACTION_DOWN时返回值对于后续ACTION_MOVE,ACTION_UP等传递路径的影响：\n\n首先介绍概念：\n\n> gesture = ACTION_DOWN+ a bounch of ACTIONS +ACTION_UP\n\n一个gesture(手势)即从手指按下到手指离开这段过程中所有的事件的集合,swipe,click,fling等等\n\nACTION_DWON发生时，android将会在当前touch区域所有的View中确定一个Touch Target,后者将接管此次gesture中的所有ACTION_MOVE,ACTION_UP。（这样做有两点好处：1.一旦确定了Touch Target，系统将会把所有的后续事件全部传递到这个target为止，这就避免了复杂的view traversing，有助于提升性能; 2：传递链中第一个能够成为Touch Target的View将独立处理后续事件，不需要考虑其他View受到影响）。在在一个gesture开始时，OnTouchEvent（ACTION_DOWN）返回true,就意味着成为TouchTarget。借用简书[作者](http://www.jianshu.com/p/e99b5e8bd67b)的总结:\n\n> ACTION_DOWN事件在哪个控件消费了（return true），  那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n\n这里可以看到，事件依旧是从上往下一直分发到TouchTarget这一层，只是在TouchTarget这一层被消费了，***且不再往上传递***(有助于性能提升)。父ViewGroup的dispatchTouchEvent和onInterceptTouchEvent依旧会先于TouchTarget接收到ACTION_MOVE等事件。所以此时如果父ViewGroup在onInterceptTouchEvent中返回true，父ViewGroup将取代原有的子View成为新的ViewTarget,后续事件(ACTION_MOVE等)将传递到该父ViewGroup中，而子View将收到ACTION_CANCEL(可以在这里做一些恢复状态的工作，比如从foucused变成unfocused)。举一个例子：在ScrollView(不是Android自带的那个)中放一个Button，ACTION_DOWN时，BUTTON表示可以处理ACTION_DOWN,因为这可能会是一次click，于是Button就成了TouchTarget，后续事件将不会传递到ScrollView中，ScrollView也就无法滑动。为解决这个问题，在ScrollView的onInterceptTouchEvent中，如果看到ACTION_DWON，返回false(点击事件对于滑动毫无意义)，但如果看到ACTION_MOVE(滑动事件),返回true并成为新的TouchTarget。注意是在OnInterceptTouchEvent中拦截而不是dispatchTouchEvent中拦截，后者会将事件传递到上层ViewGroup的onTouchEvent中。想想看，不去dispatch了、、、android这种Api起名还是可以的。\n\n### #onClick事件\n\n接下来看onClick和onLongClick，onTouchListener这类事件何时触发\n\n首先是View的dispatchTouchEvent源码部分\n\n```java\ncase MotionEvent.ACTION_UP:\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n\n                        if (prepressed) {\n                            // The button is being released before we actually\n                            // showed it as pressed.  Make it show the pressed\n                            // state now (before scheduling the click) to ensure\n                            // the user sees it.\n                            setPressed(true, x, y);\n                       }\n\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n\n                        if (mUnsetPressedState == null) {\n                            mUnsetPressedState = new UnsetPressedState();\n                        }\n\n                        if (prepressed) {\n                            postDelayed(mUnsetPressedState,\n                                    ViewConfiguration.getPressedStateDuration());\n                        } else if (!post(mUnsetPressedState)) {\n                            // If the post failed, unpress right now\n                            mUnsetPressedState.run();\n                        }\n\n                        removeTapCallback();\n                    }\n                    mIgnoreNextUpEvent = false;\n                    break;\n```\n\n所以onClick事件是在ACTION_UP中执行的\n\n而LongClick事件要看ACTION_DOWN了\n\n```java\n  case MotionEvent.ACTION_DOWN:\n                    mHasPerformedLongPress = false;\n\n                    if (performButtonActionOnTouchDown(event)) {\n                        break;\n                    }\n\n                    // Walk up the hierarchy to determine if we're inside a scrolling container.\n                    boolean isInScrollingContainer = isInScrollingContainer();\n\n                    // For views inside a scrolling container, delay the pressed feedback for\n                    // a short period in case this is a scroll.\n                    if (isInScrollingContainer) {\n                        mPrivateFlags |= PFLAG_PREPRESSED;\n                        if (mPendingCheckForTap == null) {\n                            mPendingCheckForTap = new CheckForTap();\n                        }\n                        mPendingCheckForTap.x = event.getX();\n                        mPendingCheckForTap.y = event.getY();\n                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());\n                    } else {\n                        // Not inside a scrolling container, so show the feedback right away\n                        setPressed(true, x, y);\n                        checkForLongClick(0, x, y);\n                    }\n                    break;\n```\n\n关键看checkForLongClick, 不贴代码了，结论是：在ACTION_DOWN事件被捕捉后，系统会开始触发一个postDelayed操作，delay的时间为\n\n> ```\n> ViewConfiguration.getLongPressTimeout() - delayOffset\n> ```\n\n（这个值在Eclair2.1上为500ms），500ms后会触发CheckForLongPress线程的执行：\n\n想想看，LongClick事件是在DOWN时开始计时，500ms假设，OnClick是在UP是发生，所以完全有可能同时发生OnClick和OnLongClick。这里看到当onLongClick的返回值为true时， *mHasPerformedLongPress* = true ,仔细看ACTION_UP中，如果HasPerformLongPress==true，就不会走到onClick事件里。所以在onLongClickListener里需要返回一个boolean值的原因就这么简单。\n\n```java\n if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n```\n\n接下来是OnTouchListener，直接上结论: onTouchListener里面的方法是在dispatchTouchEvent里面调用的，并且如果listener里面的onTouch返回true，事件将不会发送给onTouchEvent，因此OnTouchListener势必会优先级高于onClick和onLongClick。\n\n## VelocityTracker\n\n```java\nvelocityTracker = VelocityTracker.obtain()；\nvelocityTracker.addMovement(event);\nvelocityTracker.computeCurrentVelocity(1);  \nvelocityTracker.getXVelocity();\nvelocityTracker.recycle();\n```\n\n值得注意的是，VelocityTracker内部使用了大量的native方法，所以执行速度比java要快很多。\n\n### 实现Fling效果 \n\n```java\nprivate void onFling(float velocityX,float velocityY){\n  scroller.fling(getScrollX(),getScrollY(),(int)-velocityX\n                (int)-velocityY,minScrollX,maxScrollX,\n                minScrollY,maxScrollY);\n  invalidate();\n}\n@overdide// 这是每个View都有的方法\nprivate void computeScroll(){\n  if(scroller.isFinished()){\n    scroller.computeScrollOffset();\n    scrollTo(scroller.getCurrX(),scroller.getCurrY());\n    postInvalidateOnAnimation();\n  }\n}\n\n\n```\n\n### 捕获双击事件\n\n```java\npublic class MyView extends View {\n \nGestureDetector gestureDetector;\n \npublic MyView(Context context, AttributeSet attrs) {\n    super(context, attrs);\n            // creating new gesture detector \n    gestureDetector = new GestureDetector(context, new GestureListener());\n} \n \n// skipping measure calculation and drawing \n \n    // delegate the event to the gesture detector \n@Override \npublic boolean onTouchEvent(MotionEvent e) {\n    return gestureDetector.onTouchEvent(e);\n} \n \n \nprivate class GestureListener extends GestureDetector.SimpleOnGestureListener {\n \n    @Override \n    public boolean onDown(MotionEvent e) {\n        return true; \n    } \n    // event when double tap occurs \n    @Override \n    public boolean onDoubleTap(MotionEvent e) {\n        float x = e.getX();\n        float y = e.getY();\n \n        Log.d(\"Double Tap\", \"Tapped at: (\" + x + \",\" + y + \")\");\n \n        return true; \n    } \n} \n} \n```\n\n 最后是关于ViewConfiguration的一些常量获取的静态方法：\n\nint getScaledTouchSlop(); (if Math.abs(x*x+y*y)>mTouchSlop 就可以认为是滑动事件了)\n\n```java\n/**    \n  * 包含了方法和标准的常量用来设置UI的超时、大小和距离    \n  */ \n public class ViewConfiguration {     \n     // 设定水平滚动条的宽度和垂直滚动条的高度，单位是像素px     \n     private static final int SCROLL_BAR_SIZE = 10;     \n          \n     //定义滚动条逐渐消失的时间，单位是毫秒     \n     private static final int SCROLL_BAR_FADE_DURATION = 250;     \n          \n     // 默认的滚动条多少秒之后消失，单位是毫秒     \n     private static final int SCROLL_BAR_DEFAULT_DELAY = 300;     \n          \n     // 定义边缘地方褪色的长度     \n     private static final int FADING_EDGE_LENGTH = 12;     \n          \n     //定义子控件按下状态的持续事件     \n     private static final int PRESSED_STATE_DURATION = 125;     \n              \n     //定义一个按下状态转变成长按状态的转变时间     \n     private static final int LONG_PRESS_TIMEOUT = 500;     \n              \n     //定义用户在按住适当按钮，弹出全局的对话框的持续时间     \n     private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;     \n              \n     //定义一个touch事件中是点击事件还是一个滑动事件所需的时间，如果用户在这个时间之内滑动，那么就认为是一个点击事件     \n     private static final int TAP_TIMEOUT = 115;     \n              \n     /**    \n      * Defines the duration in milliseconds we will wait to see if a touch event     \n      * is a jump tap. If the user does not complete the jump tap within this interval, it is    \n      * considered to be a tap.     \n      */ \n     //定义一个touch事件时候是一个点击事件。如果用户在这个时间内没有完成这个点击，那么就认为是一个点击事件     \n     private static final int JUMP_TAP_TIMEOUT = 500;     \n          \n     //定义双击事件的间隔时间     \n     private static final int DOUBLE_TAP_TIMEOUT = 300;     \n              \n     //定义一个缩放控制反馈到用户界面的时间     \n     private static final int ZOOM_CONTROLS_TIMEOUT = 3000;     \n          \n     /**    \n      * Inset in pixels to look for touchable content when the user touches the edge of the screen    \n      */ \n     private static final int EDGE_SLOP = 12;     \n              \n     /**    \n      * Distance a touch can wander before we think the user is scrolling in pixels    \n      */ \n     private static final int TOUCH_SLOP = 16;     \n              \n     /**    \n      * Distance a touch can wander before we think the user is attempting a paged scroll    \n      * (in dips)    \n      */ \n     private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;     \n              \n     /**    \n      * Distance between the first touch and second touch to still be considered a double tap    \n      */ \n     private static final int DOUBLE_TAP_SLOP = 100;     \n              \n     /**    \n      * Distance a touch needs to be outside of a window's bounds for it to    \n      * count as outside for purposes of dismissing the window.    \n      */ \n     private static final int WINDOW_TOUCH_SLOP = 16;     \n          \n    //用来初始化fling的最小速度，单位是每秒多少像素     \n     private static final int MINIMUM_FLING_VELOCITY = 50;     \n              \n     //用来初始化fling的最大速度，单位是每秒多少像素     \n     private static final int MAXIMUM_FLING_VELOCITY = 4000;     \n          \n     //视图绘图缓存的最大尺寸，以字节表示。在ARGB888格式下，这个尺寸应至少等于屏幕的大小     \n     @Deprecated     \n     private static final int MAXIMUM_DRAWING_CACHE_SIZE = 320 * 480 * 4; // HVGA screen, ARGB8888     \n          \n     //flings和scrolls摩擦力度大小的系数     \n     private static float SCROLL_FRICTION = 0.015f;     \n          \n     /**    \n      * Max distance to over scroll for edge effects    \n      */ \n     private static final int OVERSCROLL_DISTANCE = 0;     \n          \n     /**    \n      * Max distance to over fling for edge effects    \n      */ \n     private static final int OVERFLING_DISTANCE = 4;     \n          \n }\n```\n\n\n\n\n\n- ## Reference\n\n1. [图解安卓事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)\n2. [making sense of the touch system](https://www.youtube.com/watch?v=usBaTHZdXSI)\n3. [Android onTouchEvent, onClick及onLongClick的调用机制](http://blog.csdn.net/ddna/article/details/5451722)\n4. [Android触摸事件机制(三)](http://wangkuiwu.github.io/2015/01/03/TouchEvent-View/)\n5. [ViewConfiguration用法](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0225/907.html)\n6. [触摸事件的分析与总结](http://glblong.blog.51cto.com/3058613/1559320)\n\n   ​","slug":"touch-event-distribution","published":1,"updated":"2017-04-23T10:52:50.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5gmdnm6003rbovrbwpjjuxd","content":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/dispatch_touch_event_video.JPG\" alt=\"\"></p>\n<p>图1 默认情况下事件传递的路径 </p>\n<blockquote>\n<p>Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。<br><a id=\"more\"></a></p>\n</blockquote>\n<ul>\n<li>首先来关注ACTION_DOWN，用户触摸屏幕，MotionEvent开始传递：</li>\n</ul>\n<blockquote>\n<ol>\n<li><p>Activity.dispatchTouchEvent</p>\n</li>\n<li><p>ViewGroup.dispatchTouchEvent</p>\n</li>\n<li><p>ViewGroup.onInterceptTouchEvent</p>\n<p>…..中间省略n个视图层级 ….&gt;&gt;&gt;</p>\n</li>\n<li><p>View.dispatchTouchEvent</p>\n</li>\n<li><p>View.onTouchEvent</p>\n</li>\n</ol>\n<p>​      ….中间省略n个视图层级….&gt;&gt;&gt;</p>\n<ol>\n<li>ViewGroup.onTouchEvent</li>\n<li>Activity.onTouchEvent</li>\n</ol>\n</blockquote>\n<p>这也就是本文最开始的图1内描述的内容，注意，在默认情况下(各个函数都返回super的情况下)才能将这个从上到下，再从下到上的循环走完整。这里讨论的还只是ACTION_DOWN。</p>\n<ul>\n<li><p>接下来看ACTION_DOWN下发过程中各个函数返回值对于整个传递链走向的影响，我们在override这些函数的时候，返回值无非三种：</p>\n<blockquote>\n<p>true , false ,super</p>\n</blockquote>\n<ul>\n<li>return true：ACTION_DOWN事件分发到此结束(消费掉)，这里有一个要注意的是onInterceptTouchEvent,返回true表示该ViewGroup打算将事件拦截下来，底层View将接收到一个ACTION_CANCEL，事件传递给该ViewGroup的onTouchEvent</li>\n<li>return false: 对于dispatchTouchEvent，返回false表明不再向下分发，ACTION_DOWN发送到上一层ViewGroup(Activity)的OnTouchEvent；对于onInterceptTouchEvent,返回false表明该ViewGroup不打算拦截，继续下发，对于onTouchEvent，返回false，事件继续上传至上一层级ViewGroup的OnTouchEvent 。</li>\n<li>return super : 完成整个传递链，就像图1中展示的一样。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/touch_event_1.png\" alt=\"\"></p>\n<p>图2 来自<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">图解安卓事件分发机制</a>  完美地解释了事件分发各个流程中返回值对于事件传递的影响。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/touch_event_2.png\" alt=\"\"></p>\n<p>图3 来自<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">图解安卓事件分发机制</a> </p>\n<p>接下来看ACTION_DOWN时返回值对于后续ACTION_MOVE,ACTION_UP等传递路径的影响：</p>\n<p>首先介绍概念：</p>\n<blockquote>\n<p>gesture = ACTION_DOWN+ a bounch of ACTIONS +ACTION_UP</p>\n</blockquote>\n<p>一个gesture(手势)即从手指按下到手指离开这段过程中所有的事件的集合,swipe,click,fling等等</p>\n<p>ACTION_DWON发生时，android将会在当前touch区域所有的View中确定一个Touch Target,后者将接管此次gesture中的所有ACTION_MOVE,ACTION_UP。（这样做有两点好处：1.一旦确定了Touch Target，系统将会把所有的后续事件全部传递到这个target为止，这就避免了复杂的view traversing，有助于提升性能; 2：传递链中第一个能够成为Touch Target的View将独立处理后续事件，不需要考虑其他View受到影响）。在在一个gesture开始时，OnTouchEvent（ACTION_DOWN）返回true,就意味着成为TouchTarget。借用简书<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">作者</a>的总结:</p>\n<blockquote>\n<p>ACTION_DOWN事件在哪个控件消费了（return true），  那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</p>\n</blockquote>\n<p>这里可以看到，事件依旧是从上往下一直分发到TouchTarget这一层，只是在TouchTarget这一层被消费了，<strong><em>且不再往上传递</em></strong>(有助于性能提升)。父ViewGroup的dispatchTouchEvent和onInterceptTouchEvent依旧会先于TouchTarget接收到ACTION_MOVE等事件。所以此时如果父ViewGroup在onInterceptTouchEvent中返回true，父ViewGroup将取代原有的子View成为新的ViewTarget,后续事件(ACTION_MOVE等)将传递到该父ViewGroup中，而子View将收到ACTION_CANCEL(可以在这里做一些恢复状态的工作，比如从foucused变成unfocused)。举一个例子：在ScrollView(不是Android自带的那个)中放一个Button，ACTION_DOWN时，BUTTON表示可以处理ACTION_DOWN,因为这可能会是一次click，于是Button就成了TouchTarget，后续事件将不会传递到ScrollView中，ScrollView也就无法滑动。为解决这个问题，在ScrollView的onInterceptTouchEvent中，如果看到ACTION_DWON，返回false(点击事件对于滑动毫无意义)，但如果看到ACTION_MOVE(滑动事件),返回true并成为新的TouchTarget。注意是在OnInterceptTouchEvent中拦截而不是dispatchTouchEvent中拦截，后者会将事件传递到上层ViewGroup的onTouchEvent中。想想看，不去dispatch了、、、android这种Api起名还是可以的。</p>\n<h3 id=\"onClick事件\"><a href=\"#onClick事件\" class=\"headerlink\" title=\"#onClick事件\"></a>#onClick事件</h3><p>接下来看onClick和onLongClick，onTouchListener这类事件何时触发</p>\n<p>首先是View的dispatchTouchEvent源码部分</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                    <span class=\"keyword\">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class=\"number\">0</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span> || prepressed) &#123;</div><div class=\"line\">                        <span class=\"comment\">// take focus if we don't have it already and we should in</span></div><div class=\"line\">                        <span class=\"comment\">// touch mode.</span></div><div class=\"line\">                        <span class=\"keyword\">boolean</span> focusTaken = <span class=\"keyword\">false</span>;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class=\"line\">                            focusTaken = requestFocus();</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (prepressed) &#123;</div><div class=\"line\">                            <span class=\"comment\">// The button is being released before we actually</span></div><div class=\"line\">                            <span class=\"comment\">// showed it as pressed.  Make it show the pressed</span></div><div class=\"line\">                            <span class=\"comment\">// state now (before scheduling the click) to ensure</span></div><div class=\"line\">                            <span class=\"comment\">// the user sees it.</span></div><div class=\"line\">                            setPressed(<span class=\"keyword\">true</span>, x, y);</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class=\"line\">                            <span class=\"comment\">// This is a tap, so remove the longpress check</span></div><div class=\"line\">                            removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                            <span class=\"comment\">// Only perform take click actions if we were in the pressed state</span></div><div class=\"line\">                            <span class=\"keyword\">if</span> (!focusTaken) &#123;</div><div class=\"line\">                                <span class=\"comment\">// Use a Runnable and post this rather than calling</span></div><div class=\"line\">                                <span class=\"comment\">// performClick directly. This lets other visual state</span></div><div class=\"line\">                                <span class=\"comment\">// of the view update before click actions start.</span></div><div class=\"line\">                                <span class=\"keyword\">if</span> (mPerformClick == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                    mPerformClick = <span class=\"keyword\">new</span> PerformClick();</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                    performClick();</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (mUnsetPressedState == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            mUnsetPressedState = <span class=\"keyword\">new</span> UnsetPressedState();</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (prepressed) &#123;</div><div class=\"line\">                            postDelayed(mUnsetPressedState,</div><div class=\"line\">                                    ViewConfiguration.getPressedStateDuration());</div><div class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!post(mUnsetPressedState)) &#123;</div><div class=\"line\">                            <span class=\"comment\">// If the post failed, unpress right now</span></div><div class=\"line\">                            mUnsetPressedState.run();</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        removeTapCallback();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div></pre></td></tr></table></figure>\n<p>所以onClick事件是在ACTION_UP中执行的</p>\n<p>而LongClick事件要看ACTION_DOWN了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">                  mHasPerformedLongPress = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">                  <span class=\"keyword\">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class=\"line\">                      <span class=\"keyword\">break</span>;</div><div class=\"line\">                  &#125;</div><div class=\"line\"></div><div class=\"line\">                  <span class=\"comment\">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class=\"line\">                  <span class=\"keyword\">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class=\"line\"></div><div class=\"line\">                  <span class=\"comment\">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class=\"line\">                  <span class=\"comment\">// a short period in case this is a scroll.</span></div><div class=\"line\">                  <span class=\"keyword\">if</span> (isInScrollingContainer) &#123;</div><div class=\"line\">                      mPrivateFlags |= PFLAG_PREPRESSED;</div><div class=\"line\">                      <span class=\"keyword\">if</span> (mPendingCheckForTap == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                          mPendingCheckForTap = <span class=\"keyword\">new</span> CheckForTap();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                      mPendingCheckForTap.x = event.getX();</div><div class=\"line\">                      mPendingCheckForTap.y = event.getY();</div><div class=\"line\">                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class=\"line\">                  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                      <span class=\"comment\">// Not inside a scrolling container, so show the feedback right away</span></div><div class=\"line\">                      setPressed(<span class=\"keyword\">true</span>, x, y);</div><div class=\"line\">                      checkForLongClick(<span class=\"number\">0</span>, x, y);</div><div class=\"line\">                  &#125;</div><div class=\"line\">                  <span class=\"keyword\">break</span>;</div></pre></td></tr></table></figure>\n<p>关键看checkForLongClick, 不贴代码了，结论是：在ACTION_DOWN事件被捕捉后，系统会开始触发一个postDelayed操作，delay的时间为</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; ViewConfiguration.getLongPressTimeout() - delayOffset</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<p>（这个值在Eclair2.1上为500ms），500ms后会触发CheckForLongPress线程的执行：</p>\n<p>想想看，LongClick事件是在DOWN时开始计时，500ms假设，OnClick是在UP是发生，所以完全有可能同时发生OnClick和OnLongClick。这里看到当onLongClick的返回值为true时， <em>mHasPerformedLongPress</em> = true ,仔细看ACTION_UP中，如果HasPerformLongPress==true，就不会走到onClick事件里。所以在onLongClickListener里需要返回一个boolean值的原因就这么简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class=\"line\">                           <span class=\"comment\">// This is a tap, so remove the longpress check</span></div><div class=\"line\">                           removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                           <span class=\"comment\">// Only perform take click actions if we were in the pressed state</span></div><div class=\"line\">                           <span class=\"keyword\">if</span> (!focusTaken) &#123;</div><div class=\"line\">                               <span class=\"comment\">// Use a Runnable and post this rather than calling</span></div><div class=\"line\">                               <span class=\"comment\">// performClick directly. This lets other visual state</span></div><div class=\"line\">                               <span class=\"comment\">// of the view update before click actions start.</span></div><div class=\"line\">                               <span class=\"keyword\">if</span> (mPerformClick == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                   mPerformClick = <span class=\"keyword\">new</span> PerformClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                               <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                   performClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div></pre></td></tr></table></figure>\n<p>接下来是OnTouchListener，直接上结论: onTouchListener里面的方法是在dispatchTouchEvent里面调用的，并且如果listener里面的onTouch返回true，事件将不会发送给onTouchEvent，因此OnTouchListener势必会优先级高于onClick和onLongClick。</p>\n<h2 id=\"VelocityTracker\"><a href=\"#VelocityTracker\" class=\"headerlink\" title=\"VelocityTracker\"></a>VelocityTracker</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">velocityTracker = VelocityTracker.obtain()；</div><div class=\"line\">velocityTracker.addMovement(event);</div><div class=\"line\">velocityTracker.computeCurrentVelocity(<span class=\"number\">1</span>);  </div><div class=\"line\">velocityTracker.getXVelocity();</div><div class=\"line\">velocityTracker.recycle();</div></pre></td></tr></table></figure>\n<p>值得注意的是，VelocityTracker内部使用了大量的native方法，所以执行速度比java要快很多。</p>\n<h3 id=\"实现Fling效果\"><a href=\"#实现Fling效果\" class=\"headerlink\" title=\"实现Fling效果\"></a>实现Fling效果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onFling</span><span class=\"params\">(<span class=\"keyword\">float</span> velocityX,<span class=\"keyword\">float</span> velocityY)</span></span>&#123;</div><div class=\"line\">  scroller.fling(getScrollX(),getScrollY(),(<span class=\"keyword\">int</span>)-velocityX</div><div class=\"line\">                (<span class=\"keyword\">int</span>)-velocityY,minScrollX,maxScrollX,</div><div class=\"line\">                minScrollY,maxScrollY);</div><div class=\"line\">  invalidate();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\">@overdide</span><span class=\"comment\">// 这是每个View都有的方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(scroller.isFinished())&#123;</div><div class=\"line\">    scroller.computeScrollOffset();</div><div class=\"line\">    scrollTo(scroller.getCurrX(),scroller.getCurrY());</div><div class=\"line\">    postInvalidateOnAnimation();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"捕获双击事件\"><a href=\"#捕获双击事件\" class=\"headerlink\" title=\"捕获双击事件\"></a>捕获双击事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">GestureDetector gestureDetector;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">            <span class=\"comment\">// creating new gesture detector </span></div><div class=\"line\">    gestureDetector = <span class=\"keyword\">new</span> GestureDetector(context, <span class=\"keyword\">new</span> GestureListener());</div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// skipping measure calculation and drawing </span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// delegate the event to the gesture detector </span></div><div class=\"line\"><span class=\"meta\">@Override</span> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gestureDetector.onTouchEvent(e);</div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GestureListener</span> <span class=\"keyword\">extends</span> <span class=\"title\">GestureDetector</span>.<span class=\"title\">SimpleOnGestureListener</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onDown</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// event when double tap occurs </span></div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onDoubleTap</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">float</span> x = e.getX();</div><div class=\"line\">        <span class=\"keyword\">float</span> y = e.getY();</div><div class=\"line\"> </div><div class=\"line\">        Log.d(<span class=\"string\">\"Double Tap\"</span>, <span class=\"string\">\"Tapped at: (\"</span> + x + <span class=\"string\">\",\"</span> + y + <span class=\"string\">\")\"</span>);</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 最后是关于ViewConfiguration的一些常量获取的静态方法：</p>\n<p>int getScaledTouchSlop(); (if Math.abs(x<em>x+y</em>y)&gt;mTouchSlop 就可以认为是滑动事件了)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**    </div><div class=\"line\">  * 包含了方法和标准的常量用来设置UI的超时、大小和距离    </div><div class=\"line\">  */</span> </div><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewConfiguration</span> </span>&#123;     </div><div class=\"line\">     <span class=\"comment\">// 设定水平滚动条的宽度和垂直滚动条的高度，单位是像素px     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SCROLL_BAR_SIZE = <span class=\"number\">10</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//定义滚动条逐渐消失的时间，单位是毫秒     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SCROLL_BAR_FADE_DURATION = <span class=\"number\">250</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">// 默认的滚动条多少秒之后消失，单位是毫秒     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SCROLL_BAR_DEFAULT_DELAY = <span class=\"number\">300</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">// 定义边缘地方褪色的长度     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FADING_EDGE_LENGTH = <span class=\"number\">12</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//定义子控件按下状态的持续事件     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PRESSED_STATE_DURATION = <span class=\"number\">125</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义一个按下状态转变成长按状态的转变时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LONG_PRESS_TIMEOUT = <span class=\"number\">500</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义用户在按住适当按钮，弹出全局的对话框的持续时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> GLOBAL_ACTIONS_KEY_TIMEOUT = <span class=\"number\">500</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义一个touch事件中是点击事件还是一个滑动事件所需的时间，如果用户在这个时间之内滑动，那么就认为是一个点击事件     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TAP_TIMEOUT = <span class=\"number\">115</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Defines the duration in milliseconds we will wait to see if a touch event     </div><div class=\"line\">      * is a jump tap. If the user does not complete the jump tap within this interval, it is    </div><div class=\"line\">      * considered to be a tap.     </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"comment\">//定义一个touch事件时候是一个点击事件。如果用户在这个时间内没有完成这个点击，那么就认为是一个点击事件     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> JUMP_TAP_TIMEOUT = <span class=\"number\">500</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//定义双击事件的间隔时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DOUBLE_TAP_TIMEOUT = <span class=\"number\">300</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义一个缩放控制反馈到用户界面的时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ZOOM_CONTROLS_TIMEOUT = <span class=\"number\">3000</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Inset in pixels to look for touchable content when the user touches the edge of the screen    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EDGE_SLOP = <span class=\"number\">12</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance a touch can wander before we think the user is scrolling in pixels    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TOUCH_SLOP = <span class=\"number\">16</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance a touch can wander before we think the user is attempting a paged scroll    </div><div class=\"line\">      * (in dips)    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PAGING_TOUCH_SLOP = TOUCH_SLOP * <span class=\"number\">2</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance between the first touch and second touch to still be considered a double tap    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DOUBLE_TAP_SLOP = <span class=\"number\">100</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance a touch needs to be outside of a window's bounds for it to    </div><div class=\"line\">      * count as outside for purposes of dismissing the window.    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WINDOW_TOUCH_SLOP = <span class=\"number\">16</span>;     </div><div class=\"line\">          </div><div class=\"line\">    <span class=\"comment\">//用来初始化fling的最小速度，单位是每秒多少像素     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MINIMUM_FLING_VELOCITY = <span class=\"number\">50</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//用来初始化fling的最大速度，单位是每秒多少像素     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_FLING_VELOCITY = <span class=\"number\">4000</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//视图绘图缓存的最大尺寸，以字节表示。在ARGB888格式下，这个尺寸应至少等于屏幕的大小     </span></div><div class=\"line\">     <span class=\"meta\">@Deprecated</span>     </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_DRAWING_CACHE_SIZE = <span class=\"number\">320</span> * <span class=\"number\">480</span> * <span class=\"number\">4</span>; <span class=\"comment\">// HVGA screen, ARGB8888     </span></div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//flings和scrolls摩擦力度大小的系数     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">float</span> SCROLL_FRICTION = <span class=\"number\">0.015f</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Max distance to over scroll for edge effects    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OVERSCROLL_DISTANCE = <span class=\"number\">0</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Max distance to over fling for edge effects    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OVERFLING_DISTANCE = <span class=\"number\">4</span>;     </div><div class=\"line\">          </div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2></li>\n</ul>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">图解安卓事件分发机制</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=usBaTHZdXSI\">making sense of the touch system</a></li>\n<li><a href=\"http://blog.csdn.net/ddna/article/details/5451722\">Android onTouchEvent, onClick及onLongClick的调用机制</a></li>\n<li><a href=\"http://wangkuiwu.github.io/2015/01/03/TouchEvent-View/\">Android触摸事件机制(三)</a></li>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0225/907.html\">ViewConfiguration用法</a></li>\n<li><p><a href=\"http://glblong.blog.51cto.com/3058613/1559320\">触摸事件的分析与总结</a></p>\n<p>​</p>\n</li>\n</ol>\n","excerpt":"<p><img src=\"http://odzl05jxx.bkt.clouddn.com/dispatch_touch_event_video.JPG\" alt=\"\"></p>\n<p>图1 默认情况下事件传递的路径 </p>\n<blockquote>\n<p>Touch事件始于ACTION_DOWN, 终止于ACTION_UP, 这其中可能会伴随着ACTION_MOVE,ACTION_CANCEL等等。<br>","more":"</p>\n</blockquote>\n<ul>\n<li>首先来关注ACTION_DOWN，用户触摸屏幕，MotionEvent开始传递：</li>\n</ul>\n<blockquote>\n<ol>\n<li><p>Activity.dispatchTouchEvent</p>\n</li>\n<li><p>ViewGroup.dispatchTouchEvent</p>\n</li>\n<li><p>ViewGroup.onInterceptTouchEvent</p>\n<p>…..中间省略n个视图层级 ….&gt;&gt;&gt;</p>\n</li>\n<li><p>View.dispatchTouchEvent</p>\n</li>\n<li><p>View.onTouchEvent</p>\n</li>\n</ol>\n<p>​      ….中间省略n个视图层级….&gt;&gt;&gt;</p>\n<ol>\n<li>ViewGroup.onTouchEvent</li>\n<li>Activity.onTouchEvent</li>\n</ol>\n</blockquote>\n<p>这也就是本文最开始的图1内描述的内容，注意，在默认情况下(各个函数都返回super的情况下)才能将这个从上到下，再从下到上的循环走完整。这里讨论的还只是ACTION_DOWN。</p>\n<ul>\n<li><p>接下来看ACTION_DOWN下发过程中各个函数返回值对于整个传递链走向的影响，我们在override这些函数的时候，返回值无非三种：</p>\n<blockquote>\n<p>true , false ,super</p>\n</blockquote>\n<ul>\n<li>return true：ACTION_DOWN事件分发到此结束(消费掉)，这里有一个要注意的是onInterceptTouchEvent,返回true表示该ViewGroup打算将事件拦截下来，底层View将接收到一个ACTION_CANCEL，事件传递给该ViewGroup的onTouchEvent</li>\n<li>return false: 对于dispatchTouchEvent，返回false表明不再向下分发，ACTION_DOWN发送到上一层ViewGroup(Activity)的OnTouchEvent；对于onInterceptTouchEvent,返回false表明该ViewGroup不打算拦截，继续下发，对于onTouchEvent，返回false，事件继续上传至上一层级ViewGroup的OnTouchEvent 。</li>\n<li>return super : 完成整个传递链，就像图1中展示的一样。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/touch_event_1.png\" alt=\"\"></p>\n<p>图2 来自<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">图解安卓事件分发机制</a>  完美地解释了事件分发各个流程中返回值对于事件传递的影响。</p>\n<p><img src=\"http://odzl05jxx.bkt.clouddn.com/touch_event_2.png\" alt=\"\"></p>\n<p>图3 来自<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">图解安卓事件分发机制</a> </p>\n<p>接下来看ACTION_DOWN时返回值对于后续ACTION_MOVE,ACTION_UP等传递路径的影响：</p>\n<p>首先介绍概念：</p>\n<blockquote>\n<p>gesture = ACTION_DOWN+ a bounch of ACTIONS +ACTION_UP</p>\n</blockquote>\n<p>一个gesture(手势)即从手指按下到手指离开这段过程中所有的事件的集合,swipe,click,fling等等</p>\n<p>ACTION_DWON发生时，android将会在当前touch区域所有的View中确定一个Touch Target,后者将接管此次gesture中的所有ACTION_MOVE,ACTION_UP。（这样做有两点好处：1.一旦确定了Touch Target，系统将会把所有的后续事件全部传递到这个target为止，这就避免了复杂的view traversing，有助于提升性能; 2：传递链中第一个能够成为Touch Target的View将独立处理后续事件，不需要考虑其他View受到影响）。在在一个gesture开始时，OnTouchEvent（ACTION_DOWN）返回true,就意味着成为TouchTarget。借用简书<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">作者</a>的总结:</p>\n<blockquote>\n<p>ACTION_DOWN事件在哪个控件消费了（return true），  那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</p>\n</blockquote>\n<p>这里可以看到，事件依旧是从上往下一直分发到TouchTarget这一层，只是在TouchTarget这一层被消费了，<strong><em>且不再往上传递</em></strong>(有助于性能提升)。父ViewGroup的dispatchTouchEvent和onInterceptTouchEvent依旧会先于TouchTarget接收到ACTION_MOVE等事件。所以此时如果父ViewGroup在onInterceptTouchEvent中返回true，父ViewGroup将取代原有的子View成为新的ViewTarget,后续事件(ACTION_MOVE等)将传递到该父ViewGroup中，而子View将收到ACTION_CANCEL(可以在这里做一些恢复状态的工作，比如从foucused变成unfocused)。举一个例子：在ScrollView(不是Android自带的那个)中放一个Button，ACTION_DOWN时，BUTTON表示可以处理ACTION_DOWN,因为这可能会是一次click，于是Button就成了TouchTarget，后续事件将不会传递到ScrollView中，ScrollView也就无法滑动。为解决这个问题，在ScrollView的onInterceptTouchEvent中，如果看到ACTION_DWON，返回false(点击事件对于滑动毫无意义)，但如果看到ACTION_MOVE(滑动事件),返回true并成为新的TouchTarget。注意是在OnInterceptTouchEvent中拦截而不是dispatchTouchEvent中拦截，后者会将事件传递到上层ViewGroup的onTouchEvent中。想想看，不去dispatch了、、、android这种Api起名还是可以的。</p>\n<h3 id=\"onClick事件\"><a href=\"#onClick事件\" class=\"headerlink\" title=\"#onClick事件\"></a>#onClick事件</h3><p>接下来看onClick和onLongClick，onTouchListener这类事件何时触发</p>\n<p>首先是View的dispatchTouchEvent源码部分</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                    <span class=\"keyword\">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class=\"number\">0</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span> || prepressed) &#123;</div><div class=\"line\">                        <span class=\"comment\">// take focus if we don't have it already and we should in</span></div><div class=\"line\">                        <span class=\"comment\">// touch mode.</span></div><div class=\"line\">                        <span class=\"keyword\">boolean</span> focusTaken = <span class=\"keyword\">false</span>;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class=\"line\">                            focusTaken = requestFocus();</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (prepressed) &#123;</div><div class=\"line\">                            <span class=\"comment\">// The button is being released before we actually</span></div><div class=\"line\">                            <span class=\"comment\">// showed it as pressed.  Make it show the pressed</span></div><div class=\"line\">                            <span class=\"comment\">// state now (before scheduling the click) to ensure</span></div><div class=\"line\">                            <span class=\"comment\">// the user sees it.</span></div><div class=\"line\">                            setPressed(<span class=\"keyword\">true</span>, x, y);</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class=\"line\">                            <span class=\"comment\">// This is a tap, so remove the longpress check</span></div><div class=\"line\">                            removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                            <span class=\"comment\">// Only perform take click actions if we were in the pressed state</span></div><div class=\"line\">                            <span class=\"keyword\">if</span> (!focusTaken) &#123;</div><div class=\"line\">                                <span class=\"comment\">// Use a Runnable and post this rather than calling</span></div><div class=\"line\">                                <span class=\"comment\">// performClick directly. This lets other visual state</span></div><div class=\"line\">                                <span class=\"comment\">// of the view update before click actions start.</span></div><div class=\"line\">                                <span class=\"keyword\">if</span> (mPerformClick == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                    mPerformClick = <span class=\"keyword\">new</span> PerformClick();</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                    performClick();</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (mUnsetPressedState == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            mUnsetPressedState = <span class=\"keyword\">new</span> UnsetPressedState();</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span> (prepressed) &#123;</div><div class=\"line\">                            postDelayed(mUnsetPressedState,</div><div class=\"line\">                                    ViewConfiguration.getPressedStateDuration());</div><div class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!post(mUnsetPressedState)) &#123;</div><div class=\"line\">                            <span class=\"comment\">// If the post failed, unpress right now</span></div><div class=\"line\">                            mUnsetPressedState.run();</div><div class=\"line\">                        &#125;</div><div class=\"line\"></div><div class=\"line\">                        removeTapCallback();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div></pre></td></tr></table></figure>\n<p>所以onClick事件是在ACTION_UP中执行的</p>\n<p>而LongClick事件要看ACTION_DOWN了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">                  mHasPerformedLongPress = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">                  <span class=\"keyword\">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class=\"line\">                      <span class=\"keyword\">break</span>;</div><div class=\"line\">                  &#125;</div><div class=\"line\"></div><div class=\"line\">                  <span class=\"comment\">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class=\"line\">                  <span class=\"keyword\">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class=\"line\"></div><div class=\"line\">                  <span class=\"comment\">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class=\"line\">                  <span class=\"comment\">// a short period in case this is a scroll.</span></div><div class=\"line\">                  <span class=\"keyword\">if</span> (isInScrollingContainer) &#123;</div><div class=\"line\">                      mPrivateFlags |= PFLAG_PREPRESSED;</div><div class=\"line\">                      <span class=\"keyword\">if</span> (mPendingCheckForTap == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                          mPendingCheckForTap = <span class=\"keyword\">new</span> CheckForTap();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                      mPendingCheckForTap.x = event.getX();</div><div class=\"line\">                      mPendingCheckForTap.y = event.getY();</div><div class=\"line\">                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class=\"line\">                  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                      <span class=\"comment\">// Not inside a scrolling container, so show the feedback right away</span></div><div class=\"line\">                      setPressed(<span class=\"keyword\">true</span>, x, y);</div><div class=\"line\">                      checkForLongClick(<span class=\"number\">0</span>, x, y);</div><div class=\"line\">                  &#125;</div><div class=\"line\">                  <span class=\"keyword\">break</span>;</div></pre></td></tr></table></figure>\n<p>关键看checkForLongClick, 不贴代码了，结论是：在ACTION_DOWN事件被捕捉后，系统会开始触发一个postDelayed操作，delay的时间为</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; ViewConfiguration.getLongPressTimeout() - delayOffset</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<p>（这个值在Eclair2.1上为500ms），500ms后会触发CheckForLongPress线程的执行：</p>\n<p>想想看，LongClick事件是在DOWN时开始计时，500ms假设，OnClick是在UP是发生，所以完全有可能同时发生OnClick和OnLongClick。这里看到当onLongClick的返回值为true时， <em>mHasPerformedLongPress</em> = true ,仔细看ACTION_UP中，如果HasPerformLongPress==true，就不会走到onClick事件里。所以在onLongClickListener里需要返回一个boolean值的原因就这么简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class=\"line\">                           <span class=\"comment\">// This is a tap, so remove the longpress check</span></div><div class=\"line\">                           removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                           <span class=\"comment\">// Only perform take click actions if we were in the pressed state</span></div><div class=\"line\">                           <span class=\"keyword\">if</span> (!focusTaken) &#123;</div><div class=\"line\">                               <span class=\"comment\">// Use a Runnable and post this rather than calling</span></div><div class=\"line\">                               <span class=\"comment\">// performClick directly. This lets other visual state</span></div><div class=\"line\">                               <span class=\"comment\">// of the view update before click actions start.</span></div><div class=\"line\">                               <span class=\"keyword\">if</span> (mPerformClick == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                                   mPerformClick = <span class=\"keyword\">new</span> PerformClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                               <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                   performClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div></pre></td></tr></table></figure>\n<p>接下来是OnTouchListener，直接上结论: onTouchListener里面的方法是在dispatchTouchEvent里面调用的，并且如果listener里面的onTouch返回true，事件将不会发送给onTouchEvent，因此OnTouchListener势必会优先级高于onClick和onLongClick。</p>\n<h2 id=\"VelocityTracker\"><a href=\"#VelocityTracker\" class=\"headerlink\" title=\"VelocityTracker\"></a>VelocityTracker</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">velocityTracker = VelocityTracker.obtain()；</div><div class=\"line\">velocityTracker.addMovement(event);</div><div class=\"line\">velocityTracker.computeCurrentVelocity(<span class=\"number\">1</span>);  </div><div class=\"line\">velocityTracker.getXVelocity();</div><div class=\"line\">velocityTracker.recycle();</div></pre></td></tr></table></figure>\n<p>值得注意的是，VelocityTracker内部使用了大量的native方法，所以执行速度比java要快很多。</p>\n<h3 id=\"实现Fling效果\"><a href=\"#实现Fling效果\" class=\"headerlink\" title=\"实现Fling效果\"></a>实现Fling效果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onFling</span><span class=\"params\">(<span class=\"keyword\">float</span> velocityX,<span class=\"keyword\">float</span> velocityY)</span></span>&#123;</div><div class=\"line\">  scroller.fling(getScrollX(),getScrollY(),(<span class=\"keyword\">int</span>)-velocityX</div><div class=\"line\">                (<span class=\"keyword\">int</span>)-velocityY,minScrollX,maxScrollX,</div><div class=\"line\">                minScrollY,maxScrollY);</div><div class=\"line\">  invalidate();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\">@overdide</span><span class=\"comment\">// 这是每个View都有的方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(scroller.isFinished())&#123;</div><div class=\"line\">    scroller.computeScrollOffset();</div><div class=\"line\">    scrollTo(scroller.getCurrX(),scroller.getCurrY());</div><div class=\"line\">    postInvalidateOnAnimation();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"捕获双击事件\"><a href=\"#捕获双击事件\" class=\"headerlink\" title=\"捕获双击事件\"></a>捕获双击事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">GestureDetector gestureDetector;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">            <span class=\"comment\">// creating new gesture detector </span></div><div class=\"line\">    gestureDetector = <span class=\"keyword\">new</span> GestureDetector(context, <span class=\"keyword\">new</span> GestureListener());</div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// skipping measure calculation and drawing </span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// delegate the event to the gesture detector </span></div><div class=\"line\"><span class=\"meta\">@Override</span> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gestureDetector.onTouchEvent(e);</div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GestureListener</span> <span class=\"keyword\">extends</span> <span class=\"title\">GestureDetector</span>.<span class=\"title\">SimpleOnGestureListener</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onDown</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// event when double tap occurs </span></div><div class=\"line\">    <span class=\"meta\">@Override</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onDoubleTap</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">float</span> x = e.getX();</div><div class=\"line\">        <span class=\"keyword\">float</span> y = e.getY();</div><div class=\"line\"> </div><div class=\"line\">        Log.d(<span class=\"string\">\"Double Tap\"</span>, <span class=\"string\">\"Tapped at: (\"</span> + x + <span class=\"string\">\",\"</span> + y + <span class=\"string\">\")\"</span>);</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 最后是关于ViewConfiguration的一些常量获取的静态方法：</p>\n<p>int getScaledTouchSlop(); (if Math.abs(x<em>x+y</em>y)&gt;mTouchSlop 就可以认为是滑动事件了)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**    </div><div class=\"line\">  * 包含了方法和标准的常量用来设置UI的超时、大小和距离    </div><div class=\"line\">  */</span> </div><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewConfiguration</span> </span>&#123;     </div><div class=\"line\">     <span class=\"comment\">// 设定水平滚动条的宽度和垂直滚动条的高度，单位是像素px     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SCROLL_BAR_SIZE = <span class=\"number\">10</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//定义滚动条逐渐消失的时间，单位是毫秒     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SCROLL_BAR_FADE_DURATION = <span class=\"number\">250</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">// 默认的滚动条多少秒之后消失，单位是毫秒     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SCROLL_BAR_DEFAULT_DELAY = <span class=\"number\">300</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">// 定义边缘地方褪色的长度     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FADING_EDGE_LENGTH = <span class=\"number\">12</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//定义子控件按下状态的持续事件     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PRESSED_STATE_DURATION = <span class=\"number\">125</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义一个按下状态转变成长按状态的转变时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LONG_PRESS_TIMEOUT = <span class=\"number\">500</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义用户在按住适当按钮，弹出全局的对话框的持续时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> GLOBAL_ACTIONS_KEY_TIMEOUT = <span class=\"number\">500</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义一个touch事件中是点击事件还是一个滑动事件所需的时间，如果用户在这个时间之内滑动，那么就认为是一个点击事件     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TAP_TIMEOUT = <span class=\"number\">115</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Defines the duration in milliseconds we will wait to see if a touch event     </div><div class=\"line\">      * is a jump tap. If the user does not complete the jump tap within this interval, it is    </div><div class=\"line\">      * considered to be a tap.     </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"comment\">//定义一个touch事件时候是一个点击事件。如果用户在这个时间内没有完成这个点击，那么就认为是一个点击事件     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> JUMP_TAP_TIMEOUT = <span class=\"number\">500</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//定义双击事件的间隔时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DOUBLE_TAP_TIMEOUT = <span class=\"number\">300</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//定义一个缩放控制反馈到用户界面的时间     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ZOOM_CONTROLS_TIMEOUT = <span class=\"number\">3000</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Inset in pixels to look for touchable content when the user touches the edge of the screen    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EDGE_SLOP = <span class=\"number\">12</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance a touch can wander before we think the user is scrolling in pixels    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TOUCH_SLOP = <span class=\"number\">16</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance a touch can wander before we think the user is attempting a paged scroll    </div><div class=\"line\">      * (in dips)    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PAGING_TOUCH_SLOP = TOUCH_SLOP * <span class=\"number\">2</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance between the first touch and second touch to still be considered a double tap    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DOUBLE_TAP_SLOP = <span class=\"number\">100</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Distance a touch needs to be outside of a window's bounds for it to    </div><div class=\"line\">      * count as outside for purposes of dismissing the window.    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WINDOW_TOUCH_SLOP = <span class=\"number\">16</span>;     </div><div class=\"line\">          </div><div class=\"line\">    <span class=\"comment\">//用来初始化fling的最小速度，单位是每秒多少像素     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MINIMUM_FLING_VELOCITY = <span class=\"number\">50</span>;     </div><div class=\"line\">              </div><div class=\"line\">     <span class=\"comment\">//用来初始化fling的最大速度，单位是每秒多少像素     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_FLING_VELOCITY = <span class=\"number\">4000</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//视图绘图缓存的最大尺寸，以字节表示。在ARGB888格式下，这个尺寸应至少等于屏幕的大小     </span></div><div class=\"line\">     <span class=\"meta\">@Deprecated</span>     </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_DRAWING_CACHE_SIZE = <span class=\"number\">320</span> * <span class=\"number\">480</span> * <span class=\"number\">4</span>; <span class=\"comment\">// HVGA screen, ARGB8888     </span></div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">//flings和scrolls摩擦力度大小的系数     </span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">float</span> SCROLL_FRICTION = <span class=\"number\">0.015f</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Max distance to over scroll for edge effects    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OVERSCROLL_DISTANCE = <span class=\"number\">0</span>;     </div><div class=\"line\">          </div><div class=\"line\">     <span class=\"comment\">/**    </div><div class=\"line\">      * Max distance to over fling for edge effects    </div><div class=\"line\">      */</span> </div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> OVERFLING_DISTANCE = <span class=\"number\">4</span>;     </div><div class=\"line\">          </div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2></li>\n</ul>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/e99b5e8bd67b\">图解安卓事件分发机制</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=usBaTHZdXSI\">making sense of the touch system</a></li>\n<li><a href=\"http://blog.csdn.net/ddna/article/details/5451722\">Android onTouchEvent, onClick及onLongClick的调用机制</a></li>\n<li><a href=\"http://wangkuiwu.github.io/2015/01/03/TouchEvent-View/\">Android触摸事件机制(三)</a></li>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0225/907.html\">ViewConfiguration用法</a></li>\n<li><p><a href=\"http://glblong.blog.51cto.com/3058613/1559320\">触摸事件的分析与总结</a></p>\n<p>​</p>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj5gmdnft0005bovrncyjp95g","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdng8000bbovrlp9k30ve"},{"post_id":"cj5gmdnf20000bovr9lqjkcld","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdngg000gbovrn4tjyet2"},{"post_id":"cj5gmdnfz0006bovrsy7njntt","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdngj000jbovre3bp52gz"},{"post_id":"cj5gmdng5000abovricu47aor","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdngm000mbovr7l0mgss5"},{"post_id":"cj5gmdnfb0001bovr110mk9q8","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdngp000pbovriy3x6iin"},{"post_id":"cj5gmdng9000cbovrtqnav23x","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdngu000tbovrr3pt32c5"},{"post_id":"cj5gmdngg000hbovra5oyctag","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdngy000wbovrlxmmmy57"},{"post_id":"cj5gmdnfq0004bovrzfeyiz2t","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnh6000ybovrv76qv1f5"},{"post_id":"cj5gmdngk000kbovr28k0jx8g","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnha0011bovrq2jrd7ix"},{"post_id":"cj5gmdngn000nbovrklqt6f62","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnhd0013bovryjhihg4h"},{"post_id":"cj5gmdngv000ubovrg72z1acl","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnhk0016bovrrc8236ds"},{"post_id":"cj5gmdnh0000xbovrlgomfb61","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnhr0019bovre9up2hi1"},{"post_id":"cj5gmdnh80010bovr38nskbjn","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnhx001dbovror4ccuhd"},{"post_id":"cj5gmdnhb0012bovry5kxogrt","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdni2001gbovryqy6rj39"},{"post_id":"cj5gmdnhe0014bovrmpflooe5","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnia001kbovrskb1gfqu"},{"post_id":"cj5gmdnhm0018bovrou42i4yn","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnif001nbovrp78bcs16"},{"post_id":"cj5gmdnhs001bbovri4b6e8d2","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnik001qbovrkvhq5wig"},{"post_id":"cj5gmdnhz001fbovriuud50uy","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnin001tbovrm0jfe9ao"},{"post_id":"cj5gmdnib001mbovr580nuzpn","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnis001xbovrt99ymehj"},{"post_id":"cj5gmdnig001obovrmvw331y2","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnj10020bovrpnvdaf88"},{"post_id":"cj5gmdnik001rbovrwuif7ghh","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnj50023bovrxw35p28d"},{"post_id":"cj5gmdnio001ubovrtusk6yvj","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnjd0027bovrzgggsqax"},{"post_id":"cj5gmdniu001ybovrqs4aj4rx","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnji002abovr0frlltzp"},{"post_id":"cj5gmdnj70025bovr8z9w2k8y","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnjo002ebovrz8mqgz02"},{"post_id":"cj5gmdnjt002hbovrx0hr12kk","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnk8002obovrfjiuvl5l"},{"post_id":"cj5gmdnkk002zbovrcwx4iqcn","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnkw0034bovrs7b32vlm"},{"post_id":"cj5gmdnkx0035bovrh3ue0ugc","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnl7003cbovr33cye1mb"},{"post_id":"cj5gmdnl00037bovrogi1a5sh","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnlc003gbovratwkwozt"},{"post_id":"cj5gmdnl3003abovr5zyvgge2","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnlu003jbovrj029r5p3"},{"post_id":"cj5gmdnl7003dbovrsbk0n8o8","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnm0003nbovr6mkzl0a9"},{"post_id":"cj5gmdnlc003hbovrn6hponqd","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnm6003qbovrkxs6kobs"},{"post_id":"cj5gmdnlw003kbovrpa12cp6i","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnm9003ubovrzyrpz99u"},{"post_id":"cj5gmdnm2003obovrm5qeb5xa","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnmb003wbovrcgz8p20h"},{"post_id":"cj5gmdnm6003rbovrbwpjjuxd","category_id":"cj5gmdnfg0002bovr9mpbrh45","_id":"cj5gmdnmd003zbovrro7lptxo"}],"PostTag":[{"post_id":"cj5gmdnf20000bovr9lqjkcld","tag_id":"cj5gmdnfo0003bovrloukv39y","_id":"cj5gmdng40009bovr075uz519"},{"post_id":"cj5gmdng5000abovricu47aor","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdngg000fbovropz6gwd6"},{"post_id":"cj5gmdng9000cbovrtqnav23x","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdngj000ibovrcgcioiko"},{"post_id":"cj5gmdnfb0001bovr110mk9q8","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdngo000obovrg34pivac"},{"post_id":"cj5gmdnfb0001bovr110mk9q8","tag_id":"cj5gmdngf000ebovrga7v0hi1","_id":"cj5gmdngs000rbovrhcbboist"},{"post_id":"cj5gmdngn000nbovrklqt6f62","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdngx000vbovr2d6odss9"},{"post_id":"cj5gmdnfq0004bovrzfeyiz2t","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnhk0017bovrle1jv0pv"},{"post_id":"cj5gmdnfq0004bovrzfeyiz2t","tag_id":"cj5gmdngt000sbovrkxm50lmd","_id":"cj5gmdnhr001abovrdyp1y0td"},{"post_id":"cj5gmdnfq0004bovrzfeyiz2t","tag_id":"cj5gmdnh7000zbovrg6000z3p","_id":"cj5gmdnhy001ebovrjzjw6v2c"},{"post_id":"cj5gmdnhm0018bovrou42i4yn","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdni2001hbovrwsuoh8w1"},{"post_id":"cj5gmdnft0005bovrncyjp95g","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnia001lbovr5ta8e5oz"},{"post_id":"cj5gmdnfz0006bovrsy7njntt","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnim001sbovr28cva4xr"},{"post_id":"cj5gmdnfz0006bovrsy7njntt","tag_id":"cj5gmdni8001jbovrmyli4304","_id":"cj5gmdnir001vbovrhwlrcvnm"},{"post_id":"cj5gmdngg000hbovra5oyctag","tag_id":"cj5gmdnij001pbovrtsnlww0h","_id":"cj5gmdnj1001zbovr80hasb3e"},{"post_id":"cj5gmdniu001ybovrqs4aj4rx","tag_id":"cj5gmdnis001wbovrtdj0zy83","_id":"cj5gmdnj50022bovrq97de62z"},{"post_id":"cj5gmdngk000kbovr28k0jx8g","tag_id":"cj5gmdnis001wbovrtdj0zy83","_id":"cj5gmdnjd0026bovrjpww8bmv"},{"post_id":"cj5gmdnj70025bovr8z9w2k8y","tag_id":"cj5gmdnis001wbovrtdj0zy83","_id":"cj5gmdnji0029bovrbh83rkur"},{"post_id":"cj5gmdnje0028bovrtvlmibzo","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnjn002dbovr8637xxea"},{"post_id":"cj5gmdngq000qbovrbor67fgb","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnjr002gbovrpwt623fz"},{"post_id":"cj5gmdngq000qbovrbor67fgb","tag_id":"cj5gmdnj60024bovrmpqnu2y9","_id":"cj5gmdnjx002jbovrf6fdhark"},{"post_id":"cj5gmdnjo002fbovrdwig0wvk","tag_id":"cj5gmdnis001wbovrtdj0zy83","_id":"cj5gmdnk2002lbovrppgtmj5l"},{"post_id":"cj5gmdngv000ubovrg72z1acl","tag_id":"cj5gmdnis001wbovrtdj0zy83","_id":"cj5gmdnk8002pbovr5pdk9jdv"},{"post_id":"cj5gmdnjx002kbovruwupxm4j","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnkb002rbovrje51wgh5"},{"post_id":"cj5gmdnh0000xbovrlgomfb61","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnke002ubovrxlne11rc"},{"post_id":"cj5gmdnh0000xbovrlgomfb61","tag_id":"cj5gmdnjw002ibovr46eokdg7","_id":"cj5gmdnkh002wbovrvcenheuy"},{"post_id":"cj5gmdnh80010bovr38nskbjn","tag_id":"cj5gmdnij001pbovrtsnlww0h","_id":"cj5gmdnkw0033bovrl6hsnxhf"},{"post_id":"cj5gmdnh80010bovr38nskbjn","tag_id":"cj5gmdnkd002tbovrtoa0n8lk","_id":"cj5gmdnkz0036bovreqsc3le6"},{"post_id":"cj5gmdnkx0035bovrh3ue0ugc","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnl6003bbovrdi1z4a87"},{"post_id":"cj5gmdnl00037bovrogi1a5sh","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnlb003fbovrtrl9uaq3"},{"post_id":"cj5gmdnhb0012bovry5kxogrt","tag_id":"cj5gmdnks0031bovrg44e2c87","_id":"cj5gmdnlt003ibovrd9860c2e"},{"post_id":"cj5gmdnhb0012bovry5kxogrt","tag_id":"cj5gmdnij001pbovrtsnlww0h","_id":"cj5gmdnlz003mbovr17docr7z"},{"post_id":"cj5gmdnhe0014bovrmpflooe5","tag_id":"cj5gmdnla003ebovrla1uqixa","_id":"cj5gmdnm5003pbovra6t5a9db"},{"post_id":"cj5gmdnm2003obovrm5qeb5xa","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnm9003tbovrxpkg1et7"},{"post_id":"cj5gmdnhs001bbovri4b6e8d2","tag_id":"cj5gmdnly003lbovrh6cqhxem","_id":"cj5gmdnmb003vbovrc9wjcag7"},{"post_id":"cj5gmdnhs001bbovri4b6e8d2","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnmc003ybovrvpdmr05b"},{"post_id":"cj5gmdnm6003rbovrbwpjjuxd","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnmd0040bovr2us4favj"},{"post_id":"cj5gmdnhz001fbovriuud50uy","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnme0041bovr63hkpqta"},{"post_id":"cj5gmdni3001ibovr3vaesbne","tag_id":"cj5gmdnmc003xbovr8hnfwdd2","_id":"cj5gmdnmf0044bovri0zkjwub"},{"post_id":"cj5gmdnib001mbovr580nuzpn","tag_id":"cj5gmdnkd002tbovrtoa0n8lk","_id":"cj5gmdnmi0047bovruwntgan1"},{"post_id":"cj5gmdnib001mbovr580nuzpn","tag_id":"cj5gmdnis001wbovrtdj0zy83","_id":"cj5gmdnmj0048bovrsowjqxl8"},{"post_id":"cj5gmdnig001obovrmvw331y2","tag_id":"cj5gmdnis001wbovrtdj0zy83","_id":"cj5gmdnmk004abovrtmvr56lz"},{"post_id":"cj5gmdnik001rbovrwuif7ghh","tag_id":"cj5gmdnmk0049bovruidphjgq","_id":"cj5gmdnmm004cbovr56h9ncu5"},{"post_id":"cj5gmdnio001ubovrtusk6yvj","tag_id":"cj5gmdnml004bbovrrsiqq2fc","_id":"cj5gmdnmn004ebovrawuao0ak"},{"post_id":"cj5gmdnj20021bovr6j37lb83","tag_id":"cj5gmdnml004bbovrrsiqq2fc","_id":"cj5gmdnmp004gbovrhok7oi43"},{"post_id":"cj5gmdnjj002bbovr9v5nho8z","tag_id":"cj5gmdnmo004fbovro5s11mtg","_id":"cj5gmdnms004kbovrnbm11t3f"},{"post_id":"cj5gmdnjj002bbovr9v5nho8z","tag_id":"cj5gmdnmp004hbovr05pzw3a0","_id":"cj5gmdnmt004lbovrp4vhi3ri"},{"post_id":"cj5gmdnjj002bbovr9v5nho8z","tag_id":"cj5gmdnmr004ibovrzdi1o5n7","_id":"cj5gmdnmu004nbovrciekxwm7"},{"post_id":"cj5gmdnjt002hbovrx0hr12kk","tag_id":"cj5gmdnkd002tbovrtoa0n8lk","_id":"cj5gmdnmu004obovrfhvf5h5l"},{"post_id":"cj5gmdnkk002zbovrcwx4iqcn","tag_id":"cj5gmdnmt004mbovrshjw0k4q","_id":"cj5gmdnmx004qbovrsbene0yv"},{"post_id":"cj5gmdnkk002zbovrcwx4iqcn","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnmx004rbovrk01noi0z"},{"post_id":"cj5gmdnl3003abovr5zyvgge2","tag_id":"cj5gmdnmv004pbovrpdam89t4","_id":"cj5gmdnn0004tbovrnf8ipzu8"},{"post_id":"cj5gmdnl7003dbovrsbk0n8o8","tag_id":"cj5gmdnmy004sbovr72qp2bg9","_id":"cj5gmdnn4004xbovrbfngoq2f"},{"post_id":"cj5gmdnl7003dbovrsbk0n8o8","tag_id":"cj5gmdnn1004vbovrl59z0ti1","_id":"cj5gmdnn5004ybovr4gv31y3c"},{"post_id":"cj5gmdnl7003dbovrsbk0n8o8","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnn70050bovr865ajf9n"},{"post_id":"cj5gmdnlc003hbovrn6hponqd","tag_id":"cj5gmdnn3004wbovr7glmvgxa","_id":"cj5gmdnn80051bovrktzy5kcz"},{"post_id":"cj5gmdnlc003hbovrn6hponqd","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnn90052bovrgoo25vfu"},{"post_id":"cj5gmdnlw003kbovrpa12cp6i","tag_id":"cj5gmdnn6004zbovr4wzsks3e","_id":"cj5gmdnna0053bovrewlp0arn"},{"post_id":"cj5gmdnlw003kbovrpa12cp6i","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmdnnb0054bovrlq9k9d9n"},{"post_id":"cj5gmdnk3002mbovrbaimiw1m","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmk2yd0000zcvrt506h9f9"},{"post_id":"cj5gmdnkb002sbovrkpad2vbj","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gmk2z70002zcvrghdhh36c"},{"post_id":"cj5gmdnkb002sbovrkpad2vbj","tag_id":"cj5gmdnml004bbovrrsiqq2fc","_id":"cj5gmk2z80003zcvroj4unwxq"},{"post_id":"cj5gmdnk9002qbovrxt27q4ov","tag_id":"cj5gmdnkd002tbovrtoa0n8lk","_id":"cj5gmk2za0005zcvrsw1eglyh"},{"post_id":"cj5gmdnk9002qbovrxt27q4ov","tag_id":"cj5gmk2yh0001zcvru9e3qgul","_id":"cj5gmk2za0006zcvrfo78y5ex"},{"post_id":"cj5gmdnke002vbovr98w9klwo","tag_id":"cj5gmdnml004bbovrrsiqq2fc","_id":"cj5gmk2zd0008zcvrt50rosrf"},{"post_id":"cj5gmdnke002vbovr98w9klwo","tag_id":"cj5gmk2z90004zcvrjlaxd0ab","_id":"cj5gmk2ze0009zcvrvvc8ql4u"},{"post_id":"cj5gmdnke002vbovr98w9klwo","tag_id":"cj5gmk2yh0001zcvru9e3qgul","_id":"cj5gmk2ze000azcvr0mlxgyor"},{"post_id":"cj5gmdnh80010bovr38nskbjn","tag_id":"cj5gmk2yh0001zcvru9e3qgul","_id":"cj5gmyjgg0000b0vrhi1n8rqi"},{"post_id":"cj5gmdnhz001fbovriuud50uy","tag_id":"cj5gmk2yh0001zcvru9e3qgul","_id":"cj5gmyjgg0001b0vrwqhy9edi"},{"post_id":"cj5gmdnl3003abovr5zyvgge2","tag_id":"cj5gmk2yh0001zcvru9e3qgul","_id":"cj5gmyjgv0002b0vrkq0j2r60"},{"post_id":"cj5gmdnkh002xbovre66s0yog","tag_id":"cj5gmdnml004bbovrrsiqq2fc","_id":"cj5gn0fb40000x0vrp325rxoo"},{"post_id":"cj5gmdnkp0030bovrskm34ba1","tag_id":"cj5gmdng20008bovrt07ngt2q","_id":"cj5gn0fb40001x0vr8cw1zbhr"},{"post_id":"cj5gmdnkt0032bovr55chdy2a","tag_id":"cj5gmdnml004bbovrrsiqq2fc","_id":"cj5gn0fbk0002x0vrbe3rd1nh"}],"Tag":[{"name":"Handler Message","_id":"cj5gmdnfo0003bovrloukv39y"},{"name":"android","_id":"cj5gmdng20008bovrt07ngt2q"},{"name":"TouchEvent","_id":"cj5gmdngf000ebovrga7v0hi1"},{"name":"Window","_id":"cj5gmdngt000sbovrkxm50lmd"},{"name":"statusBar","_id":"cj5gmdnh7000zbovrg6000z3p"},{"name":"RecyclerView","_id":"cj5gmdni8001jbovrmyli4304"},{"name":"置顶","_id":"cj5gmdnij001pbovrtsnlww0h"},{"name":"python","_id":"cj5gmdnis001wbovrtdj0zy83"},{"name":"adb","_id":"cj5gmdnj60024bovrmpqnu2y9"},{"name":"annotation","_id":"cj5gmdnjw002ibovr46eokdg7"},{"name":"linux","_id":"cj5gmdnkd002tbovrtoa0n8lk"},{"name":"notes","_id":"cj5gmdnkj002ybovrltzqfs1c"},{"name":"hexo","_id":"cj5gmdnks0031bovrg44e2c87"},{"name":"kotlin","_id":"cj5gmdnla003ebovrla1uqixa"},{"name":"rxjava2","_id":"cj5gmdnly003lbovrh6cqhxem"},{"name":"concurrency","_id":"cj5gmdnmc003xbovr8hnfwdd2"},{"name":"jvm","_id":"cj5gmdnmk0049bovruidphjgq"},{"name":"java","_id":"cj5gmdnml004bbovrrsiqq2fc"},{"name":"Retrofit","_id":"cj5gmdnmo004fbovro5s11mtg"},{"name":"OkHttp","_id":"cj5gmdnmp004hbovr05pzw3a0"},{"name":"Okio","_id":"cj5gmdnmr004ibovrzdi1o5n7"},{"name":"transition","_id":"cj5gmdnmt004mbovrshjw0k4q"},{"name":"git","_id":"cj5gmdnmv004pbovrpdam89t4"},{"name":"databinding","_id":"cj5gmdnmy004sbovr72qp2bg9"},{"name":"Butterknife","_id":"cj5gmdnn1004vbovrl59z0ti1"},{"name":"service","_id":"cj5gmdnn3004wbovr7glmvgxa"},{"name":"foreground","_id":"cj5gmdnn6004zbovr4wzsks3e"},{"name":"tools","_id":"cj5gmk2yh0001zcvru9e3qgul"},{"name":"designpattern","_id":"cj5gmk2z90004zcvrjlaxd0ab"}]}}